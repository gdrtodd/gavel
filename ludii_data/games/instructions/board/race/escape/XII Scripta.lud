Play begins in the central row and continues from left to right, then down the furthest row from right to left, then on the closest row from left to right. Played using three dice; throws can be used singly or combined but could not be divided. No second throw with doubles or triples. More than one piece of the same player can occupy one point, Single pieces can be removed from the board when the opponent lands on it; it must then be re-entered to the board before the player can move their other pieces. The goal is to bear off all of the player's pieces, which can be done one they are all in the closest row. The rules are describing with the Murray ruleset.
(game "XII Scripta" (players 2) (equipment {(board (add (merge (rectangle 3 6) (shift 7 0 (rectangle 3 6))) edges:{{5 18} {11 24} {17 30}}) {(track "Track1" "36,6,E,N1,W,0,E,End" P1 directed:True) (track "Track2" "38,6,E,S1,W,12,E,End" P2 directed:True)} use:Vertex) (dice num:3) (hand Each size:2) (piece "Disc" Each (forEach Die combined:True if:(and (notEqual (pips) 0) (notEqual (trackSite Move from:(from) steps:(pips)) -1)) (if (equals (trackSite Move from:(from) steps:(pips)) -2) (move Select (from (from)) (then (if (equals (count at:(last To)) 1) (remove (last To)) (set Count at:(last To) (sub (count at:(last To)) 1))))) (move (from (from)) (to (trackSite Move from:(from) steps:(pips)) if:(not (and (is Enemy (who at:(to))) (gt (count at:(to)) 1))) (apply if:(and (is Enemy (who at:(to))) (equals (count at:(to)) 1)) (fromTo (from (to)) (to (handSite Next 1)))))))))}) (rules (start {(place "Disc1" (handSite P1) count:15) (place "Disc2" (handSite P2) count:15)}) (play (do (if (not (is Prev Mover)) (roll)) next:(if (notEqual (what at:(handSite Mover 1)) 0) (forEach Die combined:True if:(and (notEqual (pips) 0) (notEqual (trackSite Move from:(handSite Mover) steps:(pips)) -1)) (if (equals (trackSite Move from:(handSite Mover) steps:(pips)) -2) (move Select (from (handSite Mover 1)) (then (if (equals (count at:(last To)) 1) (remove (last To)) (set Count at:(last To) (sub (count at:(last To)) 1))))) (move (from (handSite Mover 1)) (to (trackSite Move from:(handSite Mover) steps:(pips)) if:(not (and (is Enemy (who at:(to))) (gt (count at:(to)) 1))) (apply if:(and (is Enemy (who at:(to))) (equals (count at:(to)) 1)) (fromTo (from (to)) (to (handSite Next 1)))))))) (or (forEach Piece) (forEach Piece container:(mover))) (then (if (can Move (if (notEqual (what at:(handSite Mover 1)) 0) (forEach Die combined:True if:(and (notEqual (pips) 0) (notEqual (trackSite Move from:(handSite Mover) steps:(pips)) -1)) (if (equals (trackSite Move from:(handSite Mover) steps:(pips)) -2) (move Select (from (handSite Mover 1)) (then (if (equals (count at:(last To)) 1) (remove (last To)) (set Count at:(last To) (sub (count at:(last To)) 1))))) (move (from (handSite Mover 1)) (to (trackSite Move from:(handSite Mover) steps:(pips)) if:(not (and (is Enemy (who at:(to))) (gt (count at:(to)) 1))) (apply if:(and (is Enemy (who at:(to))) (equals (count at:(to)) 1)) (fromTo (from (to)) (to (handSite Next 1)))))))) (or (forEach Piece) (forEach Piece container:(mover))))) (moveAgain)))))) (end (if (no Pieces Mover) (result Mover Win))))) 
