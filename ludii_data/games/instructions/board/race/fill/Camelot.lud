The object of the game is to be the first player to occupy the opponent's castle with two of your own pieces, or, to capture all of your opponent's pieces while retaining two or more of your own pieces. Both knights and pawns can move either horizontally, vertically, or diagonally in three ways, as follows: One space in any direction (like a king in chess). This is called a plain move. A leaping move (called cantering) over an adjacent friendly piece to a vacant space immediately beyond. Multiple leaps over a player's own pieces are permitted. Cantering is always optional (never obligatory). A jumping move over an adjacent enemy piece to a vacant space immediately beyond. The enemy piece is captured and removed from the board. As in checkers, multiple jumps are allowed, and capturing is obligatory whenever it is possible. Pawns may make any of the three moves, but only one type of move per turn. Knights have a fourth option: a combination move consisting of a canter immediately followed by a jump (capture). This is called the knight's charge. The knight may, in this single move, perform multiple canters (or just one), followed by multiple jumps (or just one); but the canter(s) must precede the jump(s). A knight may not combine a plain move with a canter or a jump.
(game "Camelot" (players 2) (equipment {(board (keep (rectangle 12 16) (poly {{0 7} {1 10} {4 13} {12 13} {15 10} {16 7} {16 5} {15 2} {13 0} {3 0} {1 2} {0 5}}))) (piece "Pawn" Each (or (if (not (is In (from) (sites Next))) (move Hop (from (from)) (between if:(is Friend (who at:(between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to))))) (then (if (and (not (is In (last To) (sites Next))) (can Move (move Hop (from (last To)) (between if:(is Friend (who at:(between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to)))))))) (and (moveAgain) (set Pending)))))) (move Step (to if:(if (is In (from) (sites Next)) (and (is Empty (to)) (is In (to) (sites Next))) (is In (to) (difference (sites Empty) (sites Mover)))))))) (piece "Knight" Each (or (if (not (is In (from) (sites Next))) (move Hop (from (from)) (between if:(is Friend (who at:(between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to))))) (then (if (and (not (is In (last To) (sites Next))) (can Move (move Hop (from (last To)) (between if:(is Friend (who at:(between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to)))))))) (and (moveAgain) (set Pending)))))) (move Step (to if:(if (is In (from) (sites Next)) (and (is Empty (to)) (is In (to) (sites Next))) (is In (to) (difference (sites Empty) (sites Mover)))))))) (regions P1 (sites {"A6" "A7"})) (regions P2 (sites {"P6" "P7"}))}) (rules (start {(place "Pawn1" {"F4" "F5" "F6" "F7" "F8" "F9" "G5" "G6" "G7" "G8"}) (place "Knight1" {"F3" "G4" "G9" "F10"}) (place "Pawn2" {"K4" "K5" "K6" "K7" "K8" "K9" "J5" "J6" "J7" "J8"}) (place "Knight2" {"K3" "J4" "J9" "K10"})}) (play (if (is Prev Mover) (if (is Pending) (if (equals (what at:(last To)) (id "Knight" Mover)) (priority {(move Hop (from (last To)) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to))))) (then (if (and (not (is In (last To) (sites Next))) (can Move (move Hop (from (last To)) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to)))))))) (moveAgain)))) (or (move Hop (from (last To)) (between if:(is Friend (who at:(between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to))))) (then (if (and (not (is In (last To) (sites Next))) (can Move (move Hop (from (last To)) (between if:(is Friend (who at:(between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to)))))))) (and (moveAgain) (set Pending))))) (move Pass))}) (or (move Hop (from (last To)) (between if:(is Friend (who at:(between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to))))) (then (if (and (not (is In (last To) (sites Next))) (can Move (move Hop (from (last To)) (between if:(is Friend (who at:(between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to)))))))) (and (moveAgain) (set Pending))))) (move Pass))) (move Hop (from (last To)) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to))))) (then (if (and (not (is In (last To) (sites Next))) (can Move (move Hop (from (last To)) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to)))))))) (moveAgain))))) (priority {(forEach Site (sites Mover) (if (equals (who at:(site)) (mover)) (priority {(move Hop (from (site)) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to))))) (then (if (and (not (is In (last To) (sites Next))) (can Move (move Hop (from (last To)) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to)))))))) (moveAgain)))) (or (move Hop (from (site)) (between if:(is Friend (who at:(between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to))))) (then (if (and (not (is In (last To) (sites Next))) (can Move (move Hop (from (last To)) (between if:(is Friend (who at:(between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to)))))))) (and (moveAgain) (set Pending))))) (move Step (to if:(if (is In (from) (sites Next)) (and (is Empty (to)) (is In (to) (sites Next))) (is In (to) (difference (sites Empty) (sites Mover)))))))}))) (forEach Piece (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(if (is In (from) (sites Next)) (and (is Empty (to)) (is In (to) (sites Next))) (is In (to) (difference (sites Empty) (sites Mover))))) (then (if (and (not (is In (last To) (sites Next))) (can Move (hop (from (last To)) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))))) (moveAgain))))) (forEach Piece)}))) (end {(if (equals (sites P2) (sites Occupied by:P1)) (result P1 Win)) (if (equals (sites P1) (sites Occupied by:P2)) (result P2 Win)) (if (and (ge (count Pieces Mover) 2) (equals (count Pieces Next) 0)) (result Mover Win)) (if (and (lt (count Pieces Mover) 2) (lt (count Pieces Next) 2)) (result Mover Draw))}))) 
