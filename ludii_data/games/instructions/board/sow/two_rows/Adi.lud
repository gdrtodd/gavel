2x6 board with two stores. Four counters in each hole. Sowing occurs in an anti-clockwise direction from a hole in the player's row. If the final counter falls into a hole in the opponent's row containing two counters, making it contain three, they are captured. Any holes containing three counters in an unbroken line behind it in the opponent's row are also captured. A player cannot sow into a hole from which they sowed until it has been sown into by the opponent. Play continues until no more captures are possible, and the players win the counters they captured and the counters on their side of the board. A new round begins. The player with fewer counters fills up their holes from right to left with four counters. The opponent fills the same number of holes, and continues to play, holding any remaining counters for future rounds, if necessary. Play proceeds as before with the present number of holes in play. Play continues until one player cannot fill any holes.
(game "Adi" (players 2) (equipment {(mancalaBoard 2 6 {(track "TrackCCW" "1,E,N,W" loop:True) (track "TrackCW" "6,W,N,E" loop:True)}) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 FirstSite) (pair P2 LastSite)}) (piece "Seed" Shared) (map "RightMost" {(pair P1 6) (pair P2 7)}) (map "CorrespondingHoles" {(pair 1 12) (pair 2 11) (pair 3 10) (pair 4 9) (pair 5 8) (pair 6 7) (pair 7 6) (pair 8 5) (pair 9 4) (pair 10 3) (pair 11 2) (pair 12 1)})}) (rules (start {(set Count 4 to:(sites Track)) (set RememberValue "OwnedP1" (sites Bottom)) (set RememberValue "OwnedP2" (sites Top))}) phases:{(phase "Sowing" (play (or {(move Select (from (if (is Mover P1) (sites (values Remembered "OwnedP1")) (sites (values Remembered "OwnedP2"))) if:(and (if (is Mover P1) (not (is In (from) (values Remembered "P1SowFrom"))) (not (is In (from) (values Remembered "P2SowFrom")))) (lt 0 (count at:(from))))) (then (and {(sow "TrackCCW" if:(and (is In (to) (sites Next)) (equals (count at:(to)) 3)) apply:(fromTo (from (to)) (to (mapEntry (mover))) count:(count at:(to))) backtracking:True) (forEach Value (array (sites Track from:(last From) to:(trackSite Move from:(last From) "Track" steps:(min 12 (count at:(last From)))))) (if (is Mover P1) (if (is In (value) (values Remembered "P2SowFrom")) (forget Value "P2SowFrom" (value))) (if (is In (value) (values Remembered "P1SowFrom")) (forget Value "P1SowFrom" (value))))) (if (is Mover P1) (remember Value "P1SowFrom" (last From)) (remember Value "P2SowFrom" (last From)))})))} (then (if (not (can Move (or (move Select (from (sites (values Remembered "OwnedP1")) if:(and (not (is In (from) (values Remembered "P1SowFrom"))) (lt 0 (count at:(from)))))) (move Select (from (sites (values Remembered "OwnedP2")) if:(and (not (is In (from) (values Remembered "P2SowFrom"))) (lt 0 (count at:(from))))))))) (and {(forEach Site (sites P1) (if (lt 0 (count at:(site))) (fromTo (from (site)) (to (mapEntry P1)) count:(count at:(site))))) (forEach Site (sites P2) (if (lt 0 (count at:(site))) (fromTo (from (site)) (to (mapEntry P2)) count:(count at:(site))))) (forget Value "OwnedP1" All) (forget Value "OwnedP2" All) (forget Value "P1SowFrom" All) (forget Value "P2SowFrom" All) (if (ge (add (count at:(mapEntry P2)) (count in:(sites P2))) (add (count at:(mapEntry P1)) (count in:(sites P1)))) (set NextPlayer (player 1)) (set NextPlayer (player 2)))}))))) (end (if (all Sites (union (sites P1) (sites P2)) if:(equals 0 (count at:(site)))) {(if (gt 4 (count at:(mapEntry P1))) (result P2 Win)) (if (gt 4 (count at:(mapEntry P2))) (result P1 Win))})) (nextPhase (all Sites (union (sites P1) (sites P2)) if:(equals 0 (count at:(site)))) "BetweenRounds")) (phase "BetweenRounds" (play (if (le 4 (count at:(mapEntry Mover))) (move (from (mapEntry Mover)) (to (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))) count:4 (then (and (if (is Mover P1) (remember Value "OwnedP1" (last To)) (remember Value "OwnedP2" (last To))) (if (le 4 (count at:(mapEntry Mover))) (moveAgain) (forEach Site (sites Mover) (if (is Occupied (site)) (and (fromTo (from (mapEntry Next)) (to (mapEntry "CorrespondingHoles" (site))) count:(count at:(site))) (if (is Next P1) (remember Value "OwnedP1" (mapEntry "CorrespondingHoles" (site))) (remember Value "OwnedP2" (mapEntry "CorrespondingHoles" (site))))))))))))) (nextPhase (gt 4 (count at:(mapEntry Mover))) "Sowing"))})) 
