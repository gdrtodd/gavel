2x9 board, with two stores in between the holes. Players own the store to their right. Nine counters in each hole. A player takes all of the counters from one of the holes in their row and sows them anti-clockwise. The first stone is dropped into the hole that was just emptied, except when there is only one stone, in which case it is moved to the next hole. If the last counter falls into an opponent's hole making this hole have an even number of counters, these counters are captured and placed in the player's store. Otherwise, the turn ends. When the last counter falls into an opponent's hole, making it contain three counters, it is made into a "tuzduk." A player can only create one tuzduk per game. When a player creates a tuzduk, the opponent cannot create a tuzduk in the same hole in the player's row, with respect to the index of the hole in the respective player's hole. Stones that fall into a tuzduk are captured by its owner. The game ends when a player cannot move because all of the holes, except the tuzduk, are empty. The other player claims the remaining counters and the player with the most counters wins.
(game "Toguz Kumalak" (players 2) (equipment {(board (merge {(rectangle 1 9) (shift 2.5 1 (rectangle 1 1)) (shift 5.5 1 (rectangle 1 1)) (shift 0 2 (rectangle 1 9))}) (track "Track" "0,E,19,W" loop:True) use:Vertex) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 9) (pair P2 10)}) (piece "Seed" Shared)}) (rules (start (set Count 9 to:(sites Track))) (play (move Select (from (sites Mover) if:(gt (count at:(from)) 0)) (then (sow apply:(if (and (is In (to) (sites Next)) (is Even (count at:(to)))) (fromTo (from (to)) (to (mapEntry (mover))) count:(count at:(to))) (if (and {(is In (to) (sites Next)) (equals (count at:(to)) 3) (lt (value Player Mover) 0) (if (lt (value Player Next) 0) True (notEqual (add (to) (value Player Next)) 19))}) (and (set Value Mover (to)) (fromTo (from (to)) (to (mapEntry (mover))) count:(count at:(to)))))) origin:(notEqual (count at:(last From)) 1) (then (and (if (and (gt (value Player P1) 0) (gt (count at:(value Player P1)) 0)) (fromTo (from (value Player P1)) (to (mapEntry P1)) count:(count at:(value Player P1)))) (if (and (gt (value Player P2) 0) (gt (count at:(value Player P2)) 0)) (fromTo (from (value Player P2)) (to (mapEntry P2)) count:(count at:(value Player P2)))))))))) (end (if (no Moves Mover) (byScore {(score P1 (add (count at:(mapEntry P1)) (count in:(sites P1)))) (score P2 (add (count at:(mapEntry P2)) (count in:(sites P2))))}))))) 
