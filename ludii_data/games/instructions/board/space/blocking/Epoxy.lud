Use Options to select a board size. Goal: Be the last to play. Then the first player (Maroon) places a stone, after which the players alternate, taking up to two moves per turn. To move, either: 1. Add a stone to an empty space that is not in line-of-sight of any opponent's stone. -Or, 2. Slide a stone along a straight line to a new position, with the following restriction: Either -- A. The new location must have a greater number of opponent's stones adjacent to it, or -- B. The new location must have more sight-lines to opponent's stones than the old location, while keeping number of adjacent opponent's stones the same. To avoid forfeiting the game, a player must move at least once on a turn. The second move can be voluntarily skipped. The winner is last to play. The score shown is a count of the available moves at the beginning of a player's turn for use by the AI. Extra small board (39 nodes) as a filler game and for learning how to play
(game "Epoxy" (players 2) (equipment {(board (dual (remove (hex 4 5) cells:{0 1 15 20 25 32 36 39 44})) use:Vertex) (piece "Ball" Each (move Slide))}) (rules (start (set Score Each 0)) (play (or {(move Add (piece (mover)) (to (difference (sites Empty) (sites (results from:(sites Occupied by:Next) to:(sites LineOfSight Empty at:(from) Orthogonal) (to)))))) (forEach Piece (do (and (set Var "LoSFrom" (count Pieces Next in:(sites LineOfSight Piece at:(from) Orthogonal))) (set Var "QtyAroundFrom" (count Pieces Next in:(sites Around (from) Orthogonal)))) next:(move Slide Orthogonal) ifAfterwards:(or (gt (count Pieces Next in:(sites Around (last To) Orthogonal)) (var "QtyAroundFrom")) (and (equals (count Pieces Next in:(sites Around (last To) Orthogonal)) (var "QtyAroundFrom")) (gt (count Pieces Next in:(sites LineOfSight Piece at:(last To) Orthogonal)) (var "LoSFrom"))))) Mover) (if (and (not (is Prev Next)) (lt 0 (counter))) (move Pass))} (then (if (is Prev Next) (moveAgain) (and (set Score Mover (add (size Array (array (sites From (forEach Piece (do (and (set Var "LoSFrom" (count Pieces Next in:(sites LineOfSight Piece at:(from) Orthogonal))) (set Var "QtyAroundFrom" (count Pieces Next in:(sites Around (from) Orthogonal)))) next:(move Slide Orthogonal) ifAfterwards:(or (gt (count Pieces Next in:(sites Around (last To) Orthogonal)) (var "QtyAroundFrom")) (and (equals (count Pieces Next in:(sites Around (last To) Orthogonal)) (var "QtyAroundFrom")) (gt (count Pieces Next in:(sites LineOfSight Piece at:(last To) Orthogonal)) (var "LoSFrom"))))) Mover)))) (count Sites in:(difference (sites (results from:(sites Occupied by:Mover) to:(sites LineOfSight Empty at:(from) Orthogonal) (to))) (sites (results from:(sites Occupied by:Next) to:(sites LineOfSight Empty at:(from) Orthogonal) (to))))))) (set Score Next (add (size Array (array (sites From (forEach Piece (do (and (set Var "LoSFrom" (count Pieces Next in:(sites LineOfSight Piece at:(from) Orthogonal))) (set Var "QtyAroundFrom" (count Pieces Next in:(sites Around (from) Orthogonal)))) next:(move Slide Orthogonal) ifAfterwards:(or (gt (count Pieces Next in:(sites Around (last To) Orthogonal)) (var "QtyAroundFrom")) (and (equals (count Pieces Next in:(sites Around (last To) Orthogonal)) (var "QtyAroundFrom")) (gt (count Pieces Next in:(sites LineOfSight Piece at:(last To) Orthogonal)) (var "LoSFrom"))))) Next)))) (count Sites in:(difference (sites (results from:(sites Occupied by:Next) to:(sites LineOfSight Empty at:(from) Orthogonal) (to))) (sites (results from:(sites Occupied by:Mover) to:(sites LineOfSight Empty at:(from) Orthogonal) (to)))))))))))) (end (if (and (is Prev Mover) (no Moves Next)) (result Mover Win))))) 
