Goal: Score the most points: -- One point for each stone in one's largest group. -- Bonus points are also added to the scores according to the selected option. The board starts empty. Players take turns in alternation, placing one of their own stones onto an empty site. Restriction on placement: Every site of the board must remain connected to an empty perimeter site via a continuous path of empty sites. There is no passing. The game ends when no more placements can be made. Players score one point for every stone in their largest group, then, if applicable, score bonus points according to the selected option. Bonus Options are: -- Count of one's own groups. Standard -- Count of the opponent's groups -- No Bonus The player with the higher score wins. If the scores are tied, the game is decided by the tiebreaker option used: A: Cascading largest group LOSES -- i.e. negative scores -- This excludes tied pairs; If all groups are paired, last to place. B: Last player to have placed a stone. Order 5 board - about 20 moves each Hex N / N-1 Grid, about 20% less moves Scoring Option: Score the size of your largest group, then score an additional point for every group you have on the board. Tiebreaker is largest group (excluding tied pairs) LOSES. If all are paired, last placement wins.
(game "Brain Coral" (players 2) (equipment {(board (hex Limping (sub 5 1)) use:Cell) (piece "Ball" Each) (piece "Disc" Each)}) (rules (start (set Score Each 0)) (play (do (move Add (to (sites Empty))) ifAfterwards:(all Sites (sites Around (last To) Orthogonal includeSelf:True) if:(or (and (is Empty (site)) (is In (site) (sites Outer))) (notEqual 1000000000 (count Steps (step Orthogonal (to if:(is Empty (to)))) (site) (difference (sites Outer) (site)))))) (then (set Var "MoverScore" (add (max 0 (max (sizes Group Orthogonal Mover))) (count Groups Orthogonal if:(equals (who at:(to)) (mover)))) (then (set Var "NextScore" (add (max 0 (max (sizes Group Orthogonal Next))) (count Groups Orthogonal if:(equals (who at:(to)) (next)))) (then (if (equals (var "MoverScore") (var "NextScore")) (and (set Score Mover (mul -1 (max 0 (max (difference (sizes Group Orthogonal Mover) (sizes Group Orthogonal Next)))))) (set Score Next (mul -1 (max 0 (max (difference (sizes Group Orthogonal Next) (sizes Group Orthogonal Mover))))))) (and (set Score Mover (var "MoverScore")) (set Score Next (var "NextScore"))))))))))) (end (if (no Moves Next) {(if (equals (score Mover) (score Next)) (result Mover Win)) (if (notEqual (score Mover) (score Next)) (byScore))})))) 
