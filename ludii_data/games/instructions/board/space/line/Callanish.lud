The board is initially empty. Each player chooses a colour: White or Black. White starts by placing a stone on a vacant square. Black does the same. Players continue taking turns; however, your turn goes as follows: 1. Mark one of your exposed stones for removal from the board (i.e. it cannot be under an enemy stone). 2. Add one of your stones to the board. 3. Add another one of your stones to the board, at which point the marked stone is removed. The following rules constrain where you can add each stone: It must be a “knight’s move” away from the marked stone. That is to say, either 2 spaces vertically and 1 horizontally, or 2 spaces horizontally, and 1 vertically away from the marked stone. The space on which you place it must have none of your stones, and either: be vacant, or have an enemy stone, in which case you will place yours on top, creating a stack that you control. If, at the end of your opponent’s turn, you have at least 5 of your stones and/or stacks in the same rank, or in the same file, you win.
(game "Callanish" (players 2) (equipment {(board (square 9)) (piece "Disc" Each (move Select (from if:(and (equals (topLevel at:(from)) (level)) (le 2 (count Sites in:(sites To (move Leap (from (from)) {{F F R F} {F F L F} {F R F F} {F L F F}} (to if:(or (is Empty (to)) (and (is Enemy (who at:(to))) (equals (topLevel at:(to)) 0)))))))))) (then (do (set Var "CondemnedSite" (last From)) next:(do (set State at:(var "CondemnedSite") 1) next:(moveAgain))))))}) (rules phases:{(phase "Opening" (play (move Add (to (sites Empty)))) (nextPhase (ge (count Turns) 2) "Playing")) (phase "Playing" (play (if (is Prev Mover) (if (is Pending) (move Add (to (sites To (move Leap (from (var "CondemnedSite")) {{F F R F} {F F L F} {F R F F} {F L F F}} (to if:(or (is Empty (to)) (and (is Enemy (who at:(to))) (equals (topLevel at:(to)) 0))))))) stack:True (then (remove (var "CondemnedSite")))) (move Add (to (sites To (move Leap (from (var "CondemnedSite")) {{F F R F} {F F L F} {F R F F} {F L F F}} (to if:(or (is Empty (to)) (and (is Enemy (who at:(to))) (equals (topLevel at:(to)) 0))))))) stack:True (then (do (set Pending) next:(moveAgain))))) (forEach Piece))))} (end {(if (and (equals (mod (sub (count Moves) 2) 3) 0) (or {(le 5 (count Sites in:(intersection (sites Row 0) (sites Occupied by:Next container:"Board")))) (le 5 (count Sites in:(intersection (sites Row 1) (sites Occupied by:Next container:"Board")))) (le 5 (count Sites in:(intersection (sites Row 2) (sites Occupied by:Next container:"Board")))) (le 5 (count Sites in:(intersection (sites Row 3) (sites Occupied by:Next container:"Board")))) (le 5 (count Sites in:(intersection (sites Row 4) (sites Occupied by:Next container:"Board")))) (le 5 (count Sites in:(intersection (sites Row 5) (sites Occupied by:Next container:"Board")))) (le 5 (count Sites in:(intersection (sites Row 6) (sites Occupied by:Next container:"Board")))) (le 5 (count Sites in:(intersection (sites Row 7) (sites Occupied by:Next container:"Board")))) (le 5 (count Sites in:(intersection (sites Row 8) (sites Occupied by:Next container:"Board")))) (le 5 (count Sites in:(intersection (sites Column 0) (sites Occupied by:Next container:"Board")))) (le 5 (count Sites in:(intersection (sites Column 1) (sites Occupied by:Next container:"Board")))) (le 5 (count Sites in:(intersection (sites Column 2) (sites Occupied by:Next container:"Board")))) (le 5 (count Sites in:(intersection (sites Column 3) (sites Occupied by:Next container:"Board")))) (le 5 (count Sites in:(intersection (sites Column 4) (sites Occupied by:Next container:"Board")))) (le 5 (count Sites in:(intersection (sites Column 5) (sites Occupied by:Next container:"Board")))) (le 5 (count Sites in:(intersection (sites Column 6) (sites Occupied by:Next container:"Board")))) (le 5 (count Sites in:(intersection (sites Column 7) (sites Occupied by:Next container:"Board")))) (le 5 (count Sites in:(intersection (sites Column 8) (sites Occupied by:Next container:"Board"))))})) (result Mover Loss)) (if (no Moves Mover) (result Mover Loss))}))) 
