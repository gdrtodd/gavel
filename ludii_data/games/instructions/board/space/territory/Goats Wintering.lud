--- Goal: Have the warmest goats at end. The warmth of you goats is the total number of contacts they have with other goats. To find the winner, it is only necessary to count goat-to-goat contacts between their own kind. The game start on an empty board. Play alternates. On a turn either: 1. Pass (sometimes this is forced); or 2. Place a goat on an empty cell that is not too close to another goat of its color: -- If they are in line, they need gap of 2 or 3 spaces (as selected in Options.) 3. Move one of your goats one step with the following condition: -- the goat must gain more contacts with adjacent goats of its own kind than before; or 4. Use the following alternate condition to step-move a goat that cannot move using the previous rule: -- the step must reduce your goat's net contact with enemy goats. Exception: Moves using rule 4. are not allowed immediately after the previous player has passed. Capture -- After moving, simultaneously remove all individual enemy goats that have no adjacent space empty. -- Capturing does not happen on a passing turn: to capture one must play a piece. Ending the game -- The game ends with 2 passes. Then the number of connections are compared. -- In the case of a tie, the last to pass loses. Variants not implemented: No capture. / Score simple goat count. Edge 3,4 Hex board Placements must leave a gap of 3 spaces if in sight of a friendly piece Goat graphics - Custom if mountainGoat-alt3.svg is in Ludii directory
(game "Goats Wintering" (players 2) (equipment {(board (hex Limping 3) use:Cell) (piece "Disc" P1) (piece "Disc" P2)}) (rules (start (set Score Each 0)) (play (or {(move Pass) (move Add (to (sites Empty) if:(not (is Within (id "Disc" Mover) in:(intersection (sites LineOfSight Piece at:(to)) (sites Direction from:(to) distance:3))))) (then (do (forEach Site (sites Board) (apply if:(and (is Next (who at:(site))) (equals 0 (count Sites in:(intersection (sites Empty) (sites Around (site) includeSelf:True))))) (remove (site)))) next:(and (set Score Mover (div (add (results from:(sites Occupied by:Mover) to:(sites Around (from) if:(is Mover (who at:(to)))) 1)) 2)) (set Score Next (div (add (results from:(sites Occupied by:Next) to:(sites Around (from) if:(is Next (who at:(to)))) 1)) 2)))))) (forEach Piece (or (move Step (to if:(and (is Empty (to)) (lt (count Pieces Mover in:(sites Around (from))) (sub (count Pieces Mover in:(sites Around (to))) 1)))) (then (do (forEach Site (sites Board) (apply if:(and (is Next (who at:(site))) (equals 0 (count Sites in:(intersection (sites Empty) (sites Around (site) includeSelf:True))))) (remove (site)))) next:(and (set Score Mover (div (add (results from:(sites Occupied by:Mover) to:(sites Around (from) if:(is Mover (who at:(to)))) 1)) 2)) (set Score Next (div (add (results from:(sites Occupied by:Next) to:(sites Around (from) if:(is Next (who at:(to)))) 1)) 2)))))) (if (and (not (was Pass)) (not (can Move (move Step (to if:(and (is Empty (to)) (lt (count Pieces Mover in:(sites Around (from))) (sub (count Pieces Mover in:(sites Around (to))) 1)))) (then (do (forEach Site (sites Board) (apply if:(and (is Next (who at:(site))) (equals 0 (count Sites in:(intersection (sites Empty) (sites Around (site) includeSelf:True))))) (remove (site)))) next:(and (set Score Mover (div (add (results from:(sites Occupied by:Mover) to:(sites Around (from) if:(is Mover (who at:(to)))) 1)) 2)) (set Score Next (div (add (results from:(sites Occupied by:Next) to:(sites Around (from) if:(is Next (who at:(to)))) 1)) 2))))))))) (move Step (to if:(and (is Empty (to)) (gt (count Pieces Next in:(sites Around (from))) (count Pieces Next in:(sites Around (to)))))) (then (do (forEach Site (sites Board) (apply if:(and (is Next (who at:(site))) (equals 0 (count Sites in:(intersection (sites Empty) (sites Around (site) includeSelf:True))))) (remove (site)))) next:(and (set Score Mover (div (add (results from:(sites Occupied by:Mover) to:(sites Around (from) if:(is Mover (who at:(to)))) 1)) 2)) (set Score Next (div (add (results from:(sites Occupied by:Next) to:(sites Around (from) if:(is Next (who at:(to)))) 1)) 2)))))))))})) (end {(if (and (all Passed) (gt (score Mover) (score Next))) (result Mover Win)) (if (and (all Passed) (le (score Mover) (score Next))) (result Next Win))}))) 
