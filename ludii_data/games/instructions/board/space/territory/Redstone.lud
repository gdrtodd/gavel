Starting with Black, the two players take turns placing stones onto unoccupied points on the board, subject to restrictions, one stone per turn. Passing is not allowed in Redstone. Players will always have a placement available and must make one. GROUPS AND LIBERTIES: A group is an orthogonally interconnected collection of one or more like-colored stones. Only black groups and white groups will be discussed here, not red groups. A liberty is an unoccupied point adjacent to a (black or white) group CAPTURES: A capturing placement results in one or more groups, of either or both colors, having no liberties. Such a placement can only be made with a red stone. Conversely, a red stone can only be placed if it bounds (completely deprives of liberties) one or more groups of either or both colors. Red stones are permanent. They cannot themselves be captured. Self capture is allowed. When multiple groups without liberties result from a placement, all such groups are removed immediately following said placement, regardless of the groups' colors. Unlike Go, if you unbound your own temporarily bounded group by removing a neighboring enemy group, you must still remove your own temporarily bounded group. PIE RULE: Since Redstone is a game of annihilation, not of point score, Go’s komi can’t be used. Instead, Redstone uses the pie rule for balance. OBJECT OF THE GAME: You must annihilate your opponent, removing all of his stones from the board. If your placement eliminates all black and white stones from the board, you win. If your placement eliminates all of your own stones while enemy stones remain on the board, you lose. A size 13 board is currently selected
(game "Redstone" (players 2) (equipment {(board (square 13) use:Vertex) (piece "Disc" Each) (piece "Disc" Neutral)}) (rules (meta (swap)) (play (or (do (move Add (piece "Disc0") (to (sites Empty))) ifAfterwards:(or (not (all Sites (sites Around (last To) Enemy Orthogonal) if:(not (equals 0 (count Liberties at:(site) Orthogonal if:(is Next (who at:(to)))))))) (not (all Sites (sites Around (last To) Own Orthogonal) if:(not (equals 0 (count Liberties at:(site) Orthogonal if:(is Mover (who at:(to))))))))) (then (and (forEach Site (sites Around (last To) Enemy Orthogonal) (if (equals 0 (count Liberties at:(site) Orthogonal if:(is Next (who at:(to))))) (remove (sites Group at:(site) Orthogonal if:(is Next (who at:(to))))))) (forEach Site (sites Around (last To) Own Orthogonal) (if (equals 0 (count Liberties at:(site) Orthogonal if:(is Mover (who at:(to))))) (remove (sites Group at:(site) Orthogonal if:(is Mover (who at:(to)))))))))) (do (move Add (to (sites Empty))) ifAfterwards:(not (or (not (all Sites (sites Around (last To) Enemy Orthogonal) if:(not (equals 0 (count Liberties at:(site) Orthogonal if:(is Next (who at:(to)))))))) (not (all Sites (sites Around (last To) Own Orthogonal includeSelf:True) if:(not (equals 0 (count Liberties at:(site) Orthogonal if:(is Mover (who at:(to))))))))))))) (end {(if (and (gt (count Moves) 2) (no Pieces Next)) (result Next Loss)) (if (and {(gt (count Moves) 2) (no Pieces Mover) (not (no Pieces Next))}) (result Mover Loss))}))) 
