Claim Jumpers is a 2-player strategy game It may be played: -- on a hex grid -- on a square grid -- on a square plus diagonal grid The goal is to maximize your pieces when the board is full. A new piece is placed at the beginning of each turn. Followed, if possible, by a chain of forced jumps made by a different piece, that capture by 'flipping' the jumped opponent to your own color. The board starts empty. Turns alternate starting with White. Game ends when the board is full. No passing. Maximum captures are not required, but the piece choen to capture must capture at least one, and maynot stop capturing as long as it is able to capture the next adjacent opponent's piece. Board & size: Equiversi Hexhex with edges alternating 3 and 5
(game "Claim Jumpers" (players 2) (equipment {(board (tri {3 5 3 5 3}) use:Vertex) (piece "Disc" Each)}) (rules (start (set Score Each 0)) (play (if (is Prev Mover) (if (equals 0 (size Array (values Remembered))) (forEach Piece (move Hop (from if:(notEqual (from) (last To))) Orthogonal (between if:(is In (between) (difference (sites Occupied by:Next) (sites (values Remembered)))) (apply (set Pending (between)))) (to if:(is Empty (to))) (then (and {(remember Value (value Pending)) (remove (value Pending)) (add (piece (id "Disc" Mover)) (to (value Pending)))} (then (and {(set Pending) (if (can Move (forEach Piece (move Hop (from (last To)) Orthogonal (between if:(is In (between) (difference (sites Occupied by:Next) (sites (values Remembered))))) (to if:(is Empty (to)))))) (moveAgain))})))))) (forEach Piece (move Hop (from if:(equals (from) (last To))) Orthogonal (between if:(is In (between) (difference (sites Occupied by:Next) (sites (values Remembered)))) (apply (set Pending (between)))) (to if:(is Empty (to))) (then (and {(remember Value (value Pending)) (remove (value Pending)) (add (piece (id "Disc" Mover)) (to (value Pending)))} (then (and {(set Pending) (if (can Move (forEach Piece (move Hop (from (last To)) Orthogonal (between if:(is In (between) (difference (sites Occupied by:Next) (sites (values Remembered))))) (to if:(is Empty (to)))))) (moveAgain))}))))))) (do (forget Value All) next:(move Add (piece (id "Disc" Mover)) (to (sites Empty)) (then (if (can Move (forEach Piece (move Hop (from if:(notEqual (from) (last To))) Orthogonal (between if:(is In (between) (difference (sites Occupied by:Next) (sites (values Remembered)))) (apply (set Pending (between)))) (to if:(is Empty (to))) (then (and {(remember Value (value Pending)) (remove (value Pending)) (add (piece (id "Disc" Mover)) (to (value Pending)))} (then (and {(set Pending) (if (can Move (forEach Piece (move Hop (from (last To)) Orthogonal (between if:(is In (between) (difference (sites Occupied by:Next) (sites (values Remembered))))) (to if:(is Empty (to)))))) (moveAgain))}))))))) (moveAgain))))) (then (and (set Score Mover (count Pieces Mover)) (set Score Next (count Pieces Next)))))) (end {(if (and (or {(no Moves Next) (all Passed)}) (equals (score Mover) (score Next))) (result Mover Win)) (if (and (or {(no Moves Next) (all Passed)}) (notEqual (score Mover) (score Next))) (byScore))}))) 
