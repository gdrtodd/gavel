Each player, on their first five turns, uses some of their own pieces to create one King and three Generals, in any preferred order. A General is made by placing any single piece on top of an orthogonally adjacent piece, and a King is made by placing any single piece on top of an orthogonally adjacent General. - Soldiers move orthogonally one step to an adjacent square. - Generals move any distance in a straight line orthogonally, like a Chess Rook. - The King moves one step to any adjacent square, like a Chess King Capture is compulsory if possible. - A Soldier or King captures by jumping over an enemy piece occupying a square to which it can legally move and landing on the square immediately beyond it in the same direction, provided that the landing square is vacant. - A General captures in the same way, but may move any number of vacant squares before the captured piece, and may land on any successive vacant square in line of travel beyond the captured piece. If the capturing piece can then make another capture, it must, and it must continue doing so until all possible consecutive captures have been made. An enemy piece can only be jumped once in a single turn. If it is reached a second time it forms a block and ends the turn. At the end of a capturing turn all captured pieces must be removed from the board before the next player moves. If more than one capture is possible you must choose that which captures the greatest number of pieces, counting a King as three, a General as two, and a Soldier as one. If two possible capturing moves offer an equal number of pieces, you may freely choose between them. If one or more of your Generals is captured in one turn, you may create just one General (not more) from two orthogonally adjacent Soldiers anywhere on the board. If your King is captured you must, if possible, use your next turn to create another King by placing a Soldier on top of an adjacent General. If you are unable to create another King, when your King is captured, you lose the game. The game is played on a 9x9 square board.
(game "Fenix" (players 2) (equipment {(board (square 9)) (piece "Fenix" Each)}) (rules (start {(place "Fenix1" (expand (intersection (sites Bottom) (sites Right)) steps:6 Orthogonal) value:1) (place "Fenix2" (expand (intersection (sites Top) (sites Left)) steps:6 Orthogonal) value:1)}) phases:{(phase "Setup" (play (move (from (sites Occupied by:Mover) if:(equals 1 (size Stack at:(from)))) (to (sites Around (from) Own Orthogonal) if:(and {(notEqual (from) (to)) (lt (size Stack at:(to)) 3) (if (all Sites (sites Occupied by:Mover) if:(notEqual 3 (size Stack at:(site)))) True (lt (size Stack at:(to)) 2)) (if (notEqual 3 (count Sites in:(forEach (sites Occupied by:Mover) if:(equals 2 (size Stack at:(site)))))) True (not (equals 1 (size Stack at:(to)))))})))) (nextPhase Mover (and (not (all Sites (sites Occupied by:Mover) if:(notEqual 3 (size Stack at:(site))))) (not (notEqual 3 (count Sites in:(forEach (sites Occupied by:Mover) if:(equals 2 (size Stack at:(site)))))))) "Play")) (phase "Play" (play (if (is Prev Mover) (max Moves withValue:True (if (equals 1 (size Stack at:(last To))) (move Hop (from (last To)) Orthogonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn count:(size Stack at:(between))))) (to if:(is Empty (to))) stack:True (then (if (can Move (move Hop (from (last To)) Orthogonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn count:(size Stack at:(between))))) (to if:(is Empty (to))) stack:True)) (moveAgain)))) (if (equals 3 (size Stack at:(last To))) (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn count:(size Stack at:(between))))) (to if:(is Empty (to))) stack:True (then (if (can Move (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn count:(size Stack at:(between))))) (to if:(is Empty (to))) stack:True)) (moveAgain)))) (if (equals 2 (size Stack at:(last To))) (move Hop (from (last To)) Orthogonal (between before:(count Columns) after:(count Columns) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn count:(size Stack at:(between))))) (to if:(is Empty (to))) stack:True (then (if (can Move (hop (from (last To)) Orthogonal (between before:(count Columns) after:(count Columns) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))))))) (if (all Sites (sites Occupied by:Mover) if:(notEqual 3 (size Stack at:(site)))) (forEach Piece (if (equals 1 (size Stack at:(from))) (move Step Orthogonal (to if:(and (is Friend (who at:(to))) (equals 2 (size Stack at:(to))))) stack:True))) (priority {(max Moves withValue:True (forEach Piece (if (equals 1 (size Stack at:(from))) (move Hop (from (from)) Orthogonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn count:(size Stack at:(between))))) (to if:(is Empty (to))) stack:True (then (if (can Move (move Hop (from (last To)) Orthogonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn count:(size Stack at:(between))))) (to if:(is Empty (to))) stack:True)) (moveAgain)))) (if (equals 3 (size Stack at:(from))) (move Hop (from (from)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn count:(size Stack at:(between))))) (to if:(is Empty (to))) stack:True (then (if (can Move (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn count:(size Stack at:(between))))) (to if:(is Empty (to))) stack:True)) (moveAgain)))) (if (equals 2 (size Stack at:(from))) (move Hop (from) Orthogonal (between before:(count Columns) after:(count Columns) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn count:(size Stack at:(between))))) (to if:(is Empty (to))) stack:True (then (if (can Move (hop (from (last To)) Orthogonal (between before:(count Columns) after:(count Columns) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))))))) (forEach Piece (if (equals 1 (size Stack at:(from))) (or (move Step Orthogonal (to if:(is Empty (to))) stack:True) (if (notEqual 3 (count Sites in:(forEach (sites Occupied by:Mover) if:(equals 2 (size Stack at:(site)))))) (move Step Orthogonal (to if:(and (is Friend (who at:(to))) (equals 1 (size Stack at:(to))))) stack:True))) (if (equals 2 (size Stack at:(from))) (move Slide Orthogonal stack:True) (if (equals 3 (size Stack at:(from))) (move Step (to if:(is Empty (to))) stack:True)))))})))) (end (if (all Sites (sites Occupied by:Mover) if:(notEqual 3 (size Stack at:(site)))) (result Mover Loss))))})) 
