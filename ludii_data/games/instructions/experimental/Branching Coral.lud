Goal: Score the most points: -- One point for each stone in one's largest group. -- Bonus points are also awarded according to the selected option. The board starts empty. Players take alternating turns placing one of their stones onto an empty site. Directly after placement, every site of the board must remain connected to an empty perimeter site via a continuous path of empty sites, and the stone that was placed must be next to any 2 empty sites. Capture After placement, simultaneously remove all the stones adjacent to the placed stone that are no longer next to 2 empty sites. There is no passing. The game ends when no more placements can be made. Players score one point for every stone in their largest group, then, if applicable, score bonus points according to the selected option. Bonus Options are: -- Captured opponent's stones -- Count of one's own groups -- Count of the opponent's groups -- No Bonus The player with the higher score wins. If the scores are tied, the game is decided by the tie-breaker option that was selected before the game: A: Cascading largest group LOSES -- i.e. negative scores -- This excludes tied pairs; If all groups are paired, last to place. B: Last player to have placed a stone. Order 5 board - about 17 moves each Hex N / N-1 Grid, about 5% less moves Scoring Option: Score a point for each piece in your largest group and each opponent piece you capture Tiebreaker is largest group (excluding tied pairs) LOSES. If all are paired, last placement wins.
(game "Branching Coral" (players 2) (equipment {(board (hex Limping (sub 5 1)) use:Cell) (piece "Ball" Each) (piece "Disc" Each) (hand Each size:1)}) (rules (start (set Score Each 0)) (play (do (move Add (to (sites Empty) if:(lt 1 (count Sites in:(intersection (sites Around (to) Orthogonal) (sites Empty)))))) ifAfterwards:(all Sites (intersection (sites Around (last To) Orthogonal) (sites Empty)) if:(or (and (is Empty (site)) (is In (site) (sites Outer))) (notEqual 1000000000 (count Steps (step Orthogonal (to if:(is Empty (to)))) (site) (difference (sites Outer) (site)))))) (then (do (forEach Value (array (intersection (sites Occupied by:All) (sites Around (last To) Orthogonal))) (if (gt 2 (count Sites in:(sites Around (value) Orthogonal if:(is Empty (to))))) (if (is Mover (who at:(value))) (remove (value)) (remove (value) (then (if (is Empty (handSite Mover)) (add (piece (id "Disc" Next)) (to (handSite Mover)) (then (set Value at:(handSite Mover) (add 1 (value Piece at:(handSite Mover)))))) (set Value at:(handSite Mover) (add 1 (value Piece at:(handSite Mover)))))))))) next:(set Var "MoverScore" (add (value Piece at:(handSite Mover)) (max 0 (max (sizes Group Orthogonal Mover)))) (then (set Var "NextScore" (add (value Piece at:(handSite Next)) (max 0 (max (sizes Group Orthogonal Next)))) (then (if (equals (var "MoverScore") (var "NextScore")) (and (set Score Mover (sub 0 (max 0 (max (difference (sizes Group Orthogonal Mover) (sizes Group Orthogonal Next)))))) (set Score Next (sub 0 (max 0 (max (difference (sizes Group Orthogonal Next) (sizes Group Orthogonal Mover))))))) (and (set Score Mover (var "MoverScore")) (set Score Next (var "NextScore")))))))))))) (end (if (no Moves Next) {(if (equals (score Mover) (score Next)) (result Mover Win)) (if (notEqual (score Mover) (score Next)) (byScore))})))) 
