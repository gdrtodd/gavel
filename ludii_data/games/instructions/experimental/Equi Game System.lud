Equi is a 2-player strategy game in the Equi game system. It may be played: -- on a hex grid using hexagonal Territory pieces or -- on a square grid using square Territory pieces or -- on a square plus diagonal grid using square Territory pieces. It also uses Discs or counters as mobile pieces. The goal is to maximize your score when the board is full. Black starts by placing a black hex anywhere on the empty board, except for a corner. Turns then alternate. A turn has two parts: first 'The Move', and then 'The Required Placement'. The Move: Only Discs may move. A Disc may either: - A) move one step to an empty adjacent space, or - B) jump across a single piece belonging to either player onto the empty space directly behind it. -- As soon as any piece is jumped, the jumped piece is converted into a friendly Territory piece. -- Multiple consecutive jumps using the same piece are allowed, but no piece can be jumped more than once on the same turn. -- If the active Disc lands next to any enemy pieces which it can jump, it must immediately jump one of them. Forced Movement: If at the beginning of the turn, any enemy pieces can be jumped, the turn must start by jumping one. Otherwise, choosing to move a Disc is optional. The Required Placement: Placement is mandatory, may use either type, depending on location, (and is separate from the conversions due to jumping.) The placement must be made to an empty space on the board (possibly the place that Disc moved from.) The type of piece that gets placed depends on the number of pieces on the adjacent locations at the time of placement: -- If there are no adjacent pieces, or if the number of adjacent pieces is the same for each player, then a Territory piece is placed. -- Otherwise, a Disc must be placed there. The game ends when neither player has placed a piece on their previous turn. You score 1 point for each of your Territory pieces and deduct 3 points for each Disc. On a board with an odd number of cells there are no ties. Board & size: Hexhex with edges alternating 3 and 4 All hopped pieces become friendly territory pieces. An adjacent Enemy must be hopped, a Friend may be. Place on every turn. Discs may be placed after a Disc movement was made. No Passing, End when board is full. Place Discs at any Non-Hex location Territory score is 1 Discs penalty is 3
(game "Equi Game System" (players 2) (equipment {(board (tri {3 4 3 4 3}) use:Vertex) (piece "Disc" Each) (piece "Hex" Each)}) (rules (start (set Score Each 0)) (play (priority (if (is Prev Mover) (if (is Pending) (or (forEach Piece "Disc" (move Hop (from (last To)) Orthogonal (between if:(is In (between) (difference (intersection (difference (sites Occupied by:All) (sites Occupied by:Mover)) (sites Occupied by:All component:"Hex")) (sites (values Remembered)))) (apply (and (addScore (player (who at:(between))) (sub 1)) (set Pending (between))))) (to if:(is Empty (to)))) (then (and {(remember Value (value Pending)) (remove (value Pending)) (add (piece (id "Hex" Mover)) (to (value Pending))) (addScore Mover 1)} (then (and (set Pending) (moveAgain)))))) (forEach Piece "Disc" (move Hop (from (last To)) Orthogonal (between if:(is In (between) (difference (intersection (difference (sites Occupied by:All) (sites Occupied by:Mover)) (sites Occupied by:All component:"Disc")) (sites (values Remembered)))) (apply (and (addScore (player (who at:(between))) (sub -3)) (set Pending (between))))) (to if:(is Empty (to)))) (then (and {(remember Value (value Pending)) (remove (value Pending)) (add (piece (id "Hex" Mover)) (to (value Pending))) (addScore Mover 1)} (then (and (set Pending) (moveAgain)))))))) (do (forget Value All) next:(or (forEach Piece "Disc" (move Hop (from) Orthogonal (between if:(is In (between) (difference (intersection (difference (sites Occupied by:All) (sites Occupied by:Mover)) (sites Occupied by:All component:"Hex")) (sites (values Remembered)))) (apply (and (addScore (player (who at:(between))) (sub 1)) (set Pending (between))))) (to if:(is Empty (to)))) (then (and {(remember Value (value Pending)) (remove (value Pending)) (add (piece (id "Hex" Mover)) (to (value Pending))) (addScore Mover 1)} (then (and (set Pending) (moveAgain)))))) (forEach Piece "Disc" (move Hop (from) Orthogonal (between if:(is In (between) (difference (intersection (difference (sites Occupied by:All) (sites Occupied by:Mover)) (sites Occupied by:All component:"Disc")) (sites (values Remembered)))) (apply (and (addScore (player (who at:(between))) (sub -3)) (set Pending (between))))) (to if:(is Empty (to)))) (then (and {(remember Value (value Pending)) (remove (value Pending)) (add (piece (id "Hex" Mover)) (to (value Pending))) (addScore Mover 1)} (then (and (set Pending) (moveAgain))))))))) (or {(if (is Prev Mover) (or (move Add (piece (id "Disc" Mover)) (to (forEach (sites Empty) if:(notEqual (count Sites in:(intersection {(sites Occupied by:Mover) (sites Direction from:(site) Orthogonal distance:1) (sites LineOfSight Piece at:(site) Orthogonal)})) (count Sites in:(intersection {(difference (sites Occupied by:All) (sites Occupied by:Mover)) (sites Direction from:(site) Orthogonal distance:1) (sites LineOfSight Piece at:(site) Orthogonal)}))))) (then (and (addScore Mover -3) (set Var "FirstNoPlace" 0)))) (move Add (piece (id "Hex" Mover)) (to (forEach (sites Empty) if:(equals (count Sites in:(intersection {(sites Occupied by:Mover) (sites Direction from:(site) Orthogonal distance:1) (sites LineOfSight Piece at:(site) Orthogonal)})) (count Sites in:(intersection {(difference (sites Occupied by:All) (sites Occupied by:Mover)) (sites Direction from:(site) Orthogonal distance:1) (sites LineOfSight Piece at:(site) Orthogonal)}))))) (then (and (addScore Mover 1) (set Var "FirstNoPlace" 0))))) (or {(move Add (piece (id "Hex" Mover)) (to (forEach (sites Empty) if:(equals (count Sites in:(intersection {(sites Occupied by:Mover) (sites Direction from:(site) Orthogonal distance:1) (sites LineOfSight Piece at:(site) Orthogonal)})) (count Sites in:(intersection {(difference (sites Occupied by:All) (sites Occupied by:Mover)) (sites Direction from:(site) Orthogonal distance:1) (sites LineOfSight Piece at:(site) Orthogonal)}))))) (then (and (addScore Mover 1) (set Var "FirstNoPlace" 0)))) (move Add (piece (id "Disc" Mover)) (to (forEach (sites Empty) if:(notEqual (count Sites in:(intersection {(sites Occupied by:Mover) (sites Direction from:(site) Orthogonal distance:1) (sites LineOfSight Piece at:(site) Orthogonal)})) (count Sites in:(intersection {(difference (sites Occupied by:All) (sites Occupied by:Mover)) (sites Direction from:(site) Orthogonal distance:1) (sites LineOfSight Piece at:(site) Orthogonal)}))))) (then (and (addScore Mover -3) (set Var "FirstNoPlace" 0)))) (forEach Piece "Disc" (move (from (from)) (to (sites Around (from) Orthogonal) if:(is Empty (to))) (then (moveAgain))))})) (if (is Prev Mover) (if (is Pending) (or (forEach Piece "Disc" (move Hop (from (last To)) Orthogonal (between if:(is In (between) (difference (intersection (sites Occupied by:Mover) (sites Occupied by:All component:"Hex")) (sites (values Remembered)))) (apply (and (addScore (player (who at:(between))) (sub 1)) (set Pending (between))))) (to if:(is Empty (to)))) (then (and {(remember Value (value Pending)) (remove (value Pending)) (add (piece (id "Hex" Mover)) (to (value Pending))) (addScore Mover 1)} (then (and (set Pending) (moveAgain)))))) (forEach Piece "Disc" (move Hop (from (last To)) Orthogonal (between if:(is In (between) (difference (intersection (sites Occupied by:Mover) (sites Occupied by:All component:"Disc")) (sites (values Remembered)))) (apply (and (addScore (player (who at:(between))) (sub -3)) (set Pending (between))))) (to if:(is Empty (to)))) (then (and {(remember Value (value Pending)) (remove (value Pending)) (add (piece (id "Hex" Mover)) (to (value Pending))) (addScore Mover 1)} (then (and (set Pending) (moveAgain)))))))) (do (forget Value All) next:(or (forEach Piece "Disc" (move Hop (from) Orthogonal (between if:(is In (between) (difference (intersection (sites Occupied by:Mover) (sites Occupied by:All component:"Hex")) (sites (values Remembered)))) (apply (and (addScore (player (who at:(between))) (sub 1)) (set Pending (between))))) (to if:(is Empty (to)))) (then (and {(remember Value (value Pending)) (remove (value Pending)) (add (piece (id "Hex" Mover)) (to (value Pending))) (addScore Mover 1)} (then (and (set Pending) (moveAgain)))))) (forEach Piece "Disc" (move Hop (from) Orthogonal (between if:(is In (between) (difference (intersection (sites Occupied by:Mover) (sites Occupied by:All component:"Disc")) (sites (values Remembered)))) (apply (and (addScore (player (who at:(between))) (sub -3)) (set Pending (between))))) (to if:(is Empty (to)))) (then (and {(remember Value (value Pending)) (remove (value Pending)) (add (piece (id "Hex" Mover)) (to (value Pending))) (addScore Mover 1)} (then (and (set Pending) (moveAgain)))))))))}))) (end {(if (and {(no Moves Mover) (equals 1 (var "FirstNoPlace")) (equals (score Mover) (score Next))}) (result P1 Win)) (if (and {(no Moves Mover) (equals 2 (var "FirstNoPlace")) (equals (score Mover) (score Next))}) (result P2 Win)) (if (and (no Moves Mover) (notEqual (score Mover) (score Next))) (byScore))}))) 
