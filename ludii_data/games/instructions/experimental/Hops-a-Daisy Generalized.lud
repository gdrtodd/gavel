Equi is a game system played on a hex grid, for 2 or more players, using 2 types of reversable pieces. Each player has: -- Hexes that are stationary. The Hexes score 10 points at the end of the game, but are limited to certain sites of placement. -- Discs that move using steps and/or hops with flip-captures, Discs score according to the value selected in the (Options) normally -10. Note: look in the drop-down (Options) tab to see what Option are selected. Equi gets its name from the Hex placement rules: The neighborhood of the chosen location for a Hex must contain equal numbers of your own and your opponent's pieces. This neighborhood could be defined either as adjacent locations, or as locations in each direction of travel that are at the same distance as the closest relevant piece. (See the (Options) for your game.) The (Options) also determine who you can hop and who is your enemy in a multi-player seting. Turns: Each turn offers a choice, either place any a piece, or move a Disc. In addition, the Disc move may be followed by optionally placing a Hex. Any placement ends the turn. The standard options make Disc 'flip-captures' mandatory: This means that if a Disc is next to an opponent's piece which it can hop, then it must do so. The ownership of the hopped piece flips immediately. The same Disc may hop any number of available pieces, but may not, in any case, hop over the same location twice in the same turn. Depending on the (Options) chosen the Disc may, or may not, hop friendly pieces. Hopping friendly pieces is never required. In some (Options) the hopped pieces also 'morph' between Disc and Hex. The (Options) also determine whose pieces morph and whose don't. Except for Enemy flip-captures, all parts of a turn are optional and passing is allowed. But be careful about not making a placement during a turn, as this is an offer to end the game. Placements: Sites for placing Hexes have already been explained. Sites for placing a Disc at the beginning of a turn, are given in the (Options). -- 'Non-Hex' means sites where Hexes are not allowed to be placed. -- 'Safe' means not on sites where the next player's first action could be to hop-flip the Disc. -- 'Any' means any empty site The game ends when all the players have consecutively taken their turn without making a placement. Please have fun with this playground, and let me, the author, know which are your favorite game options... 2 players Board & size: Hexhex with edges alternating 4 and 6 Hopping enemies only changes ownership, Hopping friendly pieces unaffected An adjacent Enemy must be hopped, Friends cannot be Can hop Next, Equi is based on Next Equi count is based on adjacent cells Place Discs at any Non-Hex location, except where it can be taken by the next player's first hop Discs value is -10
(game "Hops-a-Daisy Generalized" (players 2) (equipment {(board (hex {4 6 4 6 4}) use:Cell) (piece "Disc" Each) (piece "Hex" Each)}) (rules (start (set Score Each 0)) (play (priority (if (is Prev Mover) (if (is Pending) (or (forEach Piece "Disc" (move Hop (from (last To)) (between if:(is In (between) (difference (intersection (sites Occupied by:(player (add 1 (mod (mover) 2)))) (sites Occupied by:All component:"Hex")) (sites (values Remembered)))) (apply (and (addScore (player (who at:(between))) (sub 10)) (set Pending (between))))) (to if:(is Empty (to)))) (then (and {(remember Value (value Pending)) (remove (value Pending)) (add (piece (id "Hex" Mover)) (to (value Pending))) (addScore Mover 10)} (then (and (set Pending) (moveAgain)))))) (forEach Piece "Disc" (move Hop (from (last To)) (between if:(is In (between) (difference (intersection (sites Occupied by:(player (add 1 (mod (mover) 2)))) (sites Occupied by:All component:"Disc")) (sites (values Remembered)))) (apply (and (addScore (player (who at:(between))) (sub -10)) (set Pending (between))))) (to if:(is Empty (to)))) (then (and {(remember Value (value Pending)) (remove (value Pending)) (add (piece (id "Disc" Mover)) (to (value Pending))) (addScore Mover -10)} (then (and (set Pending) (moveAgain)))))))) (do (forget Value All) next:(or (forEach Piece "Disc" (move Hop (from) (between if:(is In (between) (difference (intersection (sites Occupied by:(player (add 1 (mod (mover) 2)))) (sites Occupied by:All component:"Hex")) (sites (values Remembered)))) (apply (and (addScore (player (who at:(between))) (sub 10)) (set Pending (between))))) (to if:(is Empty (to)))) (then (and {(remember Value (value Pending)) (remove (value Pending)) (add (piece (id "Hex" Mover)) (to (value Pending))) (addScore Mover 10)} (then (and (set Pending) (moveAgain)))))) (forEach Piece "Disc" (move Hop (from) (between if:(is In (between) (difference (intersection (sites Occupied by:(player (add 1 (mod (mover) 2)))) (sites Occupied by:All component:"Disc")) (sites (values Remembered)))) (apply (and (addScore (player (who at:(between))) (sub -10)) (set Pending (between))))) (to if:(is Empty (to)))) (then (and {(remember Value (value Pending)) (remove (value Pending)) (add (piece (id "Disc" Mover)) (to (value Pending))) (addScore Mover -10)} (then (and (set Pending) (moveAgain))))))))) (or {(if (is Prev Mover) (or (do (if (equals 0 (var "FirstNoPlace")) (set Var "FirstNoPlace" (mover)) (if (equals (next) (var "FirstNoPlace")) (and (forEach Player (addScore (player (player)) (mod (add {2 (var "FirstNoPlace") (sub (player)) -1}) 2))) (propose "End")))) next:(move Pass)) (move Add (piece (id "Hex" Mover)) (to (forEach (sites Empty) if:(equals (count Sites in:(intersection {(sites Occupied by:Mover) (sites Direction from:(site) distance:1) (sites LineOfSight Piece at:(site) Orthogonal)})) (count Sites in:(intersection {(sites Occupied by:(player (add 1 (mod (mover) 2)))) (sites Direction from:(site) distance:1) (sites LineOfSight Piece at:(site) Orthogonal)}))))) (then (and (addScore Mover 10) (set Var "FirstNoPlace" 0))))) (or {(do (if (equals 0 (var "FirstNoPlace")) (set Var "FirstNoPlace" (mover)) (if (equals (next) (var "FirstNoPlace")) (and (forEach Player (addScore (player (player)) (mod (add {2 (var "FirstNoPlace") (sub (player)) -1}) 2))) (propose "End")))) next:(move Pass)) (move Add (piece (id "Hex" Mover)) (to (forEach (sites Empty) if:(equals (count Sites in:(intersection {(sites Occupied by:Mover) (sites Direction from:(site) distance:1) (sites LineOfSight Piece at:(site) Orthogonal)})) (count Sites in:(intersection {(sites Occupied by:(player (add 1 (mod (mover) 2)))) (sites Direction from:(site) distance:1) (sites LineOfSight Piece at:(site) Orthogonal)}))))) (then (and (addScore Mover 10) (set Var "FirstNoPlace" 0)))) (if (not (is Prev Mover)) (move Add (piece (id "Disc" Mover)) (to (forEach (difference (sites Empty) (sites To (forEach Site (intersection (sites Occupied by:(player (add 1 (mod (add (sub 2 2) (mover)) 2)))) (sites Occupied by:All component:"Disc")) (select (from (sites Distance from:(site) (exact 2)) if:(is Empty (from))) (to (sites Between from:(from) to:(site))))))) if:(notEqual (count Sites in:(intersection {(sites Occupied by:Mover) (sites Direction from:(site) distance:1) (sites LineOfSight Piece at:(site) Orthogonal)})) (count Sites in:(intersection {(sites Occupied by:(player (add 1 (mod (mover) 2)))) (sites Direction from:(site) distance:1) (sites LineOfSight Piece at:(site) Orthogonal)}))))) (then (and (addScore Mover -10) (set Var "FirstNoPlace" 0))))) (forEach Piece "Disc" (move (from (from)) (to (sites Around (from)) if:(is Empty (to))) (then (moveAgain))))}))}))) (end (if (is Proposed "End") (byScore))))) 
