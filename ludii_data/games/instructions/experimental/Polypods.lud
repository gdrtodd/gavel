Polypods is a game about groups of connected stones called Polypods. Understanding the mythical life of a polypod should help you to easily remember the rules. Polypods are creatures that have poisonous body segments that tie together its numerous feet. To survive, at least half of a polypod must be its feet, and this determines how they may grow and the shapes they may take. The feet die and fall off upon contact with the poisonous body segments of other polypods, however, since the feet themselves are not poisonous, there is no harm in their contact with other polypod's feet. Fortunately a polypod's foot is able to smell the area around it, and thus a polypod avoids extending its feet to touch the bodies of competing polypods. Hungry polypods do, however, find ways to bring their body against a foot of another polypod, causing that foot (or feet) to self-amputate. If the attacking polypod is lucky, the loss of a foot will cause its neighbor to die. The attacking polypod then ingests the body of its dead neighbor and spawns new polypods in the dead neighbor's feet. Definitions: -- A POLYPOD is a group of interconnected stones. The group includes every stone of the same color that is connected to it. (A single stone, or monopod, is also considered as a polypod in these rules.) Each stone in a polypod has one of two roles: Body or foot. -- FOOT STONES (FEET) are stones that connect to at most two other friendly stones:- and if connected to two stones, those two must already be adjacent to each other. -- BODY STONES are those that serve to link all the polypod feet together. As the polypods grow or shrink, the roles of their individual stones change accordingly. (In this application the body stones are marked with squares for convenience in reading the board.) A polypod is ALIVE if it has at least as many feet as body stones. -- Foot stones in contact with a body stone of the opposite color SELF-AMPUTATE (ie get immediately removed from the board) -- when a Polypod DIES, its body stones are removed, and its feet change ownership. Rules: The game uses discs played on the intersections of a triangular grid of the desired size and shape. The board starts empty and Dark starts. Turns Alternate. The moving player, either passes, or does the following sequence of actions, if possible: 1. The mover places a piece on an empty space. -- The placement must not cause the immediate self-amputation of the placed stone. -- It may add to or merge friendy polypods, UNLESS this would cause those polypod(s) to die. 2. The mover removes all self-amputating feet. 3. The mover resolves all polypod deaths. The game ends when the players pass consecutively. The winner is determined by tallying the value of each player's polypods. The value of a polypod is the number of body stones that it contains. If tied, score all the empty spaces adjacent to the players' own polypods. If this count is also equal, the game is considered a draw. Order 8 Square Grid
(game "Polypods" (players 2) (equipment {(board (square 8) use:Vertex) (piece "Disc" Each maxState:1 maxValue:4)}) (rules (play (or (move Pass) (do (do (move Add (to (difference (sites Empty) (sites Around (intersection (sites Occupied by:Next) (sites State 1))))) (then (and (set Value at:(last To) (layer of:(last To))) (if (equals 6 (count Sites in:(sites Corners))) (forEach Site (sites Group at:(last To)) (if (or (lt 2 (size Array (array (intersection (sites Group at:(last To)) (sites Around (site)))))) (and (equals 2 (size Array (array (intersection (sites Group at:(last To)) (sites Around (site)))))) (lt 1 (count Steps (min (array (intersection (sites Group at:(last To)) (sites Around (site))))) (max (array (intersection (sites Group at:(last To)) (sites Around (site))))))))) (set State at:(site) 1) (set State at:(site) 0))) (forEach Site (sites Group at:(last To)) (if (lt 1 (size Array (array (intersection (sites Group at:(last To)) (sites Around (site)))))) (set State at:(site) 1) (if (is Within (what at:(site)) in:(sites Around (site) N)) (set State at:(site) 2) (if (is Within (what at:(site)) in:(sites Around (site) E)) (set State at:(site) 3) (if (is Within (what at:(site)) in:(sites Around (site) S)) (set State at:(site) 4) (if (is Within (what at:(site)) in:(sites Around (site) W)) (set State at:(site) 5) (set State at:(site) 0))))))))))) ifAfterwards:(le 0 (add (results from:(sites Group at:(last To)) to:(from) (if (notEqual 1 (state at:(to))) 1 (sub 1))))) (then (do (forEach Site (intersection (sites Around (intersection (sites Group at:(last To)) (sites State 1))) (difference (sites Occupied by:Next) (sites State 1))) (remember Value "CS" (site) unique:True) (then (forEach Site (sites (results from:(intersection (sites Around (intersection (sites Group at:(last To)) (sites State 1))) (difference (sites Occupied by:Next) (sites State 1))) to:(min (array (difference (sites Group at:(from)) (intersection (sites Around (intersection (sites Group at:(last To)) (sites State 1))) (difference (sites Occupied by:Next) (sites State 1)))))) (to))) (remember Value "KS" (site) unique:True)))) next:(forEach Site (sites (values Remembered "CS")) (remove (site)) (then (forEach Value (values Remembered "KS") (if (equals 6 (count Sites in:(sites Corners))) (forEach Site (difference (sites Group at:(value)) (sites (values Remembered "CS"))) (if (or (lt 2 (size Array (array (intersection (difference (sites Group at:(value)) (sites (values Remembered "CS"))) (sites Around (site)))))) (and (equals 2 (size Array (array (intersection (difference (sites Group at:(value)) (sites (values Remembered "CS"))) (sites Around (site)))))) (lt 1 (count Steps (min (array (intersection (difference (sites Group at:(value)) (sites (values Remembered "CS"))) (sites Around (site))))) (max (array (intersection (difference (sites Group at:(value)) (sites (values Remembered "CS"))) (sites Around (site))))))))) (set State at:(site) 1) (set State at:(site) 0))) (forEach Site (difference (sites Group at:(value)) (sites (values Remembered "CS"))) (if (lt 1 (size Array (array (intersection (difference (sites Group at:(value)) (sites (values Remembered "CS"))) (sites Around (site)))))) (set State at:(site) 1) (if (is Within (what at:(site)) in:(sites Around (site) N)) (set State at:(site) 2) (if (is Within (what at:(site)) in:(sites Around (site) E)) (set State at:(site) 3) (if (is Within (what at:(site)) in:(sites Around (site) S)) (set State at:(site) 4) (if (is Within (what at:(site)) in:(sites Around (site) W)) (set State at:(site) 5) (set State at:(site) 0))))))))))) (then (and (forEach Value (values Remembered "KS") (if (not (le 0 (add (results from:(difference (sites Group at:(value)) (sites (values Remembered "CS"))) to:(from) (if (notEqual 1 (state at:(to))) 1 (sub 1)))))) (forEach Site (difference (sites Group at:(value)) (sites (values Remembered "CS"))) (if (equals 1 (state at:(site))) (remove (site)) (add (to (site) (apply (and (set Var "ConvertedFootSite" (to)) (remove (to))))) (then (and {(if (equals 6 (count Sites in:(sites Corners))) (forEach Site (sites Group at:(var "ConvertedFootSite")) (if (or (lt 2 (size Array (array (intersection (sites Group at:(var "ConvertedFootSite")) (sites Around (site)))))) (and (equals 2 (size Array (array (intersection (sites Group at:(var "ConvertedFootSite")) (sites Around (site)))))) (lt 1 (count Steps (min (array (intersection (sites Group at:(var "ConvertedFootSite")) (sites Around (site))))) (max (array (intersection (sites Group at:(var "ConvertedFootSite")) (sites Around (site))))))))) (set State at:(site) 1) (set State at:(site) 0))) (forEach Site (sites Group at:(var "ConvertedFootSite")) (if (lt 1 (size Array (array (intersection (sites Group at:(var "ConvertedFootSite")) (sites Around (site)))))) (set State at:(site) 1) (if (is Within (what at:(site)) in:(sites Around (site) N)) (set State at:(site) 2) (if (is Within (what at:(site)) in:(sites Around (site) E)) (set State at:(site) 3) (if (is Within (what at:(site)) in:(sites Around (site) S)) (set State at:(site) 4) (if (is Within (what at:(site)) in:(sites Around (site) W)) (set State at:(site) 5) (set State at:(site) 0))))))))} (then (if (not (le 0 (add (results from:(sites Group at:(var "ConvertedFootSite")) to:(from) (if (notEqual 1 (state at:(to))) 1 (sub 1)))))) (trigger "IllegalCapture" Mover)))))))))) (forget Value "CS" All (then (forget Value "KS" All)))))))) ifAfterwards:(not (is Triggered "IllegalCapture" Mover))) (then (and (set Score Mover (count Sites in:(intersection (sites Occupied by:Mover) (sites State 1)))) (set Score Next (count Sites in:(intersection (sites Occupied by:Next) (sites State 1)))))))) (end (if (all Passed) {(if (gt (score Mover) (score Next)) (result Mover Win)) (if (and (equals (score Mover) (score Next)) (ge (count Sites in:(difference (sites Around (sites Occupied by:Mover)) (sites Around (difference (sites Occupied by:All) (sites Occupied by:Mover)) includeSelf:True))) (count Sites in:(difference (sites Around (sites Occupied by:Next)) (sites Around (difference (sites Occupied by:All) (sites Occupied by:Next)) includeSelf:True))))) (result Mover Win)) (if (and (equals (score Mover) (score Next)) (equals (count Sites in:(difference (sites Around (sites Occupied by:Mover)) (sites Around (difference (sites Occupied by:All) (sites Occupied by:Mover)) includeSelf:True))) (count Sites in:(difference (sites Around (sites Occupied by:Next)) (sites Around (difference (sites Occupied by:All) (sites Occupied by:Next)) includeSelf:True))))) (result Mover Draw))} (result Next Win))))) 
