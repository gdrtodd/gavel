Goal: Player with the largest, most complex 'warren' wins. A warren is the entire networks of friendly stones, that separate areas of the board (enclosures) from each other and from external areas in contact with the board edges. -- Each distinct enclosure may contain any mixture of empty and enemy occupied sites. -- The sites of an enclosure cannot reach any additional site or reach an edge of the board, except by crossing friendly stones or the connections between them. The score is the product of warren complexity and free-space. The actual calculation depends on the board grid: see 'Options', below. Play: The player of the light stones starts by moving a single stone. Thereafter play alternates with each play performing two stone-moves on his turn. Each stone move is in one of the 6 grid directions, either -- to an empty cell surrounded by more friendly stones than before, or -- alternatively, to an empty cell surrounded by the same number of friendly stones, but fewer other neighbors. The moving stone may travel any distance, and pass over any number of stones of either player when moving. A player may pass part or all of his turn. When both players successively pass their entire turns, the game ends and is scored. The player with the higher score wins. If the scores are the same, the last player to move, loses. Rabbit Warrens (hex 6,8). Scoring: Product of the number of distinct enclosures, times the total number of empty sites within the enclosures.
(game "Rabbit Warrens" (players 2) (equipment {(board (hex Hexagon 6 8) use:Cell) (hand P1 size:2) (hand P2 size:2) (piece "Ball" Each) (piece "Hex" Each) (piece "Hex" Neutral)}) (rules (start {(place "Ball1" {2 6 9 13 17 21 25 29 33 37 38 42 46 53 57 61 64 68 72 77 81 85 89 93 97 101 108 112 113 117 121 125}) (place "Ball2" {1 5 11 15 18 22 26 27 31 35 41 45 49 51 55 59 65 69 73 75 79 83 88 92 99 103 105 109 115 119 120 124}) (place "Hex1" (handSite P1 0) value:0) (place "Hex2" (handSite P2 0) value:0) (place "Hex0" (handSite P1 1) value:0) (place "Hex0" (handSite P2 1) value:0)}) (play (or (move Pass) (forEach Piece (do (set Var "SitesMoverAroundFrom" (count Sites in:(sites Around (from) Orthogonal if:(is Mover (who at:(to)))))) next:(move Hop Adjacent (between (range 0 1000000000) if:True) (to (sites Empty) if:(is Empty (to)))) ifAfterwards:(or (lt (var "SitesMoverAroundFrom") (count Sites in:(sites Around (last To) Orthogonal if:(is Mover (who at:(to)))))) (and (equals (var "SitesMoverAroundFrom") (count Sites in:(sites Around (last To) Orthogonal if:(is Mover (who at:(to)))))) (gt (count Sites in:(sites Around (last From) Orthogonal if:(is Next (who at:(to))))) (count Sites in:(sites Around (last To) Orthogonal if:(is Next (who at:(to)))))))) (then (and {(and {(set Value at:(handSite Mover 0) (size Array (array (forEach (difference (sites Inner) (sites Occupied by:Mover)) if:(and (equals 1000000000 (count Steps (step Orthogonal (to if:(not (equals (id Mover) (who at:(to)))))) (site) (difference (sites Outer) (sites Inner)))) (is Empty (site))))))) (set Value at:(handSite Mover 1) (size Array (array (forEach (difference (sites Inner) (sites Occupied by:Mover)) if:(and (equals 1000000000 (count Steps (step Orthogonal (to if:(not (equals (id Mover) (who at:(to)))))) (site) (difference (sites Outer) (sites Inner)))) (equals 1000000000 (count Steps (step Orthogonal (to if:(not (equals (id Mover) (who at:(to)))))) (site) (sites (results from:(site) to:(forEach (sites Inner) if:(lt (from) (site))) (to)))))))))) (set Score Mover (mul (size Array (array (forEach (difference (sites Inner) (sites Occupied by:Mover)) if:(and (equals 1000000000 (count Steps (step Orthogonal (to if:(not (equals (id Mover) (who at:(to)))))) (site) (difference (sites Outer) (sites Inner)))) (is Empty (site)))))) (size Array (array (forEach (difference (sites Inner) (sites Occupied by:Mover)) if:(and (equals 1000000000 (count Steps (step Orthogonal (to if:(not (equals (id Mover) (who at:(to)))))) (site) (difference (sites Outer) (sites Inner)))) (equals 1000000000 (count Steps (step Orthogonal (to if:(not (equals (id Mover) (who at:(to)))))) (site) (sites (results from:(site) to:(forEach (sites Inner) if:(lt (from) (site))) (to)))))))))))}) (and {(set Value at:(handSite Next 0) (size Array (array (forEach (difference (sites Inner) (sites Occupied by:Next)) if:(and (equals 1000000000 (count Steps (step Orthogonal (to if:(not (equals (id Next) (who at:(to)))))) (site) (difference (sites Outer) (sites Inner)))) (is Empty (site))))))) (set Value at:(handSite Next 1) (size Array (array (forEach (difference (sites Inner) (sites Occupied by:Next)) if:(and (equals 1000000000 (count Steps (step Orthogonal (to if:(not (equals (id Next) (who at:(to)))))) (site) (difference (sites Outer) (sites Inner)))) (equals 1000000000 (count Steps (step Orthogonal (to if:(not (equals (id Next) (who at:(to)))))) (site) (sites (results from:(site) to:(forEach (sites Inner) if:(lt (from) (site))) (to)))))))))) (set Score Next (mul (size Array (array (forEach (difference (sites Inner) (sites Occupied by:Next)) if:(and (equals 1000000000 (count Steps (step Orthogonal (to if:(not (equals (id Next) (who at:(to)))))) (site) (difference (sites Outer) (sites Inner)))) (is Empty (site)))))) (size Array (array (forEach (difference (sites Inner) (sites Occupied by:Next)) if:(and (equals 1000000000 (count Steps (step Orthogonal (to if:(not (equals (id Next) (who at:(to)))))) (site) (difference (sites Outer) (sites Inner)))) (equals 1000000000 (count Steps (step Orthogonal (to if:(not (equals (id Next) (who at:(to)))))) (site) (sites (results from:(site) to:(forEach (sites Inner) if:(lt (from) (site))) (to)))))))))))}) (if (is Prev Next) (moveAgain))})))))) (end {(if (and (equals (score P1) (score P2)) (all Passed)) (byScore {(score Mover 0)})) (if (all Passed) (byScore))}))) 
