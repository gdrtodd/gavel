Choose a board of the desired size and grid. Play on the nodes of the grid. The board starts empty and the dark color plays first. Players alternate placing a stone of their color onto an empty node of the board. When this placement forms an adjacent pair, the mover must choose a grid direction along which to move that pair one step, pushing all the stones in front of them. RESTRICTIONS: 1) No opponent's stone may be pushed of the board. 2) Neither stone of the moving pair may leave the board. Note that pushing off OTHER friendly stones IS allowed. Note: A pair may not be created unless it can move. After the move and/or push is completed, the mover receives the leader's token if he now has more pairs than the other player. Players may pass. The game ends when either: 1) There is no place on the board for the player who doesn't have the token to be able to form a new pair in the future. - or - 2) Both pass consecutively. The player with the token wins. Medium Board (Hex 4 / Limping 3,4 / Square 5) Square Board
(game "Tennessee Waltz" (players 2) (equipment {(board (square (add 1 4)) use:Vertex) (hand Each size:1) (piece "Disc" Each)}) (rules (play (or {(if (equals 1 (mod (add (score P1) (score P2)) 2)) (move Pass)) (move Add (to (sites Empty) if:(not (and (equals 1 (count Pieces Mover in:(sites Around (to) Orthogonal))) (no Pieces Mover in:(sites Around (intersection (sites Around (to) Orthogonal) (sites Occupied by:Mover)) Orthogonal)))))) (do (set Var "StartTurnEnemy" (count Sites in:(sites Occupied by:Next))) next:(do (move Select (from (sites Empty) if:(and (equals 1 (count Pieces Mover in:(sites Around (from) Orthogonal))) (no Pieces Mover in:(sites Around (intersection (sites Around (from) Orthogonal) (sites Occupied by:Mover)) Orthogonal)))) (to (sites Around (from) All)) (then (and (set Var "LF" (last From) (then (set Var "LT" (last To) (then (set Var "PairedSite" (regionSite (intersection (sites Around (var "LF") Orthogonal) (sites Occupied by:Mover)) index:0)))))) (add (piece (id "Disc" Mover)) (to (last From)) (then (if (equals (var "PairedSite") (var "LT")) (push (from (var "LF")) (directions Vertex from:(var "LF") to:(var "LT"))) (if (equals (var "LF") (ahead (var "PairedSite") (directions Vertex from:(var "LF") to:(var "LT")))) (push (from (var "PairedSite")) (directions Vertex from:(var "LF") to:(var "LT"))) (if (equals (var "PairedSite") (ahead (var "PairedSite") (directions Vertex from:(var "LF") to:(var "LT")))) (remove (var "LF")) (and (push (from (var "LF")) (directions Vertex from:(var "LF") to:(var "LT"))) (push (from (var "PairedSite")) (directions Vertex from:(var "LF") to:(var "LT")))))))))))) ifAfterwards:(and (not (is Repeat PositionalInTurn)) (equals (count Sites in:(sites Occupied by:Next)) (var "StartTurnEnemy")))))} (then (and (and (set Score Mover (size Array (results from:(intersection (sites Board) (sites Occupied by:Mover)) to:(forEach (sites Around (from) Orthogonal) if:(and (is Mover (who at:(site))) (equals 2 (count Pieces Mover in:(union (sites Around (from) Orthogonal) (sites Around (site) Orthogonal)))))) (from)))) (if (gt (size Array (results from:(intersection (sites Board) (sites Occupied by:Mover)) to:(forEach (sites Around (from) Orthogonal) if:(and (is Mover (who at:(site))) (equals 2 (count Pieces Mover in:(union (sites Around (from) Orthogonal) (sites Around (site) Orthogonal)))))) (from))) (size Array (results from:(intersection (sites Board) (sites Occupied by:Next)) to:(forEach (sites Around (from) Orthogonal) if:(and (is Next (who at:(site))) (equals 2 (count Pieces Next in:(union (sites Around (from) Orthogonal) (sites Around (site) Orthogonal)))))) (from)))) (addScore Mover 1 (then (if (no Pieces Mover in:(sites Hand Mover)) (add (piece (id "Disc" Mover)) (to (handSite Mover)) stack:False (then (remove (sites Hand Next))))))) (if (and (not (no Pieces Mover in:(sites Hand Mover))) (equals (size Array (results from:(intersection (sites Board) (sites Occupied by:Mover)) to:(forEach (sites Around (from) Orthogonal) if:(and (is Mover (who at:(site))) (equals 2 (count Pieces Mover in:(union (sites Around (from) Orthogonal) (sites Around (site) Orthogonal)))))) (from))) (size Array (results from:(intersection (sites Board) (sites Occupied by:Next)) to:(forEach (sites Around (from) Orthogonal) if:(and (is Next (who at:(site))) (equals 2 (count Pieces Next in:(union (sites Around (from) Orthogonal) (sites Around (site) Orthogonal)))))) (from))))) (addScore Mover 1)))) (and (set Score Next (size Array (results from:(intersection (sites Board) (sites Occupied by:Next)) to:(forEach (sites Around (from) Orthogonal) if:(and (is Next (who at:(site))) (equals 2 (count Pieces Next in:(union (sites Around (from) Orthogonal) (sites Around (site) Orthogonal)))))) (from)))) (if (gt (size Array (results from:(intersection (sites Board) (sites Occupied by:Next)) to:(forEach (sites Around (from) Orthogonal) if:(and (is Next (who at:(site))) (equals 2 (count Pieces Next in:(union (sites Around (from) Orthogonal) (sites Around (site) Orthogonal)))))) (from))) (size Array (results from:(intersection (sites Board) (sites Occupied by:Mover)) to:(forEach (sites Around (from) Orthogonal) if:(and (is Mover (who at:(site))) (equals 2 (count Pieces Mover in:(union (sites Around (from) Orthogonal) (sites Around (site) Orthogonal)))))) (from)))) (addScore Next 1 (then (if (no Pieces Next in:(sites Hand Next)) (add (piece (id "Disc" Next)) (to (handSite Next)) stack:False (then (remove (sites Hand Mover))))))) (if (and (not (no Pieces Next in:(sites Hand Next))) (equals (size Array (results from:(intersection (sites Board) (sites Occupied by:Next)) to:(forEach (sites Around (from) Orthogonal) if:(and (is Next (who at:(site))) (equals 2 (count Pieces Next in:(union (sites Around (from) Orthogonal) (sites Around (site) Orthogonal)))))) (from))) (size Array (results from:(intersection (sites Board) (sites Occupied by:Mover)) to:(forEach (sites Around (from) Orthogonal) if:(and (is Mover (who at:(site))) (equals 2 (count Pieces Mover in:(union (sites Around (from) Orthogonal) (sites Around (site) Orthogonal)))))) (from))))) (addScore Next 1)))))))) (end (if (or (or {(and (gt (score Mover) (score Next)) (equals 0 (size Array (array (sites To (select (from (sites Empty) if:(or {(and (equals 1 (count Pieces Next in:(sites Around (from) Orthogonal))) (no Pieces Next in:(sites Around (intersection (sites Around (from) Orthogonal) (sites Occupied by:Next)) Orthogonal))) (and (no Pieces Next in:(sites Around (from) Orthogonal)) (lt 0 (size Array (array (forEach (intersection (sites Around (from) Orthogonal) (sites Empty)) if:(no Pieces Next in:(sites Around (site) Orthogonal)))))))})))))))) (and (lt (score Mover) (score Next)) (equals 0 (size Array (array (sites To (select (from (sites Empty) if:(or {(and (equals 1 (count Pieces Mover in:(sites Around (from) Orthogonal))) (no Pieces Mover in:(sites Around (intersection (sites Around (from) Orthogonal) (sites Occupied by:Mover)) Orthogonal))) (and (no Pieces Mover in:(sites Around (from) Orthogonal)) (lt 0 (size Array (array (forEach (intersection (sites Around (from) Orthogonal) (sites Empty)) if:(no Pieces Mover in:(sites Around (site) Orthogonal)))))))}))))))))}) (all Passed)) (byScore))))) 
