Goal: Last to place a stone, wins. Definitions: -- Stones are connected if they are the same color and next to each other orthogonally. -- Groups consist of connected stones. Every stone is part of exactly one group. Every group contains all the stones connected to it. (Groups without any adjacent playable sites are shown with grey dots, for convenience.) Play starts with black. Turns alternate. Passing is not allowed. A player with less than 2 groups with adjacent playable sites must place a stone to create a new group, or LOSE. Otherwise, placement is allowed next to a group of the same size as the smallest mover's group with an adjacent playable site. Group holdings are all the sites that lie between pairs of each group's members. After placement, capture every enemy STONE within friendly holdings. Placement inside the opponent's holdings is forbidden. -- Nibbler is close to the original Gap game, but gives a bit more freedom in play, and may work better than the original on larger boards. 4 Hexagon Board A player with less than 2 groups with adjacent playable sites must place a stone to create a new group, or LOSE. Otherwise, placement is allowed next to a group of the same size as the smallest mover's group with an adjacent playable site. Group holdings are all the sites that lie between pairs of each group's members. After placement, capture every enemy STONE within friendly holdings. Placement inside the opponent's holdings is forbidden.
(game "The SmallHolder" (players 2) (equipment {(board (hex Hexagon 4) use:Cell) (piece "Disc" Each)}) (rules (play (if (gt 2 (count Groups Orthogonal if:(and (equals 0 (state at:(to))) (is Mover (who at:(to)))))) (move Add (to (if (equals 1 (mover)) (difference (sites Empty) (sites (values Remembered "P2"))) (difference (sites Empty) (sites (values Remembered "P1")))) if:(all Sites (sites Around (to) Orthogonal) if:(not (is Mover (who at:(site))))))) (or (move Add (to (if (equals 1 (mover)) (difference (sites Empty) (sites (values Remembered "P2"))) (difference (sites Empty) (sites (values Remembered "P1")))) if:(all Sites (sites Around (to) Orthogonal) if:(not (is Mover (who at:(site))))))) (move Add (to (if (equals 1 (mover)) (difference (sites Empty) (sites (values Remembered "P2"))) (difference (sites Empty) (sites (values Remembered "P1")))) if:(not (all Sites (sites Around (to) Orthogonal if:(is Mover (who at:(to)))) if:(lt (min (results from:(difference (sites Occupied by:Mover) (sites State 1)) to:(from) (size Group at:(from) Orthogonal))) (size Group at:(site) Orthogonal))))))) (then (seq {(forEach Site (sites Group at:(last To) Orthogonal) (set Value at:(site) (count Sites in:(sites Group at:(last To) Orthogonal)))) (if (lt 0 (count Pieces Mover in:(sites Around (last To) Orthogonal))) (seq {(forEach Site (union {(intersection (sites Direction from:(sites Group at:(last To) Orthogonal) NNW) (sites Direction from:(sites Group at:(last To) Orthogonal) SSE)) (intersection (sites Direction from:(sites Group at:(last To) Orthogonal) NNE) (sites Direction from:(sites Group at:(last To) Orthogonal) SSW)) (intersection (sites Direction from:(sites Group at:(last To) Orthogonal) E) (sites Direction from:(sites Group at:(last To) Orthogonal) W))}) (if (equals (mover) 1) (remember Value "P1" (site) unique:True) (remember Value "P2" (site) unique:True))) (if (equals (mover) 1) (forEach Group Orthogonal if:(is In (to) (intersection (sites Board) (sites Occupied by:Next))) (remove (intersection (sites) (sites (values Remembered "P1")))) (then (seq {(forget Value "P2" All) (forEach Group Orthogonal if:(is In (to) (sites Occupied by:Next)) (forEach Site (union {(intersection (sites Direction from:(sites) NNW) (sites Direction from:(sites) SSE)) (intersection (sites Direction from:(sites) NNE) (sites Direction from:(sites) SSW)) (intersection (sites Direction from:(sites) E) (sites Direction from:(sites) W))}) (if (equals (mover) 1) (remember Value "P2" (site) unique:True) (remember Value "P1" (site) unique:True))))}))) (forEach Group Orthogonal if:(is In (to) (intersection (sites Board) (sites Occupied by:Next))) (remove (intersection (sites) (sites (values Remembered "P2")))) (then (seq {(forget Value "P1" All) (forEach Group Orthogonal if:(is In (to) (sites Occupied by:Next)) (forEach Site (union {(intersection (sites Direction from:(sites) NNW) (sites Direction from:(sites) SSE)) (intersection (sites Direction from:(sites) NNE) (sites Direction from:(sites) SSW)) (intersection (sites Direction from:(sites) E) (sites Direction from:(sites) W))}) (if (equals (mover) 1) (remember Value "P2" (site) unique:True) (remember Value "P1" (site) unique:True))))}))))})) (forEach Group Orthogonal if:(is In (to) (sites Occupied by:Next)) (if (lt 0 (size Array (array (intersection (sites Around (sites) Orthogonal if:(is Empty (to))) (if (equals 2 (mover)) (difference (sites Empty) (sites (values Remembered "P2"))) (difference (sites Empty) (sites (values Remembered "P1")))))))) (forEach Value (array (sites)) (set State at:(value) 0)) (forEach Value (array (sites)) (set State at:(value) 1))))})))) (end (if (no Moves Next) (result Next Loss))))) 
