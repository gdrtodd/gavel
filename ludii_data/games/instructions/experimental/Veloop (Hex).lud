Goal: Form an orthogonally connected path of friendly stones that surrounds at least one non-friendly stone. Set-up: Two stones, one of each colour, are placed next to each other adjacent to the center of the board. Then Black starts. Play: Each turn has two parts that both must be completed: A PLACEMENT and a SWAP. -- The PLACEMENT is made diagonally from a selected stone of the same color. -- The SWAP is done by exchanging the contents of the 2 cells that lie between the selected stone and the placed stone. For a SWAP to be valid, the contents of these cells must be different, i.e.: two stones of different color, or an empty space and a stone. If a turn cannot be completed with a placement to an empty position, the placement must be made by placing on top of an opponent's stone. The placement and swap rules apply to the visible stones and must still be followed. Voluntary passing is not allowed. When neither player can move, the game ends in a draw. To help visualise the moves, the 'Show Last Move' option shows an arrow from the placement site to the supporting friendly piece and the swap pieces are to either side of this arrow. Optional Variants: -- Larger Board to reduce the strategic effect of the edge cells. / Smaller board to focus on stacked play as a significant part of the game. -- Double move protocol for a shorter, more tactical game, that maintains a balance of material on every turn. Edge 343434 Hexagon Turns alternate
(game "Veloop (Hex)" (players 2) (equipment {(board (renumber (rotate 90 (hex Limping 3))) use:Cell) (piece "Disc" Each)}) (rules (start {(place "Disc1" 10) (place "Disc2" 16)}) (play (priority (move Select (from (sites Empty) if:(gt 2 (count Stack at:(from)))) (to (sites Around (from) Diagonal) if:(and {(is In (to) (sites Occupied by:Mover top:True)) (equals 2 (count Sites in:(intersection (sites Around (to) Adjacent) (sites Around (from) Adjacent)))) (or (equals 1 (count Sites in:(intersection (intersection (sites Around (to) Adjacent) (sites Around (from) Adjacent)) (sites Occupied by:Mover top:True)))) (equals 1 (count Sites in:(intersection (intersection (sites Around (to) Adjacent) (sites Around (from) Adjacent)) (sites Occupied by:Next top:True)))))})) (then (and {(add (piece (id "Disc" Mover)) (to (last From)) stack:True) (forEach Site (intersection (sites Around (last To) Adjacent) (sites Around (last From) Adjacent)) (remember Value (site)))}))) (move Select (from (sites Occupied by:Next) if:(gt 2 (count Stack at:(from)))) (to (sites Around (from) Diagonal) if:(and {(is In (to) (sites Occupied by:Mover top:True)) (equals 2 (count Sites in:(intersection (sites Around (to) Adjacent) (sites Around (from) Adjacent)))) (or (equals 1 (count Sites in:(intersection (intersection (sites Around (to) Adjacent) (sites Around (from) Adjacent)) (sites Occupied by:Mover top:True)))) (equals 1 (count Sites in:(intersection (intersection (sites Around (to) Adjacent) (sites Around (from) Adjacent)) (sites Occupied by:Next top:True)))))})) (then (and {(add (piece (id "Disc" Mover)) (to (last From)) stack:True) (forEach Site (intersection (sites Around (last To) Adjacent) (sites Around (last From) Adjacent)) (remember Value (site)))}))) (then (if (is Empty (arrayValue (values Remembered) index:1)) (fromTo (from (arrayValue (values Remembered) index:0)) (to (arrayValue (values Remembered) index:1))) (if (is Empty (arrayValue (values Remembered) index:0)) (fromTo (from (arrayValue (values Remembered) index:1)) (to (arrayValue (values Remembered) index:0))) (set Var "Piece1" (what at:(arrayValue (values Remembered) index:1) level:(topLevel at:(arrayValue (values Remembered) index:1))) (then (add (piece (what at:(arrayValue (values Remembered) index:0) level:(topLevel at:(arrayValue (values Remembered) index:0)))) (to (arrayValue (values Remembered) index:1) (apply (remove (to)))) (then (add (piece (var "Piece1")) (to (arrayValue (values Remembered) index:0) (apply (remove (to)))))))))) (then (and {(set Score Mover (sub 0 (count Sites in:(difference (sites Occupied by:Mover) (forEach (sites Board) if:(notEqual 1000000000 (count Steps Adjacent (step Adjacent (to if:(or (is Empty (to)) (is Mover (who at:(to)))))) (site) (sites Outer)))))))) (set Score Next (sub 0 (count Sites in:(difference (sites Occupied by:Next) (forEach (sites Board) if:(notEqual 1000000000 (count Steps Adjacent (step Adjacent (to if:(or (is Empty (to)) (is Next (who at:(to)))))) (site) (sites Outer)))))))) (forget Value All)})))))) (end (if (notEqual 0 (add (score P1) (score P2))) (byScore))))) 
