(define "InTheGoal" (is In #1 (sites Next)))

(define "EmptyButNotEnemyGoal" (difference (sites Empty) (sites Mover)))

(define "OnAFriend" (between if:("IsFriendAt" (between))))

(define "MoveAgainAfterJumpingFriend" (and (moveAgain) (set Pending)))

(define "MoveAgainAfterJumpingEnemy" (moveAgain))

(define "WasJumpingAFriend" (is Pending))

(define "WasAKnight" ("IsPieceAt" "Knight" Mover (last To)))

(define "OnAnEnemy" (between if:("IsEnemyAt" (between)) (apply (remove (between)))))

(define "Step" 
    (move Step
        (to if:(if ("InTheGoal" (from))
                (and 
                    (is Empty (to)) 
                    ("InTheGoal" (to))
                ) 
                (is In (to) "EmptyButNotEnemyGoal")
            )
        )
    )
)

(define "Hop" 
    (move Hop 
        (from #1)
        #2
        (to if:(and (is In (to) "EmptyButNotEnemyGoal") (not (is Visited (to)))))
        #3		
    )
) 

(define "HopSequence" 
    ("Hop" 
        #1 
        #2
        (then 
            (if 
                (and 
                    (not ("InTheGoal" (last To))) 
                    (can Move ("Hop" (last To) #2))
                ) 
                #3 
            )
        )
    )
)

(define "NotEnoughPieceForBothPlayer" (and (< (count Pieces Mover) 2) (< (count Pieces Next) 2)))

(define "NotEnoughPieceForTheMover" (and (>= (count Pieces Mover) 2) (= (count Pieces Next) 0)))

(define "GoalFilledby" (= (sites #2) (sites Occupied by:#1)))

(game "Camelot" 
    (players 2) 
    (equipment { 
        (board 
            (keep 
                (rectangle 12 16) 
                (poly { {0 7} {1 10} {4 13} {12 13} {15 10} {16 7} 
                {16 5} {15 2} {13 0} {3 0} {1 2} {0 5} })
            )
        )
        (piece "Pawn" Each
            (or
                (if (not ("InTheGoal" (from))) ("HopSequence" (from) "OnAFriend" "MoveAgainAfterJumpingFriend"))
                "Step"
            )
        )
        
        (piece "Knight" Each 
            (or
                (if (not ("InTheGoal" (from))) ("HopSequence" (from) "OnAFriend" "MoveAgainAfterJumpingFriend"))
                "Step"
            )
        )
        
        (regions P1 (sites {"A6" "A7"})) 
        (regions P2 (sites {"P6" "P7"})) 
    }) 
    (rules 
        (start {
            (place "Pawn1" {"F4" "F5" "F6" "F7" "F8" "F9" "G5" "G6" "G7" "G8"})
            (place "Knight1" {"F3" "G4" "G9" "F10"})
            (place "Pawn2" {"K4" "K5" "K6" "K7" "K8" "K9" "J5" "J6" "J7" "J8"})
            (place "Knight2" {"K3" "J4" "J9" "K10"})
        })
        
        (play 
            (if "SameTurn"
                (if "WasJumpingAFriend"
                    (if "WasAKnight"
                        
                        (priority {
                            ("HopSequence" (last To) "OnAnEnemy" "MoveAgainAfterJumpingEnemy")
                            (or
                                ("HopSequence" (last To) "OnAFriend" "MoveAgainAfterJumpingFriend")
                                (move Pass)
                            )
                        })
                        (or
                            ("HopSequence" (last To) "OnAFriend" "MoveAgainAfterJumpingFriend")
                            (move Pass)
                        )
                    )
                    ("HopSequence" (last To) "OnAnEnemy" "MoveAgainAfterJumpingEnemy")
                )
                
                (priority {
                    
                    (forEach Site
                        (sites Mover)
                        (if (= (who at:(site)) (mover))
                            (priority {
                                ("HopSequence" (site) "OnAnEnemy" "MoveAgainAfterJumpingEnemy")
                                (or
                                    ("HopSequence" (site) "OnAFriend" "MoveAgainAfterJumpingFriend")
                                    "Step"
                                )
                            })
                        )
                    )
                    
                    (forEach Piece 
                        (move Hop 
                            "OnAnEnemy"
                            (to 
                                if:(if 
                                    ("InTheGoal" (from))
                                    (and 
                                        (is Empty (to)) 
                                        ("InTheGoal" (to))
                                    ) 
                                    (is In (to) "EmptyButNotEnemyGoal")
                                )
                            ) 
                            (then 
                                (if 
                                    (and 
                                        (not ("InTheGoal" (last To))) 
                                        (can Move 
                                            (hop 
                                                (from (last To)) 
                                                "OnAnEnemy"
                                                (to if:(is Empty (to))) 
                                            ) 
                                        ) 
                                    ) 
                                    "MoveAgainAfterJumpingEnemy" 
                                ) 
                            ) 
                        ) 
                    )
                    (forEach Piece)
                })
            )
        )
        
        (end {
            (if ("GoalFilledby" P1 P2) (result P1 Win))
            (if ("GoalFilledby" P2 P1) (result P2 Win))
            (if "NotEnoughPieceForTheMover" (result Mover Win)) 
            (if "NotEnoughPieceForBothPlayer" (result Mover Draw)) 
        }) 
    )
)

