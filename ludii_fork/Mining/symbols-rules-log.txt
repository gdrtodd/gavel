
+++++++++++++++++++ SYMBOLS ++++++++++++++++++++++
gd~* <int> type=Primitive (int) => <int>, pack=game.functions.ints, label=int, cls=int, keyword=int
gd~* <boolean> type=Primitive (boolean) => <boolean>, pack=game.functions.booleans, label=boolean, cls=boolean, keyword=boolean
gd~* <float> type=Primitive (float) => <float>, pack=game.functions.floats, label=float, cls=float, keyword=float
gdm~ <Integer> type=Predefined (java.lang.Integer) => <Integer>, pack=game.functions.ints, label=int, cls=java.lang.Integer, keyword=int
gdm~ <Boolean> type=Predefined (java.lang.Boolean) => <Boolean>, pack=game.functions.booleans, label=boolean, cls=java.lang.Boolean, keyword=boolean
gdm~ <Float> type=Predefined (java.lang.Float) => <Float>, pack=game.functions.floats, label=float, cls=java.lang.Float, keyword=float
gdm~ <String> type=Predefined (java.lang.String) => <String>, pack=game.types, label=string, cls=java.lang.String, keyword=string
gd~* <Off> type=Primitive (Off) => <int>, pack=global, label=Off, cls=int, keyword=Off
gd~* <End> type=Primitive (End) => <int>, pack=global, label=End, cls=int, keyword=End
gd~* <Undefined> type=Primitive (Undefined) => <int>, pack=global, label=Undefined, cls=int, keyword=Undefined
gd~* <Unused> type=Primitive (Unused) => <int>, pack=global, label=Unused, cls=int, keyword=Unused
gd~* <Nobody> type=Primitive (Nobody) => <int>, pack=global, label=Nobody, cls=int, keyword=Nobody
gd~* <NoPiece> type=Primitive (NoPiece) => <int>, pack=global, label=NoPiece, cls=int, keyword=NoPiece
gd~~ <mode> type=Ludeme (game.mode.Mode) => <mode>, pack=game.mode, label=mode, cls=game.mode.Mode, keyword=mode
~~~* <aPI> type=Structural (game.API) => <aPI>, pack=game, label=aPI, cls=game.API, keyword=aPI
gd~~ <region.math.union> type=Ludeme (game.functions.region.math.Union) => <equipment.region>, pack=game.functions.region.math, label=region.math.union, cls=game.functions.region.math.Union, keyword=union
gd~~ <region.math.difference> type=Ludeme (game.functions.region.math.Difference) => <equipment.region>, pack=game.functions.region.math, label=region.math.difference, cls=game.functions.region.math.Difference, keyword=difference
gd~~ <expand> type=Ludeme (game.functions.region.math.Expand) => <equipment.region>, pack=game.functions.region.math, label=expand, cls=game.functions.region.math.Expand, keyword=expand
gd~~ <region.math.intersection> type=Ludeme (game.functions.region.math.Intersection) => <equipment.region>, pack=game.functions.region.math, label=region.math.intersection, cls=game.functions.region.math.Intersection, keyword=intersection
gd~~ <region.math.if> type=Ludeme (game.functions.region.math.If) => <equipment.region>, pack=game.functions.region.math, label=region.math.if, cls=game.functions.region.math.If, keyword=if
~~~~ <sitesPieceType> type=Structural (game.functions.region.sites.SitesPieceType) => <sitesPieceType>, pack=game.functions.region.sites, label=sitesPieceType, cls=game.functions.region.sites.SitesPieceType, keyword=sitesPieceType
~~~~ <between.sitesBetween> type=SubLudeme (game.functions.region.sites.between.SitesBetween) => <equipment.region>, pack=game.functions.region.sites.between, label=between.sitesBetween, cls=game.functions.region.sites.between.SitesBetween, keyword=sitesBetween
~~~~ <sitesIncidentType> type=Structural (game.functions.region.sites.SitesIncidentType) => <sitesIncidentType>, pack=game.functions.region.sites, label=sitesIncidentType, cls=game.functions.region.sites.SitesIncidentType, keyword=sitesIncidentType
~~~~ <sitesAroundType> type=Structural (game.functions.region.sites.SitesAroundType) => <sitesAroundType>, pack=game.functions.region.sites, label=sitesAroundType, cls=game.functions.region.sites.SitesAroundType, keyword=sitesAroundType
~~~~ <sitesRandomType> type=Structural (game.functions.region.sites.SitesRandomType) => <sitesRandomType>, pack=game.functions.region.sites, label=sitesRandomType, cls=game.functions.region.sites.SitesRandomType, keyword=sitesRandomType
~~~~ <sitesAxial> type=SubLudeme (game.functions.region.sites.edges.SitesAxial) => <equipment.region>, pack=game.functions.region.sites.edges, label=sitesAxial, cls=game.functions.region.sites.edges.SitesAxial, keyword=sitesAxial
~~~~ <sitesSlosh> type=SubLudeme (game.functions.region.sites.edges.SitesSlosh) => <equipment.region>, pack=game.functions.region.sites.edges, label=sitesSlosh, cls=game.functions.region.sites.edges.SitesSlosh, keyword=sitesSlosh
~~~~ <sitesAngled> type=SubLudeme (game.functions.region.sites.edges.SitesAngled) => <equipment.region>, pack=game.functions.region.sites.edges, label=sitesAngled, cls=game.functions.region.sites.edges.SitesAngled, keyword=sitesAngled
~~~~ <sitesVertical> type=SubLudeme (game.functions.region.sites.edges.SitesVertical) => <equipment.region>, pack=game.functions.region.sites.edges, label=sitesVertical, cls=game.functions.region.sites.edges.SitesVertical, keyword=sitesVertical
~~~~ <sitesHorizontal> type=SubLudeme (game.functions.region.sites.edges.SitesHorizontal) => <equipment.region>, pack=game.functions.region.sites.edges, label=sitesHorizontal, cls=game.functions.region.sites.edges.SitesHorizontal, keyword=sitesHorizontal
~~~~ <sitesSlash> type=SubLudeme (game.functions.region.sites.edges.SitesSlash) => <equipment.region>, pack=game.functions.region.sites.edges, label=sitesSlash, cls=game.functions.region.sites.edges.SitesSlash, keyword=sitesSlash
~~~~ <moves.sitesBetween> type=SubLudeme (game.functions.region.sites.moves.SitesBetween) => <equipment.region>, pack=game.functions.region.sites.moves, label=moves.sitesBetween, cls=game.functions.region.sites.moves.SitesBetween, keyword=sitesBetween
~~~~ <sitesTo> type=SubLudeme (game.functions.region.sites.moves.SitesTo) => <equipment.region>, pack=game.functions.region.sites.moves, label=sitesTo, cls=game.functions.region.sites.moves.SitesTo, keyword=sitesTo
~~~~ <sitesFrom> type=SubLudeme (game.functions.region.sites.moves.SitesFrom) => <equipment.region>, pack=game.functions.region.sites.moves, label=sitesFrom, cls=game.functions.region.sites.moves.SitesFrom, keyword=sitesFrom
~~~~ <sitesStart> type=SubLudeme (game.functions.region.sites.piece.SitesStart) => <equipment.region>, pack=game.functions.region.sites.piece, label=sitesStart, cls=game.functions.region.sites.piece.SitesStart, keyword=sitesStart
g~~~ <sitesPlayerType> type=Structural (game.functions.region.sites.SitesPlayerType) => <sitesPlayerType>, pack=game.functions.region.sites, label=sitesPlayerType, cls=game.functions.region.sites.SitesPlayerType, keyword=sitesPlayerType
~~~~ <sitesLargePieceType> type=Structural (game.functions.region.sites.SitesLargePieceType) => <sitesLargePieceType>, pack=game.functions.region.sites, label=sitesLargePieceType, cls=game.functions.region.sites.SitesLargePieceType, keyword=sitesLargePieceType
~~~~ <sitesDistance> type=SubLudeme (game.functions.region.sites.distance.SitesDistance) => <equipment.region>, pack=game.functions.region.sites.distance, label=sitesDistance, cls=game.functions.region.sites.distance.SitesDistance, keyword=sitesDistance
~~~~ <sitesSide> type=SubLudeme (game.functions.region.sites.side.SitesSide) => <equipment.region>, pack=game.functions.region.sites.side, label=sitesSide, cls=game.functions.region.sites.side.SitesSide, keyword=sitesSide
~~~~ <sitesPattern> type=SubLudeme (game.functions.region.sites.pattern.SitesPattern) => <equipment.region>, pack=game.functions.region.sites.pattern, label=sitesPattern, cls=game.functions.region.sites.pattern.SitesPattern, keyword=sitesPattern
~~~~ <sitesGroupType> type=Structural (game.functions.region.sites.SitesGroupType) => <sitesGroupType>, pack=game.functions.region.sites, label=sitesGroupType, cls=game.functions.region.sites.SitesGroupType, keyword=sitesGroupType
~~~~ <sitesCrossing> type=SubLudeme (game.functions.region.sites.crossing.SitesCrossing) => <equipment.region>, pack=game.functions.region.sites.crossing, label=sitesCrossing, cls=game.functions.region.sites.crossing.SitesCrossing, keyword=sitesCrossing
~~~~ <sitesDirection> type=SubLudeme (game.functions.region.sites.direction.SitesDirection) => <equipment.region>, pack=game.functions.region.sites.direction, label=sitesDirection, cls=game.functions.region.sites.direction.SitesDirection, keyword=sitesDirection
g~~~ <sitesIndexType> type=Structural (game.functions.region.sites.SitesIndexType) => <sitesIndexType>, pack=game.functions.region.sites, label=sitesIndexType, cls=game.functions.region.sites.SitesIndexType, keyword=sitesIndexType
~~~~ <sitesPatternType> type=Structural (game.functions.region.sites.SitesPatternType) => <sitesPatternType>, pack=game.functions.region.sites, label=sitesPatternType, cls=game.functions.region.sites.SitesPatternType, keyword=sitesPatternType
~~~~ <sitesBetweenType> type=Structural (game.functions.region.sites.SitesBetweenType) => <sitesBetweenType>, pack=game.functions.region.sites, label=sitesBetweenType, cls=game.functions.region.sites.SitesBetweenType, keyword=sitesBetweenType
~~~~ <sitesHand> type=SubLudeme (game.functions.region.sites.player.SitesHand) => <equipment.region>, pack=game.functions.region.sites.player, label=sitesHand, cls=game.functions.region.sites.player.SitesHand, keyword=sitesHand
~~~~ <sitesWinning> type=SubLudeme (game.functions.region.sites.player.SitesWinning) => <equipment.region>, pack=game.functions.region.sites.player, label=sitesWinning, cls=game.functions.region.sites.player.SitesWinning, keyword=sitesWinning
~~~~ <sitesEquipmentRegion> type=SubLudeme (game.functions.region.sites.player.SitesEquipmentRegion) => <equipment.region>, pack=game.functions.region.sites.player, label=sitesEquipmentRegion, cls=game.functions.region.sites.player.SitesEquipmentRegion, keyword=sitesEquipmentRegion
~~~~ <sitesGroup> type=SubLudeme (game.functions.region.sites.group.SitesGroup) => <equipment.region>, pack=game.functions.region.sites.group, label=sitesGroup, cls=game.functions.region.sites.group.SitesGroup, keyword=sitesGroup
g~~~ <sitesSimpleType> type=Structural (game.functions.region.sites.SitesSimpleType) => <sitesSimpleType>, pack=game.functions.region.sites, label=sitesSimpleType, cls=game.functions.region.sites.SitesSimpleType, keyword=sitesSimpleType
g~~~ <lineOfSightType> type=Structural (game.functions.region.sites.LineOfSightType) => <lineOfSightType>, pack=game.functions.region.sites, label=lineOfSightType, cls=game.functions.region.sites.LineOfSightType, keyword=lineOfSightType
~~~~ <sitesTrackType> type=Structural (game.functions.region.sites.SitesTrackType) => <sitesTrackType>, pack=game.functions.region.sites, label=sitesTrackType, cls=game.functions.region.sites.SitesTrackType, keyword=sitesTrackType
~~~~ <sitesRight> type=SubLudeme (game.functions.region.sites.simple.SitesRight) => <equipment.region>, pack=game.functions.region.sites.simple, label=sitesRight, cls=game.functions.region.sites.simple.SitesRight, keyword=sitesRight
~~~~ <sitesPending> type=SubLudeme (game.functions.region.sites.simple.SitesPending) => <equipment.region>, pack=game.functions.region.sites.simple, label=sitesPending, cls=game.functions.region.sites.simple.SitesPending, keyword=sitesPending
~~~~ <sitesMajor> type=SubLudeme (game.functions.region.sites.simple.SitesMajor) => <equipment.region>, pack=game.functions.region.sites.simple, label=sitesMajor, cls=game.functions.region.sites.simple.SitesMajor, keyword=sitesMajor
~~~~ <sitesHint> type=SubLudeme (game.functions.region.sites.simple.SitesHint) => <equipment.region>, pack=game.functions.region.sites.simple, label=sitesHint, cls=game.functions.region.sites.simple.SitesHint, keyword=sitesHint
~~~~ <sitesBoard> type=SubLudeme (game.functions.region.sites.simple.SitesBoard) => <equipment.region>, pack=game.functions.region.sites.simple, label=sitesBoard, cls=game.functions.region.sites.simple.SitesBoard, keyword=sitesBoard
~~~~ <sitesTop> type=SubLudeme (game.functions.region.sites.simple.SitesTop) => <equipment.region>, pack=game.functions.region.sites.simple, label=sitesTop, cls=game.functions.region.sites.simple.SitesTop, keyword=sitesTop
~~~~ <sitesConvexCorners> type=SubLudeme (game.functions.region.sites.simple.SitesConvexCorners) => <equipment.region>, pack=game.functions.region.sites.simple, label=sitesConvexCorners, cls=game.functions.region.sites.simple.SitesConvexCorners, keyword=sitesConvexCorners
~~~~ <sitesInner> type=SubLudeme (game.functions.region.sites.simple.SitesInner) => <equipment.region>, pack=game.functions.region.sites.simple, label=sitesInner, cls=game.functions.region.sites.simple.SitesInner, keyword=sitesInner
~~~~ <sitesLastFrom> type=SubLudeme (game.functions.region.sites.simple.SitesLastFrom) => <equipment.region>, pack=game.functions.region.sites.simple, label=sitesLastFrom, cls=game.functions.region.sites.simple.SitesLastFrom, keyword=sitesLastFrom
~~~~ <sitesOuter> type=SubLudeme (game.functions.region.sites.simple.SitesOuter) => <equipment.region>, pack=game.functions.region.sites.simple, label=sitesOuter, cls=game.functions.region.sites.simple.SitesOuter, keyword=sitesOuter
~~~~ <sitesPerimeter> type=SubLudeme (game.functions.region.sites.simple.SitesPerimeter) => <equipment.region>, pack=game.functions.region.sites.simple, label=sitesPerimeter, cls=game.functions.region.sites.simple.SitesPerimeter, keyword=sitesPerimeter
~~~~ <sitesToClear> type=SubLudeme (game.functions.region.sites.simple.SitesToClear) => <equipment.region>, pack=game.functions.region.sites.simple, label=sitesToClear, cls=game.functions.region.sites.simple.SitesToClear, keyword=sitesToClear
~~~~ <sitesLineOfPlay> type=SubLudeme (game.functions.region.sites.simple.SitesLineOfPlay) => <equipment.region>, pack=game.functions.region.sites.simple, label=sitesLineOfPlay, cls=game.functions.region.sites.simple.SitesLineOfPlay, keyword=sitesLineOfPlay
~~~~ <sitesBottom> type=SubLudeme (game.functions.region.sites.simple.SitesBottom) => <equipment.region>, pack=game.functions.region.sites.simple, label=sitesBottom, cls=game.functions.region.sites.simple.SitesBottom, keyword=sitesBottom
~~~~ <sitesLastTo> type=SubLudeme (game.functions.region.sites.simple.SitesLastTo) => <equipment.region>, pack=game.functions.region.sites.simple, label=sitesLastTo, cls=game.functions.region.sites.simple.SitesLastTo, keyword=sitesLastTo
~~~~ <sitesConcaveCorners> type=SubLudeme (game.functions.region.sites.simple.SitesConcaveCorners) => <equipment.region>, pack=game.functions.region.sites.simple, label=sitesConcaveCorners, cls=game.functions.region.sites.simple.SitesConcaveCorners, keyword=sitesConcaveCorners
~~~~ <sitesLeft> type=SubLudeme (game.functions.region.sites.simple.SitesLeft) => <equipment.region>, pack=game.functions.region.sites.simple, label=sitesLeft, cls=game.functions.region.sites.simple.SitesLeft, keyword=sitesLeft
~~~~ <sitesMinor> type=SubLudeme (game.functions.region.sites.simple.SitesMinor) => <equipment.region>, pack=game.functions.region.sites.simple, label=sitesMinor, cls=game.functions.region.sites.simple.SitesMinor, keyword=sitesMinor
~~~~ <sitesCorners> type=SubLudeme (game.functions.region.sites.simple.SitesCorners) => <equipment.region>, pack=game.functions.region.sites.simple, label=sitesCorners, cls=game.functions.region.sites.simple.SitesCorners, keyword=sitesCorners
~~~~ <sitesPlayable> type=SubLudeme (game.functions.region.sites.simple.SitesPlayable) => <equipment.region>, pack=game.functions.region.sites.simple, label=sitesPlayable, cls=game.functions.region.sites.simple.SitesPlayable, keyword=sitesPlayable
~~~~ <sitesCentre> type=SubLudeme (game.functions.region.sites.simple.SitesCentre) => <equipment.region>, pack=game.functions.region.sites.simple, label=sitesCentre, cls=game.functions.region.sites.simple.SitesCentre, keyword=sitesCentre
~~~~ <sitesAround> type=SubLudeme (game.functions.region.sites.around.SitesAround) => <equipment.region>, pack=game.functions.region.sites.around, label=sitesAround, cls=game.functions.region.sites.around.SitesAround, keyword=sitesAround
~~~~ <sitesLineOfSightType> type=Structural (game.functions.region.sites.SitesLineOfSightType) => <sitesLineOfSightType>, pack=game.functions.region.sites, label=sitesLineOfSightType, cls=game.functions.region.sites.SitesLineOfSightType, keyword=sitesLineOfSightType
~~~~ <sitesLoop> type=SubLudeme (game.functions.region.sites.loop.SitesLoop) => <equipment.region>, pack=game.functions.region.sites.loop, label=sitesLoop, cls=game.functions.region.sites.loop.SitesLoop, keyword=sitesLoop
~~~~ <sitesWalk> type=SubLudeme (game.functions.region.sites.walk.SitesWalk) => <equipment.region>, pack=game.functions.region.sites.walk, label=sitesWalk, cls=game.functions.region.sites.walk.SitesWalk, keyword=sitesWalk
g~~~ <sitesMoveType> type=Structural (game.functions.region.sites.SitesMoveType) => <sitesMoveType>, pack=game.functions.region.sites, label=sitesMoveType, cls=game.functions.region.sites.SitesMoveType, keyword=sitesMoveType
~~~~ <sitesDirectionType> type=Structural (game.functions.region.sites.SitesDirectionType) => <sitesDirectionType>, pack=game.functions.region.sites, label=sitesDirectionType, cls=game.functions.region.sites.SitesDirectionType, keyword=sitesDirectionType
~~~~ <sitesDistanceType> type=Structural (game.functions.region.sites.SitesDistanceType) => <sitesDistanceType>, pack=game.functions.region.sites, label=sitesDistanceType, cls=game.functions.region.sites.SitesDistanceType, keyword=sitesDistanceType
~~~~ <sitesEmpty> type=SuperLudeme (game.functions.region.sites.index.SitesEmpty) => <equipment.region>, pack=game.functions.region.sites.index, label=sitesEmpty, cls=game.functions.region.sites.index.SitesEmpty, keyword=sitesEmpty
~~~~ <sitesRow> type=SubLudeme (game.functions.region.sites.index.SitesRow) => <equipment.region>, pack=game.functions.region.sites.index, label=sitesRow, cls=game.functions.region.sites.index.SitesRow, keyword=sitesRow
~~~~ <sitesEdge> type=SubLudeme (game.functions.region.sites.index.SitesEdge) => <equipment.region>, pack=game.functions.region.sites.index, label=sitesEdge, cls=game.functions.region.sites.index.SitesEdge, keyword=sitesEdge
~~~~ <sitesPhase> type=SubLudeme (game.functions.region.sites.index.SitesPhase) => <equipment.region>, pack=game.functions.region.sites.index, label=sitesPhase, cls=game.functions.region.sites.index.SitesPhase, keyword=sitesPhase
~~~~ <sitesCell> type=SubLudeme (game.functions.region.sites.index.SitesCell) => <equipment.region>, pack=game.functions.region.sites.index, label=sitesCell, cls=game.functions.region.sites.index.SitesCell, keyword=sitesCell
~~~~ <sitesColumn> type=SubLudeme (game.functions.region.sites.index.SitesColumn) => <equipment.region>, pack=game.functions.region.sites.index, label=sitesColumn, cls=game.functions.region.sites.index.SitesColumn, keyword=sitesColumn
~~~~ <sitesState> type=SubLudeme (game.functions.region.sites.index.SitesState) => <equipment.region>, pack=game.functions.region.sites.index, label=sitesState, cls=game.functions.region.sites.index.SitesState, keyword=sitesState
~~~~ <sitesLayer> type=SubLudeme (game.functions.region.sites.index.SitesLayer) => <equipment.region>, pack=game.functions.region.sites.index, label=sitesLayer, cls=game.functions.region.sites.index.SitesLayer, keyword=sitesLayer
gd~~ <sites> type=SuperLudeme (game.functions.region.sites.Sites) => <equipment.region>, pack=game.functions.region.sites, label=sites, cls=game.functions.region.sites.Sites, keyword=sites
~~~~ <sitesLineOfSight> type=SubLudeme (game.functions.region.sites.lineOfSight.SitesLineOfSight) => <equipment.region>, pack=game.functions.region.sites.lineOfSight, label=sitesLineOfSight, cls=game.functions.region.sites.lineOfSight.SitesLineOfSight, keyword=sitesLineOfSight
~~~~ <sitesLargePiece> type=SubLudeme (game.functions.region.sites.largePiece.SitesLargePiece) => <equipment.region>, pack=game.functions.region.sites.largePiece, label=sitesLargePiece, cls=game.functions.region.sites.largePiece.SitesLargePiece, keyword=sitesLargePiece
~~~~ <sitesContext> type=SubLudeme (game.functions.region.sites.context.SitesContext) => <equipment.region>, pack=game.functions.region.sites.context, label=sitesContext, cls=game.functions.region.sites.context.SitesContext, keyword=sitesContext
~~~~ <sitesOccupied> type=SubLudeme (game.functions.region.sites.occupied.SitesOccupied) => <equipment.region>, pack=game.functions.region.sites.occupied, label=sitesOccupied, cls=game.functions.region.sites.occupied.SitesOccupied, keyword=sitesOccupied
g~~~ <sitesEdgeType> type=Structural (game.functions.region.sites.SitesEdgeType) => <sitesEdgeType>, pack=game.functions.region.sites, label=sitesEdgeType, cls=game.functions.region.sites.SitesEdgeType, keyword=sitesEdgeType
~~~~ <sitesLoopType> type=Structural (game.functions.region.sites.SitesLoopType) => <sitesLoopType>, pack=game.functions.region.sites, label=sitesLoopType, cls=game.functions.region.sites.SitesLoopType, keyword=sitesLoopType
~~~~ <sitesHiddenWho> type=SubLudeme (game.functions.region.sites.hidden.SitesHiddenWho) => <equipment.region>, pack=game.functions.region.sites.hidden, label=sitesHiddenWho, cls=game.functions.region.sites.hidden.SitesHiddenWho, keyword=sitesHiddenWho
~~~~ <sitesHiddenWhat> type=SubLudeme (game.functions.region.sites.hidden.SitesHiddenWhat) => <equipment.region>, pack=game.functions.region.sites.hidden, label=sitesHiddenWhat, cls=game.functions.region.sites.hidden.SitesHiddenWhat, keyword=sitesHiddenWhat
~~~~ <sitesHidden> type=SubLudeme (game.functions.region.sites.hidden.SitesHidden) => <equipment.region>, pack=game.functions.region.sites.hidden, label=sitesHidden, cls=game.functions.region.sites.hidden.SitesHidden, keyword=sitesHidden
~~~~ <sitesHiddenState> type=SubLudeme (game.functions.region.sites.hidden.SitesHiddenState) => <equipment.region>, pack=game.functions.region.sites.hidden, label=sitesHiddenState, cls=game.functions.region.sites.hidden.SitesHiddenState, keyword=sitesHiddenState
~~~~ <sitesHiddenCount> type=SubLudeme (game.functions.region.sites.hidden.SitesHiddenCount) => <equipment.region>, pack=game.functions.region.sites.hidden, label=sitesHiddenCount, cls=game.functions.region.sites.hidden.SitesHiddenCount, keyword=sitesHiddenCount
~~~~ <sitesHiddenValue> type=SubLudeme (game.functions.region.sites.hidden.SitesHiddenValue) => <equipment.region>, pack=game.functions.region.sites.hidden, label=sitesHiddenValue, cls=game.functions.region.sites.hidden.SitesHiddenValue, keyword=sitesHiddenValue
~~~~ <sitesHiddenRotation> type=SubLudeme (game.functions.region.sites.hidden.SitesHiddenRotation) => <equipment.region>, pack=game.functions.region.sites.hidden, label=sitesHiddenRotation, cls=game.functions.region.sites.hidden.SitesHiddenRotation, keyword=sitesHiddenRotation
~~~~ <sitesHiddenType> type=Structural (game.functions.region.sites.SitesHiddenType) => <sitesHiddenType>, pack=game.functions.region.sites, label=sitesHiddenType, cls=game.functions.region.sites.SitesHiddenType, keyword=sitesHiddenType
~~~~ <sitesSideType> type=Structural (game.functions.region.sites.SitesSideType) => <sitesSideType>, pack=game.functions.region.sites, label=sitesSideType, cls=game.functions.region.sites.SitesSideType, keyword=sitesSideType
~~~~ <sitesCoords> type=SubLudeme (game.functions.region.sites.coords.SitesCoords) => <equipment.region>, pack=game.functions.region.sites.coords, label=sitesCoords, cls=game.functions.region.sites.coords.SitesCoords, keyword=sitesCoords
~~~~ <sitesOccupiedType> type=Structural (game.functions.region.sites.SitesOccupiedType) => <sitesOccupiedType>, pack=game.functions.region.sites, label=sitesOccupiedType, cls=game.functions.region.sites.SitesOccupiedType, keyword=sitesOccupiedType
~~~~ <sitesCustom> type=SubLudeme (game.functions.region.sites.custom.SitesCustom) => <equipment.region>, pack=game.functions.region.sites.custom, label=sitesCustom, cls=game.functions.region.sites.custom.SitesCustom, keyword=sitesCustom
~~~~ <sitesRandom> type=SubLudeme (game.functions.region.sites.random.SitesRandom) => <equipment.region>, pack=game.functions.region.sites.random, label=sitesRandom, cls=game.functions.region.sites.random.SitesRandom, keyword=sitesRandom
~~~~ <sitesIncident> type=SubLudeme (game.functions.region.sites.incidents.SitesIncident) => <equipment.region>, pack=game.functions.region.sites.incidents, label=sitesIncident, cls=game.functions.region.sites.incidents.SitesIncident, keyword=sitesIncident
~~~~ <sitesCrossingType> type=Structural (game.functions.region.sites.SitesCrossingType) => <sitesCrossingType>, pack=game.functions.region.sites, label=sitesCrossingType, cls=game.functions.region.sites.SitesCrossingType, keyword=sitesCrossingType
~~~~ <sitesTrack> type=SubLudeme (game.functions.region.sites.track.SitesTrack) => <equipment.region>, pack=game.functions.region.sites.track, label=sitesTrack, cls=game.functions.region.sites.track.SitesTrack, keyword=sitesTrack
~~~~ <lastRegionType> type=Structural (game.functions.region.last.LastRegionType) => <lastRegionType>, pack=game.functions.region.last, label=lastRegionType, cls=game.functions.region.last.LastRegionType, keyword=lastRegionType
~~~~ <lastBetween> type=SubLudeme (game.functions.region.last.LastBetween) => <equipment.region>, pack=game.functions.region.last, label=lastBetween, cls=game.functions.region.last.LastBetween, keyword=lastBetween
gd~~ <region.last.last> type=SuperLudeme (game.functions.region.last.Last) => <equipment.region>, pack=game.functions.region.last, label=region.last.last, cls=game.functions.region.last.Last, keyword=last
~~~~ <region.foreach.player.forEachPlayer> type=SubLudeme (game.functions.region.foreach.player.ForEachPlayer) => <equipment.region>, pack=game.functions.region.foreach.player, label=region.foreach.player.forEachPlayer, cls=game.functions.region.foreach.player.ForEachPlayer, keyword=forEachPlayer
~~~~ <sites.forEachSite> type=SubLudeme (game.functions.region.foreach.sites.ForEachSite) => <equipment.region>, pack=game.functions.region.foreach.sites, label=sites.forEachSite, cls=game.functions.region.foreach.sites.ForEachSite, keyword=forEachSite
gd~~ <region.foreach.forEach> type=SuperLudeme (game.functions.region.foreach.ForEach) => <equipment.region>, pack=game.functions.region.foreach, label=region.foreach.forEach, cls=game.functions.region.foreach.ForEach, keyword=forEach
~~~~ <region.foreach.team.forEachTeam> type=SubLudeme (game.functions.region.foreach.team.ForEachTeam) => <equipment.region>, pack=game.functions.region.foreach.team, label=region.foreach.team.forEachTeam, cls=game.functions.region.foreach.team.ForEachTeam, keyword=forEachTeam
~~~* <baseRegionFunction> type=Ludeme (game.functions.region.BaseRegionFunction) => <baseRegionFunction>, pack=game.functions.region, label=baseRegionFunction, cls=game.functions.region.BaseRegionFunction, keyword=baseRegionFunction
g~m* <sites> type=Structural (game.functions.region.RegionFunction) => <equipment.region>, pack=game.functions.region, label=sites, cls=game.functions.region.RegionFunction, keyword=regionFunction
~~~~ <regionConstant> type=Ludeme (game.functions.region.RegionConstant) => <equipment.region>, pack=game.functions.region, label=regionConstant, cls=game.functions.region.RegionConstant, keyword=regionConstant
g~~* <dim> type=Structural (game.functions.dim.DimFunction) => <int>, pack=game.functions.dim, label=dim, cls=game.functions.dim.DimFunction, keyword=dimFunction
~~~~ <dimConstant> type=Ludeme (game.functions.dim.DimConstant) => <int>, pack=game.functions.dim, label=dimConstant, cls=game.functions.dim.DimConstant, keyword=dimConstant
gd~~ <dim.math.min> type=Ludeme (game.functions.dim.math.Min) => <int>, pack=game.functions.dim.math, label=dim.math.min, cls=game.functions.dim.math.Min, keyword=min
gd~~ <dim.math.abs> type=Ludeme (game.functions.dim.math.Abs) => <int>, pack=game.functions.dim.math, label=dim.math.abs, cls=game.functions.dim.math.Abs, keyword=abs
gd~~ <dim.math.*> type=Ludeme (game.functions.dim.math.Mul) => <int>, pack=game.functions.dim.math, label=dim.math.*, cls=game.functions.dim.math.Mul, keyword=*
gd~~ <dim.math.-> type=Ludeme (game.functions.dim.math.Sub) => <int>, pack=game.functions.dim.math, label=dim.math.-, cls=game.functions.dim.math.Sub, keyword=-
gd~~ <dim.math.max> type=Ludeme (game.functions.dim.math.Max) => <int>, pack=game.functions.dim.math, label=dim.math.max, cls=game.functions.dim.math.Max, keyword=max
gd~~ <dim.math.+> type=Ludeme (game.functions.dim.math.Add) => <int>, pack=game.functions.dim.math, label=dim.math.+, cls=game.functions.dim.math.Add, keyword=+
gd~~ <dim.math./> type=Ludeme (game.functions.dim.math.Div) => <int>, pack=game.functions.dim.math, label=dim.math./, cls=game.functions.dim.math.Div, keyword=/
gd~~ <dim.math.^> type=Ludeme (game.functions.dim.math.Pow) => <int>, pack=game.functions.dim.math, label=dim.math.^, cls=game.functions.dim.math.Pow, keyword=^
gd~* <dim> type=Ludeme (game.functions.dim.BaseDimFunction) => <dim>, pack=game.functions.dim, label=dim, cls=game.functions.dim.BaseDimFunction, keyword=dim
~~~~ <allValues> type=SubLudeme (game.functions.booleans.all.values.AllValues) => <boolean>, pack=game.functions.booleans.all.values, label=allValues, cls=game.functions.booleans.all.values.AllValues, keyword=allValues
~~~~ <allValuesType> type=Structural (game.functions.booleans.all.AllValuesType) => <allValuesType>, pack=game.functions.booleans.all, label=allValuesType, cls=game.functions.booleans.all.AllValuesType, keyword=allValuesType
~~~~ <allDiceEqual> type=SubLudeme (game.functions.booleans.all.simple.AllDiceEqual) => <boolean>, pack=game.functions.booleans.all.simple, label=allDiceEqual, cls=game.functions.booleans.all.simple.AllDiceEqual, keyword=allDiceEqual
~~~~ <allPassed> type=SubLudeme (game.functions.booleans.all.simple.AllPassed) => <boolean>, pack=game.functions.booleans.all.simple, label=allPassed, cls=game.functions.booleans.all.simple.AllPassed, keyword=allPassed
~~~~ <allDiceUsed> type=SubLudeme (game.functions.booleans.all.simple.AllDiceUsed) => <boolean>, pack=game.functions.booleans.all.simple, label=allDiceUsed, cls=game.functions.booleans.all.simple.AllDiceUsed, keyword=allDiceUsed
~~~~ <allSites> type=SubLudeme (game.functions.booleans.all.sites.AllSites) => <boolean>, pack=game.functions.booleans.all.sites, label=allSites, cls=game.functions.booleans.all.sites.AllSites, keyword=allSites
~~~~ <allSitesType> type=Structural (game.functions.booleans.all.AllSitesType) => <allSitesType>, pack=game.functions.booleans.all, label=allSitesType, cls=game.functions.booleans.all.AllSitesType, keyword=allSitesType
gd~~ <booleans.all.all> type=SuperLudeme (game.functions.booleans.all.All) => <boolean>, pack=game.functions.booleans.all, label=booleans.all.all, cls=game.functions.booleans.all.All, keyword=all
g~~~ <allSimpleType> type=Structural (game.functions.booleans.all.AllSimpleType) => <allSimpleType>, pack=game.functions.booleans.all, label=allSimpleType, cls=game.functions.booleans.all.AllSimpleType, keyword=allSimpleType
gd~~ <booleans.no.no> type=SuperLudeme (game.functions.booleans.no.No) => <boolean>, pack=game.functions.booleans.no, label=booleans.no.no, cls=game.functions.booleans.no.No, keyword=no
~~~~ <noMoves> type=SubLudeme (game.functions.booleans.no.NoMoves) => <boolean>, pack=game.functions.booleans.no, label=noMoves, cls=game.functions.booleans.no.NoMoves, keyword=noMoves
~~~~ <noType> type=Structural (game.functions.booleans.no.NoType) => <noType>, pack=game.functions.booleans.no, label=noType, cls=game.functions.booleans.no.NoType, keyword=noType
~~~~ <wasType> type=Structural (game.functions.booleans.was.WasType) => <wasType>, pack=game.functions.booleans.was, label=wasType, cls=game.functions.booleans.was.WasType, keyword=wasType
gd~~ <was> type=SuperLudeme (game.functions.booleans.was.Was) => <boolean>, pack=game.functions.booleans.was, label=was, cls=game.functions.booleans.was.Was, keyword=was
~~~~ <wasPass> type=SubLudeme (game.functions.booleans.was.WasPass) => <boolean>, pack=game.functions.booleans.was, label=wasPass, cls=game.functions.booleans.was.WasPass, keyword=wasPass
gd~~ <toBool> type=Ludeme (game.functions.booleans.ToBool) => <boolean>, pack=game.functions.booleans, label=toBool, cls=game.functions.booleans.ToBool, keyword=toBool
~~~~ <booleanConstant> type=SuperLudeme (game.functions.booleans.BooleanConstant) => <boolean>, pack=game.functions.booleans, label=booleanConstant, cls=game.functions.booleans.BooleanConstant, keyword=booleanConstant
g~~* <boolean> type=Structural (game.functions.booleans.BooleanFunction) => <boolean>, pack=game.functions.booleans, label=boolean, cls=game.functions.booleans.BooleanFunction, keyword=booleanFunction
gd~~ <=> type=Ludeme (game.functions.booleans.math.Equals) => <boolean>, pack=game.functions.booleans.math, label==, cls=game.functions.booleans.math.Equals, keyword==
gd~~ <xor> type=Ludeme (game.functions.booleans.math.Xor) => <boolean>, pack=game.functions.booleans.math, label=xor, cls=game.functions.booleans.math.Xor, keyword=xor
gd~~ <!=> type=Ludeme (game.functions.booleans.math.NotEqual) => <boolean>, pack=game.functions.booleans.math, label=!=, cls=game.functions.booleans.math.NotEqual, keyword=!=
gd~~ <>> type=Ludeme (game.functions.booleans.math.Gt) => <boolean>, pack=game.functions.booleans.math, label=>, cls=game.functions.booleans.math.Gt, keyword=>
gd~~ <not> type=Ludeme (game.functions.booleans.math.Not) => <boolean>, pack=game.functions.booleans.math, label=not, cls=game.functions.booleans.math.Not, keyword=not
gd~~ <>=> type=Ludeme (game.functions.booleans.math.Ge) => <boolean>, pack=game.functions.booleans.math, label=>=, cls=game.functions.booleans.math.Ge, keyword=>=
gd~~ <<> type=Ludeme (game.functions.booleans.math.Lt) => <boolean>, pack=game.functions.booleans.math, label=<, cls=game.functions.booleans.math.Lt, keyword=<
gd~~ <math.and> type=Ludeme (game.functions.booleans.math.And) => <boolean>, pack=game.functions.booleans.math, label=math.and, cls=game.functions.booleans.math.And, keyword=and
gd~~ <<=> type=Ludeme (game.functions.booleans.math.Le) => <boolean>, pack=game.functions.booleans.math, label=<=, cls=game.functions.booleans.math.Le, keyword=<=
gd~~ <booleans.math.if> type=Ludeme (game.functions.booleans.math.If) => <boolean>, pack=game.functions.booleans.math, label=booleans.math.if, cls=game.functions.booleans.math.If, keyword=if
gd~~ <math.or> type=Ludeme (game.functions.booleans.math.Or) => <boolean>, pack=game.functions.booleans.math, label=math.or, cls=game.functions.booleans.math.Or, keyword=or
~~~~ <canMove> type=SubLudeme (game.functions.booleans.can.CanMove) => <boolean>, pack=game.functions.booleans.can, label=canMove, cls=game.functions.booleans.can.CanMove, keyword=canMove
gd~~ <can> type=SuperLudeme (game.functions.booleans.can.Can) => <boolean>, pack=game.functions.booleans.can, label=can, cls=game.functions.booleans.can.Can, keyword=can
~~~~ <canType> type=Structural (game.functions.booleans.can.CanType) => <canType>, pack=game.functions.booleans.can, label=canType, cls=game.functions.booleans.can.CanType, keyword=canType
~~~* <baseBooleanFunction> type=SubLudeme (game.functions.booleans.BaseBooleanFunction) => <baseBooleanFunction>, pack=game.functions.booleans, label=baseBooleanFunction, cls=game.functions.booleans.BaseBooleanFunction, keyword=baseBooleanFunction
~~~~ <isProposed> type=SubLudeme (game.functions.booleans.is.string.IsProposed) => <boolean>, pack=game.functions.booleans.is.string, label=isProposed, cls=game.functions.booleans.is.string.IsProposed, keyword=isProposed
~~~~ <isDecided> type=SubLudeme (game.functions.booleans.is.string.IsDecided) => <boolean>, pack=game.functions.booleans.is.string, label=isDecided, cls=game.functions.booleans.is.string.IsDecided, keyword=isDecided
~~~~ <isCrossing> type=SubLudeme (game.functions.booleans.is.edge.IsCrossing) => <boolean>, pack=game.functions.booleans.is.edge, label=isCrossing, cls=game.functions.booleans.is.edge.IsCrossing, keyword=isCrossing
~~~~ <isLineType> type=Structural (game.functions.booleans.is.IsLineType) => <isLineType>, pack=game.functions.booleans.is, label=isLineType, cls=game.functions.booleans.is.IsLineType, keyword=isLineType
~~~~ <isEdgeType> type=Structural (game.functions.booleans.is.IsEdgeType) => <isEdgeType>, pack=game.functions.booleans.is, label=isEdgeType, cls=game.functions.booleans.is.IsEdgeType, keyword=isEdgeType
~~~~ <isTriggered> type=SubLudeme (game.functions.booleans.is.triggered.IsTriggered) => <boolean>, pack=game.functions.booleans.is.triggered, label=isTriggered, cls=game.functions.booleans.is.triggered.IsTriggered, keyword=isTriggered
~~~~ <isPattern> type=SubLudeme (game.functions.booleans.is.pattern.IsPattern) => <boolean>, pack=game.functions.booleans.is.pattern, label=isPattern, cls=game.functions.booleans.is.pattern.IsPattern, keyword=isPattern
~~~~ <isRepeat> type=SubLudeme (game.functions.booleans.is.repeat.IsRepeat) => <boolean>, pack=game.functions.booleans.is.repeat, label=isRepeat, cls=game.functions.booleans.is.repeat.IsRepeat, keyword=isRepeat
~~~~ <isPath> type=SubLudeme (game.functions.booleans.is.path.IsPath) => <boolean>, pack=game.functions.booleans.is.path, label=isPath, cls=game.functions.booleans.is.path.IsPath, keyword=isPath
~~~~ <isRelationType> type=Structural (game.functions.booleans.is.IsRelationType) => <isRelationType>, pack=game.functions.booleans.is, label=isRelationType, cls=game.functions.booleans.is.IsRelationType, keyword=isRelationType
~~~~ <isIn> type=SuperLudeme (game.functions.booleans.is.in.IsIn) => <boolean>, pack=game.functions.booleans.is.in, label=isIn, cls=game.functions.booleans.is.in.IsIn, keyword=isIn
~~~~ <isLine> type=SubLudeme (game.functions.booleans.is.line.IsLine) => <boolean>, pack=game.functions.booleans.is.line, label=isLine, cls=game.functions.booleans.is.line.IsLine, keyword=isLine
~~~~ <isRegularGraph> type=SubLudeme (game.functions.booleans.is.regularGraph.IsRegularGraph) => <boolean>, pack=game.functions.booleans.is.regularGraph, label=isRegularGraph, cls=game.functions.booleans.is.regularGraph.IsRegularGraph, keyword=isRegularGraph
~~~~ <isLastTo> type=SubLudeme (game.functions.booleans.is.graph.IsLastTo) => <boolean>, pack=game.functions.booleans.is.graph, label=isLastTo, cls=game.functions.booleans.is.graph.IsLastTo, keyword=isLastTo
~~~~ <isLastFrom> type=SubLudeme (game.functions.booleans.is.graph.IsLastFrom) => <boolean>, pack=game.functions.booleans.is.graph, label=isLastFrom, cls=game.functions.booleans.is.graph.IsLastFrom, keyword=isLastFrom
g~~~ <isPlayerType> type=Structural (game.functions.booleans.is.IsPlayerType) => <isPlayerType>, pack=game.functions.booleans.is, label=isPlayerType, cls=game.functions.booleans.is.IsPlayerType, keyword=isPlayerType
~~~~ <isOccupied> type=SubLudeme (game.functions.booleans.is.site.IsOccupied) => <boolean>, pack=game.functions.booleans.is.site, label=isOccupied, cls=game.functions.booleans.is.site.IsOccupied, keyword=isOccupied
~~~~ <isEmpty> type=SubLudeme (game.functions.booleans.is.site.IsEmpty) => <boolean>, pack=game.functions.booleans.is.site, label=isEmpty, cls=game.functions.booleans.is.site.IsEmpty, keyword=isEmpty
~~~~ <isMover> type=SubLudeme (game.functions.booleans.is.player.IsMover) => <boolean>, pack=game.functions.booleans.is.player, label=isMover, cls=game.functions.booleans.is.player.IsMover, keyword=isMover
~~~~ <isFriend> type=SubLudeme (game.functions.booleans.is.player.IsFriend) => <boolean>, pack=game.functions.booleans.is.player, label=isFriend, cls=game.functions.booleans.is.player.IsFriend, keyword=isFriend
~~~~ <isEnemy> type=SubLudeme (game.functions.booleans.is.player.IsEnemy) => <boolean>, pack=game.functions.booleans.is.player, label=isEnemy, cls=game.functions.booleans.is.player.IsEnemy, keyword=isEnemy
~~~~ <isPrev> type=SubLudeme (game.functions.booleans.is.player.IsPrev) => <boolean>, pack=game.functions.booleans.is.player, label=isPrev, cls=game.functions.booleans.is.player.IsPrev, keyword=isPrev
~~~~ <isActive> type=SubLudeme (game.functions.booleans.is.player.IsActive) => <boolean>, pack=game.functions.booleans.is.player, label=isActive, cls=game.functions.booleans.is.player.IsActive, keyword=isActive
~~~~ <isNext> type=SubLudeme (game.functions.booleans.is.player.IsNext) => <boolean>, pack=game.functions.booleans.is.player, label=isNext, cls=game.functions.booleans.is.player.IsNext, keyword=isNext
~~~~ <isFlat> type=SubLudeme (game.functions.booleans.is.integer.IsFlat) => <boolean>, pack=game.functions.booleans.is.integer, label=isFlat, cls=game.functions.booleans.is.integer.IsFlat, keyword=isFlat
~~~~ <isSidesMatch> type=SubLudeme (game.functions.booleans.is.integer.IsSidesMatch) => <boolean>, pack=game.functions.booleans.is.integer, label=isSidesMatch, cls=game.functions.booleans.is.integer.IsSidesMatch, keyword=isSidesMatch
~~~~ <isEven> type=SubLudeme (game.functions.booleans.is.integer.IsEven) => <boolean>, pack=game.functions.booleans.is.integer, label=isEven, cls=game.functions.booleans.is.integer.IsEven, keyword=isEven
~~~~ <isOdd> type=SubLudeme (game.functions.booleans.is.integer.IsOdd) => <boolean>, pack=game.functions.booleans.is.integer, label=isOdd, cls=game.functions.booleans.is.integer.IsOdd, keyword=isOdd
~~~~ <isVisited> type=SubLudeme (game.functions.booleans.is.integer.IsVisited) => <boolean>, pack=game.functions.booleans.is.integer, label=isVisited, cls=game.functions.booleans.is.integer.IsVisited, keyword=isVisited
~~~~ <isPipsMatch> type=SubLudeme (game.functions.booleans.is.integer.IsPipsMatch) => <boolean>, pack=game.functions.booleans.is.integer, label=isPipsMatch, cls=game.functions.booleans.is.integer.IsPipsMatch, keyword=isPipsMatch
~~~~ <isAnyDie> type=SubLudeme (game.functions.booleans.is.integer.IsAnyDie) => <boolean>, pack=game.functions.booleans.is.integer, label=isAnyDie, cls=game.functions.booleans.is.integer.IsAnyDie, keyword=isAnyDie
~~~~ <isCycle> type=SubLudeme (game.functions.booleans.is.simple.IsCycle) => <boolean>, pack=game.functions.booleans.is.simple, label=isCycle, cls=game.functions.booleans.is.simple.IsCycle, keyword=isCycle
~~~~ <isPending> type=SubLudeme (game.functions.booleans.is.simple.IsPending) => <boolean>, pack=game.functions.booleans.is.simple, label=isPending, cls=game.functions.booleans.is.simple.IsPending, keyword=isPending
~~~~ <isFull> type=SubLudeme (game.functions.booleans.is.simple.IsFull) => <boolean>, pack=game.functions.booleans.is.simple, label=isFull, cls=game.functions.booleans.is.simple.IsFull, keyword=isFull
~~~~ <isTargetType> type=Structural (game.functions.booleans.is.IsTargetType) => <isTargetType>, pack=game.functions.booleans.is, label=isTargetType, cls=game.functions.booleans.is.IsTargetType, keyword=isTargetType
~~~~ <isLoop> type=SubLudeme (game.functions.booleans.is.loop.IsLoop) => <boolean>, pack=game.functions.booleans.is.loop, label=isLoop, cls=game.functions.booleans.is.loop.IsLoop, keyword=isLoop
~~~~ <isPathType> type=Structural (game.functions.booleans.is.IsPathType) => <isPathType>, pack=game.functions.booleans.is, label=isPathType, cls=game.functions.booleans.is.IsPathType, keyword=isPathType
~~~~ <isTarget> type=SubLudeme (game.functions.booleans.is.target.IsTarget) => <boolean>, pack=game.functions.booleans.is.target, label=isTarget, cls=game.functions.booleans.is.target.IsTarget, keyword=isTarget
~~~~ <isLoopType> type=Structural (game.functions.booleans.is.IsLoopType) => <isLoopType>, pack=game.functions.booleans.is, label=isLoopType, cls=game.functions.booleans.is.IsLoopType, keyword=isLoopType
~~~~ <isHiddenType> type=Structural (game.functions.booleans.is.IsHiddenType) => <isHiddenType>, pack=game.functions.booleans.is, label=isHiddenType, cls=game.functions.booleans.is.IsHiddenType, keyword=isHiddenType
~~~~ <isTriggeredType> type=Structural (game.functions.booleans.is.IsTriggeredType) => <isTriggeredType>, pack=game.functions.booleans.is, label=isTriggeredType, cls=game.functions.booleans.is.IsTriggeredType, keyword=isTriggeredType
g~~~ <isGraphType> type=Structural (game.functions.booleans.is.IsGraphType) => <isGraphType>, pack=game.functions.booleans.is, label=isGraphType, cls=game.functions.booleans.is.IsGraphType, keyword=isGraphType
g~~~ <isConnectType> type=Structural (game.functions.booleans.is.IsConnectType) => <isConnectType>, pack=game.functions.booleans.is, label=isConnectType, cls=game.functions.booleans.is.IsConnectType, keyword=isConnectType
~~~~ <isPatternType> type=Structural (game.functions.booleans.is.IsPatternType) => <isPatternType>, pack=game.functions.booleans.is, label=isPatternType, cls=game.functions.booleans.is.IsPatternType, keyword=isPatternType
g~~~ <isStringType> type=Structural (game.functions.booleans.is.IsStringType) => <isStringType>, pack=game.functions.booleans.is, label=isStringType, cls=game.functions.booleans.is.IsStringType, keyword=isStringType
~~~~ <isRepeatType> type=Structural (game.functions.booleans.is.IsRepeatType) => <isRepeatType>, pack=game.functions.booleans.is, label=isRepeatType, cls=game.functions.booleans.is.IsRepeatType, keyword=isRepeatType
g~~~ <isComponentType> type=Structural (game.functions.booleans.is.IsComponentType) => <isComponentType>, pack=game.functions.booleans.is, label=isComponentType, cls=game.functions.booleans.is.IsComponentType, keyword=isComponentType
~~~~ <isRelated> type=SubLudeme (game.functions.booleans.is.related.IsRelated) => <boolean>, pack=game.functions.booleans.is.related, label=isRelated, cls=game.functions.booleans.is.related.IsRelated, keyword=isRelated
gd~~ <booleans.is.is> type=SuperLudeme (game.functions.booleans.is.Is) => <boolean>, pack=game.functions.booleans.is, label=booleans.is.is, cls=game.functions.booleans.is.Is, keyword=is
g~~~ <isSiteType> type=Structural (game.functions.booleans.is.IsSiteType) => <isSiteType>, pack=game.functions.booleans.is, label=isSiteType, cls=game.functions.booleans.is.IsSiteType, keyword=isSiteType
g~~~ <isIntegerType> type=Structural (game.functions.booleans.is.IsIntegerType) => <isIntegerType>, pack=game.functions.booleans.is, label=isIntegerType, cls=game.functions.booleans.is.IsIntegerType, keyword=isIntegerType
~~~~ <isTreeCentre> type=SubLudeme (game.functions.booleans.is.tree.IsTreeCentre) => <boolean>, pack=game.functions.booleans.is.tree, label=isTreeCentre, cls=game.functions.booleans.is.tree.IsTreeCentre, keyword=isTreeCentre
~~~~ <isTree> type=SubLudeme (game.functions.booleans.is.tree.IsTree) => <boolean>, pack=game.functions.booleans.is.tree, label=isTree, cls=game.functions.booleans.is.tree.IsTree, keyword=isTree
~~~~ <isCaterpillarTree> type=SubLudeme (game.functions.booleans.is.tree.IsCaterpillarTree) => <boolean>, pack=game.functions.booleans.is.tree, label=isCaterpillarTree, cls=game.functions.booleans.is.tree.IsCaterpillarTree, keyword=isCaterpillarTree
~~~~ <isSpanningTree> type=SubLudeme (game.functions.booleans.is.tree.IsSpanningTree) => <boolean>, pack=game.functions.booleans.is.tree, label=isSpanningTree, cls=game.functions.booleans.is.tree.IsSpanningTree, keyword=isSpanningTree
~~~~ <isRegularGraphType> type=Structural (game.functions.booleans.is.IsRegularGraphType) => <isRegularGraphType>, pack=game.functions.booleans.is, label=isRegularGraphType, cls=game.functions.booleans.is.IsRegularGraphType, keyword=isRegularGraphType
~~~~ <isHiddenState> type=SubLudeme (game.functions.booleans.is.Hidden.IsHiddenState) => <boolean>, pack=game.functions.booleans.is.Hidden, label=isHiddenState, cls=game.functions.booleans.is.Hidden.IsHiddenState, keyword=isHiddenState
~~~~ <isHidden> type=SubLudeme (game.functions.booleans.is.Hidden.IsHidden) => <boolean>, pack=game.functions.booleans.is.Hidden, label=isHidden, cls=game.functions.booleans.is.Hidden.IsHidden, keyword=isHidden
~~~~ <isHiddenValue> type=SubLudeme (game.functions.booleans.is.Hidden.IsHiddenValue) => <boolean>, pack=game.functions.booleans.is.Hidden, label=isHiddenValue, cls=game.functions.booleans.is.Hidden.IsHiddenValue, keyword=isHiddenValue
~~~~ <isHiddenCount> type=SubLudeme (game.functions.booleans.is.Hidden.IsHiddenCount) => <boolean>, pack=game.functions.booleans.is.Hidden, label=isHiddenCount, cls=game.functions.booleans.is.Hidden.IsHiddenCount, keyword=isHiddenCount
~~~~ <isHiddenRotation> type=SubLudeme (game.functions.booleans.is.Hidden.IsHiddenRotation) => <boolean>, pack=game.functions.booleans.is.Hidden, label=isHiddenRotation, cls=game.functions.booleans.is.Hidden.IsHiddenRotation, keyword=isHiddenRotation
~~~~ <isHiddenWho> type=SubLudeme (game.functions.booleans.is.Hidden.IsHiddenWho) => <boolean>, pack=game.functions.booleans.is.Hidden, label=isHiddenWho, cls=game.functions.booleans.is.Hidden.IsHiddenWho, keyword=isHiddenWho
~~~~ <isHiddenWhat> type=SubLudeme (game.functions.booleans.is.Hidden.IsHiddenWhat) => <boolean>, pack=game.functions.booleans.is.Hidden, label=isHiddenWhat, cls=game.functions.booleans.is.Hidden.IsHiddenWhat, keyword=isHiddenWhat
g~~~ <isSimpleType> type=Structural (game.functions.booleans.is.IsSimpleType) => <isSimpleType>, pack=game.functions.booleans.is, label=isSimpleType, cls=game.functions.booleans.is.IsSimpleType, keyword=isSimpleType
~~~~ <isConnected> type=SubLudeme (game.functions.booleans.is.connect.IsConnected) => <boolean>, pack=game.functions.booleans.is.connect, label=isConnected, cls=game.functions.booleans.is.connect.IsConnected, keyword=isConnected
~~~~ <isBlocked> type=SubLudeme (game.functions.booleans.is.connect.IsBlocked) => <boolean>, pack=game.functions.booleans.is.connect, label=isBlocked, cls=game.functions.booleans.is.connect.IsBlocked, keyword=isBlocked
g~~~ <isTreeType> type=Structural (game.functions.booleans.is.IsTreeType) => <isTreeType>, pack=game.functions.booleans.is, label=isTreeType, cls=game.functions.booleans.is.IsTreeType, keyword=isTreeType
~~~~ <isInType> type=Structural (game.functions.booleans.is.IsInType) => <isInType>, pack=game.functions.booleans.is, label=isInType, cls=game.functions.booleans.is.IsInType, keyword=isInType
~~~~ <isThreatened> type=SubLudeme (game.functions.booleans.is.component.IsThreatened) => <boolean>, pack=game.functions.booleans.is.component, label=isThreatened, cls=game.functions.booleans.is.component.IsThreatened, keyword=isThreatened
~~~~ <isWithin> type=SubLudeme (game.functions.booleans.is.component.IsWithin) => <boolean>, pack=game.functions.booleans.is.component, label=isWithin, cls=game.functions.booleans.is.component.IsWithin, keyword=isWithin
~~~~ <allDifferent> type=SubLudeme (game.functions.booleans.deductionPuzzle.all.AllDifferent) => <boolean>, pack=game.functions.booleans.deductionPuzzle.all, label=allDifferent, cls=game.functions.booleans.deductionPuzzle.all.AllDifferent, keyword=allDifferent
~~~~ <allPuzzleType> type=Structural (game.functions.booleans.deductionPuzzle.all.AllPuzzleType) => <allPuzzleType>, pack=game.functions.booleans.deductionPuzzle.all, label=allPuzzleType, cls=game.functions.booleans.deductionPuzzle.all.AllPuzzleType, keyword=allPuzzleType
gd~~ <deductionPuzzle.all.all> type=SuperLudeme (game.functions.booleans.deductionPuzzle.all.All) => <boolean>, pack=game.functions.booleans.deductionPuzzle.all, label=deductionPuzzle.all.all, cls=game.functions.booleans.deductionPuzzle.all.All, keyword=all
gd~~ <forAll> type=Ludeme (game.functions.booleans.deductionPuzzle.ForAll) => <boolean>, pack=game.functions.booleans.deductionPuzzle, label=forAll, cls=game.functions.booleans.deductionPuzzle.ForAll, keyword=forAll
g~~~ <isPuzzleRegionResultType> type=Structural (game.functions.booleans.deductionPuzzle.is.IsPuzzleRegionResultType) => <isPuzzleRegionResultType>, pack=game.functions.booleans.deductionPuzzle.is, label=isPuzzleRegionResultType, cls=game.functions.booleans.deductionPuzzle.is.IsPuzzleRegionResultType, keyword=isPuzzleRegionResultType
~~~~ <isPuzzleGraphType> type=Structural (game.functions.booleans.deductionPuzzle.is.IsPuzzleGraphType) => <isPuzzleGraphType>, pack=game.functions.booleans.deductionPuzzle.is, label=isPuzzleGraphType, cls=game.functions.booleans.deductionPuzzle.is.IsPuzzleGraphType, keyword=isPuzzleGraphType
~~~~ <isUnique> type=SubLudeme (game.functions.booleans.deductionPuzzle.is.graph.IsUnique) => <boolean>, pack=game.functions.booleans.deductionPuzzle.is.graph, label=isUnique, cls=game.functions.booleans.deductionPuzzle.is.graph.IsUnique, keyword=isUnique
~~~~ <isSolved> type=SubLudeme (game.functions.booleans.deductionPuzzle.is.simple.IsSolved) => <boolean>, pack=game.functions.booleans.deductionPuzzle.is.simple, label=isSolved, cls=game.functions.booleans.deductionPuzzle.is.simple.IsSolved, keyword=isSolved
~~~~ <isPuzzleSimpleType> type=Structural (game.functions.booleans.deductionPuzzle.is.IsPuzzleSimpleType) => <isPuzzleSimpleType>, pack=game.functions.booleans.deductionPuzzle.is, label=isPuzzleSimpleType, cls=game.functions.booleans.deductionPuzzle.is.IsPuzzleSimpleType, keyword=isPuzzleSimpleType
~~~~ <isCount> type=SubLudeme (game.functions.booleans.deductionPuzzle.is.regionResult.IsCount) => <boolean>, pack=game.functions.booleans.deductionPuzzle.is.regionResult, label=isCount, cls=game.functions.booleans.deductionPuzzle.is.regionResult.IsCount, keyword=isCount
~~~~ <isSum> type=SubLudeme (game.functions.booleans.deductionPuzzle.is.regionResult.IsSum) => <boolean>, pack=game.functions.booleans.deductionPuzzle.is.regionResult, label=isSum, cls=game.functions.booleans.deductionPuzzle.is.regionResult.IsSum, keyword=isSum
gd~~ <deductionPuzzle.is.is> type=SuperLudeme (game.functions.booleans.deductionPuzzle.is.Is) => <boolean>, pack=game.functions.booleans.deductionPuzzle.is, label=deductionPuzzle.is.is, cls=game.functions.booleans.deductionPuzzle.is.Is, keyword=is
g~~* <graph> type=Structural (game.functions.graph.GraphFunction) => <graph>, pack=game.functions.graph, label=graph, cls=game.functions.graph.GraphFunction, keyword=graphFunction
~~~* <baseGraphFunction> type=Ludeme (game.functions.graph.BaseGraphFunction) => <graph>, pack=game.functions.graph, label=baseGraphFunction, cls=game.functions.graph.BaseGraphFunction, keyword=baseGraphFunction
~~~~ <mesh> type=SuperLudeme (game.functions.graph.generators.basis.mesh.Mesh) => <graph>, pack=game.functions.graph.generators.basis.mesh, label=mesh, cls=game.functions.graph.generators.basis.mesh.Mesh, keyword=mesh
~~~~ <customOnMesh> type=SubLudeme (game.functions.graph.generators.basis.mesh.CustomOnMesh) => <graph>, pack=game.functions.graph.generators.basis.mesh, label=customOnMesh, cls=game.functions.graph.generators.basis.mesh.CustomOnMesh, keyword=customOnMesh
~~~~ <triangleOnTri> type=SubLudeme (game.functions.graph.generators.basis.tri.TriangleOnTri) => <graph>, pack=game.functions.graph.generators.basis.tri, label=triangleOnTri, cls=game.functions.graph.generators.basis.tri.TriangleOnTri, keyword=triangleOnTri
~~~~ <hexagonOnTri> type=SubLudeme (game.functions.graph.generators.basis.tri.HexagonOnTri) => <graph>, pack=game.functions.graph.generators.basis.tri, label=hexagonOnTri, cls=game.functions.graph.generators.basis.tri.HexagonOnTri, keyword=hexagonOnTri
~~~~ <starOnTri> type=SubLudeme (game.functions.graph.generators.basis.tri.StarOnTri) => <graph>, pack=game.functions.graph.generators.basis.tri, label=starOnTri, cls=game.functions.graph.generators.basis.tri.StarOnTri, keyword=starOnTri
~~~~ <rectangleOnTri> type=SubLudeme (game.functions.graph.generators.basis.tri.RectangleOnTri) => <graph>, pack=game.functions.graph.generators.basis.tri, label=rectangleOnTri, cls=game.functions.graph.generators.basis.tri.RectangleOnTri, keyword=rectangleOnTri
~~~~ <diamondOnTri> type=SubLudeme (game.functions.graph.generators.basis.tri.DiamondOnTri) => <graph>, pack=game.functions.graph.generators.basis.tri, label=diamondOnTri, cls=game.functions.graph.generators.basis.tri.DiamondOnTri, keyword=diamondOnTri
gd~~ <tri> type=SuperLudeme (game.functions.graph.generators.basis.tri.Tri) => <graph>, pack=game.functions.graph.generators.basis.tri, label=tri, cls=game.functions.graph.generators.basis.tri.Tri, keyword=tri
g~~~ <triShapeType> type=Structural (game.functions.graph.generators.basis.tri.TriShapeType) => <triShapeType>, pack=game.functions.graph.generators.basis.tri, label=triShapeType, cls=game.functions.graph.generators.basis.tri.TriShapeType, keyword=triShapeType
~~~~ <customOnTri> type=SubLudeme (game.functions.graph.generators.basis.tri.CustomOnTri) => <graph>, pack=game.functions.graph.generators.basis.tri, label=customOnTri, cls=game.functions.graph.generators.basis.tri.CustomOnTri, keyword=customOnTri
~~~~ <tiling333333_33434> type=SubLudeme (game.functions.graph.generators.basis.tiling.tiling333333_33434.Tiling333333_33434) => <graph>, pack=game.functions.graph.generators.basis.tiling.tiling333333_33434, label=tiling333333_33434, cls=game.functions.graph.generators.basis.tiling.tiling333333_33434.Tiling333333_33434, keyword=tiling333333_33434
~~~~ <tiling488> type=SubLudeme (game.functions.graph.generators.basis.tiling.tiling488.Tiling488) => <tiling488>, pack=game.functions.graph.generators.basis.tiling.tiling488, label=tiling488, cls=game.functions.graph.generators.basis.tiling.tiling488.Tiling488, keyword=tiling488
~~~~ <squareOrRectangleOn488> type=SubLudeme (game.functions.graph.generators.basis.tiling.tiling488.SquareOrRectangleOn488) => <graph>, pack=game.functions.graph.generators.basis.tiling.tiling488, label=squareOrRectangleOn488, cls=game.functions.graph.generators.basis.tiling.tiling488.SquareOrRectangleOn488, keyword=squareOrRectangleOn488
~~~~ <customOn488> type=SubLudeme (game.functions.graph.generators.basis.tiling.tiling488.CustomOn488) => <graph>, pack=game.functions.graph.generators.basis.tiling.tiling488, label=customOn488, cls=game.functions.graph.generators.basis.tiling.tiling488.CustomOn488, keyword=customOn488
~~~~ <tiling33434> type=SubLudeme (game.functions.graph.generators.basis.tiling.tiling33434.Tiling33434) => <graph>, pack=game.functions.graph.generators.basis.tiling.tiling33434, label=tiling33434, cls=game.functions.graph.generators.basis.tiling.tiling33434.Tiling33434, keyword=tiling33434
~~~~ <tiling33336> type=SubLudeme (game.functions.graph.generators.basis.tiling.tiling33336.Tiling33336) => <graph>, pack=game.functions.graph.generators.basis.tiling.tiling33336, label=tiling33336, cls=game.functions.graph.generators.basis.tiling.tiling33336.Tiling33336, keyword=tiling33336
gd~~ <tiling> type=SuperLudeme (game.functions.graph.generators.basis.tiling.Tiling) => <graph>, pack=game.functions.graph.generators.basis.tiling, label=tiling, cls=game.functions.graph.generators.basis.tiling.Tiling, keyword=tiling
~~~~ <tiling31212> type=SubLudeme (game.functions.graph.generators.basis.tiling.tiling31212.Tiling31212) => <graph>, pack=game.functions.graph.generators.basis.tiling.tiling31212, label=tiling31212, cls=game.functions.graph.generators.basis.tiling.tiling31212.Tiling31212, keyword=tiling31212
g~~~ <tilingType> type=Structural (game.functions.graph.generators.basis.tiling.TilingType) => <tilingType>, pack=game.functions.graph.generators.basis.tiling, label=tilingType, cls=game.functions.graph.generators.basis.tiling.TilingType, keyword=tilingType
~~~~ <tiling3636> type=SubLudeme (game.functions.graph.generators.basis.tiling.tiling3636.Tiling3636) => <graph>, pack=game.functions.graph.generators.basis.tiling.tiling3636, label=tiling3636, cls=game.functions.graph.generators.basis.tiling.tiling3636.Tiling3636, keyword=tiling3636
~~~~ <customOn3636> type=SubLudeme (game.functions.graph.generators.basis.tiling.tiling3636.CustomOn3636) => <graph>, pack=game.functions.graph.generators.basis.tiling.tiling3636, label=customOn3636, cls=game.functions.graph.generators.basis.tiling.tiling3636.CustomOn3636, keyword=customOn3636
~~~~ <starOn3464> type=SubLudeme (game.functions.graph.generators.basis.tiling.tiling3464.StarOn3464) => <graph>, pack=game.functions.graph.generators.basis.tiling.tiling3464, label=starOn3464, cls=game.functions.graph.generators.basis.tiling.tiling3464.StarOn3464, keyword=starOn3464
~~m~ <tiling3464ShapeType> type=Structural (game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType) => <tiling3464ShapeType>, pack=game.functions.graph.generators.basis.tiling.tiling3464, label=tiling3464ShapeType, cls=game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType, keyword=tiling3464ShapeType
~~~~ <rectangleOn3464> type=SubLudeme (game.functions.graph.generators.basis.tiling.tiling3464.RectangleOn3464) => <graph>, pack=game.functions.graph.generators.basis.tiling.tiling3464, label=rectangleOn3464, cls=game.functions.graph.generators.basis.tiling.tiling3464.RectangleOn3464, keyword=rectangleOn3464
~~~~ <hexagonOn3464> type=SubLudeme (game.functions.graph.generators.basis.tiling.tiling3464.HexagonOn3464) => <graph>, pack=game.functions.graph.generators.basis.tiling.tiling3464, label=hexagonOn3464, cls=game.functions.graph.generators.basis.tiling.tiling3464.HexagonOn3464, keyword=hexagonOn3464
~~~~ <parallelogramOn3464> type=SubLudeme (game.functions.graph.generators.basis.tiling.tiling3464.ParallelogramOn3464) => <graph>, pack=game.functions.graph.generators.basis.tiling.tiling3464, label=parallelogramOn3464, cls=game.functions.graph.generators.basis.tiling.tiling3464.ParallelogramOn3464, keyword=parallelogramOn3464
~~~~ <diamondOn3464> type=SubLudeme (game.functions.graph.generators.basis.tiling.tiling3464.DiamondOn3464) => <graph>, pack=game.functions.graph.generators.basis.tiling.tiling3464, label=diamondOn3464, cls=game.functions.graph.generators.basis.tiling.tiling3464.DiamondOn3464, keyword=diamondOn3464
~~~~ <triangleOn3464> type=SubLudeme (game.functions.graph.generators.basis.tiling.tiling3464.TriangleOn3464) => <graph>, pack=game.functions.graph.generators.basis.tiling.tiling3464, label=triangleOn3464, cls=game.functions.graph.generators.basis.tiling.tiling3464.TriangleOn3464, keyword=triangleOn3464
~~~~ <customOn3464> type=SubLudeme (game.functions.graph.generators.basis.tiling.tiling3464.CustomOn3464) => <graph>, pack=game.functions.graph.generators.basis.tiling.tiling3464, label=customOn3464, cls=game.functions.graph.generators.basis.tiling.tiling3464.CustomOn3464, keyword=customOn3464
~~~~ <tiling3464> type=SuperLudeme (game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464) => <tiling3464>, pack=game.functions.graph.generators.basis.tiling.tiling3464, label=tiling3464, cls=game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464, keyword=tiling3464
~~~~ <tiling4612> type=SubLudeme (game.functions.graph.generators.basis.tiling.tiling4612.Tiling4612) => <graph>, pack=game.functions.graph.generators.basis.tiling.tiling4612, label=tiling4612, cls=game.functions.graph.generators.basis.tiling.tiling4612.Tiling4612, keyword=tiling4612
~~~~ <tiling33344> type=SubLudeme (game.functions.graph.generators.basis.tiling.tiling33344.Tiling33344) => <graph>, pack=game.functions.graph.generators.basis.tiling.tiling33344, label=tiling33344, cls=game.functions.graph.generators.basis.tiling.tiling33344.Tiling33344, keyword=tiling33344
~~~~ <customOn33344> type=SubLudeme (game.functions.graph.generators.basis.tiling.tiling33344.CustomOn33344) => <graph>, pack=game.functions.graph.generators.basis.tiling.tiling33344, label=customOn33344, cls=game.functions.graph.generators.basis.tiling.tiling33344.CustomOn33344, keyword=customOn33344
gd~~ <quadhex> type=Ludeme (game.functions.graph.generators.basis.quadhex.Quadhex) => <graph>, pack=game.functions.graph.generators.basis.quadhex, label=quadhex, cls=game.functions.graph.generators.basis.quadhex.Quadhex, keyword=quadhex
~~~~ <diamondOnHex> type=SubLudeme (game.functions.graph.generators.basis.hex.DiamondOnHex) => <graph>, pack=game.functions.graph.generators.basis.hex, label=diamondOnHex, cls=game.functions.graph.generators.basis.hex.DiamondOnHex, keyword=diamondOnHex
~~~~ <starOnHex> type=SubLudeme (game.functions.graph.generators.basis.hex.StarOnHex) => <graph>, pack=game.functions.graph.generators.basis.hex, label=starOnHex, cls=game.functions.graph.generators.basis.hex.StarOnHex, keyword=starOnHex
~~~~ <triangleOnHex> type=SubLudeme (game.functions.graph.generators.basis.hex.TriangleOnHex) => <graph>, pack=game.functions.graph.generators.basis.hex, label=triangleOnHex, cls=game.functions.graph.generators.basis.hex.TriangleOnHex, keyword=triangleOnHex
gd~~ <hex> type=SuperLudeme (game.functions.graph.generators.basis.hex.Hex) => <graph>, pack=game.functions.graph.generators.basis.hex, label=hex, cls=game.functions.graph.generators.basis.hex.Hex, keyword=hex
~~~~ <customOnHex> type=SubLudeme (game.functions.graph.generators.basis.hex.CustomOnHex) => <graph>, pack=game.functions.graph.generators.basis.hex, label=customOnHex, cls=game.functions.graph.generators.basis.hex.CustomOnHex, keyword=customOnHex
g~~~ <hexShapeType> type=Structural (game.functions.graph.generators.basis.hex.HexShapeType) => <hexShapeType>, pack=game.functions.graph.generators.basis.hex, label=hexShapeType, cls=game.functions.graph.generators.basis.hex.HexShapeType, keyword=hexShapeType
~~~~ <rectangleOnHex> type=SubLudeme (game.functions.graph.generators.basis.hex.RectangleOnHex) => <graph>, pack=game.functions.graph.generators.basis.hex, label=rectangleOnHex, cls=game.functions.graph.generators.basis.hex.RectangleOnHex, keyword=rectangleOnHex
~~~~ <hexagonOnHex> type=SubLudeme (game.functions.graph.generators.basis.hex.HexagonOnHex) => <graph>, pack=game.functions.graph.generators.basis.hex, label=hexagonOnHex, cls=game.functions.graph.generators.basis.hex.HexagonOnHex, keyword=hexagonOnHex
g~~* <basis> type=Structural (game.functions.graph.generators.basis.Basis) => <graph>, pack=game.functions.graph.generators.basis, label=basis, cls=game.functions.graph.generators.basis.Basis, keyword=basis
gd~~ <celtic> type=Ludeme (game.functions.graph.generators.basis.celtic.Celtic) => <graph>, pack=game.functions.graph.generators.basis.celtic, label=celtic, cls=game.functions.graph.generators.basis.celtic.Celtic, keyword=celtic
gd~~ <square> type=SuperLudeme (game.functions.graph.generators.basis.square.Square) => <graph>, pack=game.functions.graph.generators.basis.square, label=square, cls=game.functions.graph.generators.basis.square.Square, keyword=square
~~~~ <diamondOnSquare> type=SubLudeme (game.functions.graph.generators.basis.square.DiamondOnSquare) => <graph>, pack=game.functions.graph.generators.basis.square, label=diamondOnSquare, cls=game.functions.graph.generators.basis.square.DiamondOnSquare, keyword=diamondOnSquare
~~~~ <rectangleOnSquare> type=SubLudeme (game.functions.graph.generators.basis.square.RectangleOnSquare) => <graph>, pack=game.functions.graph.generators.basis.square, label=rectangleOnSquare, cls=game.functions.graph.generators.basis.square.RectangleOnSquare, keyword=rectangleOnSquare
~~~~ <customOnSquare> type=SubLudeme (game.functions.graph.generators.basis.square.CustomOnSquare) => <graph>, pack=game.functions.graph.generators.basis.square, label=customOnSquare, cls=game.functions.graph.generators.basis.square.CustomOnSquare, keyword=customOnSquare
g~~~ <squareShapeType> type=Structural (game.functions.graph.generators.basis.square.SquareShapeType) => <squareShapeType>, pack=game.functions.graph.generators.basis.square, label=squareShapeType, cls=game.functions.graph.generators.basis.square.SquareShapeType, keyword=squareShapeType
g~~~ <diagonalsType> type=Structural (game.functions.graph.generators.basis.square.DiagonalsType) => <diagonalsType>, pack=game.functions.graph.generators.basis.square, label=diagonalsType, cls=game.functions.graph.generators.basis.square.DiagonalsType, keyword=diagonalsType
~~~~ <spiralOnBrick> type=SubLudeme (game.functions.graph.generators.basis.brick.SpiralOnBrick) => <graph>, pack=game.functions.graph.generators.basis.brick, label=spiralOnBrick, cls=game.functions.graph.generators.basis.brick.SpiralOnBrick, keyword=spiralOnBrick
g~~~ <brickShapeType> type=Structural (game.functions.graph.generators.basis.brick.BrickShapeType) => <brickShapeType>, pack=game.functions.graph.generators.basis.brick, label=brickShapeType, cls=game.functions.graph.generators.basis.brick.BrickShapeType, keyword=brickShapeType
gd~~ <brick> type=SuperLudeme (game.functions.graph.generators.basis.brick.Brick) => <graph>, pack=game.functions.graph.generators.basis.brick, label=brick, cls=game.functions.graph.generators.basis.brick.Brick, keyword=brick
~~~~ <diamondOrPrismOnBrick> type=SubLudeme (game.functions.graph.generators.basis.brick.DiamondOrPrismOnBrick) => <graph>, pack=game.functions.graph.generators.basis.brick, label=diamondOrPrismOnBrick, cls=game.functions.graph.generators.basis.brick.DiamondOrPrismOnBrick, keyword=diamondOrPrismOnBrick
~~~~ <squareOrRectangleOnBrick> type=SubLudeme (game.functions.graph.generators.basis.brick.SquareOrRectangleOnBrick) => <graph>, pack=game.functions.graph.generators.basis.brick, label=squareOrRectangleOnBrick, cls=game.functions.graph.generators.basis.brick.SquareOrRectangleOnBrick, keyword=squareOrRectangleOnBrick
gd~~ <repeat> type=Ludeme (game.functions.graph.generators.shape.Repeat) => <graph>, pack=game.functions.graph.generators.shape, label=repeat, cls=game.functions.graph.generators.shape.Repeat, keyword=repeat
gd~~ <regular> type=Ludeme (game.functions.graph.generators.shape.Regular) => <graph>, pack=game.functions.graph.generators.shape, label=regular, cls=game.functions.graph.generators.shape.Regular, keyword=regular
~~~~ <concentricRegular> type=SubLudeme (game.functions.graph.generators.shape.concentric.ConcentricRegular) => <graph>, pack=game.functions.graph.generators.shape.concentric, label=concentricRegular, cls=game.functions.graph.generators.shape.concentric.ConcentricRegular, keyword=concentricRegular
~~~~ <concentricTarget> type=SubLudeme (game.functions.graph.generators.shape.concentric.ConcentricTarget) => <graph>, pack=game.functions.graph.generators.shape.concentric, label=concentricTarget, cls=game.functions.graph.generators.shape.concentric.ConcentricTarget, keyword=concentricTarget
~~~~ <concentricCircle> type=SubLudeme (game.functions.graph.generators.shape.concentric.ConcentricCircle) => <graph>, pack=game.functions.graph.generators.shape.concentric, label=concentricCircle, cls=game.functions.graph.generators.shape.concentric.ConcentricCircle, keyword=concentricCircle
gd~~ <concentric> type=SuperLudeme (game.functions.graph.generators.shape.concentric.Concentric) => <graph>, pack=game.functions.graph.generators.shape.concentric, label=concentric, cls=game.functions.graph.generators.shape.concentric.Concentric, keyword=concentric
g~~~ <concentricShapeType> type=Structural (game.functions.graph.generators.shape.concentric.ConcentricShapeType) => <concentricShapeType>, pack=game.functions.graph.generators.shape.concentric, label=concentricShapeType, cls=game.functions.graph.generators.shape.concentric.ConcentricShapeType, keyword=concentricShapeType
~~~~ <shapeStarType> type=Structural (game.functions.graph.generators.shape.ShapeStarType) => <shapeStarType>, pack=game.functions.graph.generators.shape, label=shapeStarType, cls=game.functions.graph.generators.shape.ShapeStarType, keyword=shapeStarType
gd~~ <wedge> type=Ludeme (game.functions.graph.generators.shape.Wedge) => <graph>, pack=game.functions.graph.generators.shape, label=wedge, cls=game.functions.graph.generators.shape.Wedge, keyword=wedge
gd~~ <spiral> type=Ludeme (game.functions.graph.generators.shape.Spiral) => <graph>, pack=game.functions.graph.generators.shape, label=spiral, cls=game.functions.graph.generators.shape.Spiral, keyword=spiral
gd~~ <rectangle> type=SuperLudeme (game.functions.graph.generators.shape.Rectangle) => <rectangle>, pack=game.functions.graph.generators.shape, label=rectangle, cls=game.functions.graph.generators.shape.Rectangle, keyword=rectangle
gd~~ <clip> type=Ludeme (game.functions.graph.operators.Clip) => <graph>, pack=game.functions.graph.operators, label=clip, cls=game.functions.graph.operators.Clip, keyword=clip
gd~~ <subdivide> type=Ludeme (game.functions.graph.operators.Subdivide) => <graph>, pack=game.functions.graph.operators, label=subdivide, cls=game.functions.graph.operators.Subdivide, keyword=subdivide
gd~~ <scale> type=Ludeme (game.functions.graph.operators.Scale) => <graph>, pack=game.functions.graph.operators, label=scale, cls=game.functions.graph.operators.Scale, keyword=scale
gd~~ <rotate> type=Ludeme (game.functions.graph.operators.Rotate) => <graph>, pack=game.functions.graph.operators, label=rotate, cls=game.functions.graph.operators.Rotate, keyword=rotate
gd~~ <keep> type=Ludeme (game.functions.graph.operators.Keep) => <graph>, pack=game.functions.graph.operators, label=keep, cls=game.functions.graph.operators.Keep, keyword=keep
gd~~ <operators.remove> type=Ludeme (game.functions.graph.operators.Remove) => <graph>, pack=game.functions.graph.operators, label=operators.remove, cls=game.functions.graph.operators.Remove, keyword=remove
gd~~ <splitCrossings> type=Ludeme (game.functions.graph.operators.SplitCrossings) => <graph>, pack=game.functions.graph.operators, label=splitCrossings, cls=game.functions.graph.operators.SplitCrossings, keyword=splitCrossings
gd~~ <shift> type=Ludeme (game.functions.graph.operators.Shift) => <graph>, pack=game.functions.graph.operators, label=shift, cls=game.functions.graph.operators.Shift, keyword=shift
gd~~ <merge> type=Ludeme (game.functions.graph.operators.Merge) => <graph>, pack=game.functions.graph.operators, label=merge, cls=game.functions.graph.operators.Merge, keyword=merge
gd~~ <operators.add> type=Ludeme (game.functions.graph.operators.Add) => <graph>, pack=game.functions.graph.operators, label=operators.add, cls=game.functions.graph.operators.Add, keyword=add
gd~~ <intersect> type=Ludeme (game.functions.graph.operators.Intersect) => <graph>, pack=game.functions.graph.operators, label=intersect, cls=game.functions.graph.operators.Intersect, keyword=intersect
gd~~ <operators.union> type=Ludeme (game.functions.graph.operators.Union) => <graph>, pack=game.functions.graph.operators, label=operators.union, cls=game.functions.graph.operators.Union, keyword=union
gd~~ <trim> type=Ludeme (game.functions.graph.operators.Trim) => <graph>, pack=game.functions.graph.operators, label=trim, cls=game.functions.graph.operators.Trim, keyword=trim
gd~~ <makeFaces> type=Ludeme (game.functions.graph.operators.MakeFaces) => <graph>, pack=game.functions.graph.operators, label=makeFaces, cls=game.functions.graph.operators.MakeFaces, keyword=makeFaces
gd~~ <layers> type=Ludeme (game.functions.graph.operators.Layers) => <graph>, pack=game.functions.graph.operators, label=layers, cls=game.functions.graph.operators.Layers, keyword=layers
gd~~ <dual> type=Ludeme (game.functions.graph.operators.Dual) => <graph>, pack=game.functions.graph.operators, label=dual, cls=game.functions.graph.operators.Dual, keyword=dual
gd~~ <complete> type=Ludeme (game.functions.graph.operators.Complete) => <graph>, pack=game.functions.graph.operators, label=complete, cls=game.functions.graph.operators.Complete, keyword=complete
gd~~ <renumber> type=Ludeme (game.functions.graph.operators.Renumber) => <graph>, pack=game.functions.graph.operators, label=renumber, cls=game.functions.graph.operators.Renumber, keyword=renumber
gd~~ <recoordinate> type=Ludeme (game.functions.graph.operators.Recoordinate) => <graph>, pack=game.functions.graph.operators, label=recoordinate, cls=game.functions.graph.operators.Recoordinate, keyword=recoordinate
gd~~ <skew> type=Ludeme (game.functions.graph.operators.Skew) => <graph>, pack=game.functions.graph.operators, label=skew, cls=game.functions.graph.operators.Skew, keyword=skew
gd~~ <hole> type=Ludeme (game.functions.graph.operators.Hole) => <graph>, pack=game.functions.graph.operators, label=hole, cls=game.functions.graph.operators.Hole, keyword=hole
g~~~ <cardSiteType> type=Structural (game.functions.ints.card.CardSiteType) => <cardSiteType>, pack=game.functions.ints.card, label=cardSiteType, cls=game.functions.ints.card.CardSiteType, keyword=cardSiteType
gd~~ <card.card> type=SuperLudeme (game.functions.ints.card.Card) => <int>, pack=game.functions.ints.card, label=card.card, cls=game.functions.ints.card.Card, keyword=card
~~~~ <cardSuit> type=SubLudeme (game.functions.ints.card.site.CardSuit) => <int>, pack=game.functions.ints.card.site, label=cardSuit, cls=game.functions.ints.card.site.CardSuit, keyword=cardSuit
~~~~ <cardTrumpRank> type=SubLudeme (game.functions.ints.card.site.CardTrumpRank) => <int>, pack=game.functions.ints.card.site, label=cardTrumpRank, cls=game.functions.ints.card.site.CardTrumpRank, keyword=cardTrumpRank
~~~~ <cardTrumpValue> type=SubLudeme (game.functions.ints.card.site.CardTrumpValue) => <int>, pack=game.functions.ints.card.site, label=cardTrumpValue, cls=game.functions.ints.card.site.CardTrumpValue, keyword=cardTrumpValue
~~~~ <cardRank> type=SubLudeme (game.functions.ints.card.site.CardRank) => <int>, pack=game.functions.ints.card.site, label=cardRank, cls=game.functions.ints.card.site.CardRank, keyword=cardRank
~~~~ <cardTrumpSuit> type=SubLudeme (game.functions.ints.card.simple.CardTrumpSuit) => <int>, pack=game.functions.ints.card.simple, label=cardTrumpSuit, cls=game.functions.ints.card.simple.CardTrumpSuit, keyword=cardTrumpSuit
~~~~ <cardSimpleType> type=Structural (game.functions.ints.card.CardSimpleType) => <cardSimpleType>, pack=game.functions.ints.card, label=cardSimpleType, cls=game.functions.ints.card.CardSimpleType, keyword=cardSimpleType
~~~~ <intConstant> type=Ludeme (game.functions.ints.IntConstant) => <int>, pack=game.functions.ints, label=intConstant, cls=game.functions.ints.IntConstant, keyword=intConstant
~~~~ <sizeGroup> type=SubLudeme (game.functions.ints.size.connection.SizeGroup) => <int>, pack=game.functions.ints.size.connection, label=sizeGroup, cls=game.functions.ints.size.connection.SizeGroup, keyword=sizeGroup
~~~~ <sizeTerritory> type=SubLudeme (game.functions.ints.size.connection.SizeTerritory) => <int>, pack=game.functions.ints.size.connection, label=sizeTerritory, cls=game.functions.ints.size.connection.SizeTerritory, keyword=sizeTerritory
~~~~ <sizeLargePieceType> type=Structural (game.functions.ints.size.SizeLargePieceType) => <sizeLargePieceType>, pack=game.functions.ints.size, label=sizeLargePieceType, cls=game.functions.ints.size.SizeLargePieceType, keyword=sizeLargePieceType
~~~~ <sizeStack> type=SubLudeme (game.functions.ints.size.site.SizeStack) => <int>, pack=game.functions.ints.size.site, label=sizeStack, cls=game.functions.ints.size.site.SizeStack, keyword=sizeStack
~~~~ <sizeArrayType> type=Structural (game.functions.ints.size.SizeArrayType) => <sizeArrayType>, pack=game.functions.ints.size, label=sizeArrayType, cls=game.functions.ints.size.SizeArrayType, keyword=sizeArrayType
~~~~ <sizeTerritoryType> type=Structural (game.functions.ints.size.SizeTerritoryType) => <sizeTerritoryType>, pack=game.functions.ints.size, label=sizeTerritoryType, cls=game.functions.ints.size.SizeTerritoryType, keyword=sizeTerritoryType
~~~~ <sizeLargePiece> type=SubLudeme (game.functions.ints.size.largePiece.SizeLargePiece) => <int>, pack=game.functions.ints.size.largePiece, label=sizeLargePiece, cls=game.functions.ints.size.largePiece.SizeLargePiece, keyword=sizeLargePiece
~~~~ <sizeGroupType> type=Structural (game.functions.ints.size.SizeGroupType) => <sizeGroupType>, pack=game.functions.ints.size, label=sizeGroupType, cls=game.functions.ints.size.SizeGroupType, keyword=sizeGroupType
gd~~ <size> type=SuperLudeme (game.functions.ints.size.Size) => <int>, pack=game.functions.ints.size, label=size, cls=game.functions.ints.size.Size, keyword=size
~~~~ <sizeArray> type=SubLudeme (game.functions.ints.size.array.SizeArray) => <int>, pack=game.functions.ints.size.array, label=sizeArray, cls=game.functions.ints.size.array.SizeArray, keyword=sizeArray
~~~~ <sizeSiteType> type=Structural (game.functions.ints.size.SizeSiteType) => <sizeSiteType>, pack=game.functions.ints.size, label=sizeSiteType, cls=game.functions.ints.size.SizeSiteType, keyword=sizeSiteType
g~m* <int> type=Structural (game.functions.ints.IntFunction) => <int>, pack=game.functions.ints, label=int, cls=game.functions.ints.IntFunction, keyword=intFunction
gd~~ <ints.math.min> type=Ludeme (game.functions.ints.math.Min) => <int>, pack=game.functions.ints.math, label=ints.math.min, cls=game.functions.ints.math.Min, keyword=min
gd~~ <ints.math.abs> type=Ludeme (game.functions.ints.math.Abs) => <int>, pack=game.functions.ints.math, label=ints.math.abs, cls=game.functions.ints.math.Abs, keyword=abs
gd~~ <ints.math.*> type=Ludeme (game.functions.ints.math.Mul) => <int>, pack=game.functions.ints.math, label=ints.math.*, cls=game.functions.ints.math.Mul, keyword=*
gd~~ <%> type=Ludeme (game.functions.ints.math.Mod) => <int>, pack=game.functions.ints.math, label=%, cls=game.functions.ints.math.Mod, keyword=%
gd~~ <ints.math.-> type=Ludeme (game.functions.ints.math.Sub) => <int>, pack=game.functions.ints.math, label=ints.math.-, cls=game.functions.ints.math.Sub, keyword=-
gd~~ <ints.math.max> type=Ludeme (game.functions.ints.math.Max) => <int>, pack=game.functions.ints.math, label=ints.math.max, cls=game.functions.ints.math.Max, keyword=max
gd~~ <ints.math.+> type=Ludeme (game.functions.ints.math.Add) => <int>, pack=game.functions.ints.math, label=ints.math.+, cls=game.functions.ints.math.Add, keyword=+
gd~~ <ints.math./> type=Ludeme (game.functions.ints.math.Div) => <int>, pack=game.functions.ints.math, label=ints.math./, cls=game.functions.ints.math.Div, keyword=/
gd~~ <ints.math.^> type=Ludeme (game.functions.ints.math.Pow) => <int>, pack=game.functions.ints.math, label=ints.math.^, cls=game.functions.ints.math.Pow, keyword=^
gd~~ <ints.math.if> type=Ludeme (game.functions.ints.math.If) => <int>, pack=game.functions.ints.math, label=ints.math.if, cls=game.functions.ints.math.If, keyword=if
gd~~ <value> type=SuperLudeme (game.functions.ints.value.Value) => <int>, pack=game.functions.ints.value, label=value, cls=game.functions.ints.value.Value, keyword=value
~~~~ <valuePiece> type=SubLudeme (game.functions.ints.value.piece.ValuePiece) => <int>, pack=game.functions.ints.value.piece, label=valuePiece, cls=game.functions.ints.value.piece.ValuePiece, keyword=valuePiece
~~~~ <valueComponentType> type=Structural (game.functions.ints.value.ValueComponentType) => <valueComponentType>, pack=game.functions.ints.value, label=valueComponentType, cls=game.functions.ints.value.ValueComponentType, keyword=valueComponentType
~~~~ <valuePlayer> type=SubLudeme (game.functions.ints.value.player.ValuePlayer) => <int>, pack=game.functions.ints.value.player, label=valuePlayer, cls=game.functions.ints.value.player.ValuePlayer, keyword=valuePlayer
~~~~ <valuePending> type=SubLudeme (game.functions.ints.value.simple.ValuePending) => <int>, pack=game.functions.ints.value.simple, label=valuePending, cls=game.functions.ints.value.simple.ValuePending, keyword=valuePending
~~~~ <valueIterated> type=SubLudeme (game.functions.ints.value.iterated.ValueIterated) => <int>, pack=game.functions.ints.value.iterated, label=valueIterated, cls=game.functions.ints.value.iterated.ValueIterated, keyword=valueIterated
~~~~ <valueRandomType> type=Structural (game.functions.ints.value.ValueRandomType) => <valueRandomType>, pack=game.functions.ints.value, label=valueRandomType, cls=game.functions.ints.value.ValueRandomType, keyword=valueRandomType
~~~~ <valueSimpleType> type=Structural (game.functions.ints.value.ValueSimpleType) => <valueSimpleType>, pack=game.functions.ints.value, label=valueSimpleType, cls=game.functions.ints.value.ValueSimpleType, keyword=valueSimpleType
~~~~ <valuePlayerType> type=Structural (game.functions.ints.value.ValuePlayerType) => <valuePlayerType>, pack=game.functions.ints.value, label=valuePlayerType, cls=game.functions.ints.value.ValuePlayerType, keyword=valuePlayerType
~~~~ <valueRandom> type=SubLudeme (game.functions.ints.value.random.ValueRandom) => <int>, pack=game.functions.ints.value.random, label=valueRandom, cls=game.functions.ints.value.random.ValueRandom, keyword=valueRandom
gd~~ <matchScore> type=Ludeme (game.functions.ints.match.MatchScore) => <int>, pack=game.functions.ints.match, label=matchScore, cls=game.functions.ints.match.MatchScore, keyword=matchScore
~~~~ <lastFrom> type=SubLudeme (game.functions.ints.last.LastFrom) => <int>, pack=game.functions.ints.last, label=lastFrom, cls=game.functions.ints.last.LastFrom, keyword=lastFrom
g~~~ <lastType> type=Structural (game.functions.ints.last.LastType) => <lastType>, pack=game.functions.ints.last, label=lastType, cls=game.functions.ints.last.LastType, keyword=lastType
gd~~ <ints.last.last> type=SuperLudeme (game.functions.ints.last.Last) => <int>, pack=game.functions.ints.last, label=ints.last.last, cls=game.functions.ints.last.Last, keyword=last
~~~~ <lastTo> type=SubLudeme (game.functions.ints.last.LastTo) => <int>, pack=game.functions.ints.last, label=lastTo, cls=game.functions.ints.last.LastTo, keyword=lastTo
gd~~ <pathExtent> type=Ludeme (game.functions.ints.tile.PathExtent) => <int>, pack=game.functions.ints.tile, label=pathExtent, cls=game.functions.ints.tile.PathExtent, keyword=pathExtent
gd~~ <who> type=SuperLudeme (game.functions.ints.state.Who) => <int>, pack=game.functions.ints.state, label=who, cls=game.functions.ints.state.Who, keyword=who
gd~~ <next> type=SuperLudeme (game.functions.ints.state.Next) => <int>, pack=game.functions.ints.state, label=next, cls=game.functions.ints.state.Next, keyword=next
gd~~ <counter> type=Ludeme (game.functions.ints.state.Counter) => <int>, pack=game.functions.ints.state, label=counter, cls=game.functions.ints.state.Counter, keyword=counter
gd~~ <prev> type=Ludeme (game.functions.ints.state.Prev) => <int>, pack=game.functions.ints.state, label=prev, cls=game.functions.ints.state.Prev, keyword=prev
gd~~ <var> type=Ludeme (game.functions.ints.state.Var) => <int>, pack=game.functions.ints.state, label=var, cls=game.functions.ints.state.Var, keyword=var
gd~~ <what> type=Ludeme (game.functions.ints.state.What) => <int>, pack=game.functions.ints.state, label=what, cls=game.functions.ints.state.What, keyword=what
gd~~ <mover> type=Ludeme (game.functions.ints.state.Mover) => <int>, pack=game.functions.ints.state, label=mover, cls=game.functions.ints.state.Mover, keyword=mover
gd~~ <pot> type=Ludeme (game.functions.ints.state.Pot) => <int>, pack=game.functions.ints.state, label=pot, cls=game.functions.ints.state.Pot, keyword=pot
gd~~ <amount> type=Ludeme (game.functions.ints.state.Amount) => <int>, pack=game.functions.ints.state, label=amount, cls=game.functions.ints.state.Amount, keyword=amount
gd~~ <state> type=Ludeme (game.functions.ints.state.State) => <int>, pack=game.functions.ints.state, label=state, cls=game.functions.ints.state.State, keyword=state
gd~~ <rotation> type=Ludeme (game.functions.ints.state.Rotation) => <int>, pack=game.functions.ints.state, label=rotation, cls=game.functions.ints.state.Rotation, keyword=rotation
gd~~ <state.score> type=Ludeme (game.functions.ints.state.Score) => <int>, pack=game.functions.ints.state, label=state.score, cls=game.functions.ints.state.Score, keyword=score
g~~~ <countComponentType> type=Structural (game.functions.ints.count.CountComponentType) => <countComponentType>, pack=game.functions.ints.count, label=countComponentType, cls=game.functions.ints.count.CountComponentType, keyword=countComponentType
~~~~ <countStepsOnTrackType> type=Structural (game.functions.ints.count.CountStepsOnTrackType) => <countStepsOnTrackType>, pack=game.functions.ints.count, label=countStepsOnTrackType, cls=game.functions.ints.count.CountStepsOnTrackType, keyword=countStepsOnTrackType
g~~~ <countSiteType> type=Structural (game.functions.ints.count.CountSiteType) => <countSiteType>, pack=game.functions.ints.count, label=countSiteType, cls=game.functions.ints.count.CountSiteType, keyword=countSiteType
g~~~ <countSimpleType> type=Structural (game.functions.ints.count.CountSimpleType) => <countSimpleType>, pack=game.functions.ints.count, label=countSimpleType, cls=game.functions.ints.count.CountSimpleType, keyword=countSimpleType
~~~~ <countStackType> type=Structural (game.functions.ints.count.CountStackType) => <countStackType>, pack=game.functions.ints.count, label=countStackType, cls=game.functions.ints.count.CountStackType, keyword=countStackType
~~~~ <countLibertiesType> type=Structural (game.functions.ints.count.CountLibertiesType) => <countLibertiesType>, pack=game.functions.ints.count, label=countLibertiesType, cls=game.functions.ints.count.CountLibertiesType, keyword=countLibertiesType
~~~~ <countSites> type=SubLudeme (game.functions.ints.count.site.CountSites) => <int>, pack=game.functions.ints.count.site, label=countSites, cls=game.functions.ints.count.site.CountSites, keyword=countSites
~~~~ <countOrthogonal> type=SubLudeme (game.functions.ints.count.site.CountOrthogonal) => <int>, pack=game.functions.ints.count.site, label=countOrthogonal, cls=game.functions.ints.count.site.CountOrthogonal, keyword=countOrthogonal
~~~~ <countNumber> type=SubLudeme (game.functions.ints.count.site.CountNumber) => <int>, pack=game.functions.ints.count.site, label=countNumber, cls=game.functions.ints.count.site.CountNumber, keyword=countNumber
~~~~ <countOff> type=SubLudeme (game.functions.ints.count.site.CountOff) => <int>, pack=game.functions.ints.count.site, label=countOff, cls=game.functions.ints.count.site.CountOff, keyword=countOff
~~~~ <countAdjacent> type=SubLudeme (game.functions.ints.count.site.CountAdjacent) => <int>, pack=game.functions.ints.count.site, label=countAdjacent, cls=game.functions.ints.count.site.CountAdjacent, keyword=countAdjacent
~~~~ <countDiagonal> type=SubLudeme (game.functions.ints.count.site.CountDiagonal) => <int>, pack=game.functions.ints.count.site, label=countDiagonal, cls=game.functions.ints.count.site.CountDiagonal, keyword=countDiagonal
~~~~ <countNeighbours> type=SubLudeme (game.functions.ints.count.site.CountNeighbours) => <int>, pack=game.functions.ints.count.site, label=countNeighbours, cls=game.functions.ints.count.site.CountNeighbours, keyword=countNeighbours
~~~~ <countStack> type=SubLudeme (game.functions.ints.count.stack.CountStack) => <int>, pack=game.functions.ints.count.stack, label=countStack, cls=game.functions.ints.count.stack.CountStack, keyword=countStack
~~~~ <countColumns> type=SubLudeme (game.functions.ints.count.simple.CountColumns) => <int>, pack=game.functions.ints.count.simple, label=countColumns, cls=game.functions.ints.count.simple.CountColumns, keyword=countColumns
~~~~ <countMoves> type=SubLudeme (game.functions.ints.count.simple.CountMoves) => <int>, pack=game.functions.ints.count.simple, label=countMoves, cls=game.functions.ints.count.simple.CountMoves, keyword=countMoves
~~~~ <countTurns> type=SubLudeme (game.functions.ints.count.simple.CountTurns) => <int>, pack=game.functions.ints.count.simple, label=countTurns, cls=game.functions.ints.count.simple.CountTurns, keyword=countTurns
~~~~ <countVertices> type=SubLudeme (game.functions.ints.count.simple.CountVertices) => <int>, pack=game.functions.ints.count.simple, label=countVertices, cls=game.functions.ints.count.simple.CountVertices, keyword=countVertices
~~~~ <countEdges> type=SubLudeme (game.functions.ints.count.simple.CountEdges) => <int>, pack=game.functions.ints.count.simple, label=countEdges, cls=game.functions.ints.count.simple.CountEdges, keyword=countEdges
~~~~ <countPhases> type=SubLudeme (game.functions.ints.count.simple.CountPhases) => <int>, pack=game.functions.ints.count.simple, label=countPhases, cls=game.functions.ints.count.simple.CountPhases, keyword=countPhases
~~~~ <countMovesThisTurn> type=SubLudeme (game.functions.ints.count.simple.CountMovesThisTurn) => <int>, pack=game.functions.ints.count.simple, label=countMovesThisTurn, cls=game.functions.ints.count.simple.CountMovesThisTurn, keyword=countMovesThisTurn
~~~~ <countTrials> type=SubLudeme (game.functions.ints.count.simple.CountTrials) => <int>, pack=game.functions.ints.count.simple, label=countTrials, cls=game.functions.ints.count.simple.CountTrials, keyword=countTrials
~~~~ <countCells> type=SubLudeme (game.functions.ints.count.simple.CountCells) => <int>, pack=game.functions.ints.count.simple, label=countCells, cls=game.functions.ints.count.simple.CountCells, keyword=countCells
~~~~ <countPlayers> type=SubLudeme (game.functions.ints.count.simple.CountPlayers) => <int>, pack=game.functions.ints.count.simple, label=countPlayers, cls=game.functions.ints.count.simple.CountPlayers, keyword=countPlayers
~~~~ <countActive> type=SubLudeme (game.functions.ints.count.simple.CountActive) => <int>, pack=game.functions.ints.count.simple, label=countActive, cls=game.functions.ints.count.simple.CountActive, keyword=countActive
~~~~ <countRows> type=SubLudeme (game.functions.ints.count.simple.CountRows) => <int>, pack=game.functions.ints.count.simple, label=countRows, cls=game.functions.ints.count.simple.CountRows, keyword=countRows
~~~~ <countGroupsType> type=Structural (game.functions.ints.count.CountGroupsType) => <countGroupsType>, pack=game.functions.ints.count, label=countGroupsType, cls=game.functions.ints.count.CountGroupsType, keyword=countGroupsType
~~~~ <countGroups> type=SubLudeme (game.functions.ints.count.groups.CountGroups) => <int>, pack=game.functions.ints.count.groups, label=countGroups, cls=game.functions.ints.count.groups.CountGroups, keyword=countGroups
~~~~ <countStepsType> type=Structural (game.functions.ints.count.CountStepsType) => <countStepsType>, pack=game.functions.ints.count, label=countStepsType, cls=game.functions.ints.count.CountStepsType, keyword=countStepsType
~~~~ <countStepsOnTrack> type=SubLudeme (game.functions.ints.count.stepsOnTrack.CountStepsOnTrack) => <int>, pack=game.functions.ints.count.stepsOnTrack, label=countStepsOnTrack, cls=game.functions.ints.count.stepsOnTrack.CountStepsOnTrack, keyword=countStepsOnTrack
gd~~ <count.count> type=SuperLudeme (game.functions.ints.count.Count) => <int>, pack=game.functions.ints.count, label=count.count, cls=game.functions.ints.count.Count, keyword=count
~~~~ <countLiberties> type=SubLudeme (game.functions.ints.count.liberties.CountLiberties) => <int>, pack=game.functions.ints.count.liberties, label=countLiberties, cls=game.functions.ints.count.liberties.CountLiberties, keyword=countLiberties
~~~~ <countSteps> type=SubLudeme (game.functions.ints.count.steps.CountSteps) => <int>, pack=game.functions.ints.count.steps, label=countSteps, cls=game.functions.ints.count.steps.CountSteps, keyword=countSteps
~~~~ <countPieces> type=SubLudeme (game.functions.ints.count.component.CountPieces) => <int>, pack=game.functions.ints.count.component, label=countPieces, cls=game.functions.ints.count.component.CountPieces, keyword=countPieces
~~~~ <countPips> type=SubLudeme (game.functions.ints.count.component.CountPips) => <int>, pack=game.functions.ints.count.component, label=countPips, cls=game.functions.ints.count.component.CountPips, keyword=countPips
gd~~ <toInt> type=Ludeme (game.functions.ints.ToInt) => <int>, pack=game.functions.ints, label=toInt, cls=game.functions.ints.ToInt, keyword=toInt
~~~* <baseIntFunction> type=Ludeme (game.functions.ints.BaseIntFunction) => <baseIntFunction>, pack=game.functions.ints, label=baseIntFunction, cls=game.functions.ints.BaseIntFunction, keyword=baseIntFunction
gd~~ <topLevel> type=Ludeme (game.functions.ints.stacking.TopLevel) => <int>, pack=game.functions.ints.stacking, label=topLevel, cls=game.functions.ints.stacking.TopLevel, keyword=topLevel
gd~~ <mapEntry> type=Ludeme (game.functions.ints.board.MapEntry) => <int>, pack=game.functions.ints.board, label=mapEntry, cls=game.functions.ints.board.MapEntry, keyword=mapEntry
gd~~ <id> type=Ludeme (game.functions.ints.board.Id) => <int>, pack=game.functions.ints.board, label=id, cls=game.functions.ints.board.Id, keyword=id
~~~~ <whereLevel> type=SubLudeme (game.functions.ints.board.where.WhereLevel) => <int>, pack=game.functions.ints.board.where, label=whereLevel, cls=game.functions.ints.board.where.WhereLevel, keyword=whereLevel
~~~~ <whereSite> type=SubLudeme (game.functions.ints.board.where.WhereSite) => <int>, pack=game.functions.ints.board.where, label=whereSite, cls=game.functions.ints.board.where.WhereSite, keyword=whereSite
~~~~ <whereLevelType> type=Structural (game.functions.ints.board.where.WhereLevelType) => <whereLevelType>, pack=game.functions.ints.board.where, label=whereLevelType, cls=game.functions.ints.board.where.WhereLevelType, keyword=whereLevelType
gd~~ <where> type=SuperLudeme (game.functions.ints.board.where.Where) => <int>, pack=game.functions.ints.board.where, label=where, cls=game.functions.ints.board.where.Where, keyword=where
gd~~ <ahead> type=Ludeme (game.functions.ints.board.Ahead) => <int>, pack=game.functions.ints.board, label=ahead, cls=game.functions.ints.board.Ahead, keyword=ahead
gd~~ <regionSite> type=Ludeme (game.functions.ints.board.RegionSite) => <int>, pack=game.functions.ints.board, label=regionSite, cls=game.functions.ints.board.RegionSite, keyword=regionSite
gd~~ <column> type=Ludeme (game.functions.ints.board.Column) => <int>, pack=game.functions.ints.board, label=column, cls=game.functions.ints.board.Column, keyword=column
gd~~ <centrePoint> type=Ludeme (game.functions.ints.board.CentrePoint) => <int>, pack=game.functions.ints.board, label=centrePoint, cls=game.functions.ints.board.CentrePoint, keyword=centrePoint
gd~~ <board.phase> type=Ludeme (game.functions.ints.board.Phase) => <int>, pack=game.functions.ints.board, label=board.phase, cls=game.functions.ints.board.Phase, keyword=phase
gd~~ <cost> type=Ludeme (game.functions.ints.board.Cost) => <int>, pack=game.functions.ints.board, label=cost, cls=game.functions.ints.board.Cost, keyword=cost
gd~~ <coord> type=Ludeme (game.functions.ints.board.Coord) => <int>, pack=game.functions.ints.board, label=coord, cls=game.functions.ints.board.Coord, keyword=coord
gd~~ <layer> type=Ludeme (game.functions.ints.board.Layer) => <int>, pack=game.functions.ints.board, label=layer, cls=game.functions.ints.board.Layer, keyword=layer
gd~~ <handSite> type=Ludeme (game.functions.ints.board.HandSite) => <int>, pack=game.functions.ints.board, label=handSite, cls=game.functions.ints.board.HandSite, keyword=handSite
gd~~ <row> type=Ludeme (game.functions.ints.board.Row) => <int>, pack=game.functions.ints.board, label=row, cls=game.functions.ints.board.Row, keyword=row
gd~~ <dice.face> type=Ludeme (game.functions.ints.dice.Face) => <int>, pack=game.functions.ints.dice, label=dice.face, cls=game.functions.ints.dice.Face, keyword=face
gd~~ <level> type=Ludeme (game.functions.ints.iterator.Level) => <int>, pack=game.functions.ints.iterator, label=level, cls=game.functions.ints.iterator.Level, keyword=level
gd~~ <iterator.player> type=Ludeme (game.functions.ints.iterator.Player) => <int>, pack=game.functions.ints.iterator, label=iterator.player, cls=game.functions.ints.iterator.Player, keyword=player
gd~~ <site> type=Ludeme (game.functions.ints.iterator.Site) => <int>, pack=game.functions.ints.iterator, label=site, cls=game.functions.ints.iterator.Site, keyword=site
gd~~ <iterator.between> type=SuperLudeme (game.functions.ints.iterator.Between) => <int>, pack=game.functions.ints.iterator, label=iterator.between, cls=game.functions.ints.iterator.Between, keyword=between
gd~~ <iterator.to> type=SuperLudeme (game.functions.ints.iterator.To) => <int>, pack=game.functions.ints.iterator, label=iterator.to, cls=game.functions.ints.iterator.To, keyword=to
gd~~ <iterator.track> type=Ludeme (game.functions.ints.iterator.Track) => <int>, pack=game.functions.ints.iterator, label=iterator.track, cls=game.functions.ints.iterator.Track, keyword=track
gd~~ <pips> type=SuperLudeme (game.functions.ints.iterator.Pips) => <int>, pack=game.functions.ints.iterator, label=pips, cls=game.functions.ints.iterator.Pips, keyword=pips
gd~~ <iterator.hint> type=Ludeme (game.functions.ints.iterator.Hint) => <int>, pack=game.functions.ints.iterator, label=iterator.hint, cls=game.functions.ints.iterator.Hint, keyword=hint
gd~~ <iterator.from> type=Ludeme (game.functions.ints.iterator.From) => <int>, pack=game.functions.ints.iterator, label=iterator.from, cls=game.functions.ints.iterator.From, keyword=from
gd~~ <iterator.edge> type=Ludeme (game.functions.ints.iterator.Edge) => <int>, pack=game.functions.ints.iterator, label=iterator.edge, cls=game.functions.ints.iterator.Edge, keyword=edge
~~~~ <trackSiteEndTrack> type=SubLudeme (game.functions.ints.trackSite.position.TrackSiteEndTrack) => <int>, pack=game.functions.ints.trackSite.position, label=trackSiteEndTrack, cls=game.functions.ints.trackSite.position.TrackSiteEndTrack, keyword=trackSiteEndTrack
~~~~ <trackSiteMoveType> type=Structural (game.functions.ints.trackSite.TrackSiteMoveType) => <trackSiteMoveType>, pack=game.functions.ints.trackSite, label=trackSiteMoveType, cls=game.functions.ints.trackSite.TrackSiteMoveType, keyword=trackSiteMoveType
gd~~ <trackSite> type=SuperLudeme (game.functions.ints.trackSite.TrackSite) => <int>, pack=game.functions.ints.trackSite, label=trackSite, cls=game.functions.ints.trackSite.TrackSite, keyword=trackSite
~~~~ <trackSiteType> type=Structural (game.functions.ints.trackSite.TrackSiteType) => <trackSiteType>, pack=game.functions.ints.trackSite, label=trackSiteType, cls=game.functions.ints.trackSite.TrackSiteType, keyword=trackSiteType
~~~~ <trackSiteMove> type=SubLudeme (game.functions.ints.trackSite.move.TrackSiteMove) => <int>, pack=game.functions.ints.trackSite.move, label=trackSiteMove, cls=game.functions.ints.trackSite.move.TrackSiteMove, keyword=trackSiteMove
~~~~ <randomDirectionType> type=Structural (game.functions.directions.RandomDirectionType) => <randomDirectionType>, pack=game.functions.directions, label=randomDirectionType, cls=game.functions.directions.RandomDirectionType, keyword=randomDirectionType
gd~~ <directions.difference> type=Ludeme (game.functions.directions.Difference) => <direction>, pack=game.functions.directions, label=directions.difference, cls=game.functions.directions.Difference, keyword=difference
gd~~ <directions.if> type=Ludeme (game.functions.directions.If) => <directions.if>, pack=game.functions.directions, label=directions.if, cls=game.functions.directions.If, keyword=if
~~~* <directions> type=Ludeme (game.functions.directions.DirectionsFunction) => <directions>, pack=game.functions.directions, label=directions, cls=game.functions.directions.DirectionsFunction, keyword=directionsFunction
gd~~ <directions> type=Ludeme (game.functions.directions.Directions) => <directions>, pack=game.functions.directions, label=directions, cls=game.functions.directions.Directions, keyword=directions
~~~~ <floatConstant> type=Ludeme (game.functions.floats.FloatConstant) => <float>, pack=game.functions.floats, label=floatConstant, cls=game.functions.floats.FloatConstant, keyword=floatConstant
g~~* <float> type=Structural (game.functions.floats.FloatFunction) => <float>, pack=game.functions.floats, label=float, cls=game.functions.floats.FloatFunction, keyword=floatFunction
gd~~ <sin> type=Ludeme (game.functions.floats.math.Sin) => <float>, pack=game.functions.floats.math, label=sin, cls=game.functions.floats.math.Sin, keyword=sin
gd~~ <tan> type=Ludeme (game.functions.floats.math.Tan) => <float>, pack=game.functions.floats.math, label=tan, cls=game.functions.floats.math.Tan, keyword=tan
gd~~ <floats.math.min> type=Ludeme (game.functions.floats.math.Min) => <float>, pack=game.functions.floats.math, label=floats.math.min, cls=game.functions.floats.math.Min, keyword=min
gd~~ <exp> type=Ludeme (game.functions.floats.math.Exp) => <float>, pack=game.functions.floats.math, label=exp, cls=game.functions.floats.math.Exp, keyword=exp
gd~~ <floats.math.abs> type=Ludeme (game.functions.floats.math.Abs) => <float>, pack=game.functions.floats.math, label=floats.math.abs, cls=game.functions.floats.math.Abs, keyword=abs
gd~~ <floats.math.*> type=Ludeme (game.functions.floats.math.Mul) => <float>, pack=game.functions.floats.math, label=floats.math.*, cls=game.functions.floats.math.Mul, keyword=*
gd~~ <cos> type=Ludeme (game.functions.floats.math.Cos) => <float>, pack=game.functions.floats.math, label=cos, cls=game.functions.floats.math.Cos, keyword=cos
gd~~ <floats.math.-> type=Ludeme (game.functions.floats.math.Sub) => <float>, pack=game.functions.floats.math, label=floats.math.-, cls=game.functions.floats.math.Sub, keyword=-
gd~~ <floats.math.max> type=Ludeme (game.functions.floats.math.Max) => <float>, pack=game.functions.floats.math, label=floats.math.max, cls=game.functions.floats.math.Max, keyword=max
gd~~ <floats.math.+> type=Ludeme (game.functions.floats.math.Add) => <float>, pack=game.functions.floats.math, label=floats.math.+, cls=game.functions.floats.math.Add, keyword=+
gd~~ <floats.math./> type=Ludeme (game.functions.floats.math.Div) => <float>, pack=game.functions.floats.math, label=floats.math./, cls=game.functions.floats.math.Div, keyword=/
gd~~ <log> type=Ludeme (game.functions.floats.math.Log) => <float>, pack=game.functions.floats.math, label=log, cls=game.functions.floats.math.Log, keyword=log
gd~~ <floats.math.^> type=Ludeme (game.functions.floats.math.Pow) => <float>, pack=game.functions.floats.math, label=floats.math.^, cls=game.functions.floats.math.Pow, keyword=^
gd~~ <sqrt> type=Ludeme (game.functions.floats.math.Sqrt) => <float>, pack=game.functions.floats.math, label=sqrt, cls=game.functions.floats.math.Sqrt, keyword=sqrt
gd~~ <log10> type=Ludeme (game.functions.floats.math.Log10) => <float>, pack=game.functions.floats.math, label=log10, cls=game.functions.floats.math.Log10, keyword=log10
gd~~ <toFloat> type=Ludeme (game.functions.floats.ToFloat) => <float>, pack=game.functions.floats, label=toFloat, cls=game.functions.floats.ToFloat, keyword=toFloat
~~~* <baseFloatFunction> type=Ludeme (game.functions.floats.BaseFloatFunction) => <baseFloatFunction>, pack=game.functions.floats, label=baseFloatFunction, cls=game.functions.floats.BaseFloatFunction, keyword=baseFloatFunction
~~~~ <valuesRemembered> type=SubLudeme (game.functions.intArray.values.ValuesRemembered) => <int>{<int>}, pack=game.functions.intArray.values, label=valuesRemembered, cls=game.functions.intArray.values.ValuesRemembered, keyword=valuesRemembered
gd~~ <values.values> type=SuperLudeme (game.functions.intArray.values.Values) => <int>{<int>}, pack=game.functions.intArray.values, label=values.values, cls=game.functions.intArray.values.Values, keyword=values
~~~~ <valuesStringType> type=Structural (game.functions.intArray.values.ValuesStringType) => <valuesStringType>, pack=game.functions.intArray.values, label=valuesStringType, cls=game.functions.intArray.values.ValuesStringType, keyword=valuesStringType
~~~* <baseIntArrayFunction> type=Ludeme (game.functions.intArray.BaseIntArrayFunction) => <baseIntArrayFunction>, pack=game.functions.intArray, label=baseIntArrayFunction, cls=game.functions.intArray.BaseIntArrayFunction, keyword=baseIntArrayFunction
~~~~ <sizesGroup> type=SubLudeme (game.functions.intArray.sizes.group.SizesGroup) => <int>{<int>}, pack=game.functions.intArray.sizes.group, label=sizesGroup, cls=game.functions.intArray.sizes.group.SizesGroup, keyword=sizesGroup
~~~~ <sizesGroupType> type=Structural (game.functions.intArray.sizes.SizesGroupType) => <sizesGroupType>, pack=game.functions.intArray.sizes, label=sizesGroupType, cls=game.functions.intArray.sizes.SizesGroupType, keyword=sizesGroupType
gd~~ <sizes> type=SuperLudeme (game.functions.intArray.sizes.Sizes) => <int>{<int>}, pack=game.functions.intArray.sizes, label=sizes, cls=game.functions.intArray.sizes.Sizes, keyword=sizes
g~~* <ints> type=Structural (game.functions.intArray.IntArrayFunction) => <int>{<int>}, pack=game.functions.intArray, label=ints, cls=game.functions.intArray.IntArrayFunction, keyword=intArrayFunction
gd~~ <intArray.math.union> type=Ludeme (game.functions.intArray.math.Union) => <int>{<int>}, pack=game.functions.intArray.math, label=intArray.math.union, cls=game.functions.intArray.math.Union, keyword=union
gd~~ <intArray.math.difference> type=Ludeme (game.functions.intArray.math.Difference) => <int>{<int>}, pack=game.functions.intArray.math, label=intArray.math.difference, cls=game.functions.intArray.math.Difference, keyword=difference
gd~~ <results> type=Ludeme (game.functions.intArray.math.Results) => <int>{<int>}, pack=game.functions.intArray.math, label=results, cls=game.functions.intArray.math.Results, keyword=results
gd~~ <intArray.math.intersection> type=Ludeme (game.functions.intArray.math.Intersection) => <int>{<int>}, pack=game.functions.intArray.math, label=intArray.math.intersection, cls=game.functions.intArray.math.Intersection, keyword=intersection
~~~~ <degrees> type=Ludeme (game.functions.intArray.state.wip.Degrees) => <int>{<int>}, pack=game.functions.intArray.state.wip, label=degrees, cls=game.functions.intArray.state.wip.Degrees, keyword=degrees
gd~~ <rotations> type=Ludeme (game.functions.intArray.state.Rotations) => <int>{<int>}, pack=game.functions.intArray.state, label=rotations, cls=game.functions.intArray.state.Rotations, keyword=rotations
g~~~ <playersManyType> type=Structural (game.functions.intArray.players.PlayersManyType) => <playersManyType>, pack=game.functions.intArray.players, label=playersManyType, cls=game.functions.intArray.players.PlayersManyType, keyword=playersManyType
~~~~ <playersMany> type=SubLudeme (game.functions.intArray.players.many.PlayersMany) => <int>{<int>}, pack=game.functions.intArray.players.many, label=playersMany, cls=game.functions.intArray.players.many.PlayersMany, keyword=playersMany
gd~~ <intArray.players.players> type=SuperLudeme (game.functions.intArray.players.Players) => <int>{<int>}, pack=game.functions.intArray.players, label=intArray.players.players, cls=game.functions.intArray.players.Players, keyword=players
~~~~ <playersTeam> type=SubLudeme (game.functions.intArray.players.team.PlayersTeam) => <int>{<int>}, pack=game.functions.intArray.players.team, label=playersTeam, cls=game.functions.intArray.players.team.PlayersTeam, keyword=playersTeam
g~~~ <playersTeamType> type=Structural (game.functions.intArray.players.PlayersTeamType) => <playersTeamType>, pack=game.functions.intArray.players, label=playersTeamType, cls=game.functions.intArray.players.PlayersTeamType, keyword=playersTeamType
gd~~ <array> type=Ludeme (game.functions.intArray.array.Array) => <int>{<int>}, pack=game.functions.intArray.array, label=array, cls=game.functions.intArray.array.Array, keyword=array
~~~~ <intArrayConstant> type=Ludeme (game.functions.intArray.IntArrayConstant) => <int>{<int>}, pack=game.functions.intArray, label=intArrayConstant, cls=game.functions.intArray.IntArrayConstant, keyword=intArrayConstant
gd~~ <team> type=Ludeme (game.functions.intArray.iteraror.Team) => <int>{<int>}, pack=game.functions.intArray.iteraror, label=team, cls=game.functions.intArray.iteraror.Team, keyword=team
g~~* <range> type=Structural (game.functions.range.RangeFunction) => <range>, pack=game.functions.range, label=range, cls=game.functions.range.RangeFunction, keyword=rangeFunction
gd~~ <range> type=Ludeme (game.functions.range.Range) => <range>, pack=game.functions.range, label=range, cls=game.functions.range.Range, keyword=range
gd~~ <range.math.min> type=Ludeme (game.functions.range.math.Min) => <range>, pack=game.functions.range.math, label=range.math.min, cls=game.functions.range.math.Min, keyword=min
gd~~ <exact> type=Ludeme (game.functions.range.math.Exact) => <range>, pack=game.functions.range.math, label=exact, cls=game.functions.range.math.Exact, keyword=exact
gd~~ <range.math.max> type=Ludeme (game.functions.range.math.Max) => <range>, pack=game.functions.range.math, label=range.math.max, cls=game.functions.range.math.Max, keyword=max
~~~* <baseRangeFunction> type=Ludeme (game.functions.range.BaseRangeFunction) => <range>, pack=game.functions.range, label=baseRangeFunction, cls=game.functions.range.BaseRangeFunction, keyword=baseRangeFunction
gd~~ <end> type=Ludeme (game.rules.end.End) => <end>, pack=game.rules.end, label=end, cls=game.rules.end.End, keyword=end
g~~* <endRule> type=Structural (game.rules.end.EndRule) => <endRule>, pack=game.rules.end, label=endRule, cls=game.rules.end.EndRule, keyword=endRule
gd~~ <payoffs> type=Ludeme (game.rules.end.Payoffs) => <payoffs>, pack=game.rules.end, label=payoffs, cls=game.rules.end.Payoffs, keyword=payoffs
gd~~ <result> type=Ludeme (game.rules.end.Result) => <result>, pack=game.rules.end, label=result, cls=game.rules.end.Result, keyword=result
gd~~ <byScore> type=Ludeme (game.rules.end.ByScore) => <byScore>, pack=game.rules.end, label=byScore, cls=game.rules.end.ByScore, keyword=byScore
~~~~ <baseEndRule> type=Ludeme (game.rules.end.BaseEndRule) => <endRule>, pack=game.rules.end, label=baseEndRule, cls=game.rules.end.BaseEndRule, keyword=baseEndRule
gd~~ <end.forEach> type=Ludeme (game.rules.end.ForEach) => <endRule>, pack=game.rules.end, label=end.forEach, cls=game.rules.end.ForEach, keyword=forEach
gd~~ <end.if> type=Ludeme (game.rules.end.If) => <endRule>, pack=game.rules.end, label=end.if, cls=game.rules.end.If, keyword=if
~~~* <rule> type=Structural (game.rules.Rule) => <rule>, pack=game.rules, label=rule, cls=game.rules.Rule, keyword=rule
g~~* <startRule> type=Structural (game.rules.start.StartRule) => <startRule>, pack=game.rules.start, label=startRule, cls=game.rules.start.StartRule, keyword=startRule
~~~~ <setStartPlayersType> type=Structural (game.rules.start.set.SetStartPlayersType) => <setStartPlayersType>, pack=game.rules.start.set, label=setStartPlayersType, cls=game.rules.start.set.SetStartPlayersType, keyword=setStartPlayersType
~~~~ <setStartHiddenType> type=Structural (game.rules.start.set.SetStartHiddenType) => <setStartHiddenType>, pack=game.rules.start.set, label=setStartHiddenType, cls=game.rules.start.set.SetStartHiddenType, keyword=setStartHiddenType
g~~~ <setStartSitesType> type=Structural (game.rules.start.set.SetStartSitesType) => <setStartSitesType>, pack=game.rules.start.set, label=setStartSitesType, cls=game.rules.start.set.SetStartSitesType, keyword=setStartSitesType
~~~~ <setRememberValueType> type=Structural (game.rules.start.set.SetRememberValueType) => <setRememberValueType>, pack=game.rules.start.set, label=setRememberValueType, cls=game.rules.start.set.SetRememberValueType, keyword=setRememberValueType
~~~~ <setAmount> type=SubLudeme (game.rules.start.set.player.SetAmount) => <setAmount>, pack=game.rules.start.set.player, label=setAmount, cls=game.rules.start.set.player.SetAmount, keyword=setAmount
~~~~ <start.set.player.setScore> type=SubLudeme (game.rules.start.set.player.SetScore) => <start.set.player.setScore>, pack=game.rules.start.set.player, label=start.set.player.setScore, cls=game.rules.start.set.player.SetScore, keyword=setScore
~~~~ <setSite> type=SubLudeme (game.rules.start.set.sites.SetSite) => <setSite>, pack=game.rules.start.set.sites, label=setSite, cls=game.rules.start.set.sites.SetSite, keyword=setSite
~~~~ <setCost> type=SubLudeme (game.rules.start.set.sites.SetCost) => <setCost>, pack=game.rules.start.set.sites, label=setCost, cls=game.rules.start.set.sites.SetCost, keyword=setCost
~~~~ <setPhase> type=SubLudeme (game.rules.start.set.sites.SetPhase) => <setPhase>, pack=game.rules.start.set.sites, label=setPhase, cls=game.rules.start.set.sites.SetPhase, keyword=setPhase
~~~~ <sites.setCount> type=SubLudeme (game.rules.start.set.sites.SetCount) => <sites.setCount>, pack=game.rules.start.set.sites, label=sites.setCount, cls=game.rules.start.set.sites.SetCount, keyword=setCount
g~~~ <setStartPlayerType> type=Structural (game.rules.start.set.SetStartPlayerType) => <setStartPlayerType>, pack=game.rules.start.set, label=setStartPlayerType, cls=game.rules.start.set.SetStartPlayerType, keyword=setStartPlayerType
~~~~ <setStartGraphType> type=Structural (game.rules.start.set.SetStartGraphType) => <setStartGraphType>, pack=game.rules.start.set, label=setStartGraphType, cls=game.rules.start.set.SetStartGraphType, keyword=setStartGraphType
gd~~ <start.set.set> type=SuperLudeme (game.rules.start.set.Set) => <start.set.set>, pack=game.rules.start.set, label=start.set.set, cls=game.rules.start.set.Set, keyword=set
~~~~ <players.setTeam> type=SubLudeme (game.rules.start.set.players.SetTeam) => <players.setTeam>, pack=game.rules.start.set.players, label=players.setTeam, cls=game.rules.start.set.players.SetTeam, keyword=setTeam
~~~~ <start.set.hidden.setHidden> type=SubLudeme (game.rules.start.set.hidden.SetHidden) => <start.set.hidden.setHidden>, pack=game.rules.start.set.hidden, label=start.set.hidden.setHidden, cls=game.rules.start.set.hidden.SetHidden, keyword=setHidden
~~~~ <setRememberValue> type=SubLudeme (game.rules.start.set.remember.SetRememberValue) => <setRememberValue>, pack=game.rules.start.set.remember, label=setRememberValue, cls=game.rules.start.set.remember.SetRememberValue, keyword=setRememberValue
gd~~ <start> type=Ludeme (game.rules.start.Start) => <start>, pack=game.rules.start, label=start, cls=game.rules.start.Start, keyword=start
gd~~ <start.deal> type=Ludeme (game.rules.start.Deal) => <start.deal>, pack=game.rules.start, label=start.deal, cls=game.rules.start.Deal, keyword=deal
~~~~ <forEach.site.forEachSite> type=SubLudeme (game.rules.start.forEach.site.ForEachSite) => <forEach.site.forEachSite>, pack=game.rules.start.forEach.site, label=forEach.site.forEachSite, cls=game.rules.start.forEach.site.ForEachSite, keyword=forEachSite
~~~~ <forEach.player.forEachPlayer> type=SubLudeme (game.rules.start.forEach.player.ForEachPlayer) => <forEach.player.forEachPlayer>, pack=game.rules.start.forEach.player, label=forEach.player.forEachPlayer, cls=game.rules.start.forEach.player.ForEachPlayer, keyword=forEachPlayer
~~~~ <forEach.value.forEachValue> type=SubLudeme (game.rules.start.forEach.value.ForEachValue) => <forEach.value.forEachValue>, pack=game.rules.start.forEach.value, label=forEach.value.forEachValue, cls=game.rules.start.forEach.value.ForEachValue, keyword=forEachValue
~~~~ <forEachTeamType> type=Structural (game.rules.start.forEach.ForEachTeamType) => <forEachTeamType>, pack=game.rules.start.forEach, label=forEachTeamType, cls=game.rules.start.forEach.ForEachTeamType, keyword=forEachTeamType
gd~~ <forEach.forEach> type=SuperLudeme (game.rules.start.forEach.ForEach) => <forEach.forEach>, pack=game.rules.start.forEach, label=forEach.forEach, cls=game.rules.start.forEach.ForEach, keyword=forEach
~~~~ <forEach.team.forEachTeam> type=SubLudeme (game.rules.start.forEach.team.ForEachTeam) => <forEach.team.forEachTeam>, pack=game.rules.start.forEach.team, label=forEach.team.forEachTeam, cls=game.rules.start.forEach.team.ForEachTeam, keyword=forEachTeam
~~~~ <forEachStartValueType> type=Structural (game.rules.start.forEach.ForEachStartValueType) => <forEachStartValueType>, pack=game.rules.start.forEach, label=forEachStartValueType, cls=game.rules.start.forEach.ForEachStartValueType, keyword=forEachStartValueType
~~~~ <placeItem> type=SubLudeme (game.rules.start.place.item.PlaceItem) => <placeItem>, pack=game.rules.start.place.item, label=placeItem, cls=game.rules.start.place.item.PlaceItem, keyword=placeItem
gd~~ <place> type=SuperLudeme (game.rules.start.place.Place) => <place>, pack=game.rules.start.place, label=place, cls=game.rules.start.place.Place, keyword=place
~~~~ <placeRandomType> type=Structural (game.rules.start.place.PlaceRandomType) => <placeRandomType>, pack=game.rules.start.place, label=placeRandomType, cls=game.rules.start.place.PlaceRandomType, keyword=placeRandomType
~~~~ <placeMonotonousStack> type=SubLudeme (game.rules.start.place.stack.PlaceMonotonousStack) => <placeMonotonousStack>, pack=game.rules.start.place.stack, label=placeMonotonousStack, cls=game.rules.start.place.stack.PlaceMonotonousStack, keyword=placeMonotonousStack
~~~~ <placeCustomStack> type=SubLudeme (game.rules.start.place.stack.PlaceCustomStack) => <placeCustomStack>, pack=game.rules.start.place.stack, label=placeCustomStack, cls=game.rules.start.place.stack.PlaceCustomStack, keyword=placeCustomStack
~~~~ <placeStackType> type=Structural (game.rules.start.place.PlaceStackType) => <placeStackType>, pack=game.rules.start.place, label=placeStackType, cls=game.rules.start.place.PlaceStackType, keyword=placeStackType
~~~~ <placeRandom> type=SubLudeme (game.rules.start.place.random.PlaceRandom) => <placeRandom>, pack=game.rules.start.place.random, label=placeRandom, cls=game.rules.start.place.random.PlaceRandom, keyword=placeRandom
gd~~ <deductionPuzzle.set> type=Ludeme (game.rules.start.deductionPuzzle.Set) => <deductionPuzzle.set>, pack=game.rules.start.deductionPuzzle, label=deductionPuzzle.set, cls=game.rules.start.deductionPuzzle.Set, keyword=set
gd~~ <split> type=Ludeme (game.rules.start.split.Split) => <split>, pack=game.rules.start.split, label=split, cls=game.rules.start.split.Split, keyword=split
~~~~ <splitType> type=Structural (game.rules.start.split.SplitType) => <splitType>, pack=game.rules.start.split, label=splitType, cls=game.rules.start.split.SplitType, keyword=splitType
gd~~ <meta> type=Ludeme (game.rules.meta.Meta) => <meta>, pack=game.rules.meta, label=meta, cls=game.rules.meta.Meta, keyword=meta
gd~~ <gravity> type=Ludeme (game.rules.meta.Gravity) => <gravity>, pack=game.rules.meta, label=gravity, cls=game.rules.meta.Gravity, keyword=gravity
gd~~ <meta.swap> type=Ludeme (game.rules.meta.Swap) => <meta.swap>, pack=game.rules.meta, label=meta.swap, cls=game.rules.meta.Swap, keyword=swap
gd~~ <passEnd> type=Ludeme (game.rules.meta.PassEnd) => <passEnd>, pack=game.rules.meta, label=passEnd, cls=game.rules.meta.PassEnd, keyword=passEnd
gd~~ <noRepeat> type=Ludeme (game.rules.meta.NoRepeat) => <noRepeat>, pack=game.rules.meta, label=noRepeat, cls=game.rules.meta.NoRepeat, keyword=noRepeat
gd~~ <pin> type=Ludeme (game.rules.meta.Pin) => <pin>, pack=game.rules.meta, label=pin, cls=game.rules.meta.Pin, keyword=pin
gd~~ <automove> type=Ludeme (game.rules.meta.Automove) => <automove>, pack=game.rules.meta, label=automove, cls=game.rules.meta.Automove, keyword=automove
g~~* <metaRule> type=Structural (game.rules.meta.MetaRule) => <metaRule>, pack=game.rules.meta, label=metaRule, cls=game.rules.meta.MetaRule, keyword=metaRule
gd~~ <phase.phase> type=Ludeme (game.rules.phase.Phase) => <phase.phase>, pack=game.rules.phase, label=phase.phase, cls=game.rules.phase.Phase, keyword=phase
gd~~ <nextPhase> type=Ludeme (game.rules.phase.NextPhase) => <int>, pack=game.rules.phase, label=nextPhase, cls=game.rules.phase.NextPhase, keyword=nextPhase
gd~~ <play> type=Ludeme (game.rules.play.Play) => <play>, pack=game.rules.play, label=play, cls=game.rules.play.Play, keyword=play
g~~* <moves> type=Structural (game.rules.play.moves.Moves) => <moves>, pack=game.rules.play.moves, label=moves, cls=game.rules.play.moves.Moves, keyword=moves
~~~~ <baseMoves> type=Ludeme (game.rules.play.moves.BaseMoves) => <moves>, pack=game.rules.play.moves, label=baseMoves, cls=game.rules.play.moves.BaseMoves, keyword=baseMoves
~~~~ <moveLeapType> type=Structural (game.rules.play.moves.decision.MoveLeapType) => <moveLeapType>, pack=game.rules.play.moves.decision, label=moveLeapType, cls=game.rules.play.moves.decision.MoveLeapType, keyword=moveLeapType
~~~~ <moveBetType> type=Structural (game.rules.play.moves.decision.MoveBetType) => <moveBetType>, pack=game.rules.play.moves.decision, label=moveBetType, cls=game.rules.play.moves.decision.MoveBetType, keyword=moveBetType
~~~~ <moveSlideType> type=Structural (game.rules.play.moves.decision.MoveSlideType) => <moveSlideType>, pack=game.rules.play.moves.decision, label=moveSlideType, cls=game.rules.play.moves.decision.MoveSlideType, keyword=moveSlideType
gd~~ <move> type=SuperLudeme (game.rules.play.moves.decision.Move) => <moves>, pack=game.rules.play.moves.decision, label=move, cls=game.rules.play.moves.decision.Move, keyword=move
g~~~ <moveSimpleType> type=Structural (game.rules.play.moves.decision.MoveSimpleType) => <moveSimpleType>, pack=game.rules.play.moves.decision, label=moveSimpleType, cls=game.rules.play.moves.decision.MoveSimpleType, keyword=moveSimpleType
~~~~ <moveFromToType> type=Structural (game.rules.play.moves.decision.MoveFromToType) => <moveFromToType>, pack=game.rules.play.moves.decision, label=moveFromToType, cls=game.rules.play.moves.decision.MoveFromToType, keyword=moveFromToType
~~~~ <movePromoteType> type=Structural (game.rules.play.moves.decision.MovePromoteType) => <movePromoteType>, pack=game.rules.play.moves.decision, label=movePromoteType, cls=game.rules.play.moves.decision.MovePromoteType, keyword=movePromoteType
g~~~ <moveMessageType> type=Structural (game.rules.play.moves.decision.MoveMessageType) => <moveMessageType>, pack=game.rules.play.moves.decision, label=moveMessageType, cls=game.rules.play.moves.decision.MoveMessageType, keyword=moveMessageType
~~~~ <moveSetType> type=Structural (game.rules.play.moves.decision.MoveSetType) => <moveSetType>, pack=game.rules.play.moves.decision, label=moveSetType, cls=game.rules.play.moves.decision.MoveSetType, keyword=moveSetType
~~~~ <moveSelectType> type=Structural (game.rules.play.moves.decision.MoveSelectType) => <moveSelectType>, pack=game.rules.play.moves.decision, label=moveSelectType, cls=game.rules.play.moves.decision.MoveSelectType, keyword=moveSelectType
~~~~ <moveStepType> type=Structural (game.rules.play.moves.decision.MoveStepType) => <moveStepType>, pack=game.rules.play.moves.decision, label=moveStepType, cls=game.rules.play.moves.decision.MoveStepType, keyword=moveStepType
~~~~ <moveSwapType> type=Structural (game.rules.play.moves.decision.MoveSwapType) => <moveSwapType>, pack=game.rules.play.moves.decision, label=moveSwapType, cls=game.rules.play.moves.decision.MoveSwapType, keyword=moveSwapType
g~~~ <moveSiteType> type=Structural (game.rules.play.moves.decision.MoveSiteType) => <moveSiteType>, pack=game.rules.play.moves.decision, label=moveSiteType, cls=game.rules.play.moves.decision.MoveSiteType, keyword=moveSiteType
~~~~ <moveRemoveType> type=Structural (game.rules.play.moves.decision.MoveRemoveType) => <moveRemoveType>, pack=game.rules.play.moves.decision, label=moveRemoveType, cls=game.rules.play.moves.decision.MoveRemoveType, keyword=moveRemoveType
g~~* <decision> type=Structural (game.rules.play.moves.decision.Decision) => <moves>, pack=game.rules.play.moves.decision, label=decision, cls=game.rules.play.moves.decision.Decision, keyword=decision
~~~~ <moveHopType> type=Structural (game.rules.play.moves.decision.MoveHopType) => <moveHopType>, pack=game.rules.play.moves.decision, label=moveHopType, cls=game.rules.play.moves.decision.MoveHopType, keyword=moveHopType
~~~~ <moveShootType> type=Structural (game.rules.play.moves.decision.MoveShootType) => <moveShootType>, pack=game.rules.play.moves.decision, label=moveShootType, cls=game.rules.play.moves.decision.MoveShootType, keyword=moveShootType
g~~* <operator> type=Structural (game.rules.play.moves.nonDecision.operator.Operator) => <moves>, pack=game.rules.play.moves.nonDecision.operator, label=operator, cls=game.rules.play.moves.nonDecision.operator.Operator, keyword=operator
g~~* <nonDecision> type=Structural (game.rules.play.moves.nonDecision.NonDecision) => <moves>, pack=game.rules.play.moves.nonDecision, label=nonDecision, cls=game.rules.play.moves.nonDecision.NonDecision, keyword=nonDecision
gd~~ <apply> type=Ludeme (game.rules.play.moves.nonDecision.effect.Apply) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=apply, cls=game.rules.play.moves.nonDecision.effect.Apply, keyword=apply
gd~~ <surround> type=Ludeme (game.rules.play.moves.nonDecision.effect.Surround) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=surround, cls=game.rules.play.moves.nonDecision.effect.Surround, keyword=surround
gd~~ <slide> type=Ludeme (game.rules.play.moves.nonDecision.effect.Slide) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=slide, cls=game.rules.play.moves.nonDecision.effect.Slide, keyword=slide
~~~~ <setNextPlayerType> type=Structural (game.rules.play.moves.nonDecision.effect.set.SetNextPlayerType) => <setNextPlayerType>, pack=game.rules.play.moves.nonDecision.effect.set, label=setNextPlayerType, cls=game.rules.play.moves.nonDecision.effect.set.SetNextPlayerType, keyword=setNextPlayerType
~~~~ <setTeamType> type=Structural (game.rules.play.moves.nonDecision.effect.set.SetTeamType) => <setTeamType>, pack=game.rules.play.moves.nonDecision.effect.set, label=setTeamType, cls=game.rules.play.moves.nonDecision.effect.set.SetTeamType, keyword=setTeamType
g~~~ <setPlayerType> type=Structural (game.rules.play.moves.nonDecision.effect.set.SetPlayerType) => <setPlayerType>, pack=game.rules.play.moves.nonDecision.effect.set, label=setPlayerType, cls=game.rules.play.moves.nonDecision.effect.set.SetPlayerType, keyword=setPlayerType
~~~~ <setPendingType> type=Structural (game.rules.play.moves.nonDecision.effect.set.SetPendingType) => <setPendingType>, pack=game.rules.play.moves.nonDecision.effect.set, label=setPendingType, cls=game.rules.play.moves.nonDecision.effect.set.SetPendingType, keyword=setPendingType
~~~~ <setVar> type=SubLudeme (game.rules.play.moves.nonDecision.effect.set.var.SetVar) => <moves>, pack=game.rules.play.moves.nonDecision.effect.set.var, label=setVar, cls=game.rules.play.moves.nonDecision.effect.set.var.SetVar, keyword=setVar
~~~~ <setRotation> type=SubLudeme (game.rules.play.moves.nonDecision.effect.set.direction.SetRotation) => <moves>, pack=game.rules.play.moves.nonDecision.effect.set.direction, label=setRotation, cls=game.rules.play.moves.nonDecision.effect.set.direction.SetRotation, keyword=setRotation
g~~~ <setSiteType> type=Structural (game.rules.play.moves.nonDecision.effect.set.SetSiteType) => <setSiteType>, pack=game.rules.play.moves.nonDecision.effect.set, label=setSiteType, cls=game.rules.play.moves.nonDecision.effect.set.SetSiteType, keyword=setSiteType
~~~~ <setVarType> type=Structural (game.rules.play.moves.nonDecision.effect.set.SetVarType) => <setVarType>, pack=game.rules.play.moves.nonDecision.effect.set, label=setVarType, cls=game.rules.play.moves.nonDecision.effect.set.SetVarType, keyword=setVarType
~~~~ <setState> type=SubLudeme (game.rules.play.moves.nonDecision.effect.set.site.SetState) => <moves>, pack=game.rules.play.moves.nonDecision.effect.set.site, label=setState, cls=game.rules.play.moves.nonDecision.effect.set.site.SetState, keyword=setState
~~~~ <setValue> type=SubLudeme (game.rules.play.moves.nonDecision.effect.set.site.SetValue) => <moves>, pack=game.rules.play.moves.nonDecision.effect.set.site, label=setValue, cls=game.rules.play.moves.nonDecision.effect.set.site.SetValue, keyword=setValue
~~~~ <site.setCount> type=SubLudeme (game.rules.play.moves.nonDecision.effect.set.site.SetCount) => <moves>, pack=game.rules.play.moves.nonDecision.effect.set.site, label=site.setCount, cls=game.rules.play.moves.nonDecision.effect.set.site.SetCount, keyword=setCount
~~~~ <effect.set.player.setScore> type=SubLudeme (game.rules.play.moves.nonDecision.effect.set.player.SetScore) => <moves>, pack=game.rules.play.moves.nonDecision.effect.set.player, label=effect.set.player.setScore, cls=game.rules.play.moves.nonDecision.effect.set.player.SetScore, keyword=setScore
~~~~ <setValuePlayer> type=SubLudeme (game.rules.play.moves.nonDecision.effect.set.player.SetValuePlayer) => <moves>, pack=game.rules.play.moves.nonDecision.effect.set.player, label=setValuePlayer, cls=game.rules.play.moves.nonDecision.effect.set.player.SetValuePlayer, keyword=setValuePlayer
~~~~ <setTrumpSuit> type=SubLudeme (game.rules.play.moves.nonDecision.effect.set.suit.SetTrumpSuit) => <moves>, pack=game.rules.play.moves.nonDecision.effect.set.suit, label=setTrumpSuit, cls=game.rules.play.moves.nonDecision.effect.set.suit.SetTrumpSuit, keyword=setTrumpSuit
~~~~ <setPot> type=SubLudeme (game.rules.play.moves.nonDecision.effect.set.value.SetPot) => <moves>, pack=game.rules.play.moves.nonDecision.effect.set.value, label=setPot, cls=game.rules.play.moves.nonDecision.effect.set.value.SetPot, keyword=setPot
~~~~ <setCounter> type=SubLudeme (game.rules.play.moves.nonDecision.effect.set.value.SetCounter) => <moves>, pack=game.rules.play.moves.nonDecision.effect.set.value, label=setCounter, cls=game.rules.play.moves.nonDecision.effect.set.value.SetCounter, keyword=setCounter
~~~~ <setHiddenType> type=Structural (game.rules.play.moves.nonDecision.effect.set.SetHiddenType) => <setHiddenType>, pack=game.rules.play.moves.nonDecision.effect.set, label=setHiddenType, cls=game.rules.play.moves.nonDecision.effect.set.SetHiddenType, keyword=setHiddenType
gd~~ <effect.set.set> type=SuperLudeme (game.rules.play.moves.nonDecision.effect.set.Set) => <moves>, pack=game.rules.play.moves.nonDecision.effect.set, label=effect.set.set, cls=game.rules.play.moves.nonDecision.effect.set.Set, keyword=set
g~~~ <setValueType> type=Structural (game.rules.play.moves.nonDecision.effect.set.SetValueType) => <setValueType>, pack=game.rules.play.moves.nonDecision.effect.set, label=setValueType, cls=game.rules.play.moves.nonDecision.effect.set.SetValueType, keyword=setValueType
~~~~ <setTrumpType> type=Structural (game.rules.play.moves.nonDecision.effect.set.SetTrumpType) => <setTrumpType>, pack=game.rules.play.moves.nonDecision.effect.set, label=setTrumpType, cls=game.rules.play.moves.nonDecision.effect.set.SetTrumpType, keyword=setTrumpType
~~~~ <setNextPlayer> type=SubLudeme (game.rules.play.moves.nonDecision.effect.set.nextPlayer.SetNextPlayer) => <moves>, pack=game.rules.play.moves.nonDecision.effect.set.nextPlayer, label=setNextPlayer, cls=game.rules.play.moves.nonDecision.effect.set.nextPlayer.SetNextPlayer, keyword=setNextPlayer
~~~~ <effect.set.hidden.setHidden> type=SubLudeme (game.rules.play.moves.nonDecision.effect.set.hidden.SetHidden) => <moves>, pack=game.rules.play.moves.nonDecision.effect.set.hidden, label=effect.set.hidden.setHidden, cls=game.rules.play.moves.nonDecision.effect.set.hidden.SetHidden, keyword=setHidden
~~~~ <team.setTeam> type=SubLudeme (game.rules.play.moves.nonDecision.effect.set.team.SetTeam) => <moves>, pack=game.rules.play.moves.nonDecision.effect.set.team, label=team.setTeam, cls=game.rules.play.moves.nonDecision.effect.set.team.SetTeam, keyword=setTeam
~~~~ <setRotationType> type=Structural (game.rules.play.moves.nonDecision.effect.set.SetRotationType) => <setRotationType>, pack=game.rules.play.moves.nonDecision.effect.set, label=setRotationType, cls=game.rules.play.moves.nonDecision.effect.set.SetRotationType, keyword=setRotationType
~~~~ <setPending> type=SubLudeme (game.rules.play.moves.nonDecision.effect.set.pending.SetPending) => <moves>, pack=game.rules.play.moves.nonDecision.effect.set.pending, label=setPending, cls=game.rules.play.moves.nonDecision.effect.set.pending.SetPending, keyword=setPending
gd~~ <leap> type=Ludeme (game.rules.play.moves.nonDecision.effect.Leap) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=leap, cls=game.rules.play.moves.nonDecision.effect.Leap, keyword=leap
gd~~ <while> type=Ludeme (game.rules.play.moves.nonDecision.effect.requirement.While) => <moves>, pack=game.rules.play.moves.nonDecision.effect.requirement, label=while, cls=game.rules.play.moves.nonDecision.effect.requirement.While, keyword=while
gd~~ <avoidStoredState> type=Ludeme (game.rules.play.moves.nonDecision.effect.requirement.AvoidStoredState) => <moves>, pack=game.rules.play.moves.nonDecision.effect.requirement, label=avoidStoredState, cls=game.rules.play.moves.nonDecision.effect.requirement.AvoidStoredState, keyword=avoidStoredState
gd~~ <firstMoveOnTrack> type=Ludeme (game.rules.play.moves.nonDecision.effect.requirement.FirstMoveOnTrack) => <moves>, pack=game.rules.play.moves.nonDecision.effect.requirement, label=firstMoveOnTrack, cls=game.rules.play.moves.nonDecision.effect.requirement.FirstMoveOnTrack, keyword=firstMoveOnTrack
gd~~ <priority> type=Ludeme (game.rules.play.moves.nonDecision.effect.requirement.Priority) => <moves>, pack=game.rules.play.moves.nonDecision.effect.requirement, label=priority, cls=game.rules.play.moves.nonDecision.effect.requirement.Priority, keyword=priority
~~~~ <maxCaptures> type=SubLudeme (game.rules.play.moves.nonDecision.effect.requirement.max.moves.MaxCaptures) => <moves>, pack=game.rules.play.moves.nonDecision.effect.requirement.max.moves, label=maxCaptures, cls=game.rules.play.moves.nonDecision.effect.requirement.max.moves.MaxCaptures, keyword=maxCaptures
~~~~ <maxMoves> type=SubLudeme (game.rules.play.moves.nonDecision.effect.requirement.max.moves.MaxMoves) => <moves>, pack=game.rules.play.moves.nonDecision.effect.requirement.max.moves, label=maxMoves, cls=game.rules.play.moves.nonDecision.effect.requirement.max.moves.MaxMoves, keyword=maxMoves
~~~~ <maxDistance> type=SubLudeme (game.rules.play.moves.nonDecision.effect.requirement.max.distance.MaxDistance) => <moves>, pack=game.rules.play.moves.nonDecision.effect.requirement.max.distance, label=maxDistance, cls=game.rules.play.moves.nonDecision.effect.requirement.max.distance.MaxDistance, keyword=maxDistance
g~~~ <maxMovesType> type=Structural (game.rules.play.moves.nonDecision.effect.requirement.max.MaxMovesType) => <maxMovesType>, pack=game.rules.play.moves.nonDecision.effect.requirement.max, label=maxMovesType, cls=game.rules.play.moves.nonDecision.effect.requirement.max.MaxMovesType, keyword=maxMovesType
gd~~ <max.max> type=SuperLudeme (game.rules.play.moves.nonDecision.effect.requirement.max.Max) => <moves>, pack=game.rules.play.moves.nonDecision.effect.requirement.max, label=max.max, cls=game.rules.play.moves.nonDecision.effect.requirement.max.Max, keyword=max
~~~~ <maxDistanceType> type=Structural (game.rules.play.moves.nonDecision.effect.requirement.max.MaxDistanceType) => <maxDistanceType>, pack=game.rules.play.moves.nonDecision.effect.requirement.max, label=maxDistanceType, cls=game.rules.play.moves.nonDecision.effect.requirement.max.MaxDistanceType, keyword=maxDistanceType
gd~~ <do> type=Ludeme (game.rules.play.moves.nonDecision.effect.requirement.Do) => <moves>, pack=game.rules.play.moves.nonDecision.effect.requirement, label=do, cls=game.rules.play.moves.nonDecision.effect.requirement.Do, keyword=do
gd~~ <custodial> type=Ludeme (game.rules.play.moves.nonDecision.effect.Custodial) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=custodial, cls=game.rules.play.moves.nonDecision.effect.Custodial, keyword=custodial
gd~~ <effect.remove> type=Ludeme (game.rules.play.moves.nonDecision.effect.Remove) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=effect.remove, cls=game.rules.play.moves.nonDecision.effect.Remove, keyword=remove
gd~~ <then> type=Ludeme (game.rules.play.moves.nonDecision.effect.Then) => <then>, pack=game.rules.play.moves.nonDecision.effect, label=then, cls=game.rules.play.moves.nonDecision.effect.Then, keyword=then
gd~~ <trigger> type=Ludeme (game.rules.play.moves.nonDecision.effect.Trigger) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=trigger, cls=game.rules.play.moves.nonDecision.effect.Trigger, keyword=trigger
gd~~ <fromTo> type=Ludeme (game.rules.play.moves.nonDecision.effect.FromTo) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=fromTo, cls=game.rules.play.moves.nonDecision.effect.FromTo, keyword=fromTo
gd~~ <push> type=Ludeme (game.rules.play.moves.nonDecision.effect.Push) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=push, cls=game.rules.play.moves.nonDecision.effect.Push, keyword=push
gd~~ <sow> type=Ludeme (game.rules.play.moves.nonDecision.effect.Sow) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=sow, cls=game.rules.play.moves.nonDecision.effect.Sow, keyword=sow
gd~~ <enclose> type=Ludeme (game.rules.play.moves.nonDecision.effect.Enclose) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=enclose, cls=game.rules.play.moves.nonDecision.effect.Enclose, keyword=enclose
gd~~ <effect.add> type=Ludeme (game.rules.play.moves.nonDecision.effect.Add) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=effect.add, cls=game.rules.play.moves.nonDecision.effect.Add, keyword=add
gd~~ <bet> type=Ludeme (game.rules.play.moves.nonDecision.effect.Bet) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=bet, cls=game.rules.play.moves.nonDecision.effect.Bet, keyword=bet
gd~~ <effect.deal> type=Ludeme (game.rules.play.moves.nonDecision.effect.Deal) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=effect.deal, cls=game.rules.play.moves.nonDecision.effect.Deal, keyword=deal
gd~~ <directionCapture> type=Ludeme (game.rules.play.moves.nonDecision.effect.DirectionCapture) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=directionCapture, cls=game.rules.play.moves.nonDecision.effect.DirectionCapture, keyword=directionCapture
gd~~ <forget> type=SuperLudeme (game.rules.play.moves.nonDecision.effect.state.forget.Forget) => <moves>, pack=game.rules.play.moves.nonDecision.effect.state.forget, label=forget, cls=game.rules.play.moves.nonDecision.effect.state.forget.Forget, keyword=forget
~~~~ <forgetValueType> type=Structural (game.rules.play.moves.nonDecision.effect.state.forget.ForgetValueType) => <forgetValueType>, pack=game.rules.play.moves.nonDecision.effect.state.forget, label=forgetValueType, cls=game.rules.play.moves.nonDecision.effect.state.forget.ForgetValueType, keyword=forgetValueType
~~~~ <forgetValue> type=SubLudeme (game.rules.play.moves.nonDecision.effect.state.forget.value.ForgetValue) => <moves>, pack=game.rules.play.moves.nonDecision.effect.state.forget.value, label=forgetValue, cls=game.rules.play.moves.nonDecision.effect.state.forget.value.ForgetValue, keyword=forgetValue
~~~~ <forgetValueAll> type=SubLudeme (game.rules.play.moves.nonDecision.effect.state.forget.value.ForgetValueAll) => <moves>, pack=game.rules.play.moves.nonDecision.effect.state.forget.value, label=forgetValueAll, cls=game.rules.play.moves.nonDecision.effect.state.forget.value.ForgetValueAll, keyword=forgetValueAll
~~~~ <forgetValueAllType> type=Structural (game.rules.play.moves.nonDecision.effect.state.forget.ForgetValueAllType) => <forgetValueAllType>, pack=game.rules.play.moves.nonDecision.effect.state.forget, label=forgetValueAllType, cls=game.rules.play.moves.nonDecision.effect.state.forget.ForgetValueAllType, keyword=forgetValueAllType
gd~~ <moveAgain> type=Ludeme (game.rules.play.moves.nonDecision.effect.state.MoveAgain) => <moves>, pack=game.rules.play.moves.nonDecision.effect.state, label=moveAgain, cls=game.rules.play.moves.nonDecision.effect.state.MoveAgain, keyword=moveAgain
~~~~ <swapPlayersType> type=Structural (game.rules.play.moves.nonDecision.effect.state.swap.SwapPlayersType) => <swapPlayersType>, pack=game.rules.play.moves.nonDecision.effect.state.swap, label=swapPlayersType, cls=game.rules.play.moves.nonDecision.effect.state.swap.SwapPlayersType, keyword=swapPlayersType
gd~~ <swap.swap> type=SuperLudeme (game.rules.play.moves.nonDecision.effect.state.swap.Swap) => <moves>, pack=game.rules.play.moves.nonDecision.effect.state.swap, label=swap.swap, cls=game.rules.play.moves.nonDecision.effect.state.swap.Swap, keyword=swap
~~~~ <swapPieces> type=SubLudeme (game.rules.play.moves.nonDecision.effect.state.swap.sites.SwapPieces) => <moves>, pack=game.rules.play.moves.nonDecision.effect.state.swap.sites, label=swapPieces, cls=game.rules.play.moves.nonDecision.effect.state.swap.sites.SwapPieces, keyword=swapPieces
~~~~ <swapPlayers> type=SubLudeme (game.rules.play.moves.nonDecision.effect.state.swap.players.SwapPlayers) => <moves>, pack=game.rules.play.moves.nonDecision.effect.state.swap.players, label=swapPlayers, cls=game.rules.play.moves.nonDecision.effect.state.swap.players.SwapPlayers, keyword=swapPlayers
~~~~ <swapSitesType> type=Structural (game.rules.play.moves.nonDecision.effect.state.swap.SwapSitesType) => <swapSitesType>, pack=game.rules.play.moves.nonDecision.effect.state.swap, label=swapSitesType, cls=game.rules.play.moves.nonDecision.effect.state.swap.SwapSitesType, keyword=swapSitesType
gd~~ <addScore> type=Ludeme (game.rules.play.moves.nonDecision.effect.state.AddScore) => <moves>, pack=game.rules.play.moves.nonDecision.effect.state, label=addScore, cls=game.rules.play.moves.nonDecision.effect.state.AddScore, keyword=addScore
~~~~ <rememberStateType> type=Structural (game.rules.play.moves.nonDecision.effect.state.remember.RememberStateType) => <rememberStateType>, pack=game.rules.play.moves.nonDecision.effect.state.remember, label=rememberStateType, cls=game.rules.play.moves.nonDecision.effect.state.remember.RememberStateType, keyword=rememberStateType
~~~~ <rememberValue> type=SubLudeme (game.rules.play.moves.nonDecision.effect.state.remember.value.RememberValue) => <moves>, pack=game.rules.play.moves.nonDecision.effect.state.remember.value, label=rememberValue, cls=game.rules.play.moves.nonDecision.effect.state.remember.value.RememberValue, keyword=rememberValue
~~~~ <rememberValueType> type=Structural (game.rules.play.moves.nonDecision.effect.state.remember.RememberValueType) => <rememberValueType>, pack=game.rules.play.moves.nonDecision.effect.state.remember, label=rememberValueType, cls=game.rules.play.moves.nonDecision.effect.state.remember.RememberValueType, keyword=rememberValueType
~~~~ <rememberState> type=SubLudeme (game.rules.play.moves.nonDecision.effect.state.remember.state.RememberState) => <moves>, pack=game.rules.play.moves.nonDecision.effect.state.remember.state, label=rememberState, cls=game.rules.play.moves.nonDecision.effect.state.remember.state.RememberState, keyword=rememberState
gd~~ <remember> type=SuperLudeme (game.rules.play.moves.nonDecision.effect.state.remember.Remember) => <moves>, pack=game.rules.play.moves.nonDecision.effect.state.remember, label=remember, cls=game.rules.play.moves.nonDecision.effect.state.remember.Remember, keyword=remember
gd~~ <claim> type=Ludeme (game.rules.play.moves.nonDecision.effect.Claim) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=claim, cls=game.rules.play.moves.nonDecision.effect.Claim, keyword=claim
gd~~ <flip> type=Ludeme (game.rules.play.moves.nonDecision.effect.Flip) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=flip, cls=game.rules.play.moves.nonDecision.effect.Flip, keyword=flip
~~~~ <takeDomino> type=SubLudeme (game.rules.play.moves.nonDecision.effect.take.simple.TakeDomino) => <moves>, pack=game.rules.play.moves.nonDecision.effect.take.simple, label=takeDomino, cls=game.rules.play.moves.nonDecision.effect.take.simple.TakeDomino, keyword=takeDomino
gd~~ <take> type=SuperLudeme (game.rules.play.moves.nonDecision.effect.take.Take) => <moves>, pack=game.rules.play.moves.nonDecision.effect.take, label=take, cls=game.rules.play.moves.nonDecision.effect.take.Take, keyword=take
~~~~ <takeControlType> type=Structural (game.rules.play.moves.nonDecision.effect.take.TakeControlType) => <takeControlType>, pack=game.rules.play.moves.nonDecision.effect.take, label=takeControlType, cls=game.rules.play.moves.nonDecision.effect.take.TakeControlType, keyword=takeControlType
~~~~ <takeControl> type=SubLudeme (game.rules.play.moves.nonDecision.effect.take.control.TakeControl) => <moves>, pack=game.rules.play.moves.nonDecision.effect.take.control, label=takeControl, cls=game.rules.play.moves.nonDecision.effect.take.control.TakeControl, keyword=takeControl
~~~~ <takeSimpleType> type=Structural (game.rules.play.moves.nonDecision.effect.take.TakeSimpleType) => <takeSimpleType>, pack=game.rules.play.moves.nonDecision.effect.take, label=takeSimpleType, cls=game.rules.play.moves.nonDecision.effect.take.TakeSimpleType, keyword=takeSimpleType
gd~~ <note> type=Ludeme (game.rules.play.moves.nonDecision.effect.Note) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=note, cls=game.rules.play.moves.nonDecision.effect.Note, keyword=note
gd~~ <vote> type=Ludeme (game.rules.play.moves.nonDecision.effect.Vote) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=vote, cls=game.rules.play.moves.nonDecision.effect.Vote, keyword=vote
gd~~ <effect.step> type=Ludeme (game.rules.play.moves.nonDecision.effect.Step) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=effect.step, cls=game.rules.play.moves.nonDecision.effect.Step, keyword=step
gd~~ <satisfy> type=Ludeme (game.rules.play.moves.nonDecision.effect.Satisfy) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=satisfy, cls=game.rules.play.moves.nonDecision.effect.Satisfy, keyword=satisfy
gd~~ <random> type=Ludeme (game.rules.play.moves.nonDecision.effect.Random) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=random, cls=game.rules.play.moves.nonDecision.effect.Random, keyword=random
gd~~ <roll> type=Ludeme (game.rules.play.moves.nonDecision.effect.Roll) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=roll, cls=game.rules.play.moves.nonDecision.effect.Roll, keyword=roll
gd~~ <playCard> type=Ludeme (game.rules.play.moves.nonDecision.effect.PlayCard) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=playCard, cls=game.rules.play.moves.nonDecision.effect.PlayCard, keyword=playCard
gd~~ <select> type=Ludeme (game.rules.play.moves.nonDecision.effect.Select) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=select, cls=game.rules.play.moves.nonDecision.effect.Select, keyword=select
gd~~ <intervene> type=Ludeme (game.rules.play.moves.nonDecision.effect.Intervene) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=intervene, cls=game.rules.play.moves.nonDecision.effect.Intervene, keyword=intervene
gd~~ <promote> type=Ludeme (game.rules.play.moves.nonDecision.effect.Promote) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=promote, cls=game.rules.play.moves.nonDecision.effect.Promote, keyword=promote
gd~~ <attract> type=Ludeme (game.rules.play.moves.nonDecision.effect.Attract) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=attract, cls=game.rules.play.moves.nonDecision.effect.Attract, keyword=attract
g~~* <effect> type=Structural (game.rules.play.moves.nonDecision.effect.Effect) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=effect, cls=game.rules.play.moves.nonDecision.effect.Effect, keyword=effect
gd~~ <hop> type=Ludeme (game.rules.play.moves.nonDecision.effect.Hop) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=hop, cls=game.rules.play.moves.nonDecision.effect.Hop, keyword=hop
gd~~ <propose> type=Ludeme (game.rules.play.moves.nonDecision.effect.Propose) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=propose, cls=game.rules.play.moves.nonDecision.effect.Propose, keyword=propose
gd~~ <pass> type=Ludeme (game.rules.play.moves.nonDecision.effect.Pass) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=pass, cls=game.rules.play.moves.nonDecision.effect.Pass, keyword=pass
gd~~ <shoot> type=Ludeme (game.rules.play.moves.nonDecision.effect.Shoot) => <moves>, pack=game.rules.play.moves.nonDecision.effect, label=shoot, cls=game.rules.play.moves.nonDecision.effect.Shoot, keyword=shoot
~~~~ <forEachPiece> type=SubLudeme (game.rules.play.moves.nonDecision.operators.foreach.piece.ForEachPiece) => <moves>, pack=game.rules.play.moves.nonDecision.operators.foreach.piece, label=forEachPiece, cls=game.rules.play.moves.nonDecision.operators.foreach.piece.ForEachPiece, keyword=forEachPiece
~~~~ <forEachDirection> type=SubLudeme (game.rules.play.moves.nonDecision.operators.foreach.direction.ForEachDirection) => <moves>, pack=game.rules.play.moves.nonDecision.operators.foreach.direction, label=forEachDirection, cls=game.rules.play.moves.nonDecision.operators.foreach.direction.ForEachDirection, keyword=forEachDirection
~~~~ <forEachSiteType> type=Structural (game.rules.play.moves.nonDecision.operators.foreach.ForEachSiteType) => <forEachSiteType>, pack=game.rules.play.moves.nonDecision.operators.foreach, label=forEachSiteType, cls=game.rules.play.moves.nonDecision.operators.foreach.ForEachSiteType, keyword=forEachSiteType
~~~~ <forEachDie> type=SubLudeme (game.rules.play.moves.nonDecision.operators.foreach.die.ForEachDie) => <moves>, pack=game.rules.play.moves.nonDecision.operators.foreach.die, label=forEachDie, cls=game.rules.play.moves.nonDecision.operators.foreach.die.ForEachDie, keyword=forEachDie
~~~~ <forEachPlayerType> type=Structural (game.rules.play.moves.nonDecision.operators.foreach.ForEachPlayerType) => <forEachPlayerType>, pack=game.rules.play.moves.nonDecision.operators.foreach, label=forEachPlayerType, cls=game.rules.play.moves.nonDecision.operators.foreach.ForEachPlayerType, keyword=forEachPlayerType
~~~~ <foreach.site.forEachSite> type=SubLudeme (game.rules.play.moves.nonDecision.operators.foreach.site.ForEachSite) => <moves>, pack=game.rules.play.moves.nonDecision.operators.foreach.site, label=foreach.site.forEachSite, cls=game.rules.play.moves.nonDecision.operators.foreach.site.ForEachSite, keyword=forEachSite
~~~~ <operators.foreach.player.forEachPlayer> type=SubLudeme (game.rules.play.moves.nonDecision.operators.foreach.player.ForEachPlayer) => <moves>, pack=game.rules.play.moves.nonDecision.operators.foreach.player, label=operators.foreach.player.forEachPlayer, cls=game.rules.play.moves.nonDecision.operators.foreach.player.ForEachPlayer, keyword=forEachPlayer
~~~~ <forEachGroup> type=SubLudeme (game.rules.play.moves.nonDecision.operators.foreach.group.ForEachGroup) => <moves>, pack=game.rules.play.moves.nonDecision.operators.foreach.group, label=forEachGroup, cls=game.rules.play.moves.nonDecision.operators.foreach.group.ForEachGroup, keyword=forEachGroup
~~~~ <foreach.value.forEachValue> type=SubLudeme (game.rules.play.moves.nonDecision.operators.foreach.value.ForEachValue) => <moves>, pack=game.rules.play.moves.nonDecision.operators.foreach.value, label=foreach.value.forEachValue, cls=game.rules.play.moves.nonDecision.operators.foreach.value.ForEachValue, keyword=forEachValue
~~~~ <forEachDirectionType> type=Structural (game.rules.play.moves.nonDecision.operators.foreach.ForEachDirectionType) => <forEachDirectionType>, pack=game.rules.play.moves.nonDecision.operators.foreach, label=forEachDirectionType, cls=game.rules.play.moves.nonDecision.operators.foreach.ForEachDirectionType, keyword=forEachDirectionType
~~~~ <forEachPieceType> type=Structural (game.rules.play.moves.nonDecision.operators.foreach.ForEachPieceType) => <forEachPieceType>, pack=game.rules.play.moves.nonDecision.operators.foreach, label=forEachPieceType, cls=game.rules.play.moves.nonDecision.operators.foreach.ForEachPieceType, keyword=forEachPieceType
~~~~ <forEachValueType> type=Structural (game.rules.play.moves.nonDecision.operators.foreach.ForEachValueType) => <forEachValueType>, pack=game.rules.play.moves.nonDecision.operators.foreach, label=forEachValueType, cls=game.rules.play.moves.nonDecision.operators.foreach.ForEachValueType, keyword=forEachValueType
~~~~ <forEachDieType> type=Structural (game.rules.play.moves.nonDecision.operators.foreach.ForEachDieType) => <forEachDieType>, pack=game.rules.play.moves.nonDecision.operators.foreach, label=forEachDieType, cls=game.rules.play.moves.nonDecision.operators.foreach.ForEachDieType, keyword=forEachDieType
gd~~ <operators.foreach.forEach> type=SuperLudeme (game.rules.play.moves.nonDecision.operators.foreach.ForEach) => <moves>, pack=game.rules.play.moves.nonDecision.operators.foreach, label=operators.foreach.forEach, cls=game.rules.play.moves.nonDecision.operators.foreach.ForEach, keyword=forEach
~~~~ <operators.foreach.team.forEachTeam> type=SubLudeme (game.rules.play.moves.nonDecision.operators.foreach.team.ForEachTeam) => <moves>, pack=game.rules.play.moves.nonDecision.operators.foreach.team, label=operators.foreach.team.forEachTeam, cls=game.rules.play.moves.nonDecision.operators.foreach.team.ForEachTeam, keyword=forEachTeam
~~~~ <forEachGroupType> type=Structural (game.rules.play.moves.nonDecision.operators.foreach.ForEachGroupType) => <forEachGroupType>, pack=game.rules.play.moves.nonDecision.operators.foreach, label=forEachGroupType, cls=game.rules.play.moves.nonDecision.operators.foreach.ForEachGroupType, keyword=forEachGroupType
gd~~ <append> type=Ludeme (game.rules.play.moves.nonDecision.operators.logical.Append) => <moves>, pack=game.rules.play.moves.nonDecision.operators.logical, label=append, cls=game.rules.play.moves.nonDecision.operators.logical.Append, keyword=append
gd~~ <allCombinations> type=Ludeme (game.rules.play.moves.nonDecision.operators.logical.AllCombinations) => <moves>, pack=game.rules.play.moves.nonDecision.operators.logical, label=allCombinations, cls=game.rules.play.moves.nonDecision.operators.logical.AllCombinations, keyword=allCombinations
gd~~ <logical.and> type=SuperLudeme (game.rules.play.moves.nonDecision.operators.logical.And) => <moves>, pack=game.rules.play.moves.nonDecision.operators.logical, label=logical.and, cls=game.rules.play.moves.nonDecision.operators.logical.And, keyword=and
gd~~ <logical.if> type=Ludeme (game.rules.play.moves.nonDecision.operators.logical.If) => <moves>, pack=game.rules.play.moves.nonDecision.operators.logical, label=logical.if, cls=game.rules.play.moves.nonDecision.operators.logical.If, keyword=if
gd~~ <logical.or> type=Ludeme (game.rules.play.moves.nonDecision.operators.logical.Or) => <moves>, pack=game.rules.play.moves.nonDecision.operators.logical, label=logical.or, cls=game.rules.play.moves.nonDecision.operators.logical.Or, keyword=or
gd~~ <rules.rules> type=Ludeme (game.rules.Rules) => <rules.rules>, pack=game.rules, label=rules.rules, cls=game.rules.Rules, keyword=rules
gd~~ <games> type=Ludeme (game.match.Games) => <games>, pack=game.match, label=games, cls=game.match.Games, keyword=games
gd~~ <subgame> type=Ludeme (game.match.Subgame) => <subgame>, pack=game.match, label=subgame, cls=game.match.Subgame, keyword=subgame
gd~~ <match> type=Ludeme (game.match.Match) => <match>, pack=game.match, label=match, cls=game.match.Match, keyword=match
g~~* <item> type=Structural (game.equipment.Item) => <item>, pack=game.equipment, label=item, cls=game.equipment.Item, keyword=item
gd~~ <equipment> type=Ludeme (game.equipment.Equipment) => <equipment>, pack=game.equipment, label=equipment, cls=game.equipment.Equipment, keyword=equipment
gd~~ <hints> type=Ludeme (game.equipment.other.Hints) => <hints>, pack=game.equipment.other, label=hints, cls=game.equipment.other.Hints, keyword=hints
gd~~ <map> type=Ludeme (game.equipment.other.Map) => <map>, pack=game.equipment.other, label=map, cls=game.equipment.other.Map, keyword=map
gd~~ <dominoes> type=Ludeme (game.equipment.other.Dominoes) => <dominoes>, pack=game.equipment.other, label=dominoes, cls=game.equipment.other.Dominoes, keyword=dominoes
gd~~ <regions> type=Ludeme (game.equipment.other.Regions) => <int>{<int>}, pack=game.equipment.other, label=regions, cls=game.equipment.other.Regions, keyword=regions
g~~* <container> type=Structural (game.equipment.container.Container) => <container>, pack=game.equipment.container, label=container, cls=game.equipment.container.Container, keyword=container
gd~~ <boardless> type=Ludeme (game.equipment.container.board.Boardless) => <boardless>, pack=game.equipment.container.board, label=boardless, cls=game.equipment.container.board.Boardless, keyword=boardless
gd~~ <container.board.board> type=Ludeme (game.equipment.container.board.Board) => <container.board.board>, pack=game.equipment.container.board, label=container.board.board, cls=game.equipment.container.board.Board, keyword=board
gd~~ <board.track> type=Ludeme (game.equipment.container.board.Track) => <board.track>, pack=game.equipment.container.board, label=board.track, cls=game.equipment.container.board.Track, keyword=track
gd~~ <surakartaBoard> type=Ludeme (game.equipment.container.board.custom.SurakartaBoard) => <surakartaBoard>, pack=game.equipment.container.board.custom, label=surakartaBoard, cls=game.equipment.container.board.custom.SurakartaBoard, keyword=surakartaBoard
gd~~ <mancalaBoard> type=Ludeme (game.equipment.container.board.custom.MancalaBoard) => <mancalaBoard>, pack=game.equipment.container.board.custom, label=mancalaBoard, cls=game.equipment.container.board.custom.MancalaBoard, keyword=mancalaBoard
gd~~ <other.hand> type=Ludeme (game.equipment.container.other.Hand) => <other.hand>, pack=game.equipment.container.other, label=other.hand, cls=game.equipment.container.other.Hand, keyword=hand
gd~~ <deck> type=Ludeme (game.equipment.container.other.Deck) => <deck>, pack=game.equipment.container.other, label=deck, cls=game.equipment.container.other.Deck, keyword=deck
gd~~ <dice> type=Ludeme (game.equipment.container.other.Dice) => <dice>, pack=game.equipment.container.other, label=dice, cls=game.equipment.container.other.Dice, keyword=dice
gd~~ <component.card> type=Ludeme (game.equipment.component.Card) => <component.card>, pack=game.equipment.component, label=component.card, cls=game.equipment.component.Card, keyword=card
gd~~ <component> type=Ludeme (game.equipment.component.Component) => <component>, pack=game.equipment.component, label=component, cls=game.equipment.component.Component, keyword=component
gd~~ <domino> type=Ludeme (game.equipment.component.tile.Domino) => <domino>, pack=game.equipment.component.tile, label=domino, cls=game.equipment.component.tile.Domino, keyword=domino
gd~~ <path> type=Ludeme (game.equipment.component.tile.Path) => <path>, pack=game.equipment.component.tile, label=path, cls=game.equipment.component.tile.Path, keyword=path
gd~~ <tile> type=Ludeme (game.equipment.component.tile.Tile) => <tile>, pack=game.equipment.component.tile, label=tile, cls=game.equipment.component.tile.Tile, keyword=tile
gd~~ <component.piece> type=Ludeme (game.equipment.component.Piece) => <component.piece>, pack=game.equipment.component, label=component.piece, cls=game.equipment.component.Piece, keyword=piece
gd~~ <die> type=Ludeme (game.equipment.component.Die) => <die>, pack=game.equipment.component, label=die, cls=game.equipment.component.Die, keyword=die
gd~~ <end.score> type=Ludeme (game.util.end.Score) => <end.score>, pack=game.util.end, label=end.score, cls=game.util.end.Score, keyword=score
gd~~ <payoff> type=Ludeme (game.util.end.Payoff) => <payoff>, pack=game.util.end, label=payoff, cls=game.util.end.Payoff, keyword=payoff
gd~~ <moves.player> type=Ludeme (game.util.moves.Player) => <moves.player>, pack=game.util.moves, label=moves.player, cls=game.util.moves.Player, keyword=player
gd~~ <moves.between> type=Ludeme (game.util.moves.Between) => <moves.between>, pack=game.util.moves, label=moves.between, cls=game.util.moves.Between, keyword=between
gd~~ <moves.to> type=Ludeme (game.util.moves.To) => <moves.to>, pack=game.util.moves, label=moves.to, cls=game.util.moves.To, keyword=to
gd~~ <flips> type=Ludeme (game.util.moves.Flips) => <flips>, pack=game.util.moves, label=flips, cls=game.util.moves.Flips, keyword=flips
gd~~ <moves.piece> type=Ludeme (game.util.moves.Piece) => <moves.piece>, pack=game.util.moves, label=moves.piece, cls=game.util.moves.Piece, keyword=piece
gd~~ <moves.from> type=Ludeme (game.util.moves.From) => <moves.from>, pack=game.util.moves, label=moves.from, cls=game.util.moves.From, keyword=from
~~~~ <radial> type=Ludeme (game.util.graph.Radial) => <radial>, pack=game.util.graph, label=radial, cls=game.util.graph.Radial, keyword=radial
~~~* <graphElement> type=Ludeme (game.util.graph.GraphElement) => <graphElement>, pack=game.util.graph, label=graphElement, cls=game.util.graph.GraphElement, keyword=graphElement
~~~~ <graph.face> type=Ludeme (game.util.graph.Face) => <graph.face>, pack=game.util.graph, label=graph.face, cls=game.util.graph.Face, keyword=face
~~~~ <radials> type=Ludeme (game.util.graph.Radials) => <radials>, pack=game.util.graph, label=radials, cls=game.util.graph.Radials, keyword=radials
gd~~ <graph> type=Ludeme (game.util.graph.Graph) => <graph>, pack=game.util.graph, label=graph, cls=game.util.graph.Graph, keyword=graph
~~~~ <perimeter> type=Ludeme (game.util.graph.Perimeter) => <perimeter>, pack=game.util.graph, label=perimeter, cls=game.util.graph.Perimeter, keyword=perimeter
gd~~ <poly> type=Ludeme (game.util.graph.Poly) => <poly>, pack=game.util.graph, label=poly, cls=game.util.graph.Poly, keyword=poly
~~~~ <trajectories> type=Ludeme (game.util.graph.Trajectories) => <trajectories>, pack=game.util.graph, label=trajectories, cls=game.util.graph.Trajectories, keyword=trajectories
~~~~ <steps> type=Ludeme (game.util.graph.Steps) => <steps>, pack=game.util.graph, label=steps, cls=game.util.graph.Steps, keyword=steps
~~~~ <graph.step> type=Ludeme (game.util.graph.Step) => <graph.step>, pack=game.util.graph, label=graph.step, cls=game.util.graph.Step, keyword=step
~~~* <measureGraph> type=Ludeme (game.util.graph.MeasureGraph) => <measureGraph>, pack=game.util.graph, label=measureGraph, cls=game.util.graph.MeasureGraph, keyword=measureGraph
~~~~ <properties> type=Ludeme (game.util.graph.Properties) => <properties>, pack=game.util.graph, label=properties, cls=game.util.graph.Properties, keyword=properties
~~~~ <bucket> type=Ludeme (game.util.graph.Bucket) => <bucket>, pack=game.util.graph, label=bucket, cls=game.util.graph.Bucket, keyword=bucket
~~~~ <vertex> type=Ludeme (game.util.graph.Vertex) => <vertex>, pack=game.util.graph, label=vertex, cls=game.util.graph.Vertex, keyword=vertex
~~~~ <situation> type=Ludeme (game.util.graph.Situation) => <situation>, pack=game.util.graph, label=situation, cls=game.util.graph.Situation, keyword=situation
~~~~ <graph.edge> type=Ludeme (game.util.graph.Edge) => <graph.edge>, pack=game.util.graph, label=graph.edge, cls=game.util.graph.Edge, keyword=edge
~~~~ <itemScore> type=Ludeme (game.util.graph.ItemScore) => <itemScore>, pack=game.util.graph, label=itemScore, cls=game.util.graph.ItemScore, keyword=itemScore
gd~~ <math.pair> type=Ludeme (game.util.math.Pair) => <math.pair>, pack=game.util.math, label=math.pair, cls=game.util.math.Pair, keyword=pair
gd~~ <math.count> type=Ludeme (game.util.math.Count) => <math.count>, pack=game.util.math, label=math.count, cls=game.util.math.Count, keyword=count
~~~~ <directionUniqueName> type=Ludeme (game.util.directions.DirectionUniqueName) => <directionUniqueName>, pack=game.util.directions, label=directionUniqueName, cls=game.util.directions.DirectionUniqueName, keyword=directionUniqueName
g~~* <direction> type=Structural (game.util.directions.Direction) => <direction>, pack=game.util.directions, label=direction, cls=game.util.directions.Direction, keyword=direction
g~~~ <stackDirection> type=Structural (game.util.directions.StackDirection) => <stackDirection>, pack=game.util.directions, label=stackDirection, cls=game.util.directions.StackDirection, keyword=stackDirection
g~~* <directionFacing> type=Structural (game.util.directions.DirectionFacing) => <directionFacing>, pack=game.util.directions, label=directionFacing, cls=game.util.directions.DirectionFacing, keyword=directionFacing
~~~~ <directionType> type=Structural (game.util.directions.DirectionType) => <directionType>, pack=game.util.directions, label=directionType, cls=game.util.directions.DirectionType, keyword=directionType
g~~* <relativeDirection> type=Structural (game.util.directions.RelativeDirection) => <relativeDirection>, pack=game.util.directions, label=relativeDirection, cls=game.util.directions.RelativeDirection, keyword=relativeDirection
g~~* <absoluteDirection> type=Structural (game.util.directions.AbsoluteDirection) => <absoluteDirection>, pack=game.util.directions, label=absoluteDirection, cls=game.util.directions.AbsoluteDirection, keyword=absoluteDirection
~~~* <rotationalDirection> type=Ludeme (game.util.directions.RotationalDirection) => <rotationalDirection>, pack=game.util.directions, label=rotationalDirection, cls=game.util.directions.RotationalDirection, keyword=rotationalDirection
g~~* <compassDirection> type=Structural (game.util.directions.CompassDirection) => <compassDirection>, pack=game.util.directions, label=compassDirection, cls=game.util.directions.CompassDirection, keyword=compassDirection
~~~* <spatialDirection> type=Ludeme (game.util.directions.SpatialDirection) => <spatialDirection>, pack=game.util.directions, label=spatialDirection, cls=game.util.directions.SpatialDirection, keyword=spatialDirection
~~~* <util.dummy> type=Ludeme (game.util.dummy) => <util.dummy>, pack=game.util, label=util.dummy, cls=game.util.dummy, keyword=dummy
gd~~ <equipment.card> type=Ludeme (game.util.equipment.Card) => <equipment.card>, pack=game.util.equipment, label=equipment.card, cls=game.util.equipment.Card, keyword=card
gd~~ <equipment.region> type=Ludeme (game.util.equipment.Region) => <equipment.region>, pack=game.util.equipment, label=equipment.region, cls=game.util.equipment.Region, keyword=region
gd~~ <equipment.values> type=Ludeme (game.util.equipment.Values) => <equipment.values>, pack=game.util.equipment, label=equipment.values, cls=game.util.equipment.Values, keyword=values
gd~~ <equipment.hint> type=Ludeme (game.util.equipment.Hint) => <equipment.hint>, pack=game.util.equipment, label=equipment.hint, cls=game.util.equipment.Hint, keyword=hint
gd~~ <players.player> type=Ludeme (game.players.Player) => <players.player>, pack=game.players, label=players.player, cls=game.players.Player, keyword=player
gd~~ <players> type=Ludeme (game.players.Players) => <players>, pack=game.players, label=players, cls=game.players.Players, keyword=players
~~~* <types.dummy> type=Ludeme (game.types.dummy) => <types.dummy>, pack=game.types, label=types.dummy, cls=game.types.dummy, keyword=dummy
~~~* <gameType> type=Structural (game.types.state.GameType) => <gameType>, pack=game.types.state, label=gameType, cls=game.types.state.GameType, keyword=gameType
g~~~ <hiddenData> type=Structural (game.types.board.HiddenData) => <hiddenData>, pack=game.types.board, label=hiddenData, cls=game.types.board.HiddenData, keyword=hiddenData
g~m~ <shapeType> type=Structural (game.types.board.ShapeType) => <shapeType>, pack=game.types.board, label=shapeType, cls=game.types.board.ShapeType, keyword=shapeType
g~~~ <tilingBoardlessType> type=Structural (game.types.board.TilingBoardlessType) => <tilingBoardlessType>, pack=game.types.board, label=tilingBoardlessType, cls=game.types.board.TilingBoardlessType, keyword=tilingBoardlessType
g~~~ <stepType> type=Structural (game.types.board.StepType) => <stepType>, pack=game.types.board, label=stepType, cls=game.types.board.StepType, keyword=stepType
g~~~ <regionTypeStatic> type=Structural (game.types.board.RegionTypeStatic) => <regionTypeStatic>, pack=game.types.board, label=regionTypeStatic, cls=game.types.board.RegionTypeStatic, keyword=regionTypeStatic
g~m~ <relationType> type=Structural (game.types.board.RelationType) => <relationType>, pack=game.types.board, label=relationType, cls=game.types.board.RelationType, keyword=relationType
g~~~ <puzzleElementType> type=Structural (game.types.board.PuzzleElementType) => <puzzleElementType>, pack=game.types.board, label=puzzleElementType, cls=game.types.board.PuzzleElementType, keyword=puzzleElementType
g~~~ <storeType> type=Structural (game.types.board.StoreType) => <storeType>, pack=game.types.board, label=storeType, cls=game.types.board.StoreType, keyword=storeType
g~m~ <siteType> type=Structural (game.types.board.SiteType) => <siteType>, pack=game.types.board, label=siteType, cls=game.types.board.SiteType, keyword=siteType
g~~~ <landmarkType> type=Structural (game.types.board.LandmarkType) => <landmarkType>, pack=game.types.board, label=landmarkType, cls=game.types.board.LandmarkType, keyword=landmarkType
~~~~ <trackType> type=Structural (game.types.board.TrackType) => <trackType>, pack=game.types.board, label=trackType, cls=game.types.board.TrackType, keyword=trackType
g~~~ <regionTypeDynamic> type=Structural (game.types.board.RegionTypeDynamic) => <regionTypeDynamic>, pack=game.types.board, label=regionTypeDynamic, cls=game.types.board.RegionTypeDynamic, keyword=regionTypeDynamic
g~~~ <basisType> type=Structural (game.types.board.BasisType) => <basisType>, pack=game.types.board, label=basisType, cls=game.types.board.BasisType, keyword=basisType
g~~~ <prevType> type=Structural (game.types.play.PrevType) => <prevType>, pack=game.types.play, label=prevType, cls=game.types.play.PrevType, keyword=prevType
g~~~ <repetitionType> type=Structural (game.types.play.RepetitionType) => <repetitionType>, pack=game.types.play, label=repetitionType, cls=game.types.play.RepetitionType, keyword=repetitionType
g~~~ <passEndType> type=Structural (game.types.play.PassEndType) => <passEndType>, pack=game.types.play, label=passEndType, cls=game.types.play.PassEndType, keyword=passEndType
g~m~ <roleType> type=Structural (game.types.play.RoleType) => <roleType>, pack=game.types.play, label=roleType, cls=game.types.play.RoleType, keyword=roleType
g~~~ <whenType> type=Structural (game.types.play.WhenType) => <whenType>, pack=game.types.play, label=whenType, cls=game.types.play.WhenType, keyword=whenType
g~~~ <modeType> type=Structural (game.types.play.ModeType) => <modeType>, pack=game.types.play, label=modeType, cls=game.types.play.ModeType, keyword=modeType
g~~~ <resultType> type=Structural (game.types.play.ResultType) => <resultType>, pack=game.types.play, label=resultType, cls=game.types.play.ResultType, keyword=resultType
~~~~ <pinType> type=Structural (game.types.play.PinType) => <pinType>, pack=game.types.play, label=pinType, cls=game.types.play.PinType, keyword=pinType
~~~~ <gravityType> type=Structural (game.types.play.GravityType) => <gravityType>, pack=game.types.play, label=gravityType, cls=game.types.play.GravityType, keyword=gravityType
g~~~ <dealableType> type=Structural (game.types.component.DealableType) => <dealableType>, pack=game.types.component, label=dealableType, cls=game.types.component.DealableType, keyword=dealableType
~~m~ <suitType> type=Structural (game.types.component.SuitType) => <suitType>, pack=game.types.component, label=suitType, cls=game.types.component.SuitType, keyword=suitType
g~~~ <cardType> type=Structural (game.types.component.CardType) => <cardType>, pack=game.types.component, label=cardType, cls=game.types.component.CardType, keyword=cardType
gd~~ <game> type=Ludeme (game.Game) => <game>, pack=game, label=game, cls=game.Game, keyword=game
~~m~ <ai> type=Structural (metadata.ai.Ai) => <ai>, pack=metadata.ai, label=ai, cls=metadata.ai.Ai, keyword=ai
~~m* <aIItem> type=Structural (metadata.ai.AIItem) => <aIItem>, pack=metadata.ai, label=aIItem, cls=metadata.ai.AIItem, keyword=aIItem
~~m~ <misc.pair> type=Structural (metadata.ai.misc.Pair) => <misc.pair>, pack=metadata.ai.misc, label=misc.pair, cls=metadata.ai.misc.Pair, keyword=pair
~~m~ <bestAgent> type=Structural (metadata.ai.misc.BestAgent) => <bestAgent>, pack=metadata.ai.misc, label=bestAgent, cls=metadata.ai.misc.BestAgent, keyword=bestAgent
~~m~ <featureSet> type=Structural (metadata.ai.features.FeatureSet) => <featureSet>, pack=metadata.ai.features, label=featureSet, cls=metadata.ai.features.FeatureSet, keyword=featureSet
~~m~ <features> type=Structural (metadata.ai.features.Features) => <features>, pack=metadata.ai.features, label=features, cls=metadata.ai.features.Features, keyword=features
~~m~ <influence> type=Structural (metadata.ai.heuristics.terms.Influence) => <influence>, pack=metadata.ai.heuristics.terms, label=influence, cls=metadata.ai.heuristics.terms.Influence, keyword=influence
~~m~ <currentMoverHeuristic> type=Structural (metadata.ai.heuristics.terms.CurrentMoverHeuristic) => <currentMoverHeuristic>, pack=metadata.ai.heuristics.terms, label=currentMoverHeuristic, cls=metadata.ai.heuristics.terms.CurrentMoverHeuristic, keyword=currentMoverHeuristic
~~m~ <playerRegionsProximity> type=Structural (metadata.ai.heuristics.terms.PlayerRegionsProximity) => <playerRegionsProximity>, pack=metadata.ai.heuristics.terms, label=playerRegionsProximity, cls=metadata.ai.heuristics.terms.PlayerRegionsProximity, keyword=playerRegionsProximity
~~m* <heuristicTerm> type=Structural (metadata.ai.heuristics.terms.HeuristicTerm) => <heuristicTerm>, pack=metadata.ai.heuristics.terms, label=heuristicTerm, cls=metadata.ai.heuristics.terms.HeuristicTerm, keyword=heuristicTerm
~~m~ <playerSiteMapCount> type=Structural (metadata.ai.heuristics.terms.PlayerSiteMapCount) => <playerSiteMapCount>, pack=metadata.ai.heuristics.terms, label=playerSiteMapCount, cls=metadata.ai.heuristics.terms.PlayerSiteMapCount, keyword=playerSiteMapCount
~~m~ <cornerProximity> type=Structural (metadata.ai.heuristics.terms.CornerProximity) => <cornerProximity>, pack=metadata.ai.heuristics.terms, label=cornerProximity, cls=metadata.ai.heuristics.terms.CornerProximity, keyword=cornerProximity
~~m~ <ownRegionsCount> type=Structural (metadata.ai.heuristics.terms.OwnRegionsCount) => <ownRegionsCount>, pack=metadata.ai.heuristics.terms, label=ownRegionsCount, cls=metadata.ai.heuristics.terms.OwnRegionsCount, keyword=ownRegionsCount
~~m~ <nullHeuristic> type=Structural (metadata.ai.heuristics.terms.NullHeuristic) => <nullHeuristic>, pack=metadata.ai.heuristics.terms, label=nullHeuristic, cls=metadata.ai.heuristics.terms.NullHeuristic, keyword=nullHeuristic
~~m~ <centreProximity> type=Structural (metadata.ai.heuristics.terms.CentreProximity) => <centreProximity>, pack=metadata.ai.heuristics.terms, label=centreProximity, cls=metadata.ai.heuristics.terms.CentreProximity, keyword=centreProximity
~~m~ <sidesProximity> type=Structural (metadata.ai.heuristics.terms.SidesProximity) => <sidesProximity>, pack=metadata.ai.heuristics.terms, label=sidesProximity, cls=metadata.ai.heuristics.terms.SidesProximity, keyword=sidesProximity
~~m~ <lineCompletionHeuristic> type=Structural (metadata.ai.heuristics.terms.LineCompletionHeuristic) => <lineCompletionHeuristic>, pack=metadata.ai.heuristics.terms, label=lineCompletionHeuristic, cls=metadata.ai.heuristics.terms.LineCompletionHeuristic, keyword=lineCompletionHeuristic
~~m~ <mobilitySimple> type=Structural (metadata.ai.heuristics.terms.MobilitySimple) => <mobilitySimple>, pack=metadata.ai.heuristics.terms, label=mobilitySimple, cls=metadata.ai.heuristics.terms.MobilitySimple, keyword=mobilitySimple
~~m~ <componentValues> type=Structural (metadata.ai.heuristics.terms.ComponentValues) => <componentValues>, pack=metadata.ai.heuristics.terms, label=componentValues, cls=metadata.ai.heuristics.terms.ComponentValues, keyword=componentValues
~~m~ <regionProximity> type=Structural (metadata.ai.heuristics.terms.RegionProximity) => <regionProximity>, pack=metadata.ai.heuristics.terms, label=regionProximity, cls=metadata.ai.heuristics.terms.RegionProximity, keyword=regionProximity
~~m~ <terms.score> type=Structural (metadata.ai.heuristics.terms.Score) => <terms.score>, pack=metadata.ai.heuristics.terms, label=terms.score, cls=metadata.ai.heuristics.terms.Score, keyword=score
~~m~ <material> type=Structural (metadata.ai.heuristics.terms.Material) => <material>, pack=metadata.ai.heuristics.terms, label=material, cls=metadata.ai.heuristics.terms.Material, keyword=material
~~m~ <heuristics> type=Structural (metadata.ai.heuristics.Heuristics) => <heuristics>, pack=metadata.ai.heuristics, label=heuristics, cls=metadata.ai.heuristics.Heuristics, keyword=heuristics
~~m~ <tanh> type=Structural (metadata.ai.heuristics.transformations.Tanh) => <tanh>, pack=metadata.ai.heuristics.transformations, label=tanh, cls=metadata.ai.heuristics.transformations.Tanh, keyword=tanh
~~m* <heuristicTransformation> type=Structural (metadata.ai.heuristics.transformations.HeuristicTransformation) => <heuristicTransformation>, pack=metadata.ai.heuristics.transformations, label=heuristicTransformation, cls=metadata.ai.heuristics.transformations.HeuristicTransformation, keyword=heuristicTransformation
~~m~ <divNumInitPlacement> type=Structural (metadata.ai.heuristics.transformations.DivNumInitPlacement) => <divNumInitPlacement>, pack=metadata.ai.heuristics.transformations, label=divNumInitPlacement, cls=metadata.ai.heuristics.transformations.DivNumInitPlacement, keyword=divNumInitPlacement
~~m~ <logisticFunction> type=Structural (metadata.ai.heuristics.transformations.LogisticFunction) => <logisticFunction>, pack=metadata.ai.heuristics.transformations, label=logisticFunction, cls=metadata.ai.heuristics.transformations.LogisticFunction, keyword=logisticFunction
~~m~ <divNumBoardSites> type=Structural (metadata.ai.heuristics.transformations.DivNumBoardSites) => <divNumBoardSites>, pack=metadata.ai.heuristics.transformations, label=divNumBoardSites, cls=metadata.ai.heuristics.transformations.DivNumBoardSites, keyword=divNumBoardSites
~~m* <metadataItem> type=Structural (metadata.MetadataItem) => <metadataItem>, pack=metadata, label=metadataItem, cls=metadata.MetadataItem, keyword=metadataItem
~~m* <infoItem> type=Structural (metadata.info.InfoItem) => <infoItem>, pack=metadata.info, label=infoItem, cls=metadata.info.InfoItem, keyword=infoItem
~~m~ <info> type=Structural (metadata.info.Info) => <info>, pack=metadata.info, label=info, cls=metadata.info.Info, keyword=info
~~m~ <version> type=Structural (metadata.info.database.Version) => <version>, pack=metadata.info.database, label=version, cls=metadata.info.database.Version, keyword=version
~~m~ <author> type=Structural (metadata.info.database.Author) => <author>, pack=metadata.info.database, label=author, cls=metadata.info.database.Author, keyword=author
~~m~ <credit> type=Structural (metadata.info.database.Credit) => <credit>, pack=metadata.info.database, label=credit, cls=metadata.info.database.Credit, keyword=credit
~~m~ <aliases> type=Structural (metadata.info.database.Aliases) => <aliases>, pack=metadata.info.database, label=aliases, cls=metadata.info.database.Aliases, keyword=aliases
~~m~ <publisher> type=Structural (metadata.info.database.Publisher) => <publisher>, pack=metadata.info.database, label=publisher, cls=metadata.info.database.Publisher, keyword=publisher
~~m~ <origin> type=Structural (metadata.info.database.Origin) => <origin>, pack=metadata.info.database, label=origin, cls=metadata.info.database.Origin, keyword=origin
~~m~ <classification> type=Structural (metadata.info.database.Classification) => <classification>, pack=metadata.info.database, label=classification, cls=metadata.info.database.Classification, keyword=classification
~~m~ <source> type=Structural (metadata.info.database.Source) => <source>, pack=metadata.info.database, label=source, cls=metadata.info.database.Source, keyword=source
~~m~ <description> type=Structural (metadata.info.database.Description) => <description>, pack=metadata.info.database, label=description, cls=metadata.info.database.Description, keyword=description
~~m~ <date> type=Structural (metadata.info.database.Date) => <date>, pack=metadata.info.database, label=date, cls=metadata.info.database.Date, keyword=date
~~m~ <database.rules> type=Structural (metadata.info.database.Rules) => <database.rules>, pack=metadata.info.database, label=database.rules, cls=metadata.info.database.Rules, keyword=rules
~~m~ <metadata> type=Structural (metadata.Metadata) => <metadata>, pack=metadata, label=metadata, cls=metadata.Metadata, keyword=metadata
~~m~ <graphics.no.no> type=Structural (metadata.graphics.no.No) => <graphics.no.no>, pack=metadata.graphics.no, label=graphics.no.no, cls=metadata.graphics.no.No, keyword=no
~~m~ <noBooleanType> type=Structural (metadata.graphics.no.NoBooleanType) => <noBooleanType>, pack=metadata.graphics.no, label=noBooleanType, cls=metadata.graphics.no.NoBooleanType, keyword=noBooleanType
~~m~ <noAnimation> type=Ludeme (metadata.graphics.no.Boolean.NoAnimation) => <noAnimation>, pack=metadata.graphics.no.Boolean, label=noAnimation, cls=metadata.graphics.no.Boolean.NoAnimation, keyword=noAnimation
~~m~ <noBoard> type=Ludeme (metadata.graphics.no.Boolean.NoBoard) => <noBoard>, pack=metadata.graphics.no.Boolean, label=noBoard, cls=metadata.graphics.no.Boolean.NoBoard, keyword=noBoard
~~m~ <noHandScale> type=Ludeme (metadata.graphics.no.Boolean.NoHandScale) => <noHandScale>, pack=metadata.graphics.no.Boolean, label=noHandScale, cls=metadata.graphics.no.Boolean.NoHandScale, keyword=noHandScale
~~m~ <noDicePips> type=Ludeme (metadata.graphics.no.Boolean.NoDicePips) => <noDicePips>, pack=metadata.graphics.no.Boolean, label=noDicePips, cls=metadata.graphics.no.Boolean.NoDicePips, keyword=noDicePips
~~m~ <noSunken> type=Ludeme (metadata.graphics.no.Boolean.NoSunken) => <noSunken>, pack=metadata.graphics.no.Boolean, label=noSunken, cls=metadata.graphics.no.Boolean.NoSunken, keyword=noSunken
~~m~ <noCurves> type=Ludeme (metadata.graphics.no.Boolean.NoCurves) => <noCurves>, pack=metadata.graphics.no.Boolean, label=noCurves, cls=metadata.graphics.no.Boolean.NoCurves, keyword=noCurves
~~m~ <regionColour> type=Ludeme (metadata.graphics.region.colour.RegionColour) => <regionColour>, pack=metadata.graphics.region.colour, label=regionColour, cls=metadata.graphics.region.colour.RegionColour, keyword=regionColour
~~~~ <regionColourType> type=Structural (metadata.graphics.region.RegionColourType) => <regionColourType>, pack=metadata.graphics.region, label=regionColourType, cls=metadata.graphics.region.RegionColourType, keyword=regionColourType
~~m~ <region.region> type=Structural (metadata.graphics.region.Region) => <region.region>, pack=metadata.graphics.region, label=region.region, cls=metadata.graphics.region.Region, keyword=region
~~~~ <pieceStyleType> type=Structural (metadata.graphics.piece.PieceStyleType) => <pieceStyleType>, pack=metadata.graphics.piece, label=pieceStyleType, cls=metadata.graphics.piece.PieceStyleType, keyword=pieceStyleType
~~m~ <pieceNameType> type=Structural (metadata.graphics.piece.PieceNameType) => <pieceNameType>, pack=metadata.graphics.piece, label=pieceNameType, cls=metadata.graphics.piece.PieceNameType, keyword=pieceNameType
~~~~ <pieceReflectType> type=Structural (metadata.graphics.piece.PieceReflectType) => <pieceReflectType>, pack=metadata.graphics.piece, label=pieceReflectType, cls=metadata.graphics.piece.PieceReflectType, keyword=pieceReflectType
~~~~ <pieceColourType> type=Structural (metadata.graphics.piece.PieceColourType) => <pieceColourType>, pack=metadata.graphics.piece, label=pieceColourType, cls=metadata.graphics.piece.PieceColourType, keyword=pieceColourType
~~m~ <pieceReflect> type=Ludeme (metadata.graphics.piece.reflect.PieceReflect) => <pieceReflect>, pack=metadata.graphics.piece.reflect, label=pieceReflect, cls=metadata.graphics.piece.reflect.PieceReflect, keyword=pieceReflect
~~~~ <pieceScaleByType> type=Structural (metadata.graphics.piece.PieceScaleByType) => <pieceScaleByType>, pack=metadata.graphics.piece, label=pieceScaleByType, cls=metadata.graphics.piece.PieceScaleByType, keyword=pieceScaleByType
~~m~ <pieceScale> type=Ludeme (metadata.graphics.piece.scale.PieceScale) => <pieceScale>, pack=metadata.graphics.piece.scale, label=pieceScale, cls=metadata.graphics.piece.scale.PieceScale, keyword=pieceScale
~~m~ <pieceRotate> type=Ludeme (metadata.graphics.piece.rotate.PieceRotate) => <pieceRotate>, pack=metadata.graphics.piece.rotate, label=pieceRotate, cls=metadata.graphics.piece.rotate.PieceRotate, keyword=pieceRotate
~~~~ <pieceFamiliesType> type=Structural (metadata.graphics.piece.PieceFamiliesType) => <pieceFamiliesType>, pack=metadata.graphics.piece, label=pieceFamiliesType, cls=metadata.graphics.piece.PieceFamiliesType, keyword=pieceFamiliesType
~~m~ <pieceStyle> type=Ludeme (metadata.graphics.piece.style.PieceStyle) => <pieceStyle>, pack=metadata.graphics.piece.style, label=pieceStyle, cls=metadata.graphics.piece.style.PieceStyle, keyword=pieceStyle
~~m~ <pieceColour> type=Ludeme (metadata.graphics.piece.colour.PieceColour) => <pieceColour>, pack=metadata.graphics.piece.colour, label=pieceColour, cls=metadata.graphics.piece.colour.PieceColour, keyword=pieceColour
~~m~ <pieceBackground> type=Ludeme (metadata.graphics.piece.ground.PieceBackground) => <pieceBackground>, pack=metadata.graphics.piece.ground, label=pieceBackground, cls=metadata.graphics.piece.ground.PieceBackground, keyword=pieceBackground
~~m~ <pieceForeground> type=Ludeme (metadata.graphics.piece.ground.PieceForeground) => <pieceForeground>, pack=metadata.graphics.piece.ground, label=pieceForeground, cls=metadata.graphics.piece.ground.PieceForeground, keyword=pieceForeground
~~~~ <pieceScaleType> type=Structural (metadata.graphics.piece.PieceScaleType) => <pieceScaleType>, pack=metadata.graphics.piece, label=pieceScaleType, cls=metadata.graphics.piece.PieceScaleType, keyword=pieceScaleType
~~m~ <pieceAddStateToName> type=Ludeme (metadata.graphics.piece.name.PieceAddStateToName) => <pieceAddStateToName>, pack=metadata.graphics.piece.name, label=pieceAddStateToName, cls=metadata.graphics.piece.name.PieceAddStateToName, keyword=pieceAddStateToName
~~m~ <pieceExtendName> type=Ludeme (metadata.graphics.piece.name.PieceExtendName) => <pieceExtendName>, pack=metadata.graphics.piece.name, label=pieceExtendName, cls=metadata.graphics.piece.name.PieceExtendName, keyword=pieceExtendName
~~m~ <pieceRename> type=Ludeme (metadata.graphics.piece.name.PieceRename) => <pieceRename>, pack=metadata.graphics.piece.name, label=pieceRename, cls=metadata.graphics.piece.name.PieceRename, keyword=pieceRename
~~~~ <pieceRotateType> type=Structural (metadata.graphics.piece.PieceRotateType) => <pieceRotateType>, pack=metadata.graphics.piece, label=pieceRotateType, cls=metadata.graphics.piece.PieceRotateType, keyword=pieceRotateType
~~m~ <piece.piece> type=Structural (metadata.graphics.piece.Piece) => <piece.piece>, pack=metadata.graphics.piece, label=piece.piece, cls=metadata.graphics.piece.Piece, keyword=piece
~~m~ <pieceGroundType> type=Structural (metadata.graphics.piece.PieceGroundType) => <pieceGroundType>, pack=metadata.graphics.piece, label=pieceGroundType, cls=metadata.graphics.piece.PieceGroundType, keyword=pieceGroundType
~~m~ <pieceFamilies> type=Ludeme (metadata.graphics.piece.families.PieceFamilies) => <pieceFamilies>, pack=metadata.graphics.piece.families, label=pieceFamilies, cls=metadata.graphics.piece.families.PieceFamilies, keyword=pieceFamilies
~~m~ <player.player> type=Structural (metadata.graphics.player.Player) => <player.player>, pack=metadata.graphics.player, label=player.player, cls=metadata.graphics.player.Player, keyword=player
~~m~ <playerColour> type=Ludeme (metadata.graphics.player.colour.PlayerColour) => <playerColour>, pack=metadata.graphics.player.colour, label=playerColour, cls=metadata.graphics.player.colour.PlayerColour, keyword=playerColour
~~~~ <playerColourType> type=Structural (metadata.graphics.player.PlayerColourType) => <playerColourType>, pack=metadata.graphics.player, label=playerColourType, cls=metadata.graphics.player.PlayerColourType, keyword=playerColourType
~~~~ <playerNameType> type=Structural (metadata.graphics.player.PlayerNameType) => <playerNameType>, pack=metadata.graphics.player, label=playerNameType, cls=metadata.graphics.player.PlayerNameType, keyword=playerNameType
~~m~ <playerName> type=Ludeme (metadata.graphics.player.name.PlayerName) => <playerName>, pack=metadata.graphics.player.name, label=playerName, cls=metadata.graphics.player.name.PlayerName, keyword=playerName
~~m~ <graphics> type=Structural (metadata.graphics.Graphics) => <graphics>, pack=metadata.graphics, label=graphics, cls=metadata.graphics.Graphics, keyword=graphics
~~m~ <containerStyleType> type=Structural (metadata.graphics.util.ContainerStyleType) => <containerStyleType>, pack=metadata.graphics.util, label=containerStyleType, cls=metadata.graphics.util.ContainerStyleType, keyword=containerStyleType
~~~~ <edgeInfoGUI> type=Ludeme (metadata.graphics.util.EdgeInfoGUI) => <edgeInfoGUI>, pack=metadata.graphics.util, label=edgeInfoGUI, cls=metadata.graphics.util.EdgeInfoGUI, keyword=edgeInfoGUI
~~m~ <lineStyle> type=Structural (metadata.graphics.util.LineStyle) => <lineStyle>, pack=metadata.graphics.util, label=lineStyle, cls=metadata.graphics.util.LineStyle, keyword=lineStyle
~~~~ <scoreDisplayInfo> type=Ludeme (metadata.graphics.util.ScoreDisplayInfo) => <scoreDisplayInfo>, pack=metadata.graphics.util, label=scoreDisplayInfo, cls=metadata.graphics.util.ScoreDisplayInfo, keyword=scoreDisplayInfo
~~~~ <valueDisplayInfo> type=Ludeme (metadata.graphics.util.ValueDisplayInfo) => <valueDisplayInfo>, pack=metadata.graphics.util, label=valueDisplayInfo, cls=metadata.graphics.util.ValueDisplayInfo, keyword=valueDisplayInfo
~~m~ <puzzleHintLocationType> type=Structural (metadata.graphics.util.PuzzleHintLocationType) => <puzzleHintLocationType>, pack=metadata.graphics.util, label=puzzleHintLocationType, cls=metadata.graphics.util.PuzzleHintLocationType, keyword=puzzleHintLocationType
~~m~ <boardGraphicsType> type=Structural (metadata.graphics.util.BoardGraphicsType) => <boardGraphicsType>, pack=metadata.graphics.util, label=boardGraphicsType, cls=metadata.graphics.util.BoardGraphicsType, keyword=boardGraphicsType
~~m~ <componentStyleType> type=Structural (metadata.graphics.util.ComponentStyleType) => <componentStyleType>, pack=metadata.graphics.util, label=componentStyleType, cls=metadata.graphics.util.ComponentStyleType, keyword=componentStyleType
~~m~ <whenScoreType> type=Structural (metadata.graphics.util.WhenScoreType) => <whenScoreType>, pack=metadata.graphics.util, label=whenScoreType, cls=metadata.graphics.util.WhenScoreType, keyword=whenScoreType
~~m~ <userColourType> type=Structural (metadata.graphics.util.colour.UserColourType) => <userColourType>, pack=metadata.graphics.util.colour, label=userColourType, cls=metadata.graphics.util.colour.UserColourType, keyword=userColourType
~~~~ <colourRoutines> type=Ludeme (metadata.graphics.util.colour.ColourRoutines) => <colourRoutines>, pack=metadata.graphics.util.colour, label=colourRoutines, cls=metadata.graphics.util.colour.ColourRoutines, keyword=colourRoutines
~~m~ <colour> type=Structural (metadata.graphics.util.colour.Colour) => <colour>, pack=metadata.graphics.util.colour, label=colour, cls=metadata.graphics.util.colour.Colour, keyword=colour
~~m~ <curveType> type=Structural (metadata.graphics.util.CurveType) => <curveType>, pack=metadata.graphics.util, label=curveType, cls=metadata.graphics.util.CurveType, keyword=curveType
~~m~ <controllerType> type=Structural (metadata.graphics.util.ControllerType) => <controllerType>, pack=metadata.graphics.util, label=controllerType, cls=metadata.graphics.util.ControllerType, keyword=controllerType
~~m~ <puzzleDrawHintType> type=Structural (metadata.graphics.util.PuzzleDrawHintType) => <puzzleDrawHintType>, pack=metadata.graphics.util, label=puzzleDrawHintType, cls=metadata.graphics.util.PuzzleDrawHintType, keyword=puzzleDrawHintType
~~~~ <metadataFunctions> type=Ludeme (metadata.graphics.util.MetadataFunctions) => <metadataFunctions>, pack=metadata.graphics.util, label=metadataFunctions, cls=metadata.graphics.util.MetadataFunctions, keyword=metadataFunctions
~~m~ <valueLocationType> type=Structural (metadata.graphics.util.ValueLocationType) => <valueLocationType>, pack=metadata.graphics.util, label=valueLocationType, cls=metadata.graphics.util.ValueLocationType, keyword=valueLocationType
~~m~ <holeType> type=Structural (metadata.graphics.util.HoleType) => <holeType>, pack=metadata.graphics.util, label=holeType, cls=metadata.graphics.util.HoleType, keyword=holeType
~~m~ <pieceStackType> type=Structural (metadata.graphics.util.PieceStackType) => <pieceStackType>, pack=metadata.graphics.util, label=pieceStackType, cls=metadata.graphics.util.PieceStackType, keyword=pieceStackType
~~m~ <edgeType> type=Structural (metadata.graphics.util.EdgeType) => <edgeType>, pack=metadata.graphics.util, label=edgeType, cls=metadata.graphics.util.EdgeType, keyword=edgeType
~~~~ <metadataImageInfo> type=Ludeme (metadata.graphics.util.MetadataImageInfo) => <metadataImageInfo>, pack=metadata.graphics.util, label=metadataImageInfo, cls=metadata.graphics.util.MetadataImageInfo, keyword=metadataImageInfo
~~~~ <boardStyleThicknessType> type=Structural (metadata.graphics.board.BoardStyleThicknessType) => <boardStyleThicknessType>, pack=metadata.graphics.board, label=boardStyleThicknessType, cls=metadata.graphics.board.BoardStyleThicknessType, keyword=boardStyleThicknessType
~~m~ <boardPlacement> type=Ludeme (metadata.graphics.board.placement.BoardPlacement) => <boardPlacement>, pack=metadata.graphics.board.placement, label=boardPlacement, cls=metadata.graphics.board.placement.BoardPlacement, keyword=boardPlacement
~~~~ <boardColourType> type=Structural (metadata.graphics.board.BoardColourType) => <boardColourType>, pack=metadata.graphics.board, label=boardColourType, cls=metadata.graphics.board.BoardColourType, keyword=boardColourType
~~m~ <boardStyle> type=Ludeme (metadata.graphics.board.style.BoardStyle) => <boardStyle>, pack=metadata.graphics.board.style, label=boardStyle, cls=metadata.graphics.board.style.BoardStyle, keyword=boardStyle
~~~~ <boardShapeType> type=Structural (metadata.graphics.board.BoardShapeType) => <boardShapeType>, pack=metadata.graphics.board, label=boardShapeType, cls=metadata.graphics.board.BoardShapeType, keyword=boardShapeType
~~~~ <boardStylePenAndPaperType> type=Structural (metadata.graphics.board.BoardStylePenAndPaperType) => <boardStylePenAndPaperType>, pack=metadata.graphics.board, label=boardStylePenAndPaperType, cls=metadata.graphics.board.BoardStylePenAndPaperType, keyword=boardStylePenAndPaperType
~~m~ <boardColour> type=Ludeme (metadata.graphics.board.colour.BoardColour) => <boardColour>, pack=metadata.graphics.board.colour, label=boardColour, cls=metadata.graphics.board.colour.BoardColour, keyword=boardColour
~~m~ <graphics.board.board> type=Structural (metadata.graphics.board.Board) => <graphics.board.board>, pack=metadata.graphics.board, label=graphics.board.board, cls=metadata.graphics.board.Board, keyword=board
~~m~ <boardStyleThickness> type=Ludeme (metadata.graphics.board.styleThickness.BoardStyleThickness) => <boardStyleThickness>, pack=metadata.graphics.board.styleThickness, label=boardStyleThickness, cls=metadata.graphics.board.styleThickness.BoardStyleThickness, keyword=boardStyleThickness
~~m~ <boardForeground> type=Ludeme (metadata.graphics.board.ground.BoardForeground) => <boardForeground>, pack=metadata.graphics.board.ground, label=boardForeground, cls=metadata.graphics.board.ground.BoardForeground, keyword=boardForeground
~~m~ <boardBackground> type=Ludeme (metadata.graphics.board.ground.BoardBackground) => <boardBackground>, pack=metadata.graphics.board.ground, label=boardBackground, cls=metadata.graphics.board.ground.BoardBackground, keyword=boardBackground
~~m~ <boardBooleanType> type=Structural (metadata.graphics.board.BoardBooleanType) => <boardBooleanType>, pack=metadata.graphics.board, label=boardBooleanType, cls=metadata.graphics.board.BoardBooleanType, keyword=boardBooleanType
~~~~ <boardPlacementType> type=Structural (metadata.graphics.board.BoardPlacementType) => <boardPlacementType>, pack=metadata.graphics.board, label=boardPlacementType, cls=metadata.graphics.board.BoardPlacementType, keyword=boardPlacementType
~~~~ <boardStyleType> type=Structural (metadata.graphics.board.BoardStyleType) => <boardStyleType>, pack=metadata.graphics.board, label=boardStyleType, cls=metadata.graphics.board.BoardStyleType, keyword=boardStyleType
~~m~ <boardShape> type=Ludeme (metadata.graphics.board.shape.BoardShape) => <boardShape>, pack=metadata.graphics.board.shape, label=boardShape, cls=metadata.graphics.board.shape.BoardShape, keyword=boardShape
~~m~ <boardRedrawAfterMove> type=Ludeme (metadata.graphics.board.Boolean.BoardRedrawAfterMove) => <boardRedrawAfterMove>, pack=metadata.graphics.board.Boolean, label=boardRedrawAfterMove, cls=metadata.graphics.board.Boolean.BoardRedrawAfterMove, keyword=boardRedrawAfterMove
~~m~ <boardCheckered> type=Ludeme (metadata.graphics.board.Boolean.BoardCheckered) => <boardCheckered>, pack=metadata.graphics.board.Boolean, label=boardCheckered, cls=metadata.graphics.board.Boolean.BoardCheckered, keyword=boardCheckered
~~m~ <autoPass> type=Structural (metadata.graphics.others.AutoPass) => <autoPass>, pack=metadata.graphics.others, label=autoPass, cls=metadata.graphics.others.AutoPass, keyword=autoPass
~~m~ <stackType> type=Structural (metadata.graphics.others.StackType) => <stackType>, pack=metadata.graphics.others, label=stackType, cls=metadata.graphics.others.StackType, keyword=stackType
~~m~ <suitRanking> type=Structural (metadata.graphics.others.SuitRanking) => <suitRanking>, pack=metadata.graphics.others, label=suitRanking, cls=metadata.graphics.others.SuitRanking, keyword=suitRanking
~~m~ <hiddenImage> type=Structural (metadata.graphics.others.HiddenImage) => <hiddenImage>, pack=metadata.graphics.others, label=hiddenImage, cls=metadata.graphics.others.HiddenImage, keyword=hiddenImage
~~m* <graphicsItem> type=Structural (metadata.graphics.GraphicsItem) => <graphicsItem>, pack=metadata.graphics, label=graphicsItem, cls=metadata.graphics.GraphicsItem, keyword=graphicsItem
~~m~ <adversarialPuzzle> type=Structural (metadata.graphics.puzzle.AdversarialPuzzle) => <adversarialPuzzle>, pack=metadata.graphics.puzzle, label=adversarialPuzzle, cls=metadata.graphics.puzzle.AdversarialPuzzle, keyword=adversarialPuzzle
~~m~ <hintLocation> type=Structural (metadata.graphics.puzzle.HintLocation) => <hintLocation>, pack=metadata.graphics.puzzle, label=hintLocation, cls=metadata.graphics.puzzle.HintLocation, keyword=hintLocation
~~m~ <drawHint> type=Structural (metadata.graphics.puzzle.DrawHint) => <drawHint>, pack=metadata.graphics.puzzle, label=drawHint, cls=metadata.graphics.puzzle.DrawHint, keyword=drawHint
~~m~ <handPlacement> type=Ludeme (metadata.graphics.hand.placement.HandPlacement) => <handPlacement>, pack=metadata.graphics.hand.placement, label=handPlacement, cls=metadata.graphics.hand.placement.HandPlacement, keyword=handPlacement
~~~~ <handPlacementType> type=Structural (metadata.graphics.hand.HandPlacementType) => <handPlacementType>, pack=metadata.graphics.hand, label=handPlacementType, cls=metadata.graphics.hand.HandPlacementType, keyword=handPlacementType
~~m~ <hand.hand> type=Structural (metadata.graphics.hand.Hand) => <hand.hand>, pack=metadata.graphics.hand, label=hand.hand, cls=metadata.graphics.hand.Hand, keyword=hand
~~m~ <showEdges> type=Ludeme (metadata.graphics.show.edges.ShowEdges) => <showEdges>, pack=metadata.graphics.show.edges, label=showEdges, cls=metadata.graphics.show.edges.ShowEdges, keyword=showEdges
~~m~ <show> type=Structural (metadata.graphics.show.Show) => <show>, pack=metadata.graphics.show, label=show, cls=metadata.graphics.show.Show, keyword=show
~~m~ <showLine> type=Ludeme (metadata.graphics.show.line.ShowLine) => <showLine>, pack=metadata.graphics.show.line, label=showLine, cls=metadata.graphics.show.line.ShowLine, keyword=showLine
~~~~ <showScoreType> type=Structural (metadata.graphics.show.ShowScoreType) => <showScoreType>, pack=metadata.graphics.show, label=showScoreType, cls=metadata.graphics.show.ShowScoreType, keyword=showScoreType
~~m~ <showSitesShape> type=Ludeme (metadata.graphics.show.sites.ShowSitesShape) => <showSitesShape>, pack=metadata.graphics.show.sites, label=showSitesShape, cls=metadata.graphics.show.sites.ShowSitesShape, keyword=showSitesShape
~~m~ <showSitesAsHoles> type=Ludeme (metadata.graphics.show.sites.ShowSitesAsHoles) => <showSitesAsHoles>, pack=metadata.graphics.show.sites, label=showSitesAsHoles, cls=metadata.graphics.show.sites.ShowSitesAsHoles, keyword=showSitesAsHoles
~~m~ <showSymbol> type=Ludeme (metadata.graphics.show.symbol.ShowSymbol) => <showSymbol>, pack=metadata.graphics.show.symbol, label=showSymbol, cls=metadata.graphics.show.symbol.ShowSymbol, keyword=showSymbol
~~m~ <showBooleanType> type=Structural (metadata.graphics.show.ShowBooleanType) => <showBooleanType>, pack=metadata.graphics.show, label=showBooleanType, cls=metadata.graphics.show.ShowBooleanType, keyword=showBooleanType
~~~~ <showSiteDataType> type=Structural (metadata.graphics.show.ShowSiteDataType) => <showSiteDataType>, pack=metadata.graphics.show, label=showSiteDataType, cls=metadata.graphics.show.ShowSiteDataType, keyword=showSiteDataType
~~~~ <showLineType> type=Structural (metadata.graphics.show.ShowLineType) => <showLineType>, pack=metadata.graphics.show, label=showLineType, cls=metadata.graphics.show.ShowLineType, keyword=showLineType
~~~~ <showCheckType> type=Structural (metadata.graphics.show.ShowCheckType) => <showCheckType>, pack=metadata.graphics.show, label=showCheckType, cls=metadata.graphics.show.ShowCheckType, keyword=showCheckType
~~~~ <showSiteType> type=Structural (metadata.graphics.show.ShowSiteType) => <showSiteType>, pack=metadata.graphics.show, label=showSiteType, cls=metadata.graphics.show.ShowSiteType, keyword=showSiteType
~~~~ <showComponentType> type=Structural (metadata.graphics.show.ShowComponentType) => <showComponentType>, pack=metadata.graphics.show, label=showComponentType, cls=metadata.graphics.show.ShowComponentType, keyword=showComponentType
~~m~ <showScore> type=Ludeme (metadata.graphics.show.score.ShowScore) => <showScore>, pack=metadata.graphics.show.score, label=showScore, cls=metadata.graphics.show.score.ShowScore, keyword=showScore
~~m~ <showComponentDataType> type=Structural (metadata.graphics.show.ShowComponentDataType) => <showComponentDataType>, pack=metadata.graphics.show, label=showComponentDataType, cls=metadata.graphics.show.ShowComponentDataType, keyword=showComponentDataType
~~m~ <showCheck> type=Ludeme (metadata.graphics.show.check.ShowCheck) => <showCheck>, pack=metadata.graphics.show.check, label=showCheck, cls=metadata.graphics.show.check.ShowCheck, keyword=showCheck
~~~~ <showSymbolType> type=Structural (metadata.graphics.show.ShowSymbolType) => <showSymbolType>, pack=metadata.graphics.show, label=showSymbolType, cls=metadata.graphics.show.ShowSymbolType, keyword=showSymbolType
~~m~ <showCurvedEdges> type=Ludeme (metadata.graphics.show.Boolean.ShowCurvedEdges) => <showCurvedEdges>, pack=metadata.graphics.show.Boolean, label=showCurvedEdges, cls=metadata.graphics.show.Boolean.ShowCurvedEdges, keyword=showCurvedEdges
~~m~ <showCost> type=Ludeme (metadata.graphics.show.Boolean.ShowCost) => <showCost>, pack=metadata.graphics.show.Boolean, label=showCost, cls=metadata.graphics.show.Boolean.ShowCost, keyword=showCost
~~m~ <showRegionOwner> type=Ludeme (metadata.graphics.show.Boolean.ShowRegionOwner) => <showRegionOwner>, pack=metadata.graphics.show.Boolean, label=showRegionOwner, cls=metadata.graphics.show.Boolean.ShowRegionOwner, keyword=showRegionOwner
~~m~ <showEdgeDirections> type=Ludeme (metadata.graphics.show.Boolean.ShowEdgeDirections) => <showEdgeDirections>, pack=metadata.graphics.show.Boolean, label=showEdgeDirections, cls=metadata.graphics.show.Boolean.ShowEdgeDirections, keyword=showEdgeDirections
~~m~ <showPossibleMoves> type=Ludeme (metadata.graphics.show.Boolean.ShowPossibleMoves) => <showPossibleMoves>, pack=metadata.graphics.show.Boolean, label=showPossibleMoves, cls=metadata.graphics.show.Boolean.ShowPossibleMoves, keyword=showPossibleMoves
~~m~ <showPlayerHoles> type=Ludeme (metadata.graphics.show.Boolean.ShowPlayerHoles) => <showPlayerHoles>, pack=metadata.graphics.show.Boolean, label=showPlayerHoles, cls=metadata.graphics.show.Boolean.ShowPlayerHoles, keyword=showPlayerHoles
~~m~ <showLocalStateHoles> type=Ludeme (metadata.graphics.show.Boolean.ShowLocalStateHoles) => <showLocalStateHoles>, pack=metadata.graphics.show.Boolean, label=showLocalStateHoles, cls=metadata.graphics.show.Boolean.ShowLocalStateHoles, keyword=showLocalStateHoles
~~m~ <showPits> type=Ludeme (metadata.graphics.show.Boolean.ShowPits) => <showPits>, pack=metadata.graphics.show.Boolean, label=showPits, cls=metadata.graphics.show.Boolean.ShowPits, keyword=showPits
~~m~ <showStraightEdges> type=Ludeme (metadata.graphics.show.Boolean.ShowStraightEdges) => <showStraightEdges>, pack=metadata.graphics.show.Boolean, label=showStraightEdges, cls=metadata.graphics.show.Boolean.ShowStraightEdges, keyword=showStraightEdges
~~m~ <showPieceValue> type=Ludeme (metadata.graphics.show.component.ShowPieceValue) => <showPieceValue>, pack=metadata.graphics.show.component, label=showPieceValue, cls=metadata.graphics.show.component.ShowPieceValue, keyword=showPieceValue
~~m~ <showPieceState> type=Ludeme (metadata.graphics.show.component.ShowPieceState) => <showPieceState>, pack=metadata.graphics.show.component, label=showPieceState, cls=metadata.graphics.show.component.ShowPieceState, keyword=showPieceState
~~~~ <showEdgeType> type=Structural (metadata.graphics.show.ShowEdgeType) => <showEdgeType>, pack=metadata.graphics.show, label=showEdgeType, cls=metadata.graphics.show.ShowEdgeType, keyword=showEdgeType
gd~~ Start type=Constant (game.functions.region.sites.SitesPieceType.Start) => <sitesPieceType>, pack=game.functions.region.sites, label=Start, cls=game.functions.region.sites.SitesPieceType, keyword=Start
gd~~ Incident type=Constant (game.functions.region.sites.SitesIncidentType.Incident) => <sitesIncidentType>, pack=game.functions.region.sites, label=Incident, cls=game.functions.region.sites.SitesIncidentType, keyword=Incident
gd~~ Around type=Constant (game.functions.region.sites.SitesAroundType.Around) => <sitesAroundType>, pack=game.functions.region.sites, label=Around, cls=game.functions.region.sites.SitesAroundType, keyword=Around
gd~~ Random type=Constant (game.functions.region.sites.SitesRandomType.Random) => <sitesRandomType>, pack=game.functions.region.sites, label=Random, cls=game.functions.region.sites.SitesRandomType, keyword=Random
gd~~ Hand type=Constant (game.functions.region.sites.SitesPlayerType.Hand) => <sitesPlayerType>, pack=game.functions.region.sites, label=Hand, cls=game.functions.region.sites.SitesPlayerType, keyword=Hand
gd~~ Winning type=Constant (game.functions.region.sites.SitesPlayerType.Winning) => <sitesPlayerType>, pack=game.functions.region.sites, label=Winning, cls=game.functions.region.sites.SitesPlayerType, keyword=Winning
gd~~ Visible type=Constant (game.functions.region.sites.SitesPlayerType.Visible) => <sitesPlayerType>, pack=game.functions.region.sites, label=Visible, cls=game.functions.region.sites.SitesPlayerType, keyword=Visible
gd~~ Masked type=Constant (game.functions.region.sites.SitesPlayerType.Masked) => <sitesPlayerType>, pack=game.functions.region.sites, label=Masked, cls=game.functions.region.sites.SitesPlayerType, keyword=Masked
gd~~ Invisible type=Constant (game.functions.region.sites.SitesPlayerType.Invisible) => <sitesPlayerType>, pack=game.functions.region.sites, label=Invisible, cls=game.functions.region.sites.SitesPlayerType, keyword=Invisible
gd~~ LargePiece type=Constant (game.functions.region.sites.SitesLargePieceType.LargePiece) => <sitesLargePieceType>, pack=game.functions.region.sites, label=LargePiece, cls=game.functions.region.sites.SitesLargePieceType, keyword=LargePiece
gd~~ Group type=Constant (game.functions.region.sites.SitesGroupType.Group) => <sitesGroupType>, pack=game.functions.region.sites, label=Group, cls=game.functions.region.sites.SitesGroupType, keyword=Group
gd~~ Row type=Constant (game.functions.region.sites.SitesIndexType.Row) => <sitesIndexType>, pack=game.functions.region.sites, label=Row, cls=game.functions.region.sites.SitesIndexType, keyword=Row
gd~~ Column type=Constant (game.functions.region.sites.SitesIndexType.Column) => <sitesIndexType>, pack=game.functions.region.sites, label=Column, cls=game.functions.region.sites.SitesIndexType, keyword=Column
gd~~ Phase type=Constant (game.functions.region.sites.SitesIndexType.Phase) => <sitesIndexType>, pack=game.functions.region.sites, label=Phase, cls=game.functions.region.sites.SitesIndexType, keyword=Phase
gd~~ Cell type=Constant (game.functions.region.sites.SitesIndexType.Cell) => <sitesIndexType>, pack=game.functions.region.sites, label=Cell, cls=game.functions.region.sites.SitesIndexType, keyword=Cell
gd~~ Edge type=Constant (game.functions.region.sites.SitesIndexType.Edge) => <sitesIndexType>, pack=game.functions.region.sites, label=Edge, cls=game.functions.region.sites.SitesIndexType, keyword=Edge
gd~~ State type=Constant (game.functions.region.sites.SitesIndexType.State) => <sitesIndexType>, pack=game.functions.region.sites, label=State, cls=game.functions.region.sites.SitesIndexType, keyword=State
gd~~ Empty type=Constant (game.functions.region.sites.SitesIndexType.Empty) => <sitesIndexType>, pack=game.functions.region.sites, label=Empty, cls=game.functions.region.sites.SitesIndexType, keyword=Empty
gd~~ Layer type=Constant (game.functions.region.sites.SitesIndexType.Layer) => <sitesIndexType>, pack=game.functions.region.sites, label=Layer, cls=game.functions.region.sites.SitesIndexType, keyword=Layer
gd~~ Pattern type=Constant (game.functions.region.sites.SitesPatternType.Pattern) => <sitesPatternType>, pack=game.functions.region.sites, label=Pattern, cls=game.functions.region.sites.SitesPatternType, keyword=Pattern
gd~~ Between type=Constant (game.functions.region.sites.SitesBetweenType.Between) => <sitesBetweenType>, pack=game.functions.region.sites, label=Between, cls=game.functions.region.sites.SitesBetweenType, keyword=Between
gd~~ Board type=Constant (game.functions.region.sites.SitesSimpleType.Board) => <sitesSimpleType>, pack=game.functions.region.sites, label=Board, cls=game.functions.region.sites.SitesSimpleType, keyword=Board
gd~~ Top type=Constant (game.functions.region.sites.SitesSimpleType.Top) => <sitesSimpleType>, pack=game.functions.region.sites, label=Top, cls=game.functions.region.sites.SitesSimpleType, keyword=Top
gd~~ Bottom type=Constant (game.functions.region.sites.SitesSimpleType.Bottom) => <sitesSimpleType>, pack=game.functions.region.sites, label=Bottom, cls=game.functions.region.sites.SitesSimpleType, keyword=Bottom
gd~~ Left type=Constant (game.functions.region.sites.SitesSimpleType.Left) => <sitesSimpleType>, pack=game.functions.region.sites, label=Left, cls=game.functions.region.sites.SitesSimpleType, keyword=Left
gd~~ Right type=Constant (game.functions.region.sites.SitesSimpleType.Right) => <sitesSimpleType>, pack=game.functions.region.sites, label=Right, cls=game.functions.region.sites.SitesSimpleType, keyword=Right
gd~~ Inner type=Constant (game.functions.region.sites.SitesSimpleType.Inner) => <sitesSimpleType>, pack=game.functions.region.sites, label=Inner, cls=game.functions.region.sites.SitesSimpleType, keyword=Inner
gd~~ Outer type=Constant (game.functions.region.sites.SitesSimpleType.Outer) => <sitesSimpleType>, pack=game.functions.region.sites, label=Outer, cls=game.functions.region.sites.SitesSimpleType, keyword=Outer
gd~~ Perimeter type=Constant (game.functions.region.sites.SitesSimpleType.Perimeter) => <sitesSimpleType>, pack=game.functions.region.sites, label=Perimeter, cls=game.functions.region.sites.SitesSimpleType, keyword=Perimeter
gd~~ Corners type=Constant (game.functions.region.sites.SitesSimpleType.Corners) => <sitesSimpleType>, pack=game.functions.region.sites, label=Corners, cls=game.functions.region.sites.SitesSimpleType, keyword=Corners
gd~~ ConcaveCorners type=Constant (game.functions.region.sites.SitesSimpleType.ConcaveCorners) => <sitesSimpleType>, pack=game.functions.region.sites, label=ConcaveCorners, cls=game.functions.region.sites.SitesSimpleType, keyword=ConcaveCorners
gd~~ ConvexCorners type=Constant (game.functions.region.sites.SitesSimpleType.ConvexCorners) => <sitesSimpleType>, pack=game.functions.region.sites, label=ConvexCorners, cls=game.functions.region.sites.SitesSimpleType, keyword=ConvexCorners
gd~~ Major type=Constant (game.functions.region.sites.SitesSimpleType.Major) => <sitesSimpleType>, pack=game.functions.region.sites, label=Major, cls=game.functions.region.sites.SitesSimpleType, keyword=Major
gd~~ Minor type=Constant (game.functions.region.sites.SitesSimpleType.Minor) => <sitesSimpleType>, pack=game.functions.region.sites, label=Minor, cls=game.functions.region.sites.SitesSimpleType, keyword=Minor
gd~~ Centre type=Constant (game.functions.region.sites.SitesSimpleType.Centre) => <sitesSimpleType>, pack=game.functions.region.sites, label=Centre, cls=game.functions.region.sites.SitesSimpleType, keyword=Centre
gd~~ Hint type=Constant (game.functions.region.sites.SitesSimpleType.Hint) => <sitesSimpleType>, pack=game.functions.region.sites, label=Hint, cls=game.functions.region.sites.SitesSimpleType, keyword=Hint
gd~~ ToClear type=Constant (game.functions.region.sites.SitesSimpleType.ToClear) => <sitesSimpleType>, pack=game.functions.region.sites, label=ToClear, cls=game.functions.region.sites.SitesSimpleType, keyword=ToClear
gd~~ LineOfPlay type=Constant (game.functions.region.sites.SitesSimpleType.LineOfPlay) => <sitesSimpleType>, pack=game.functions.region.sites, label=LineOfPlay, cls=game.functions.region.sites.SitesSimpleType, keyword=LineOfPlay
gd~~ Pending type=Constant (game.functions.region.sites.SitesSimpleType.Pending) => <sitesSimpleType>, pack=game.functions.region.sites, label=Pending, cls=game.functions.region.sites.SitesSimpleType, keyword=Pending
gd~~ Playable type=Constant (game.functions.region.sites.SitesSimpleType.Playable) => <sitesSimpleType>, pack=game.functions.region.sites, label=Playable, cls=game.functions.region.sites.SitesSimpleType, keyword=Playable
gd~~ LastTo type=Constant (game.functions.region.sites.SitesSimpleType.LastTo) => <sitesSimpleType>, pack=game.functions.region.sites, label=LastTo, cls=game.functions.region.sites.SitesSimpleType, keyword=LastTo
gd~~ LastFrom type=Constant (game.functions.region.sites.SitesSimpleType.LastFrom) => <sitesSimpleType>, pack=game.functions.region.sites, label=LastFrom, cls=game.functions.region.sites.SitesSimpleType, keyword=LastFrom
gd~~ Empty type=Constant (game.functions.region.sites.LineOfSightType.Empty) => <lineOfSightType>, pack=game.functions.region.sites, label=Empty, cls=game.functions.region.sites.LineOfSightType, keyword=Empty
gd~~ Farthest type=Constant (game.functions.region.sites.LineOfSightType.Farthest) => <lineOfSightType>, pack=game.functions.region.sites, label=Farthest, cls=game.functions.region.sites.LineOfSightType, keyword=Farthest
gd~~ Piece type=Constant (game.functions.region.sites.LineOfSightType.Piece) => <lineOfSightType>, pack=game.functions.region.sites, label=Piece, cls=game.functions.region.sites.LineOfSightType, keyword=Piece
gd~~ Track type=Constant (game.functions.region.sites.SitesTrackType.Track) => <sitesTrackType>, pack=game.functions.region.sites, label=Track, cls=game.functions.region.sites.SitesTrackType, keyword=Track
gd~~ LineOfSight type=Constant (game.functions.region.sites.SitesLineOfSightType.LineOfSight) => <sitesLineOfSightType>, pack=game.functions.region.sites, label=LineOfSight, cls=game.functions.region.sites.SitesLineOfSightType, keyword=LineOfSight
gd~~ From type=Constant (game.functions.region.sites.SitesMoveType.From) => <sitesMoveType>, pack=game.functions.region.sites, label=From, cls=game.functions.region.sites.SitesMoveType, keyword=From
gd~~ Between type=Constant (game.functions.region.sites.SitesMoveType.Between) => <sitesMoveType>, pack=game.functions.region.sites, label=Between, cls=game.functions.region.sites.SitesMoveType, keyword=Between
gd~~ To type=Constant (game.functions.region.sites.SitesMoveType.To) => <sitesMoveType>, pack=game.functions.region.sites, label=To, cls=game.functions.region.sites.SitesMoveType, keyword=To
gd~~ Direction type=Constant (game.functions.region.sites.SitesDirectionType.Direction) => <sitesDirectionType>, pack=game.functions.region.sites, label=Direction, cls=game.functions.region.sites.SitesDirectionType, keyword=Direction
gd~~ Distance type=Constant (game.functions.region.sites.SitesDistanceType.Distance) => <sitesDistanceType>, pack=game.functions.region.sites, label=Distance, cls=game.functions.region.sites.SitesDistanceType, keyword=Distance
gd~~ Axial type=Constant (game.functions.region.sites.SitesEdgeType.Axial) => <sitesEdgeType>, pack=game.functions.region.sites, label=Axial, cls=game.functions.region.sites.SitesEdgeType, keyword=Axial
gd~~ Horizontal type=Constant (game.functions.region.sites.SitesEdgeType.Horizontal) => <sitesEdgeType>, pack=game.functions.region.sites, label=Horizontal, cls=game.functions.region.sites.SitesEdgeType, keyword=Horizontal
gd~~ Vertical type=Constant (game.functions.region.sites.SitesEdgeType.Vertical) => <sitesEdgeType>, pack=game.functions.region.sites, label=Vertical, cls=game.functions.region.sites.SitesEdgeType, keyword=Vertical
gd~~ Angled type=Constant (game.functions.region.sites.SitesEdgeType.Angled) => <sitesEdgeType>, pack=game.functions.region.sites, label=Angled, cls=game.functions.region.sites.SitesEdgeType, keyword=Angled
gd~~ Slash type=Constant (game.functions.region.sites.SitesEdgeType.Slash) => <sitesEdgeType>, pack=game.functions.region.sites, label=Slash, cls=game.functions.region.sites.SitesEdgeType, keyword=Slash
gd~~ Slosh type=Constant (game.functions.region.sites.SitesEdgeType.Slosh) => <sitesEdgeType>, pack=game.functions.region.sites, label=Slosh, cls=game.functions.region.sites.SitesEdgeType, keyword=Slosh
gd~~ Loop type=Constant (game.functions.region.sites.SitesLoopType.Loop) => <sitesLoopType>, pack=game.functions.region.sites, label=Loop, cls=game.functions.region.sites.SitesLoopType, keyword=Loop
gd~~ Hidden type=Constant (game.functions.region.sites.SitesHiddenType.Hidden) => <sitesHiddenType>, pack=game.functions.region.sites, label=Hidden, cls=game.functions.region.sites.SitesHiddenType, keyword=Hidden
gd~~ Side type=Constant (game.functions.region.sites.SitesSideType.Side) => <sitesSideType>, pack=game.functions.region.sites, label=Side, cls=game.functions.region.sites.SitesSideType, keyword=Side
gd~~ Occupied type=Constant (game.functions.region.sites.SitesOccupiedType.Occupied) => <sitesOccupiedType>, pack=game.functions.region.sites, label=Occupied, cls=game.functions.region.sites.SitesOccupiedType, keyword=Occupied
gd~~ Crossing type=Constant (game.functions.region.sites.SitesCrossingType.Crossing) => <sitesCrossingType>, pack=game.functions.region.sites, label=Crossing, cls=game.functions.region.sites.SitesCrossingType, keyword=Crossing
gd~~ Between type=Constant (game.functions.region.last.LastRegionType.Between) => <lastRegionType>, pack=game.functions.region.last, label=Between, cls=game.functions.region.last.LastRegionType, keyword=Between
gd~~ Values type=Constant (game.functions.booleans.all.AllValuesType.Values) => <allValuesType>, pack=game.functions.booleans.all, label=Values, cls=game.functions.booleans.all.AllValuesType, keyword=Values
gd~~ Sites type=Constant (game.functions.booleans.all.AllSitesType.Sites) => <allSitesType>, pack=game.functions.booleans.all, label=Sites, cls=game.functions.booleans.all.AllSitesType, keyword=Sites
gd~~ DiceUsed type=Constant (game.functions.booleans.all.AllSimpleType.DiceUsed) => <allSimpleType>, pack=game.functions.booleans.all, label=DiceUsed, cls=game.functions.booleans.all.AllSimpleType, keyword=DiceUsed
gd~~ DiceEqual type=Constant (game.functions.booleans.all.AllSimpleType.DiceEqual) => <allSimpleType>, pack=game.functions.booleans.all, label=DiceEqual, cls=game.functions.booleans.all.AllSimpleType, keyword=DiceEqual
gd~~ Passed type=Constant (game.functions.booleans.all.AllSimpleType.Passed) => <allSimpleType>, pack=game.functions.booleans.all, label=Passed, cls=game.functions.booleans.all.AllSimpleType, keyword=Passed
gd~~ Moves type=Constant (game.functions.booleans.no.NoType.Moves) => <noType>, pack=game.functions.booleans.no, label=Moves, cls=game.functions.booleans.no.NoType, keyword=Moves
gd~~ Pass type=Constant (game.functions.booleans.was.WasType.Pass) => <wasType>, pack=game.functions.booleans.was, label=Pass, cls=game.functions.booleans.was.WasType, keyword=Pass
gd~~ Move type=Constant (game.functions.booleans.can.CanType.Move) => <canType>, pack=game.functions.booleans.can, label=Move, cls=game.functions.booleans.can.CanType, keyword=Move
gd~~ Line type=Constant (game.functions.booleans.is.IsLineType.Line) => <isLineType>, pack=game.functions.booleans.is, label=Line, cls=game.functions.booleans.is.IsLineType, keyword=Line
gd~~ Crossing type=Constant (game.functions.booleans.is.IsEdgeType.Crossing) => <isEdgeType>, pack=game.functions.booleans.is, label=Crossing, cls=game.functions.booleans.is.IsEdgeType, keyword=Crossing
gd~~ Related type=Constant (game.functions.booleans.is.IsRelationType.Related) => <isRelationType>, pack=game.functions.booleans.is, label=Related, cls=game.functions.booleans.is.IsRelationType, keyword=Related
gd~~ Mover type=Constant (game.functions.booleans.is.IsPlayerType.Mover) => <isPlayerType>, pack=game.functions.booleans.is, label=Mover, cls=game.functions.booleans.is.IsPlayerType, keyword=Mover
gd~~ Next type=Constant (game.functions.booleans.is.IsPlayerType.Next) => <isPlayerType>, pack=game.functions.booleans.is, label=Next, cls=game.functions.booleans.is.IsPlayerType, keyword=Next
gd~~ Prev type=Constant (game.functions.booleans.is.IsPlayerType.Prev) => <isPlayerType>, pack=game.functions.booleans.is, label=Prev, cls=game.functions.booleans.is.IsPlayerType, keyword=Prev
gd~~ Friend type=Constant (game.functions.booleans.is.IsPlayerType.Friend) => <isPlayerType>, pack=game.functions.booleans.is, label=Friend, cls=game.functions.booleans.is.IsPlayerType, keyword=Friend
gd~~ Enemy type=Constant (game.functions.booleans.is.IsPlayerType.Enemy) => <isPlayerType>, pack=game.functions.booleans.is, label=Enemy, cls=game.functions.booleans.is.IsPlayerType, keyword=Enemy
gd~~ Active type=Constant (game.functions.booleans.is.IsPlayerType.Active) => <isPlayerType>, pack=game.functions.booleans.is, label=Active, cls=game.functions.booleans.is.IsPlayerType, keyword=Active
gd~~ Target type=Constant (game.functions.booleans.is.IsTargetType.Target) => <isTargetType>, pack=game.functions.booleans.is, label=Target, cls=game.functions.booleans.is.IsTargetType, keyword=Target
gd~~ Path type=Constant (game.functions.booleans.is.IsPathType.Path) => <isPathType>, pack=game.functions.booleans.is, label=Path, cls=game.functions.booleans.is.IsPathType, keyword=Path
gd~~ Loop type=Constant (game.functions.booleans.is.IsLoopType.Loop) => <isLoopType>, pack=game.functions.booleans.is, label=Loop, cls=game.functions.booleans.is.IsLoopType, keyword=Loop
gd~~ Hidden type=Constant (game.functions.booleans.is.IsHiddenType.Hidden) => <isHiddenType>, pack=game.functions.booleans.is, label=Hidden, cls=game.functions.booleans.is.IsHiddenType, keyword=Hidden
gd~~ Triggered type=Constant (game.functions.booleans.is.IsTriggeredType.Triggered) => <isTriggeredType>, pack=game.functions.booleans.is, label=Triggered, cls=game.functions.booleans.is.IsTriggeredType, keyword=Triggered
gd~~ LastFrom type=Constant (game.functions.booleans.is.IsGraphType.LastFrom) => <isGraphType>, pack=game.functions.booleans.is, label=LastFrom, cls=game.functions.booleans.is.IsGraphType, keyword=LastFrom
gd~~ LastTo type=Constant (game.functions.booleans.is.IsGraphType.LastTo) => <isGraphType>, pack=game.functions.booleans.is, label=LastTo, cls=game.functions.booleans.is.IsGraphType, keyword=LastTo
gd~~ Connected type=Constant (game.functions.booleans.is.IsConnectType.Connected) => <isConnectType>, pack=game.functions.booleans.is, label=Connected, cls=game.functions.booleans.is.IsConnectType, keyword=Connected
gd~~ Blocked type=Constant (game.functions.booleans.is.IsConnectType.Blocked) => <isConnectType>, pack=game.functions.booleans.is, label=Blocked, cls=game.functions.booleans.is.IsConnectType, keyword=Blocked
gd~~ Pattern type=Constant (game.functions.booleans.is.IsPatternType.Pattern) => <isPatternType>, pack=game.functions.booleans.is, label=Pattern, cls=game.functions.booleans.is.IsPatternType, keyword=Pattern
gd~~ Proposed type=Constant (game.functions.booleans.is.IsStringType.Proposed) => <isStringType>, pack=game.functions.booleans.is, label=Proposed, cls=game.functions.booleans.is.IsStringType, keyword=Proposed
gd~~ Decided type=Constant (game.functions.booleans.is.IsStringType.Decided) => <isStringType>, pack=game.functions.booleans.is, label=Decided, cls=game.functions.booleans.is.IsStringType, keyword=Decided
gd~~ Repeat type=Constant (game.functions.booleans.is.IsRepeatType.Repeat) => <isRepeatType>, pack=game.functions.booleans.is, label=Repeat, cls=game.functions.booleans.is.IsRepeatType, keyword=Repeat
gd~~ Threatened type=Constant (game.functions.booleans.is.IsComponentType.Threatened) => <isComponentType>, pack=game.functions.booleans.is, label=Threatened, cls=game.functions.booleans.is.IsComponentType, keyword=Threatened
gd~~ Within type=Constant (game.functions.booleans.is.IsComponentType.Within) => <isComponentType>, pack=game.functions.booleans.is, label=Within, cls=game.functions.booleans.is.IsComponentType, keyword=Within
gd~~ Empty type=Constant (game.functions.booleans.is.IsSiteType.Empty) => <isSiteType>, pack=game.functions.booleans.is, label=Empty, cls=game.functions.booleans.is.IsSiteType, keyword=Empty
gd~~ Occupied type=Constant (game.functions.booleans.is.IsSiteType.Occupied) => <isSiteType>, pack=game.functions.booleans.is, label=Occupied, cls=game.functions.booleans.is.IsSiteType, keyword=Occupied
gd~~ Odd type=Constant (game.functions.booleans.is.IsIntegerType.Odd) => <isIntegerType>, pack=game.functions.booleans.is, label=Odd, cls=game.functions.booleans.is.IsIntegerType, keyword=Odd
gd~~ Even type=Constant (game.functions.booleans.is.IsIntegerType.Even) => <isIntegerType>, pack=game.functions.booleans.is, label=Even, cls=game.functions.booleans.is.IsIntegerType, keyword=Even
gd~~ Visited type=Constant (game.functions.booleans.is.IsIntegerType.Visited) => <isIntegerType>, pack=game.functions.booleans.is, label=Visited, cls=game.functions.booleans.is.IsIntegerType, keyword=Visited
gd~~ SidesMatch type=Constant (game.functions.booleans.is.IsIntegerType.SidesMatch) => <isIntegerType>, pack=game.functions.booleans.is, label=SidesMatch, cls=game.functions.booleans.is.IsIntegerType, keyword=SidesMatch
gd~~ PipsMatch type=Constant (game.functions.booleans.is.IsIntegerType.PipsMatch) => <isIntegerType>, pack=game.functions.booleans.is, label=PipsMatch, cls=game.functions.booleans.is.IsIntegerType, keyword=PipsMatch
gd~~ Flat type=Constant (game.functions.booleans.is.IsIntegerType.Flat) => <isIntegerType>, pack=game.functions.booleans.is, label=Flat, cls=game.functions.booleans.is.IsIntegerType, keyword=Flat
gd~~ AnyDie type=Constant (game.functions.booleans.is.IsIntegerType.AnyDie) => <isIntegerType>, pack=game.functions.booleans.is, label=AnyDie, cls=game.functions.booleans.is.IsIntegerType, keyword=AnyDie
gd~~ RegularGraph type=Constant (game.functions.booleans.is.IsRegularGraphType.RegularGraph) => <isRegularGraphType>, pack=game.functions.booleans.is, label=RegularGraph, cls=game.functions.booleans.is.IsRegularGraphType, keyword=RegularGraph
gd~~ Cycle type=Constant (game.functions.booleans.is.IsSimpleType.Cycle) => <isSimpleType>, pack=game.functions.booleans.is, label=Cycle, cls=game.functions.booleans.is.IsSimpleType, keyword=Cycle
gd~~ Pending type=Constant (game.functions.booleans.is.IsSimpleType.Pending) => <isSimpleType>, pack=game.functions.booleans.is, label=Pending, cls=game.functions.booleans.is.IsSimpleType, keyword=Pending
gd~~ Full type=Constant (game.functions.booleans.is.IsSimpleType.Full) => <isSimpleType>, pack=game.functions.booleans.is, label=Full, cls=game.functions.booleans.is.IsSimpleType, keyword=Full
gd~~ Tree type=Constant (game.functions.booleans.is.IsTreeType.Tree) => <isTreeType>, pack=game.functions.booleans.is, label=Tree, cls=game.functions.booleans.is.IsTreeType, keyword=Tree
gd~~ SpanningTree type=Constant (game.functions.booleans.is.IsTreeType.SpanningTree) => <isTreeType>, pack=game.functions.booleans.is, label=SpanningTree, cls=game.functions.booleans.is.IsTreeType, keyword=SpanningTree
gd~~ CaterpillarTree type=Constant (game.functions.booleans.is.IsTreeType.CaterpillarTree) => <isTreeType>, pack=game.functions.booleans.is, label=CaterpillarTree, cls=game.functions.booleans.is.IsTreeType, keyword=CaterpillarTree
gd~~ TreeCentre type=Constant (game.functions.booleans.is.IsTreeType.TreeCentre) => <isTreeType>, pack=game.functions.booleans.is, label=TreeCentre, cls=game.functions.booleans.is.IsTreeType, keyword=TreeCentre
gd~~ In type=Constant (game.functions.booleans.is.IsInType.In) => <isInType>, pack=game.functions.booleans.is, label=In, cls=game.functions.booleans.is.IsInType, keyword=In
gd~~ Different type=Constant (game.functions.booleans.deductionPuzzle.all.AllPuzzleType.Different) => <allPuzzleType>, pack=game.functions.booleans.deductionPuzzle.all, label=Different, cls=game.functions.booleans.deductionPuzzle.all.AllPuzzleType, keyword=Different
gd~~ Count type=Constant (game.functions.booleans.deductionPuzzle.is.IsPuzzleRegionResultType.Count) => <isPuzzleRegionResultType>, pack=game.functions.booleans.deductionPuzzle.is, label=Count, cls=game.functions.booleans.deductionPuzzle.is.IsPuzzleRegionResultType, keyword=Count
gd~~ Sum type=Constant (game.functions.booleans.deductionPuzzle.is.IsPuzzleRegionResultType.Sum) => <isPuzzleRegionResultType>, pack=game.functions.booleans.deductionPuzzle.is, label=Sum, cls=game.functions.booleans.deductionPuzzle.is.IsPuzzleRegionResultType, keyword=Sum
gd~~ Unique type=Constant (game.functions.booleans.deductionPuzzle.is.IsPuzzleGraphType.Unique) => <isPuzzleGraphType>, pack=game.functions.booleans.deductionPuzzle.is, label=Unique, cls=game.functions.booleans.deductionPuzzle.is.IsPuzzleGraphType, keyword=Unique
gd~~ Solved type=Constant (game.functions.booleans.deductionPuzzle.is.IsPuzzleSimpleType.Solved) => <isPuzzleSimpleType>, pack=game.functions.booleans.deductionPuzzle.is, label=Solved, cls=game.functions.booleans.deductionPuzzle.is.IsPuzzleSimpleType, keyword=Solved
gd~~ NoShape type=Constant (game.functions.graph.generators.basis.tri.TriShapeType.NoShape) => <triShapeType>, pack=game.functions.graph.generators.basis.tri, label=NoShape, cls=game.functions.graph.generators.basis.tri.TriShapeType, keyword=NoShape
gd~~ Square type=Constant (game.functions.graph.generators.basis.tri.TriShapeType.Square) => <triShapeType>, pack=game.functions.graph.generators.basis.tri, label=Square, cls=game.functions.graph.generators.basis.tri.TriShapeType, keyword=Square
gd~~ Rectangle type=Constant (game.functions.graph.generators.basis.tri.TriShapeType.Rectangle) => <triShapeType>, pack=game.functions.graph.generators.basis.tri, label=Rectangle, cls=game.functions.graph.generators.basis.tri.TriShapeType, keyword=Rectangle
gd~~ Diamond type=Constant (game.functions.graph.generators.basis.tri.TriShapeType.Diamond) => <triShapeType>, pack=game.functions.graph.generators.basis.tri, label=Diamond, cls=game.functions.graph.generators.basis.tri.TriShapeType, keyword=Diamond
gd~~ Triangle type=Constant (game.functions.graph.generators.basis.tri.TriShapeType.Triangle) => <triShapeType>, pack=game.functions.graph.generators.basis.tri, label=Triangle, cls=game.functions.graph.generators.basis.tri.TriShapeType, keyword=Triangle
gd~~ Hexagon type=Constant (game.functions.graph.generators.basis.tri.TriShapeType.Hexagon) => <triShapeType>, pack=game.functions.graph.generators.basis.tri, label=Hexagon, cls=game.functions.graph.generators.basis.tri.TriShapeType, keyword=Hexagon
gd~~ Star type=Constant (game.functions.graph.generators.basis.tri.TriShapeType.Star) => <triShapeType>, pack=game.functions.graph.generators.basis.tri, label=Star, cls=game.functions.graph.generators.basis.tri.TriShapeType, keyword=Star
gd~~ Limping type=Constant (game.functions.graph.generators.basis.tri.TriShapeType.Limping) => <triShapeType>, pack=game.functions.graph.generators.basis.tri, label=Limping, cls=game.functions.graph.generators.basis.tri.TriShapeType, keyword=Limping
gd~~ Prism type=Constant (game.functions.graph.generators.basis.tri.TriShapeType.Prism) => <triShapeType>, pack=game.functions.graph.generators.basis.tri, label=Prism, cls=game.functions.graph.generators.basis.tri.TriShapeType, keyword=Prism
gd~~ T31212 type=Constant (game.functions.graph.generators.basis.tiling.TilingType.T31212) => <tilingType>, pack=game.functions.graph.generators.basis.tiling, label=T31212, cls=game.functions.graph.generators.basis.tiling.TilingType, keyword=T31212
gd~~ T3464 type=Constant (game.functions.graph.generators.basis.tiling.TilingType.T3464) => <tilingType>, pack=game.functions.graph.generators.basis.tiling, label=T3464, cls=game.functions.graph.generators.basis.tiling.TilingType, keyword=T3464
gd~~ T488 type=Constant (game.functions.graph.generators.basis.tiling.TilingType.T488) => <tilingType>, pack=game.functions.graph.generators.basis.tiling, label=T488, cls=game.functions.graph.generators.basis.tiling.TilingType, keyword=T488
gd~~ T33434 type=Constant (game.functions.graph.generators.basis.tiling.TilingType.T33434) => <tilingType>, pack=game.functions.graph.generators.basis.tiling, label=T33434, cls=game.functions.graph.generators.basis.tiling.TilingType, keyword=T33434
gd~~ T33336 type=Constant (game.functions.graph.generators.basis.tiling.TilingType.T33336) => <tilingType>, pack=game.functions.graph.generators.basis.tiling, label=T33336, cls=game.functions.graph.generators.basis.tiling.TilingType, keyword=T33336
gd~~ T33344 type=Constant (game.functions.graph.generators.basis.tiling.TilingType.T33344) => <tilingType>, pack=game.functions.graph.generators.basis.tiling, label=T33344, cls=game.functions.graph.generators.basis.tiling.TilingType, keyword=T33344
gd~~ T3636 type=Constant (game.functions.graph.generators.basis.tiling.TilingType.T3636) => <tilingType>, pack=game.functions.graph.generators.basis.tiling, label=T3636, cls=game.functions.graph.generators.basis.tiling.TilingType, keyword=T3636
gd~~ T4612 type=Constant (game.functions.graph.generators.basis.tiling.TilingType.T4612) => <tilingType>, pack=game.functions.graph.generators.basis.tiling, label=T4612, cls=game.functions.graph.generators.basis.tiling.TilingType, keyword=T4612
gd~~ T333333_33434 type=Constant (game.functions.graph.generators.basis.tiling.TilingType.T333333_33434) => <tilingType>, pack=game.functions.graph.generators.basis.tiling, label=T333333_33434, cls=game.functions.graph.generators.basis.tiling.TilingType, keyword=T333333_33434
~~m~ Custom type=Constant (game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType.Custom) => <tiling3464ShapeType>, pack=game.functions.graph.generators.basis.tiling.tiling3464, label=Custom, cls=game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType, keyword=Custom
~~m~ Square type=Constant (game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType.Square) => <tiling3464ShapeType>, pack=game.functions.graph.generators.basis.tiling.tiling3464, label=Square, cls=game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType, keyword=Square
~~m~ Rectangle type=Constant (game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType.Rectangle) => <tiling3464ShapeType>, pack=game.functions.graph.generators.basis.tiling.tiling3464, label=Rectangle, cls=game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType, keyword=Rectangle
~~m~ Diamond type=Constant (game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType.Diamond) => <tiling3464ShapeType>, pack=game.functions.graph.generators.basis.tiling.tiling3464, label=Diamond, cls=game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType, keyword=Diamond
~~m~ Prism type=Constant (game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType.Prism) => <tiling3464ShapeType>, pack=game.functions.graph.generators.basis.tiling.tiling3464, label=Prism, cls=game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType, keyword=Prism
~~m~ Triangle type=Constant (game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType.Triangle) => <tiling3464ShapeType>, pack=game.functions.graph.generators.basis.tiling.tiling3464, label=Triangle, cls=game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType, keyword=Triangle
~~m~ Hexagon type=Constant (game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType.Hexagon) => <tiling3464ShapeType>, pack=game.functions.graph.generators.basis.tiling.tiling3464, label=Hexagon, cls=game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType, keyword=Hexagon
~~m~ Star type=Constant (game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType.Star) => <tiling3464ShapeType>, pack=game.functions.graph.generators.basis.tiling.tiling3464, label=Star, cls=game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType, keyword=Star
~~m~ Limping type=Constant (game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType.Limping) => <tiling3464ShapeType>, pack=game.functions.graph.generators.basis.tiling.tiling3464, label=Limping, cls=game.functions.graph.generators.basis.tiling.tiling3464.Tiling3464ShapeType, keyword=Limping
gd~~ NoShape type=Constant (game.functions.graph.generators.basis.hex.HexShapeType.NoShape) => <hexShapeType>, pack=game.functions.graph.generators.basis.hex, label=NoShape, cls=game.functions.graph.generators.basis.hex.HexShapeType, keyword=NoShape
gd~~ Square type=Constant (game.functions.graph.generators.basis.hex.HexShapeType.Square) => <hexShapeType>, pack=game.functions.graph.generators.basis.hex, label=Square, cls=game.functions.graph.generators.basis.hex.HexShapeType, keyword=Square
gd~~ Rectangle type=Constant (game.functions.graph.generators.basis.hex.HexShapeType.Rectangle) => <hexShapeType>, pack=game.functions.graph.generators.basis.hex, label=Rectangle, cls=game.functions.graph.generators.basis.hex.HexShapeType, keyword=Rectangle
gd~~ Diamond type=Constant (game.functions.graph.generators.basis.hex.HexShapeType.Diamond) => <hexShapeType>, pack=game.functions.graph.generators.basis.hex, label=Diamond, cls=game.functions.graph.generators.basis.hex.HexShapeType, keyword=Diamond
gd~~ Triangle type=Constant (game.functions.graph.generators.basis.hex.HexShapeType.Triangle) => <hexShapeType>, pack=game.functions.graph.generators.basis.hex, label=Triangle, cls=game.functions.graph.generators.basis.hex.HexShapeType, keyword=Triangle
gd~~ Hexagon type=Constant (game.functions.graph.generators.basis.hex.HexShapeType.Hexagon) => <hexShapeType>, pack=game.functions.graph.generators.basis.hex, label=Hexagon, cls=game.functions.graph.generators.basis.hex.HexShapeType, keyword=Hexagon
gd~~ Star type=Constant (game.functions.graph.generators.basis.hex.HexShapeType.Star) => <hexShapeType>, pack=game.functions.graph.generators.basis.hex, label=Star, cls=game.functions.graph.generators.basis.hex.HexShapeType, keyword=Star
gd~~ Limping type=Constant (game.functions.graph.generators.basis.hex.HexShapeType.Limping) => <hexShapeType>, pack=game.functions.graph.generators.basis.hex, label=Limping, cls=game.functions.graph.generators.basis.hex.HexShapeType, keyword=Limping
gd~~ Prism type=Constant (game.functions.graph.generators.basis.hex.HexShapeType.Prism) => <hexShapeType>, pack=game.functions.graph.generators.basis.hex, label=Prism, cls=game.functions.graph.generators.basis.hex.HexShapeType, keyword=Prism
gd~~ NoShape type=Constant (game.functions.graph.generators.basis.square.SquareShapeType.NoShape) => <squareShapeType>, pack=game.functions.graph.generators.basis.square, label=NoShape, cls=game.functions.graph.generators.basis.square.SquareShapeType, keyword=NoShape
gd~~ Square type=Constant (game.functions.graph.generators.basis.square.SquareShapeType.Square) => <squareShapeType>, pack=game.functions.graph.generators.basis.square, label=Square, cls=game.functions.graph.generators.basis.square.SquareShapeType, keyword=Square
gd~~ Rectangle type=Constant (game.functions.graph.generators.basis.square.SquareShapeType.Rectangle) => <squareShapeType>, pack=game.functions.graph.generators.basis.square, label=Rectangle, cls=game.functions.graph.generators.basis.square.SquareShapeType, keyword=Rectangle
gd~~ Diamond type=Constant (game.functions.graph.generators.basis.square.SquareShapeType.Diamond) => <squareShapeType>, pack=game.functions.graph.generators.basis.square, label=Diamond, cls=game.functions.graph.generators.basis.square.SquareShapeType, keyword=Diamond
gd~~ Limping type=Constant (game.functions.graph.generators.basis.square.SquareShapeType.Limping) => <squareShapeType>, pack=game.functions.graph.generators.basis.square, label=Limping, cls=game.functions.graph.generators.basis.square.SquareShapeType, keyword=Limping
gd~~ Implied type=Constant (game.functions.graph.generators.basis.square.DiagonalsType.Implied) => <diagonalsType>, pack=game.functions.graph.generators.basis.square, label=Implied, cls=game.functions.graph.generators.basis.square.DiagonalsType, keyword=Implied
gd~~ Solid type=Constant (game.functions.graph.generators.basis.square.DiagonalsType.Solid) => <diagonalsType>, pack=game.functions.graph.generators.basis.square, label=Solid, cls=game.functions.graph.generators.basis.square.DiagonalsType, keyword=Solid
gd~~ Alternating type=Constant (game.functions.graph.generators.basis.square.DiagonalsType.Alternating) => <diagonalsType>, pack=game.functions.graph.generators.basis.square, label=Alternating, cls=game.functions.graph.generators.basis.square.DiagonalsType, keyword=Alternating
gd~~ Concentric type=Constant (game.functions.graph.generators.basis.square.DiagonalsType.Concentric) => <diagonalsType>, pack=game.functions.graph.generators.basis.square, label=Concentric, cls=game.functions.graph.generators.basis.square.DiagonalsType, keyword=Concentric
gd~~ Radiating type=Constant (game.functions.graph.generators.basis.square.DiagonalsType.Radiating) => <diagonalsType>, pack=game.functions.graph.generators.basis.square, label=Radiating, cls=game.functions.graph.generators.basis.square.DiagonalsType, keyword=Radiating
gd~~ Square type=Constant (game.functions.graph.generators.basis.brick.BrickShapeType.Square) => <brickShapeType>, pack=game.functions.graph.generators.basis.brick, label=Square, cls=game.functions.graph.generators.basis.brick.BrickShapeType, keyword=Square
gd~~ Rectangle type=Constant (game.functions.graph.generators.basis.brick.BrickShapeType.Rectangle) => <brickShapeType>, pack=game.functions.graph.generators.basis.brick, label=Rectangle, cls=game.functions.graph.generators.basis.brick.BrickShapeType, keyword=Rectangle
gd~~ Diamond type=Constant (game.functions.graph.generators.basis.brick.BrickShapeType.Diamond) => <brickShapeType>, pack=game.functions.graph.generators.basis.brick, label=Diamond, cls=game.functions.graph.generators.basis.brick.BrickShapeType, keyword=Diamond
gd~~ Prism type=Constant (game.functions.graph.generators.basis.brick.BrickShapeType.Prism) => <brickShapeType>, pack=game.functions.graph.generators.basis.brick, label=Prism, cls=game.functions.graph.generators.basis.brick.BrickShapeType, keyword=Prism
gd~~ Spiral type=Constant (game.functions.graph.generators.basis.brick.BrickShapeType.Spiral) => <brickShapeType>, pack=game.functions.graph.generators.basis.brick, label=Spiral, cls=game.functions.graph.generators.basis.brick.BrickShapeType, keyword=Spiral
gd~~ Limping type=Constant (game.functions.graph.generators.basis.brick.BrickShapeType.Limping) => <brickShapeType>, pack=game.functions.graph.generators.basis.brick, label=Limping, cls=game.functions.graph.generators.basis.brick.BrickShapeType, keyword=Limping
gd~~ Square type=Constant (game.functions.graph.generators.shape.concentric.ConcentricShapeType.Square) => <concentricShapeType>, pack=game.functions.graph.generators.shape.concentric, label=Square, cls=game.functions.graph.generators.shape.concentric.ConcentricShapeType, keyword=Square
gd~~ Triangle type=Constant (game.functions.graph.generators.shape.concentric.ConcentricShapeType.Triangle) => <concentricShapeType>, pack=game.functions.graph.generators.shape.concentric, label=Triangle, cls=game.functions.graph.generators.shape.concentric.ConcentricShapeType, keyword=Triangle
gd~~ Hexagon type=Constant (game.functions.graph.generators.shape.concentric.ConcentricShapeType.Hexagon) => <concentricShapeType>, pack=game.functions.graph.generators.shape.concentric, label=Hexagon, cls=game.functions.graph.generators.shape.concentric.ConcentricShapeType, keyword=Hexagon
gd~~ Target type=Constant (game.functions.graph.generators.shape.concentric.ConcentricShapeType.Target) => <concentricShapeType>, pack=game.functions.graph.generators.shape.concentric, label=Target, cls=game.functions.graph.generators.shape.concentric.ConcentricShapeType, keyword=Target
gd~~ Star type=Constant (game.functions.graph.generators.shape.ShapeStarType.Star) => <shapeStarType>, pack=game.functions.graph.generators.shape, label=Star, cls=game.functions.graph.generators.shape.ShapeStarType, keyword=Star
gd~~ Rank type=Constant (game.functions.ints.card.CardSiteType.Rank) => <cardSiteType>, pack=game.functions.ints.card, label=Rank, cls=game.functions.ints.card.CardSiteType, keyword=Rank
gd~~ Suit type=Constant (game.functions.ints.card.CardSiteType.Suit) => <cardSiteType>, pack=game.functions.ints.card, label=Suit, cls=game.functions.ints.card.CardSiteType, keyword=Suit
gd~~ TrumpValue type=Constant (game.functions.ints.card.CardSiteType.TrumpValue) => <cardSiteType>, pack=game.functions.ints.card, label=TrumpValue, cls=game.functions.ints.card.CardSiteType, keyword=TrumpValue
gd~~ TrumpRank type=Constant (game.functions.ints.card.CardSiteType.TrumpRank) => <cardSiteType>, pack=game.functions.ints.card, label=TrumpRank, cls=game.functions.ints.card.CardSiteType, keyword=TrumpRank
gd~~ TrumpSuit type=Constant (game.functions.ints.card.CardSimpleType.TrumpSuit) => <cardSimpleType>, pack=game.functions.ints.card, label=TrumpSuit, cls=game.functions.ints.card.CardSimpleType, keyword=TrumpSuit
gd~~ LargePiece type=Constant (game.functions.ints.size.SizeLargePieceType.LargePiece) => <sizeLargePieceType>, pack=game.functions.ints.size, label=LargePiece, cls=game.functions.ints.size.SizeLargePieceType, keyword=LargePiece
gd~~ Array type=Constant (game.functions.ints.size.SizeArrayType.Array) => <sizeArrayType>, pack=game.functions.ints.size, label=Array, cls=game.functions.ints.size.SizeArrayType, keyword=Array
gd~~ Territory type=Constant (game.functions.ints.size.SizeTerritoryType.Territory) => <sizeTerritoryType>, pack=game.functions.ints.size, label=Territory, cls=game.functions.ints.size.SizeTerritoryType, keyword=Territory
gd~~ Group type=Constant (game.functions.ints.size.SizeGroupType.Group) => <sizeGroupType>, pack=game.functions.ints.size, label=Group, cls=game.functions.ints.size.SizeGroupType, keyword=Group
gd~~ Stack type=Constant (game.functions.ints.size.SizeSiteType.Stack) => <sizeSiteType>, pack=game.functions.ints.size, label=Stack, cls=game.functions.ints.size.SizeSiteType, keyword=Stack
gd~~ Piece type=Constant (game.functions.ints.value.ValueComponentType.Piece) => <valueComponentType>, pack=game.functions.ints.value, label=Piece, cls=game.functions.ints.value.ValueComponentType, keyword=Piece
gd~~ Random type=Constant (game.functions.ints.value.ValueRandomType.Random) => <valueRandomType>, pack=game.functions.ints.value, label=Random, cls=game.functions.ints.value.ValueRandomType, keyword=Random
gd~~ Pending type=Constant (game.functions.ints.value.ValueSimpleType.Pending) => <valueSimpleType>, pack=game.functions.ints.value, label=Pending, cls=game.functions.ints.value.ValueSimpleType, keyword=Pending
gd~~ Player type=Constant (game.functions.ints.value.ValuePlayerType.Player) => <valuePlayerType>, pack=game.functions.ints.value, label=Player, cls=game.functions.ints.value.ValuePlayerType, keyword=Player
gd~~ To type=Constant (game.functions.ints.last.LastType.To) => <lastType>, pack=game.functions.ints.last, label=To, cls=game.functions.ints.last.LastType, keyword=To
gd~~ From type=Constant (game.functions.ints.last.LastType.From) => <lastType>, pack=game.functions.ints.last, label=From, cls=game.functions.ints.last.LastType, keyword=From
gd~~ Pieces type=Constant (game.functions.ints.count.CountComponentType.Pieces) => <countComponentType>, pack=game.functions.ints.count, label=Pieces, cls=game.functions.ints.count.CountComponentType, keyword=Pieces
gd~~ Pips type=Constant (game.functions.ints.count.CountComponentType.Pips) => <countComponentType>, pack=game.functions.ints.count, label=Pips, cls=game.functions.ints.count.CountComponentType, keyword=Pips
gd~~ StepsOnTrack type=Constant (game.functions.ints.count.CountStepsOnTrackType.StepsOnTrack) => <countStepsOnTrackType>, pack=game.functions.ints.count, label=StepsOnTrack, cls=game.functions.ints.count.CountStepsOnTrackType, keyword=StepsOnTrack
gd~~ Sites type=Constant (game.functions.ints.count.CountSiteType.Sites) => <countSiteType>, pack=game.functions.ints.count, label=Sites, cls=game.functions.ints.count.CountSiteType, keyword=Sites
gd~~ Adjacent type=Constant (game.functions.ints.count.CountSiteType.Adjacent) => <countSiteType>, pack=game.functions.ints.count, label=Adjacent, cls=game.functions.ints.count.CountSiteType, keyword=Adjacent
gd~~ Neighbours type=Constant (game.functions.ints.count.CountSiteType.Neighbours) => <countSiteType>, pack=game.functions.ints.count, label=Neighbours, cls=game.functions.ints.count.CountSiteType, keyword=Neighbours
gd~~ Orthogonal type=Constant (game.functions.ints.count.CountSiteType.Orthogonal) => <countSiteType>, pack=game.functions.ints.count, label=Orthogonal, cls=game.functions.ints.count.CountSiteType, keyword=Orthogonal
gd~~ Diagonal type=Constant (game.functions.ints.count.CountSiteType.Diagonal) => <countSiteType>, pack=game.functions.ints.count, label=Diagonal, cls=game.functions.ints.count.CountSiteType, keyword=Diagonal
gd~~ Off type=Constant (game.functions.ints.count.CountSiteType.Off) => <countSiteType>, pack=game.functions.ints.count, label=Off, cls=game.functions.ints.count.CountSiteType, keyword=Off
gd~~ Rows type=Constant (game.functions.ints.count.CountSimpleType.Rows) => <countSimpleType>, pack=game.functions.ints.count, label=Rows, cls=game.functions.ints.count.CountSimpleType, keyword=Rows
gd~~ Columns type=Constant (game.functions.ints.count.CountSimpleType.Columns) => <countSimpleType>, pack=game.functions.ints.count, label=Columns, cls=game.functions.ints.count.CountSimpleType, keyword=Columns
gd~~ Turns type=Constant (game.functions.ints.count.CountSimpleType.Turns) => <countSimpleType>, pack=game.functions.ints.count, label=Turns, cls=game.functions.ints.count.CountSimpleType, keyword=Turns
gd~~ Moves type=Constant (game.functions.ints.count.CountSimpleType.Moves) => <countSimpleType>, pack=game.functions.ints.count, label=Moves, cls=game.functions.ints.count.CountSimpleType, keyword=Moves
gd~~ Trials type=Constant (game.functions.ints.count.CountSimpleType.Trials) => <countSimpleType>, pack=game.functions.ints.count, label=Trials, cls=game.functions.ints.count.CountSimpleType, keyword=Trials
gd~~ MovesThisTurn type=Constant (game.functions.ints.count.CountSimpleType.MovesThisTurn) => <countSimpleType>, pack=game.functions.ints.count, label=MovesThisTurn, cls=game.functions.ints.count.CountSimpleType, keyword=MovesThisTurn
gd~~ Phases type=Constant (game.functions.ints.count.CountSimpleType.Phases) => <countSimpleType>, pack=game.functions.ints.count, label=Phases, cls=game.functions.ints.count.CountSimpleType, keyword=Phases
gd~~ Vertices type=Constant (game.functions.ints.count.CountSimpleType.Vertices) => <countSimpleType>, pack=game.functions.ints.count, label=Vertices, cls=game.functions.ints.count.CountSimpleType, keyword=Vertices
gd~~ Edges type=Constant (game.functions.ints.count.CountSimpleType.Edges) => <countSimpleType>, pack=game.functions.ints.count, label=Edges, cls=game.functions.ints.count.CountSimpleType, keyword=Edges
gd~~ Cells type=Constant (game.functions.ints.count.CountSimpleType.Cells) => <countSimpleType>, pack=game.functions.ints.count, label=Cells, cls=game.functions.ints.count.CountSimpleType, keyword=Cells
gd~~ Players type=Constant (game.functions.ints.count.CountSimpleType.Players) => <countSimpleType>, pack=game.functions.ints.count, label=Players, cls=game.functions.ints.count.CountSimpleType, keyword=Players
gd~~ Active type=Constant (game.functions.ints.count.CountSimpleType.Active) => <countSimpleType>, pack=game.functions.ints.count, label=Active, cls=game.functions.ints.count.CountSimpleType, keyword=Active
gd~~ Stack type=Constant (game.functions.ints.count.CountStackType.Stack) => <countStackType>, pack=game.functions.ints.count, label=Stack, cls=game.functions.ints.count.CountStackType, keyword=Stack
gd~~ Liberties type=Constant (game.functions.ints.count.CountLibertiesType.Liberties) => <countLibertiesType>, pack=game.functions.ints.count, label=Liberties, cls=game.functions.ints.count.CountLibertiesType, keyword=Liberties
gd~~ Groups type=Constant (game.functions.ints.count.CountGroupsType.Groups) => <countGroupsType>, pack=game.functions.ints.count, label=Groups, cls=game.functions.ints.count.CountGroupsType, keyword=Groups
gd~~ Steps type=Constant (game.functions.ints.count.CountStepsType.Steps) => <countStepsType>, pack=game.functions.ints.count, label=Steps, cls=game.functions.ints.count.CountStepsType, keyword=Steps
gd~~ Level type=Constant (game.functions.ints.board.where.WhereLevelType.Level) => <whereLevelType>, pack=game.functions.ints.board.where, label=Level, cls=game.functions.ints.board.where.WhereLevelType, keyword=Level
gd~~ Move type=Constant (game.functions.ints.trackSite.TrackSiteMoveType.Move) => <trackSiteMoveType>, pack=game.functions.ints.trackSite, label=Move, cls=game.functions.ints.trackSite.TrackSiteMoveType, keyword=Move
gd~~ EndSite type=Constant (game.functions.ints.trackSite.TrackSiteType.EndSite) => <trackSiteType>, pack=game.functions.ints.trackSite, label=EndSite, cls=game.functions.ints.trackSite.TrackSiteType, keyword=EndSite
gd~~ Random type=Constant (game.functions.directions.RandomDirectionType.Random) => <randomDirectionType>, pack=game.functions.directions, label=Random, cls=game.functions.directions.RandomDirectionType, keyword=Random
gd~~ Remembered type=Constant (game.functions.intArray.values.ValuesStringType.Remembered) => <valuesStringType>, pack=game.functions.intArray.values, label=Remembered, cls=game.functions.intArray.values.ValuesStringType, keyword=Remembered
gd~~ Group type=Constant (game.functions.intArray.sizes.SizesGroupType.Group) => <sizesGroupType>, pack=game.functions.intArray.sizes, label=Group, cls=game.functions.intArray.sizes.SizesGroupType, keyword=Group
gd~~ All type=Constant (game.functions.intArray.players.PlayersManyType.All) => <playersManyType>, pack=game.functions.intArray.players, label=All, cls=game.functions.intArray.players.PlayersManyType, keyword=All
gd~~ NonMover type=Constant (game.functions.intArray.players.PlayersManyType.NonMover) => <playersManyType>, pack=game.functions.intArray.players, label=NonMover, cls=game.functions.intArray.players.PlayersManyType, keyword=NonMover
gd~~ Enemy type=Constant (game.functions.intArray.players.PlayersManyType.Enemy) => <playersManyType>, pack=game.functions.intArray.players, label=Enemy, cls=game.functions.intArray.players.PlayersManyType, keyword=Enemy
gd~~ Friend type=Constant (game.functions.intArray.players.PlayersManyType.Friend) => <playersManyType>, pack=game.functions.intArray.players, label=Friend, cls=game.functions.intArray.players.PlayersManyType, keyword=Friend
gd~~ Ally type=Constant (game.functions.intArray.players.PlayersManyType.Ally) => <playersManyType>, pack=game.functions.intArray.players, label=Ally, cls=game.functions.intArray.players.PlayersManyType, keyword=Ally
gd~~ Team1 type=Constant (game.functions.intArray.players.PlayersTeamType.Team1) => <playersTeamType>, pack=game.functions.intArray.players, label=Team1, cls=game.functions.intArray.players.PlayersTeamType, keyword=Team1
gd~~ Team2 type=Constant (game.functions.intArray.players.PlayersTeamType.Team2) => <playersTeamType>, pack=game.functions.intArray.players, label=Team2, cls=game.functions.intArray.players.PlayersTeamType, keyword=Team2
gd~~ Team3 type=Constant (game.functions.intArray.players.PlayersTeamType.Team3) => <playersTeamType>, pack=game.functions.intArray.players, label=Team3, cls=game.functions.intArray.players.PlayersTeamType, keyword=Team3
gd~~ Team4 type=Constant (game.functions.intArray.players.PlayersTeamType.Team4) => <playersTeamType>, pack=game.functions.intArray.players, label=Team4, cls=game.functions.intArray.players.PlayersTeamType, keyword=Team4
gd~~ Team5 type=Constant (game.functions.intArray.players.PlayersTeamType.Team5) => <playersTeamType>, pack=game.functions.intArray.players, label=Team5, cls=game.functions.intArray.players.PlayersTeamType, keyword=Team5
gd~~ Team6 type=Constant (game.functions.intArray.players.PlayersTeamType.Team6) => <playersTeamType>, pack=game.functions.intArray.players, label=Team6, cls=game.functions.intArray.players.PlayersTeamType, keyword=Team6
gd~~ Team7 type=Constant (game.functions.intArray.players.PlayersTeamType.Team7) => <playersTeamType>, pack=game.functions.intArray.players, label=Team7, cls=game.functions.intArray.players.PlayersTeamType, keyword=Team7
gd~~ Team8 type=Constant (game.functions.intArray.players.PlayersTeamType.Team8) => <playersTeamType>, pack=game.functions.intArray.players, label=Team8, cls=game.functions.intArray.players.PlayersTeamType, keyword=Team8
gd~~ Team9 type=Constant (game.functions.intArray.players.PlayersTeamType.Team9) => <playersTeamType>, pack=game.functions.intArray.players, label=Team9, cls=game.functions.intArray.players.PlayersTeamType, keyword=Team9
gd~~ Team10 type=Constant (game.functions.intArray.players.PlayersTeamType.Team10) => <playersTeamType>, pack=game.functions.intArray.players, label=Team10, cls=game.functions.intArray.players.PlayersTeamType, keyword=Team10
gd~~ Team11 type=Constant (game.functions.intArray.players.PlayersTeamType.Team11) => <playersTeamType>, pack=game.functions.intArray.players, label=Team11, cls=game.functions.intArray.players.PlayersTeamType, keyword=Team11
gd~~ Team12 type=Constant (game.functions.intArray.players.PlayersTeamType.Team12) => <playersTeamType>, pack=game.functions.intArray.players, label=Team12, cls=game.functions.intArray.players.PlayersTeamType, keyword=Team12
gd~~ Team13 type=Constant (game.functions.intArray.players.PlayersTeamType.Team13) => <playersTeamType>, pack=game.functions.intArray.players, label=Team13, cls=game.functions.intArray.players.PlayersTeamType, keyword=Team13
gd~~ Team14 type=Constant (game.functions.intArray.players.PlayersTeamType.Team14) => <playersTeamType>, pack=game.functions.intArray.players, label=Team14, cls=game.functions.intArray.players.PlayersTeamType, keyword=Team14
gd~~ Team15 type=Constant (game.functions.intArray.players.PlayersTeamType.Team15) => <playersTeamType>, pack=game.functions.intArray.players, label=Team15, cls=game.functions.intArray.players.PlayersTeamType, keyword=Team15
gd~~ Team16 type=Constant (game.functions.intArray.players.PlayersTeamType.Team16) => <playersTeamType>, pack=game.functions.intArray.players, label=Team16, cls=game.functions.intArray.players.PlayersTeamType, keyword=Team16
gd~~ Team type=Constant (game.rules.start.set.SetStartPlayersType.Team) => <setStartPlayersType>, pack=game.rules.start.set, label=Team, cls=game.rules.start.set.SetStartPlayersType, keyword=Team
gd~~ Hidden type=Constant (game.rules.start.set.SetStartHiddenType.Hidden) => <setStartHiddenType>, pack=game.rules.start.set, label=Hidden, cls=game.rules.start.set.SetStartHiddenType, keyword=Hidden
gd~~ Count type=Constant (game.rules.start.set.SetStartSitesType.Count) => <setStartSitesType>, pack=game.rules.start.set, label=Count, cls=game.rules.start.set.SetStartSitesType, keyword=Count
gd~~ Cost type=Constant (game.rules.start.set.SetStartSitesType.Cost) => <setStartSitesType>, pack=game.rules.start.set, label=Cost, cls=game.rules.start.set.SetStartSitesType, keyword=Cost
gd~~ Phase type=Constant (game.rules.start.set.SetStartSitesType.Phase) => <setStartSitesType>, pack=game.rules.start.set, label=Phase, cls=game.rules.start.set.SetStartSitesType, keyword=Phase
gd~~ RememberValue type=Constant (game.rules.start.set.SetRememberValueType.RememberValue) => <setRememberValueType>, pack=game.rules.start.set, label=RememberValue, cls=game.rules.start.set.SetRememberValueType, keyword=RememberValue
gd~~ Amount type=Constant (game.rules.start.set.SetStartPlayerType.Amount) => <setStartPlayerType>, pack=game.rules.start.set, label=Amount, cls=game.rules.start.set.SetStartPlayerType, keyword=Amount
gd~~ Score type=Constant (game.rules.start.set.SetStartPlayerType.Score) => <setStartPlayerType>, pack=game.rules.start.set, label=Score, cls=game.rules.start.set.SetStartPlayerType, keyword=Score
~~~~ AllInvisible type=Constant (game.rules.start.set.SetStartGraphType.AllInvisible) => <setStartGraphType>, pack=game.rules.start.set, label=AllInvisible, cls=game.rules.start.set.SetStartGraphType, keyword=AllInvisible
gd~~ Team type=Constant (game.rules.start.forEach.ForEachTeamType.Team) => <forEachTeamType>, pack=game.rules.start.forEach, label=Team, cls=game.rules.start.forEach.ForEachTeamType, keyword=Team
gd~~ Value type=Constant (game.rules.start.forEach.ForEachStartValueType.Value) => <forEachStartValueType>, pack=game.rules.start.forEach, label=Value, cls=game.rules.start.forEach.ForEachStartValueType, keyword=Value
gd~~ Random type=Constant (game.rules.start.place.PlaceRandomType.Random) => <placeRandomType>, pack=game.rules.start.place, label=Random, cls=game.rules.start.place.PlaceRandomType, keyword=Random
gd~~ Stack type=Constant (game.rules.start.place.PlaceStackType.Stack) => <placeStackType>, pack=game.rules.start.place, label=Stack, cls=game.rules.start.place.PlaceStackType, keyword=Stack
gd~~ Deck type=Constant (game.rules.start.split.SplitType.Deck) => <splitType>, pack=game.rules.start.split, label=Deck, cls=game.rules.start.split.SplitType, keyword=Deck
gd~~ Leap type=Constant (game.rules.play.moves.decision.MoveLeapType.Leap) => <moveLeapType>, pack=game.rules.play.moves.decision, label=Leap, cls=game.rules.play.moves.decision.MoveLeapType, keyword=Leap
gd~~ Bet type=Constant (game.rules.play.moves.decision.MoveBetType.Bet) => <moveBetType>, pack=game.rules.play.moves.decision, label=Bet, cls=game.rules.play.moves.decision.MoveBetType, keyword=Bet
gd~~ Slide type=Constant (game.rules.play.moves.decision.MoveSlideType.Slide) => <moveSlideType>, pack=game.rules.play.moves.decision, label=Slide, cls=game.rules.play.moves.decision.MoveSlideType, keyword=Slide
gd~~ Pass type=Constant (game.rules.play.moves.decision.MoveSimpleType.Pass) => <moveSimpleType>, pack=game.rules.play.moves.decision, label=Pass, cls=game.rules.play.moves.decision.MoveSimpleType, keyword=Pass
gd~~ PlayCard type=Constant (game.rules.play.moves.decision.MoveSimpleType.PlayCard) => <moveSimpleType>, pack=game.rules.play.moves.decision, label=PlayCard, cls=game.rules.play.moves.decision.MoveSimpleType, keyword=PlayCard
~~~~ FromTo type=Constant (game.rules.play.moves.decision.MoveFromToType.FromTo) => <moveFromToType>, pack=game.rules.play.moves.decision, label=FromTo, cls=game.rules.play.moves.decision.MoveFromToType, keyword=FromTo
gd~~ Promote type=Constant (game.rules.play.moves.decision.MovePromoteType.Promote) => <movePromoteType>, pack=game.rules.play.moves.decision, label=Promote, cls=game.rules.play.moves.decision.MovePromoteType, keyword=Promote
gd~~ Propose type=Constant (game.rules.play.moves.decision.MoveMessageType.Propose) => <moveMessageType>, pack=game.rules.play.moves.decision, label=Propose, cls=game.rules.play.moves.decision.MoveMessageType, keyword=Propose
gd~~ Vote type=Constant (game.rules.play.moves.decision.MoveMessageType.Vote) => <moveMessageType>, pack=game.rules.play.moves.decision, label=Vote, cls=game.rules.play.moves.decision.MoveMessageType, keyword=Vote
gd~~ Set type=Constant (game.rules.play.moves.decision.MoveSetType.Set) => <moveSetType>, pack=game.rules.play.moves.decision, label=Set, cls=game.rules.play.moves.decision.MoveSetType, keyword=Set
gd~~ Select type=Constant (game.rules.play.moves.decision.MoveSelectType.Select) => <moveSelectType>, pack=game.rules.play.moves.decision, label=Select, cls=game.rules.play.moves.decision.MoveSelectType, keyword=Select
gd~~ Step type=Constant (game.rules.play.moves.decision.MoveStepType.Step) => <moveStepType>, pack=game.rules.play.moves.decision, label=Step, cls=game.rules.play.moves.decision.MoveStepType, keyword=Step
gd~~ Swap type=Constant (game.rules.play.moves.decision.MoveSwapType.Swap) => <moveSwapType>, pack=game.rules.play.moves.decision, label=Swap, cls=game.rules.play.moves.decision.MoveSwapType, keyword=Swap
gd~~ Add type=Constant (game.rules.play.moves.decision.MoveSiteType.Add) => <moveSiteType>, pack=game.rules.play.moves.decision, label=Add, cls=game.rules.play.moves.decision.MoveSiteType, keyword=Add
gd~~ Claim type=Constant (game.rules.play.moves.decision.MoveSiteType.Claim) => <moveSiteType>, pack=game.rules.play.moves.decision, label=Claim, cls=game.rules.play.moves.decision.MoveSiteType, keyword=Claim
gd~~ Remove type=Constant (game.rules.play.moves.decision.MoveRemoveType.Remove) => <moveRemoveType>, pack=game.rules.play.moves.decision, label=Remove, cls=game.rules.play.moves.decision.MoveRemoveType, keyword=Remove
gd~~ Hop type=Constant (game.rules.play.moves.decision.MoveHopType.Hop) => <moveHopType>, pack=game.rules.play.moves.decision, label=Hop, cls=game.rules.play.moves.decision.MoveHopType, keyword=Hop
gd~~ Shoot type=Constant (game.rules.play.moves.decision.MoveShootType.Shoot) => <moveShootType>, pack=game.rules.play.moves.decision, label=Shoot, cls=game.rules.play.moves.decision.MoveShootType, keyword=Shoot
gd~~ NextPlayer type=Constant (game.rules.play.moves.nonDecision.effect.set.SetNextPlayerType.NextPlayer) => <setNextPlayerType>, pack=game.rules.play.moves.nonDecision.effect.set, label=NextPlayer, cls=game.rules.play.moves.nonDecision.effect.set.SetNextPlayerType, keyword=NextPlayer
gd~~ Team type=Constant (game.rules.play.moves.nonDecision.effect.set.SetTeamType.Team) => <setTeamType>, pack=game.rules.play.moves.nonDecision.effect.set, label=Team, cls=game.rules.play.moves.nonDecision.effect.set.SetTeamType, keyword=Team
gd~~ Value type=Constant (game.rules.play.moves.nonDecision.effect.set.SetPlayerType.Value) => <setPlayerType>, pack=game.rules.play.moves.nonDecision.effect.set, label=Value, cls=game.rules.play.moves.nonDecision.effect.set.SetPlayerType, keyword=Value
gd~~ Score type=Constant (game.rules.play.moves.nonDecision.effect.set.SetPlayerType.Score) => <setPlayerType>, pack=game.rules.play.moves.nonDecision.effect.set, label=Score, cls=game.rules.play.moves.nonDecision.effect.set.SetPlayerType, keyword=Score
gd~~ Pending type=Constant (game.rules.play.moves.nonDecision.effect.set.SetPendingType.Pending) => <setPendingType>, pack=game.rules.play.moves.nonDecision.effect.set, label=Pending, cls=game.rules.play.moves.nonDecision.effect.set.SetPendingType, keyword=Pending
gd~~ Count type=Constant (game.rules.play.moves.nonDecision.effect.set.SetSiteType.Count) => <setSiteType>, pack=game.rules.play.moves.nonDecision.effect.set, label=Count, cls=game.rules.play.moves.nonDecision.effect.set.SetSiteType, keyword=Count
gd~~ State type=Constant (game.rules.play.moves.nonDecision.effect.set.SetSiteType.State) => <setSiteType>, pack=game.rules.play.moves.nonDecision.effect.set, label=State, cls=game.rules.play.moves.nonDecision.effect.set.SetSiteType, keyword=State
gd~~ Value type=Constant (game.rules.play.moves.nonDecision.effect.set.SetSiteType.Value) => <setSiteType>, pack=game.rules.play.moves.nonDecision.effect.set, label=Value, cls=game.rules.play.moves.nonDecision.effect.set.SetSiteType, keyword=Value
gd~~ Var type=Constant (game.rules.play.moves.nonDecision.effect.set.SetVarType.Var) => <setVarType>, pack=game.rules.play.moves.nonDecision.effect.set, label=Var, cls=game.rules.play.moves.nonDecision.effect.set.SetVarType, keyword=Var
gd~~ Hidden type=Constant (game.rules.play.moves.nonDecision.effect.set.SetHiddenType.Hidden) => <setHiddenType>, pack=game.rules.play.moves.nonDecision.effect.set, label=Hidden, cls=game.rules.play.moves.nonDecision.effect.set.SetHiddenType, keyword=Hidden
gd~~ Counter type=Constant (game.rules.play.moves.nonDecision.effect.set.SetValueType.Counter) => <setValueType>, pack=game.rules.play.moves.nonDecision.effect.set, label=Counter, cls=game.rules.play.moves.nonDecision.effect.set.SetValueType, keyword=Counter
gd~~ Pot type=Constant (game.rules.play.moves.nonDecision.effect.set.SetValueType.Pot) => <setValueType>, pack=game.rules.play.moves.nonDecision.effect.set, label=Pot, cls=game.rules.play.moves.nonDecision.effect.set.SetValueType, keyword=Pot
gd~~ TrumpSuit type=Constant (game.rules.play.moves.nonDecision.effect.set.SetTrumpType.TrumpSuit) => <setTrumpType>, pack=game.rules.play.moves.nonDecision.effect.set, label=TrumpSuit, cls=game.rules.play.moves.nonDecision.effect.set.SetTrumpType, keyword=TrumpSuit
gd~~ Rotation type=Constant (game.rules.play.moves.nonDecision.effect.set.SetRotationType.Rotation) => <setRotationType>, pack=game.rules.play.moves.nonDecision.effect.set, label=Rotation, cls=game.rules.play.moves.nonDecision.effect.set.SetRotationType, keyword=Rotation
gd~~ Moves type=Constant (game.rules.play.moves.nonDecision.effect.requirement.max.MaxMovesType.Moves) => <maxMovesType>, pack=game.rules.play.moves.nonDecision.effect.requirement.max, label=Moves, cls=game.rules.play.moves.nonDecision.effect.requirement.max.MaxMovesType, keyword=Moves
gd~~ Captures type=Constant (game.rules.play.moves.nonDecision.effect.requirement.max.MaxMovesType.Captures) => <maxMovesType>, pack=game.rules.play.moves.nonDecision.effect.requirement.max, label=Captures, cls=game.rules.play.moves.nonDecision.effect.requirement.max.MaxMovesType, keyword=Captures
gd~~ Distance type=Constant (game.rules.play.moves.nonDecision.effect.requirement.max.MaxDistanceType.Distance) => <maxDistanceType>, pack=game.rules.play.moves.nonDecision.effect.requirement.max, label=Distance, cls=game.rules.play.moves.nonDecision.effect.requirement.max.MaxDistanceType, keyword=Distance
gd~~ Value type=Constant (game.rules.play.moves.nonDecision.effect.state.forget.ForgetValueType.Value) => <forgetValueType>, pack=game.rules.play.moves.nonDecision.effect.state.forget, label=Value, cls=game.rules.play.moves.nonDecision.effect.state.forget.ForgetValueType, keyword=Value
gd~~ All type=Constant (game.rules.play.moves.nonDecision.effect.state.forget.ForgetValueAllType.All) => <forgetValueAllType>, pack=game.rules.play.moves.nonDecision.effect.state.forget, label=All, cls=game.rules.play.moves.nonDecision.effect.state.forget.ForgetValueAllType, keyword=All
gd~~ Players type=Constant (game.rules.play.moves.nonDecision.effect.state.swap.SwapPlayersType.Players) => <swapPlayersType>, pack=game.rules.play.moves.nonDecision.effect.state.swap, label=Players, cls=game.rules.play.moves.nonDecision.effect.state.swap.SwapPlayersType, keyword=Players
gd~~ Pieces type=Constant (game.rules.play.moves.nonDecision.effect.state.swap.SwapSitesType.Pieces) => <swapSitesType>, pack=game.rules.play.moves.nonDecision.effect.state.swap, label=Pieces, cls=game.rules.play.moves.nonDecision.effect.state.swap.SwapSitesType, keyword=Pieces
gd~~ State type=Constant (game.rules.play.moves.nonDecision.effect.state.remember.RememberStateType.State) => <rememberStateType>, pack=game.rules.play.moves.nonDecision.effect.state.remember, label=State, cls=game.rules.play.moves.nonDecision.effect.state.remember.RememberStateType, keyword=State
gd~~ Value type=Constant (game.rules.play.moves.nonDecision.effect.state.remember.RememberValueType.Value) => <rememberValueType>, pack=game.rules.play.moves.nonDecision.effect.state.remember, label=Value, cls=game.rules.play.moves.nonDecision.effect.state.remember.RememberValueType, keyword=Value
gd~~ Control type=Constant (game.rules.play.moves.nonDecision.effect.take.TakeControlType.Control) => <takeControlType>, pack=game.rules.play.moves.nonDecision.effect.take, label=Control, cls=game.rules.play.moves.nonDecision.effect.take.TakeControlType, keyword=Control
gd~~ Domino type=Constant (game.rules.play.moves.nonDecision.effect.take.TakeSimpleType.Domino) => <takeSimpleType>, pack=game.rules.play.moves.nonDecision.effect.take, label=Domino, cls=game.rules.play.moves.nonDecision.effect.take.TakeSimpleType, keyword=Domino
gd~~ Site type=Constant (game.rules.play.moves.nonDecision.operators.foreach.ForEachSiteType.Site) => <forEachSiteType>, pack=game.rules.play.moves.nonDecision.operators.foreach, label=Site, cls=game.rules.play.moves.nonDecision.operators.foreach.ForEachSiteType, keyword=Site
gd~~ Player type=Constant (game.rules.play.moves.nonDecision.operators.foreach.ForEachPlayerType.Player) => <forEachPlayerType>, pack=game.rules.play.moves.nonDecision.operators.foreach, label=Player, cls=game.rules.play.moves.nonDecision.operators.foreach.ForEachPlayerType, keyword=Player
gd~~ Direction type=Constant (game.rules.play.moves.nonDecision.operators.foreach.ForEachDirectionType.Direction) => <forEachDirectionType>, pack=game.rules.play.moves.nonDecision.operators.foreach, label=Direction, cls=game.rules.play.moves.nonDecision.operators.foreach.ForEachDirectionType, keyword=Direction
gd~~ Piece type=Constant (game.rules.play.moves.nonDecision.operators.foreach.ForEachPieceType.Piece) => <forEachPieceType>, pack=game.rules.play.moves.nonDecision.operators.foreach, label=Piece, cls=game.rules.play.moves.nonDecision.operators.foreach.ForEachPieceType, keyword=Piece
gd~~ Value type=Constant (game.rules.play.moves.nonDecision.operators.foreach.ForEachValueType.Value) => <forEachValueType>, pack=game.rules.play.moves.nonDecision.operators.foreach, label=Value, cls=game.rules.play.moves.nonDecision.operators.foreach.ForEachValueType, keyword=Value
gd~~ Die type=Constant (game.rules.play.moves.nonDecision.operators.foreach.ForEachDieType.Die) => <forEachDieType>, pack=game.rules.play.moves.nonDecision.operators.foreach, label=Die, cls=game.rules.play.moves.nonDecision.operators.foreach.ForEachDieType, keyword=Die
gd~~ Group type=Constant (game.rules.play.moves.nonDecision.operators.foreach.ForEachGroupType.Group) => <forEachGroupType>, pack=game.rules.play.moves.nonDecision.operators.foreach, label=Group, cls=game.rules.play.moves.nonDecision.operators.foreach.ForEachGroupType, keyword=Group
~~~~ N type=Constant (game.util.directions.DirectionUniqueName.N) => <directionUniqueName>, pack=game.util.directions, label=N, cls=game.util.directions.DirectionUniqueName, keyword=N
~~~~ NNE type=Constant (game.util.directions.DirectionUniqueName.NNE) => <directionUniqueName>, pack=game.util.directions, label=NNE, cls=game.util.directions.DirectionUniqueName, keyword=NNE
~~~~ NE type=Constant (game.util.directions.DirectionUniqueName.NE) => <directionUniqueName>, pack=game.util.directions, label=NE, cls=game.util.directions.DirectionUniqueName, keyword=NE
~~~~ E type=Constant (game.util.directions.DirectionUniqueName.E) => <directionUniqueName>, pack=game.util.directions, label=E, cls=game.util.directions.DirectionUniqueName, keyword=E
~~~~ SSE type=Constant (game.util.directions.DirectionUniqueName.SSE) => <directionUniqueName>, pack=game.util.directions, label=SSE, cls=game.util.directions.DirectionUniqueName, keyword=SSE
~~~~ SE type=Constant (game.util.directions.DirectionUniqueName.SE) => <directionUniqueName>, pack=game.util.directions, label=SE, cls=game.util.directions.DirectionUniqueName, keyword=SE
~~~~ S type=Constant (game.util.directions.DirectionUniqueName.S) => <directionUniqueName>, pack=game.util.directions, label=S, cls=game.util.directions.DirectionUniqueName, keyword=S
~~~~ SSW type=Constant (game.util.directions.DirectionUniqueName.SSW) => <directionUniqueName>, pack=game.util.directions, label=SSW, cls=game.util.directions.DirectionUniqueName, keyword=SSW
~~~~ SW type=Constant (game.util.directions.DirectionUniqueName.SW) => <directionUniqueName>, pack=game.util.directions, label=SW, cls=game.util.directions.DirectionUniqueName, keyword=SW
~~~~ W type=Constant (game.util.directions.DirectionUniqueName.W) => <directionUniqueName>, pack=game.util.directions, label=W, cls=game.util.directions.DirectionUniqueName, keyword=W
~~~~ NW type=Constant (game.util.directions.DirectionUniqueName.NW) => <directionUniqueName>, pack=game.util.directions, label=NW, cls=game.util.directions.DirectionUniqueName, keyword=NW
~~~~ NNW type=Constant (game.util.directions.DirectionUniqueName.NNW) => <directionUniqueName>, pack=game.util.directions, label=NNW, cls=game.util.directions.DirectionUniqueName, keyword=NNW
~~~~ WNW type=Constant (game.util.directions.DirectionUniqueName.WNW) => <directionUniqueName>, pack=game.util.directions, label=WNW, cls=game.util.directions.DirectionUniqueName, keyword=WNW
~~~~ ENE type=Constant (game.util.directions.DirectionUniqueName.ENE) => <directionUniqueName>, pack=game.util.directions, label=ENE, cls=game.util.directions.DirectionUniqueName, keyword=ENE
~~~~ ESE type=Constant (game.util.directions.DirectionUniqueName.ESE) => <directionUniqueName>, pack=game.util.directions, label=ESE, cls=game.util.directions.DirectionUniqueName, keyword=ESE
~~~~ WSW type=Constant (game.util.directions.DirectionUniqueName.WSW) => <directionUniqueName>, pack=game.util.directions, label=WSW, cls=game.util.directions.DirectionUniqueName, keyword=WSW
~~~~ CW type=Constant (game.util.directions.DirectionUniqueName.CW) => <directionUniqueName>, pack=game.util.directions, label=CW, cls=game.util.directions.DirectionUniqueName, keyword=CW
~~~~ Out type=Constant (game.util.directions.DirectionUniqueName.Out) => <directionUniqueName>, pack=game.util.directions, label=Out, cls=game.util.directions.DirectionUniqueName, keyword=Out
~~~~ CCW type=Constant (game.util.directions.DirectionUniqueName.CCW) => <directionUniqueName>, pack=game.util.directions, label=CCW, cls=game.util.directions.DirectionUniqueName, keyword=CCW
~~~~ In type=Constant (game.util.directions.DirectionUniqueName.In) => <directionUniqueName>, pack=game.util.directions, label=In, cls=game.util.directions.DirectionUniqueName, keyword=In
~~~~ UNW type=Constant (game.util.directions.DirectionUniqueName.UNW) => <directionUniqueName>, pack=game.util.directions, label=UNW, cls=game.util.directions.DirectionUniqueName, keyword=UNW
~~~~ UNE type=Constant (game.util.directions.DirectionUniqueName.UNE) => <directionUniqueName>, pack=game.util.directions, label=UNE, cls=game.util.directions.DirectionUniqueName, keyword=UNE
~~~~ USE type=Constant (game.util.directions.DirectionUniqueName.USE) => <directionUniqueName>, pack=game.util.directions, label=USE, cls=game.util.directions.DirectionUniqueName, keyword=USE
~~~~ USW type=Constant (game.util.directions.DirectionUniqueName.USW) => <directionUniqueName>, pack=game.util.directions, label=USW, cls=game.util.directions.DirectionUniqueName, keyword=USW
~~~~ DNW type=Constant (game.util.directions.DirectionUniqueName.DNW) => <directionUniqueName>, pack=game.util.directions, label=DNW, cls=game.util.directions.DirectionUniqueName, keyword=DNW
~~~~ DNE type=Constant (game.util.directions.DirectionUniqueName.DNE) => <directionUniqueName>, pack=game.util.directions, label=DNE, cls=game.util.directions.DirectionUniqueName, keyword=DNE
~~~~ DSE type=Constant (game.util.directions.DirectionUniqueName.DSE) => <directionUniqueName>, pack=game.util.directions, label=DSE, cls=game.util.directions.DirectionUniqueName, keyword=DSE
~~~~ DSW type=Constant (game.util.directions.DirectionUniqueName.DSW) => <directionUniqueName>, pack=game.util.directions, label=DSW, cls=game.util.directions.DirectionUniqueName, keyword=DSW
~~~~ U type=Constant (game.util.directions.DirectionUniqueName.U) => <directionUniqueName>, pack=game.util.directions, label=U, cls=game.util.directions.DirectionUniqueName, keyword=U
~~~~ UN type=Constant (game.util.directions.DirectionUniqueName.UN) => <directionUniqueName>, pack=game.util.directions, label=UN, cls=game.util.directions.DirectionUniqueName, keyword=UN
~~~~ UW type=Constant (game.util.directions.DirectionUniqueName.UW) => <directionUniqueName>, pack=game.util.directions, label=UW, cls=game.util.directions.DirectionUniqueName, keyword=UW
~~~~ UE type=Constant (game.util.directions.DirectionUniqueName.UE) => <directionUniqueName>, pack=game.util.directions, label=UE, cls=game.util.directions.DirectionUniqueName, keyword=UE
~~~~ US type=Constant (game.util.directions.DirectionUniqueName.US) => <directionUniqueName>, pack=game.util.directions, label=US, cls=game.util.directions.DirectionUniqueName, keyword=US
~~~~ D type=Constant (game.util.directions.DirectionUniqueName.D) => <directionUniqueName>, pack=game.util.directions, label=D, cls=game.util.directions.DirectionUniqueName, keyword=D
~~~~ DN type=Constant (game.util.directions.DirectionUniqueName.DN) => <directionUniqueName>, pack=game.util.directions, label=DN, cls=game.util.directions.DirectionUniqueName, keyword=DN
~~~~ DW type=Constant (game.util.directions.DirectionUniqueName.DW) => <directionUniqueName>, pack=game.util.directions, label=DW, cls=game.util.directions.DirectionUniqueName, keyword=DW
~~~~ DE type=Constant (game.util.directions.DirectionUniqueName.DE) => <directionUniqueName>, pack=game.util.directions, label=DE, cls=game.util.directions.DirectionUniqueName, keyword=DE
~~~~ DS type=Constant (game.util.directions.DirectionUniqueName.DS) => <directionUniqueName>, pack=game.util.directions, label=DS, cls=game.util.directions.DirectionUniqueName, keyword=DS
gd~~ FromBottom type=Constant (game.util.directions.StackDirection.FromBottom) => <stackDirection>, pack=game.util.directions, label=FromBottom, cls=game.util.directions.StackDirection, keyword=FromBottom
gd~~ FromTop type=Constant (game.util.directions.StackDirection.FromTop) => <stackDirection>, pack=game.util.directions, label=FromTop, cls=game.util.directions.StackDirection, keyword=FromTop
gd~~ Forward type=Constant (game.util.directions.RelativeDirection.Forward) => <relativeDirection>, pack=game.util.directions, label=Forward, cls=game.util.directions.RelativeDirection, keyword=Forward
gd~~ Backward type=Constant (game.util.directions.RelativeDirection.Backward) => <relativeDirection>, pack=game.util.directions, label=Backward, cls=game.util.directions.RelativeDirection, keyword=Backward
gd~~ Rightward type=Constant (game.util.directions.RelativeDirection.Rightward) => <relativeDirection>, pack=game.util.directions, label=Rightward, cls=game.util.directions.RelativeDirection, keyword=Rightward
gd~~ Leftward type=Constant (game.util.directions.RelativeDirection.Leftward) => <relativeDirection>, pack=game.util.directions, label=Leftward, cls=game.util.directions.RelativeDirection, keyword=Leftward
gd~~ Forwards type=Constant (game.util.directions.RelativeDirection.Forwards) => <relativeDirection>, pack=game.util.directions, label=Forwards, cls=game.util.directions.RelativeDirection, keyword=Forwards
gd~~ Backwards type=Constant (game.util.directions.RelativeDirection.Backwards) => <relativeDirection>, pack=game.util.directions, label=Backwards, cls=game.util.directions.RelativeDirection, keyword=Backwards
gd~~ Rightwards type=Constant (game.util.directions.RelativeDirection.Rightwards) => <relativeDirection>, pack=game.util.directions, label=Rightwards, cls=game.util.directions.RelativeDirection, keyword=Rightwards
gd~~ Leftwards type=Constant (game.util.directions.RelativeDirection.Leftwards) => <relativeDirection>, pack=game.util.directions, label=Leftwards, cls=game.util.directions.RelativeDirection, keyword=Leftwards
gd~~ FL type=Constant (game.util.directions.RelativeDirection.FL) => <relativeDirection>, pack=game.util.directions, label=FL, cls=game.util.directions.RelativeDirection, keyword=FL
gd~~ FLL type=Constant (game.util.directions.RelativeDirection.FLL) => <relativeDirection>, pack=game.util.directions, label=FLL, cls=game.util.directions.RelativeDirection, keyword=FLL
gd~~ FLLL type=Constant (game.util.directions.RelativeDirection.FLLL) => <relativeDirection>, pack=game.util.directions, label=FLLL, cls=game.util.directions.RelativeDirection, keyword=FLLL
gd~~ BL type=Constant (game.util.directions.RelativeDirection.BL) => <relativeDirection>, pack=game.util.directions, label=BL, cls=game.util.directions.RelativeDirection, keyword=BL
gd~~ BLL type=Constant (game.util.directions.RelativeDirection.BLL) => <relativeDirection>, pack=game.util.directions, label=BLL, cls=game.util.directions.RelativeDirection, keyword=BLL
gd~~ BLLL type=Constant (game.util.directions.RelativeDirection.BLLL) => <relativeDirection>, pack=game.util.directions, label=BLLL, cls=game.util.directions.RelativeDirection, keyword=BLLL
gd~~ FR type=Constant (game.util.directions.RelativeDirection.FR) => <relativeDirection>, pack=game.util.directions, label=FR, cls=game.util.directions.RelativeDirection, keyword=FR
gd~~ FRR type=Constant (game.util.directions.RelativeDirection.FRR) => <relativeDirection>, pack=game.util.directions, label=FRR, cls=game.util.directions.RelativeDirection, keyword=FRR
gd~~ FRRR type=Constant (game.util.directions.RelativeDirection.FRRR) => <relativeDirection>, pack=game.util.directions, label=FRRR, cls=game.util.directions.RelativeDirection, keyword=FRRR
gd~~ BR type=Constant (game.util.directions.RelativeDirection.BR) => <relativeDirection>, pack=game.util.directions, label=BR, cls=game.util.directions.RelativeDirection, keyword=BR
gd~~ BRR type=Constant (game.util.directions.RelativeDirection.BRR) => <relativeDirection>, pack=game.util.directions, label=BRR, cls=game.util.directions.RelativeDirection, keyword=BRR
gd~~ BRRR type=Constant (game.util.directions.RelativeDirection.BRRR) => <relativeDirection>, pack=game.util.directions, label=BRRR, cls=game.util.directions.RelativeDirection, keyword=BRRR
gd~~ SameDirection type=Constant (game.util.directions.RelativeDirection.SameDirection) => <relativeDirection>, pack=game.util.directions, label=SameDirection, cls=game.util.directions.RelativeDirection, keyword=SameDirection
gd~~ OppositeDirection type=Constant (game.util.directions.RelativeDirection.OppositeDirection) => <relativeDirection>, pack=game.util.directions, label=OppositeDirection, cls=game.util.directions.RelativeDirection, keyword=OppositeDirection
gd~~ All type=Constant (game.util.directions.AbsoluteDirection.All) => <absoluteDirection>, pack=game.util.directions, label=All, cls=game.util.directions.AbsoluteDirection, keyword=All
gd~~ Angled type=Constant (game.util.directions.AbsoluteDirection.Angled) => <absoluteDirection>, pack=game.util.directions, label=Angled, cls=game.util.directions.AbsoluteDirection, keyword=Angled
gd~~ Adjacent type=Constant (game.util.directions.AbsoluteDirection.Adjacent) => <absoluteDirection>, pack=game.util.directions, label=Adjacent, cls=game.util.directions.AbsoluteDirection, keyword=Adjacent
gd~~ Axial type=Constant (game.util.directions.AbsoluteDirection.Axial) => <absoluteDirection>, pack=game.util.directions, label=Axial, cls=game.util.directions.AbsoluteDirection, keyword=Axial
gd~~ Orthogonal type=Constant (game.util.directions.AbsoluteDirection.Orthogonal) => <absoluteDirection>, pack=game.util.directions, label=Orthogonal, cls=game.util.directions.AbsoluteDirection, keyword=Orthogonal
gd~~ Diagonal type=Constant (game.util.directions.AbsoluteDirection.Diagonal) => <absoluteDirection>, pack=game.util.directions, label=Diagonal, cls=game.util.directions.AbsoluteDirection, keyword=Diagonal
gd~~ OffDiagonal type=Constant (game.util.directions.AbsoluteDirection.OffDiagonal) => <absoluteDirection>, pack=game.util.directions, label=OffDiagonal, cls=game.util.directions.AbsoluteDirection, keyword=OffDiagonal
gd~~ SameLayer type=Constant (game.util.directions.AbsoluteDirection.SameLayer) => <absoluteDirection>, pack=game.util.directions, label=SameLayer, cls=game.util.directions.AbsoluteDirection, keyword=SameLayer
gd~~ Upward type=Constant (game.util.directions.AbsoluteDirection.Upward) => <absoluteDirection>, pack=game.util.directions, label=Upward, cls=game.util.directions.AbsoluteDirection, keyword=Upward
gd~~ Downward type=Constant (game.util.directions.AbsoluteDirection.Downward) => <absoluteDirection>, pack=game.util.directions, label=Downward, cls=game.util.directions.AbsoluteDirection, keyword=Downward
gd~~ Rotational type=Constant (game.util.directions.AbsoluteDirection.Rotational) => <absoluteDirection>, pack=game.util.directions, label=Rotational, cls=game.util.directions.AbsoluteDirection, keyword=Rotational
gd~~ Base type=Constant (game.util.directions.AbsoluteDirection.Base) => <absoluteDirection>, pack=game.util.directions, label=Base, cls=game.util.directions.AbsoluteDirection, keyword=Base
gd~~ Support type=Constant (game.util.directions.AbsoluteDirection.Support) => <absoluteDirection>, pack=game.util.directions, label=Support, cls=game.util.directions.AbsoluteDirection, keyword=Support
gd~~ N type=Constant (game.util.directions.AbsoluteDirection.N) => <absoluteDirection>, pack=game.util.directions, label=N, cls=game.util.directions.AbsoluteDirection, keyword=N
gd~~ E type=Constant (game.util.directions.AbsoluteDirection.E) => <absoluteDirection>, pack=game.util.directions, label=E, cls=game.util.directions.AbsoluteDirection, keyword=E
gd~~ S type=Constant (game.util.directions.AbsoluteDirection.S) => <absoluteDirection>, pack=game.util.directions, label=S, cls=game.util.directions.AbsoluteDirection, keyword=S
gd~~ W type=Constant (game.util.directions.AbsoluteDirection.W) => <absoluteDirection>, pack=game.util.directions, label=W, cls=game.util.directions.AbsoluteDirection, keyword=W
gd~~ NE type=Constant (game.util.directions.AbsoluteDirection.NE) => <absoluteDirection>, pack=game.util.directions, label=NE, cls=game.util.directions.AbsoluteDirection, keyword=NE
gd~~ SE type=Constant (game.util.directions.AbsoluteDirection.SE) => <absoluteDirection>, pack=game.util.directions, label=SE, cls=game.util.directions.AbsoluteDirection, keyword=SE
gd~~ NW type=Constant (game.util.directions.AbsoluteDirection.NW) => <absoluteDirection>, pack=game.util.directions, label=NW, cls=game.util.directions.AbsoluteDirection, keyword=NW
gd~~ SW type=Constant (game.util.directions.AbsoluteDirection.SW) => <absoluteDirection>, pack=game.util.directions, label=SW, cls=game.util.directions.AbsoluteDirection, keyword=SW
gd~~ NNW type=Constant (game.util.directions.AbsoluteDirection.NNW) => <absoluteDirection>, pack=game.util.directions, label=NNW, cls=game.util.directions.AbsoluteDirection, keyword=NNW
gd~~ WNW type=Constant (game.util.directions.AbsoluteDirection.WNW) => <absoluteDirection>, pack=game.util.directions, label=WNW, cls=game.util.directions.AbsoluteDirection, keyword=WNW
gd~~ WSW type=Constant (game.util.directions.AbsoluteDirection.WSW) => <absoluteDirection>, pack=game.util.directions, label=WSW, cls=game.util.directions.AbsoluteDirection, keyword=WSW
gd~~ SSW type=Constant (game.util.directions.AbsoluteDirection.SSW) => <absoluteDirection>, pack=game.util.directions, label=SSW, cls=game.util.directions.AbsoluteDirection, keyword=SSW
gd~~ SSE type=Constant (game.util.directions.AbsoluteDirection.SSE) => <absoluteDirection>, pack=game.util.directions, label=SSE, cls=game.util.directions.AbsoluteDirection, keyword=SSE
gd~~ ESE type=Constant (game.util.directions.AbsoluteDirection.ESE) => <absoluteDirection>, pack=game.util.directions, label=ESE, cls=game.util.directions.AbsoluteDirection, keyword=ESE
gd~~ ENE type=Constant (game.util.directions.AbsoluteDirection.ENE) => <absoluteDirection>, pack=game.util.directions, label=ENE, cls=game.util.directions.AbsoluteDirection, keyword=ENE
gd~~ NNE type=Constant (game.util.directions.AbsoluteDirection.NNE) => <absoluteDirection>, pack=game.util.directions, label=NNE, cls=game.util.directions.AbsoluteDirection, keyword=NNE
gd~~ CW type=Constant (game.util.directions.AbsoluteDirection.CW) => <absoluteDirection>, pack=game.util.directions, label=CW, cls=game.util.directions.AbsoluteDirection, keyword=CW
gd~~ CCW type=Constant (game.util.directions.AbsoluteDirection.CCW) => <absoluteDirection>, pack=game.util.directions, label=CCW, cls=game.util.directions.AbsoluteDirection, keyword=CCW
gd~~ In type=Constant (game.util.directions.AbsoluteDirection.In) => <absoluteDirection>, pack=game.util.directions, label=In, cls=game.util.directions.AbsoluteDirection, keyword=In
gd~~ Out type=Constant (game.util.directions.AbsoluteDirection.Out) => <absoluteDirection>, pack=game.util.directions, label=Out, cls=game.util.directions.AbsoluteDirection, keyword=Out
gd~~ U type=Constant (game.util.directions.AbsoluteDirection.U) => <absoluteDirection>, pack=game.util.directions, label=U, cls=game.util.directions.AbsoluteDirection, keyword=U
gd~~ UN type=Constant (game.util.directions.AbsoluteDirection.UN) => <absoluteDirection>, pack=game.util.directions, label=UN, cls=game.util.directions.AbsoluteDirection, keyword=UN
gd~~ UNE type=Constant (game.util.directions.AbsoluteDirection.UNE) => <absoluteDirection>, pack=game.util.directions, label=UNE, cls=game.util.directions.AbsoluteDirection, keyword=UNE
gd~~ UE type=Constant (game.util.directions.AbsoluteDirection.UE) => <absoluteDirection>, pack=game.util.directions, label=UE, cls=game.util.directions.AbsoluteDirection, keyword=UE
gd~~ USE type=Constant (game.util.directions.AbsoluteDirection.USE) => <absoluteDirection>, pack=game.util.directions, label=USE, cls=game.util.directions.AbsoluteDirection, keyword=USE
gd~~ US type=Constant (game.util.directions.AbsoluteDirection.US) => <absoluteDirection>, pack=game.util.directions, label=US, cls=game.util.directions.AbsoluteDirection, keyword=US
gd~~ USW type=Constant (game.util.directions.AbsoluteDirection.USW) => <absoluteDirection>, pack=game.util.directions, label=USW, cls=game.util.directions.AbsoluteDirection, keyword=USW
gd~~ UW type=Constant (game.util.directions.AbsoluteDirection.UW) => <absoluteDirection>, pack=game.util.directions, label=UW, cls=game.util.directions.AbsoluteDirection, keyword=UW
gd~~ UNW type=Constant (game.util.directions.AbsoluteDirection.UNW) => <absoluteDirection>, pack=game.util.directions, label=UNW, cls=game.util.directions.AbsoluteDirection, keyword=UNW
gd~~ D type=Constant (game.util.directions.AbsoluteDirection.D) => <absoluteDirection>, pack=game.util.directions, label=D, cls=game.util.directions.AbsoluteDirection, keyword=D
gd~~ DN type=Constant (game.util.directions.AbsoluteDirection.DN) => <absoluteDirection>, pack=game.util.directions, label=DN, cls=game.util.directions.AbsoluteDirection, keyword=DN
gd~~ DNE type=Constant (game.util.directions.AbsoluteDirection.DNE) => <absoluteDirection>, pack=game.util.directions, label=DNE, cls=game.util.directions.AbsoluteDirection, keyword=DNE
gd~~ DE type=Constant (game.util.directions.AbsoluteDirection.DE) => <absoluteDirection>, pack=game.util.directions, label=DE, cls=game.util.directions.AbsoluteDirection, keyword=DE
gd~~ DSE type=Constant (game.util.directions.AbsoluteDirection.DSE) => <absoluteDirection>, pack=game.util.directions, label=DSE, cls=game.util.directions.AbsoluteDirection, keyword=DSE
gd~~ DS type=Constant (game.util.directions.AbsoluteDirection.DS) => <absoluteDirection>, pack=game.util.directions, label=DS, cls=game.util.directions.AbsoluteDirection, keyword=DS
gd~~ DSW type=Constant (game.util.directions.AbsoluteDirection.DSW) => <absoluteDirection>, pack=game.util.directions, label=DSW, cls=game.util.directions.AbsoluteDirection, keyword=DSW
gd~~ DW type=Constant (game.util.directions.AbsoluteDirection.DW) => <absoluteDirection>, pack=game.util.directions, label=DW, cls=game.util.directions.AbsoluteDirection, keyword=DW
gd~~ DNW type=Constant (game.util.directions.AbsoluteDirection.DNW) => <absoluteDirection>, pack=game.util.directions, label=DNW, cls=game.util.directions.AbsoluteDirection, keyword=DNW
~~~~ Out type=Constant (game.util.directions.RotationalDirection.Out) => <rotationalDirection>, pack=game.util.directions, label=Out, cls=game.util.directions.RotationalDirection, keyword=Out
~~~~ CW type=Constant (game.util.directions.RotationalDirection.CW) => <rotationalDirection>, pack=game.util.directions, label=CW, cls=game.util.directions.RotationalDirection, keyword=CW
~~~~ In type=Constant (game.util.directions.RotationalDirection.In) => <rotationalDirection>, pack=game.util.directions, label=In, cls=game.util.directions.RotationalDirection, keyword=In
~~~~ CCW type=Constant (game.util.directions.RotationalDirection.CCW) => <rotationalDirection>, pack=game.util.directions, label=CCW, cls=game.util.directions.RotationalDirection, keyword=CCW
gd~~ N type=Constant (game.util.directions.CompassDirection.N) => <compassDirection>, pack=game.util.directions, label=N, cls=game.util.directions.CompassDirection, keyword=N
gd~~ NNE type=Constant (game.util.directions.CompassDirection.NNE) => <compassDirection>, pack=game.util.directions, label=NNE, cls=game.util.directions.CompassDirection, keyword=NNE
gd~~ NE type=Constant (game.util.directions.CompassDirection.NE) => <compassDirection>, pack=game.util.directions, label=NE, cls=game.util.directions.CompassDirection, keyword=NE
gd~~ ENE type=Constant (game.util.directions.CompassDirection.ENE) => <compassDirection>, pack=game.util.directions, label=ENE, cls=game.util.directions.CompassDirection, keyword=ENE
gd~~ E type=Constant (game.util.directions.CompassDirection.E) => <compassDirection>, pack=game.util.directions, label=E, cls=game.util.directions.CompassDirection, keyword=E
gd~~ ESE type=Constant (game.util.directions.CompassDirection.ESE) => <compassDirection>, pack=game.util.directions, label=ESE, cls=game.util.directions.CompassDirection, keyword=ESE
gd~~ SE type=Constant (game.util.directions.CompassDirection.SE) => <compassDirection>, pack=game.util.directions, label=SE, cls=game.util.directions.CompassDirection, keyword=SE
gd~~ SSE type=Constant (game.util.directions.CompassDirection.SSE) => <compassDirection>, pack=game.util.directions, label=SSE, cls=game.util.directions.CompassDirection, keyword=SSE
gd~~ S type=Constant (game.util.directions.CompassDirection.S) => <compassDirection>, pack=game.util.directions, label=S, cls=game.util.directions.CompassDirection, keyword=S
gd~~ SSW type=Constant (game.util.directions.CompassDirection.SSW) => <compassDirection>, pack=game.util.directions, label=SSW, cls=game.util.directions.CompassDirection, keyword=SSW
gd~~ SW type=Constant (game.util.directions.CompassDirection.SW) => <compassDirection>, pack=game.util.directions, label=SW, cls=game.util.directions.CompassDirection, keyword=SW
gd~~ WSW type=Constant (game.util.directions.CompassDirection.WSW) => <compassDirection>, pack=game.util.directions, label=WSW, cls=game.util.directions.CompassDirection, keyword=WSW
gd~~ W type=Constant (game.util.directions.CompassDirection.W) => <compassDirection>, pack=game.util.directions, label=W, cls=game.util.directions.CompassDirection, keyword=W
gd~~ WNW type=Constant (game.util.directions.CompassDirection.WNW) => <compassDirection>, pack=game.util.directions, label=WNW, cls=game.util.directions.CompassDirection, keyword=WNW
gd~~ NW type=Constant (game.util.directions.CompassDirection.NW) => <compassDirection>, pack=game.util.directions, label=NW, cls=game.util.directions.CompassDirection, keyword=NW
gd~~ NNW type=Constant (game.util.directions.CompassDirection.NNW) => <compassDirection>, pack=game.util.directions, label=NNW, cls=game.util.directions.CompassDirection, keyword=NNW
~~~~ D type=Constant (game.util.directions.SpatialDirection.D) => <spatialDirection>, pack=game.util.directions, label=D, cls=game.util.directions.SpatialDirection, keyword=D
~~~~ DN type=Constant (game.util.directions.SpatialDirection.DN) => <spatialDirection>, pack=game.util.directions, label=DN, cls=game.util.directions.SpatialDirection, keyword=DN
~~~~ DNE type=Constant (game.util.directions.SpatialDirection.DNE) => <spatialDirection>, pack=game.util.directions, label=DNE, cls=game.util.directions.SpatialDirection, keyword=DNE
~~~~ DE type=Constant (game.util.directions.SpatialDirection.DE) => <spatialDirection>, pack=game.util.directions, label=DE, cls=game.util.directions.SpatialDirection, keyword=DE
~~~~ DSE type=Constant (game.util.directions.SpatialDirection.DSE) => <spatialDirection>, pack=game.util.directions, label=DSE, cls=game.util.directions.SpatialDirection, keyword=DSE
~~~~ DS type=Constant (game.util.directions.SpatialDirection.DS) => <spatialDirection>, pack=game.util.directions, label=DS, cls=game.util.directions.SpatialDirection, keyword=DS
~~~~ DSW type=Constant (game.util.directions.SpatialDirection.DSW) => <spatialDirection>, pack=game.util.directions, label=DSW, cls=game.util.directions.SpatialDirection, keyword=DSW
~~~~ DW type=Constant (game.util.directions.SpatialDirection.DW) => <spatialDirection>, pack=game.util.directions, label=DW, cls=game.util.directions.SpatialDirection, keyword=DW
~~~~ DNW type=Constant (game.util.directions.SpatialDirection.DNW) => <spatialDirection>, pack=game.util.directions, label=DNW, cls=game.util.directions.SpatialDirection, keyword=DNW
~~~~ U type=Constant (game.util.directions.SpatialDirection.U) => <spatialDirection>, pack=game.util.directions, label=U, cls=game.util.directions.SpatialDirection, keyword=U
~~~~ UN type=Constant (game.util.directions.SpatialDirection.UN) => <spatialDirection>, pack=game.util.directions, label=UN, cls=game.util.directions.SpatialDirection, keyword=UN
~~~~ UNE type=Constant (game.util.directions.SpatialDirection.UNE) => <spatialDirection>, pack=game.util.directions, label=UNE, cls=game.util.directions.SpatialDirection, keyword=UNE
~~~~ UE type=Constant (game.util.directions.SpatialDirection.UE) => <spatialDirection>, pack=game.util.directions, label=UE, cls=game.util.directions.SpatialDirection, keyword=UE
~~~~ USE type=Constant (game.util.directions.SpatialDirection.USE) => <spatialDirection>, pack=game.util.directions, label=USE, cls=game.util.directions.SpatialDirection, keyword=USE
~~~~ US type=Constant (game.util.directions.SpatialDirection.US) => <spatialDirection>, pack=game.util.directions, label=US, cls=game.util.directions.SpatialDirection, keyword=US
~~~~ USW type=Constant (game.util.directions.SpatialDirection.USW) => <spatialDirection>, pack=game.util.directions, label=USW, cls=game.util.directions.SpatialDirection, keyword=USW
~~~~ UW type=Constant (game.util.directions.SpatialDirection.UW) => <spatialDirection>, pack=game.util.directions, label=UW, cls=game.util.directions.SpatialDirection, keyword=UW
~~~~ UNW type=Constant (game.util.directions.SpatialDirection.UNW) => <spatialDirection>, pack=game.util.directions, label=UNW, cls=game.util.directions.SpatialDirection, keyword=UNW
gd~~ What type=Constant (game.types.board.HiddenData.What) => <hiddenData>, pack=game.types.board, label=What, cls=game.types.board.HiddenData, keyword=What
gd~~ Who type=Constant (game.types.board.HiddenData.Who) => <hiddenData>, pack=game.types.board, label=Who, cls=game.types.board.HiddenData, keyword=Who
gd~~ State type=Constant (game.types.board.HiddenData.State) => <hiddenData>, pack=game.types.board, label=State, cls=game.types.board.HiddenData, keyword=State
gd~~ Count type=Constant (game.types.board.HiddenData.Count) => <hiddenData>, pack=game.types.board, label=Count, cls=game.types.board.HiddenData, keyword=Count
gd~~ Rotation type=Constant (game.types.board.HiddenData.Rotation) => <hiddenData>, pack=game.types.board, label=Rotation, cls=game.types.board.HiddenData, keyword=Rotation
gd~~ Value type=Constant (game.types.board.HiddenData.Value) => <hiddenData>, pack=game.types.board, label=Value, cls=game.types.board.HiddenData, keyword=Value
gd~~ NoShape type=Constant (game.types.board.ShapeType.NoShape) => <shapeType>, pack=game.types.board, label=NoShape, cls=game.types.board.ShapeType, keyword=NoShape
gd~~ Custom type=Constant (game.types.board.ShapeType.Custom) => <shapeType>, pack=game.types.board, label=Custom, cls=game.types.board.ShapeType, keyword=Custom
gd~~ Square type=Constant (game.types.board.ShapeType.Square) => <shapeType>, pack=game.types.board, label=Square, cls=game.types.board.ShapeType, keyword=Square
gd~~ Rectangle type=Constant (game.types.board.ShapeType.Rectangle) => <shapeType>, pack=game.types.board, label=Rectangle, cls=game.types.board.ShapeType, keyword=Rectangle
gd~~ Triangle type=Constant (game.types.board.ShapeType.Triangle) => <shapeType>, pack=game.types.board, label=Triangle, cls=game.types.board.ShapeType, keyword=Triangle
gd~~ Hexagon type=Constant (game.types.board.ShapeType.Hexagon) => <shapeType>, pack=game.types.board, label=Hexagon, cls=game.types.board.ShapeType, keyword=Hexagon
gd~~ Cross type=Constant (game.types.board.ShapeType.Cross) => <shapeType>, pack=game.types.board, label=Cross, cls=game.types.board.ShapeType, keyword=Cross
gd~~ Diamond type=Constant (game.types.board.ShapeType.Diamond) => <shapeType>, pack=game.types.board, label=Diamond, cls=game.types.board.ShapeType, keyword=Diamond
gd~~ Prism type=Constant (game.types.board.ShapeType.Prism) => <shapeType>, pack=game.types.board, label=Prism, cls=game.types.board.ShapeType, keyword=Prism
gd~~ Quadrilateral type=Constant (game.types.board.ShapeType.Quadrilateral) => <shapeType>, pack=game.types.board, label=Quadrilateral, cls=game.types.board.ShapeType, keyword=Quadrilateral
gd~~ Rhombus type=Constant (game.types.board.ShapeType.Rhombus) => <shapeType>, pack=game.types.board, label=Rhombus, cls=game.types.board.ShapeType, keyword=Rhombus
gd~~ Wheel type=Constant (game.types.board.ShapeType.Wheel) => <shapeType>, pack=game.types.board, label=Wheel, cls=game.types.board.ShapeType, keyword=Wheel
gd~~ Circle type=Constant (game.types.board.ShapeType.Circle) => <shapeType>, pack=game.types.board, label=Circle, cls=game.types.board.ShapeType, keyword=Circle
gd~~ Spiral type=Constant (game.types.board.ShapeType.Spiral) => <shapeType>, pack=game.types.board, label=Spiral, cls=game.types.board.ShapeType, keyword=Spiral
gd~~ Wedge type=Constant (game.types.board.ShapeType.Wedge) => <shapeType>, pack=game.types.board, label=Wedge, cls=game.types.board.ShapeType, keyword=Wedge
gd~~ Star type=Constant (game.types.board.ShapeType.Star) => <shapeType>, pack=game.types.board, label=Star, cls=game.types.board.ShapeType, keyword=Star
gd~~ Limping type=Constant (game.types.board.ShapeType.Limping) => <shapeType>, pack=game.types.board, label=Limping, cls=game.types.board.ShapeType, keyword=Limping
gd~~ Regular type=Constant (game.types.board.ShapeType.Regular) => <shapeType>, pack=game.types.board, label=Regular, cls=game.types.board.ShapeType, keyword=Regular
gd~~ Polygon type=Constant (game.types.board.ShapeType.Polygon) => <shapeType>, pack=game.types.board, label=Polygon, cls=game.types.board.ShapeType, keyword=Polygon
gd~~ Square type=Constant (game.types.board.TilingBoardlessType.Square) => <tilingBoardlessType>, pack=game.types.board, label=Square, cls=game.types.board.TilingBoardlessType, keyword=Square
gd~~ Triangular type=Constant (game.types.board.TilingBoardlessType.Triangular) => <tilingBoardlessType>, pack=game.types.board, label=Triangular, cls=game.types.board.TilingBoardlessType, keyword=Triangular
gd~~ Hexagonal type=Constant (game.types.board.TilingBoardlessType.Hexagonal) => <tilingBoardlessType>, pack=game.types.board, label=Hexagonal, cls=game.types.board.TilingBoardlessType, keyword=Hexagonal
gd~~ F type=Constant (game.types.board.StepType.F) => <stepType>, pack=game.types.board, label=F, cls=game.types.board.StepType, keyword=F
gd~~ L type=Constant (game.types.board.StepType.L) => <stepType>, pack=game.types.board, label=L, cls=game.types.board.StepType, keyword=L
gd~~ R type=Constant (game.types.board.StepType.R) => <stepType>, pack=game.types.board, label=R, cls=game.types.board.StepType, keyword=R
gd~~ Rows type=Constant (game.types.board.RegionTypeStatic.Rows) => <regionTypeStatic>, pack=game.types.board, label=Rows, cls=game.types.board.RegionTypeStatic, keyword=Rows
gd~~ Columns type=Constant (game.types.board.RegionTypeStatic.Columns) => <regionTypeStatic>, pack=game.types.board, label=Columns, cls=game.types.board.RegionTypeStatic, keyword=Columns
gd~~ AllDirections type=Constant (game.types.board.RegionTypeStatic.AllDirections) => <regionTypeStatic>, pack=game.types.board, label=AllDirections, cls=game.types.board.RegionTypeStatic, keyword=AllDirections
gd~~ HintRegions type=Constant (game.types.board.RegionTypeStatic.HintRegions) => <regionTypeStatic>, pack=game.types.board, label=HintRegions, cls=game.types.board.RegionTypeStatic, keyword=HintRegions
gd~~ Layers type=Constant (game.types.board.RegionTypeStatic.Layers) => <regionTypeStatic>, pack=game.types.board, label=Layers, cls=game.types.board.RegionTypeStatic, keyword=Layers
gd~~ Diagonals type=Constant (game.types.board.RegionTypeStatic.Diagonals) => <regionTypeStatic>, pack=game.types.board, label=Diagonals, cls=game.types.board.RegionTypeStatic, keyword=Diagonals
gd~~ SubGrids type=Constant (game.types.board.RegionTypeStatic.SubGrids) => <regionTypeStatic>, pack=game.types.board, label=SubGrids, cls=game.types.board.RegionTypeStatic, keyword=SubGrids
gd~~ Regions type=Constant (game.types.board.RegionTypeStatic.Regions) => <regionTypeStatic>, pack=game.types.board, label=Regions, cls=game.types.board.RegionTypeStatic, keyword=Regions
gd~~ Vertices type=Constant (game.types.board.RegionTypeStatic.Vertices) => <regionTypeStatic>, pack=game.types.board, label=Vertices, cls=game.types.board.RegionTypeStatic, keyword=Vertices
gd~~ Corners type=Constant (game.types.board.RegionTypeStatic.Corners) => <regionTypeStatic>, pack=game.types.board, label=Corners, cls=game.types.board.RegionTypeStatic, keyword=Corners
gd~~ Sides type=Constant (game.types.board.RegionTypeStatic.Sides) => <regionTypeStatic>, pack=game.types.board, label=Sides, cls=game.types.board.RegionTypeStatic, keyword=Sides
gd~~ SidesNoCorners type=Constant (game.types.board.RegionTypeStatic.SidesNoCorners) => <regionTypeStatic>, pack=game.types.board, label=SidesNoCorners, cls=game.types.board.RegionTypeStatic, keyword=SidesNoCorners
gd~~ AllSites type=Constant (game.types.board.RegionTypeStatic.AllSites) => <regionTypeStatic>, pack=game.types.board, label=AllSites, cls=game.types.board.RegionTypeStatic, keyword=AllSites
gd~~ Touching type=Constant (game.types.board.RegionTypeStatic.Touching) => <regionTypeStatic>, pack=game.types.board, label=Touching, cls=game.types.board.RegionTypeStatic, keyword=Touching
gd~~ Orthogonal type=Constant (game.types.board.RelationType.Orthogonal) => <relationType>, pack=game.types.board, label=Orthogonal, cls=game.types.board.RelationType, keyword=Orthogonal
gd~~ Diagonal type=Constant (game.types.board.RelationType.Diagonal) => <relationType>, pack=game.types.board, label=Diagonal, cls=game.types.board.RelationType, keyword=Diagonal
gd~~ OffDiagonal type=Constant (game.types.board.RelationType.OffDiagonal) => <relationType>, pack=game.types.board, label=OffDiagonal, cls=game.types.board.RelationType, keyword=OffDiagonal
gd~~ Adjacent type=Constant (game.types.board.RelationType.Adjacent) => <relationType>, pack=game.types.board, label=Adjacent, cls=game.types.board.RelationType, keyword=Adjacent
gd~~ All type=Constant (game.types.board.RelationType.All) => <relationType>, pack=game.types.board, label=All, cls=game.types.board.RelationType, keyword=All
gd~~ Cell type=Constant (game.types.board.PuzzleElementType.Cell) => <puzzleElementType>, pack=game.types.board, label=Cell, cls=game.types.board.PuzzleElementType, keyword=Cell
gd~~ Edge type=Constant (game.types.board.PuzzleElementType.Edge) => <puzzleElementType>, pack=game.types.board, label=Edge, cls=game.types.board.PuzzleElementType, keyword=Edge
gd~~ Vertex type=Constant (game.types.board.PuzzleElementType.Vertex) => <puzzleElementType>, pack=game.types.board, label=Vertex, cls=game.types.board.PuzzleElementType, keyword=Vertex
gd~~ Hint type=Constant (game.types.board.PuzzleElementType.Hint) => <puzzleElementType>, pack=game.types.board, label=Hint, cls=game.types.board.PuzzleElementType, keyword=Hint
gd~~ None type=Constant (game.types.board.StoreType.None) => <storeType>, pack=game.types.board, label=None, cls=game.types.board.StoreType, keyword=None
gd~~ Outer type=Constant (game.types.board.StoreType.Outer) => <storeType>, pack=game.types.board, label=Outer, cls=game.types.board.StoreType, keyword=Outer
gd~~ Inner type=Constant (game.types.board.StoreType.Inner) => <storeType>, pack=game.types.board, label=Inner, cls=game.types.board.StoreType, keyword=Inner
gd~~ Vertex type=Constant (game.types.board.SiteType.Vertex) => <siteType>, pack=game.types.board, label=Vertex, cls=game.types.board.SiteType, keyword=Vertex
gd~~ Edge type=Constant (game.types.board.SiteType.Edge) => <siteType>, pack=game.types.board, label=Edge, cls=game.types.board.SiteType, keyword=Edge
gd~~ Cell type=Constant (game.types.board.SiteType.Cell) => <siteType>, pack=game.types.board, label=Cell, cls=game.types.board.SiteType, keyword=Cell
gd~~ CentreSite type=Constant (game.types.board.LandmarkType.CentreSite) => <landmarkType>, pack=game.types.board, label=CentreSite, cls=game.types.board.LandmarkType, keyword=CentreSite
gd~~ LeftSite type=Constant (game.types.board.LandmarkType.LeftSite) => <landmarkType>, pack=game.types.board, label=LeftSite, cls=game.types.board.LandmarkType, keyword=LeftSite
gd~~ RightSite type=Constant (game.types.board.LandmarkType.RightSite) => <landmarkType>, pack=game.types.board, label=RightSite, cls=game.types.board.LandmarkType, keyword=RightSite
gd~~ Topsite type=Constant (game.types.board.LandmarkType.Topsite) => <landmarkType>, pack=game.types.board, label=Topsite, cls=game.types.board.LandmarkType, keyword=Topsite
gd~~ BottomSite type=Constant (game.types.board.LandmarkType.BottomSite) => <landmarkType>, pack=game.types.board, label=BottomSite, cls=game.types.board.LandmarkType, keyword=BottomSite
gd~~ FirstSite type=Constant (game.types.board.LandmarkType.FirstSite) => <landmarkType>, pack=game.types.board, label=FirstSite, cls=game.types.board.LandmarkType, keyword=FirstSite
gd~~ LastSite type=Constant (game.types.board.LandmarkType.LastSite) => <landmarkType>, pack=game.types.board, label=LastSite, cls=game.types.board.LandmarkType, keyword=LastSite
gd~~ Track type=Constant (game.types.board.TrackType.Track) => <trackType>, pack=game.types.board, label=Track, cls=game.types.board.TrackType, keyword=Track
gd~~ Empty type=Constant (game.types.board.RegionTypeDynamic.Empty) => <regionTypeDynamic>, pack=game.types.board, label=Empty, cls=game.types.board.RegionTypeDynamic, keyword=Empty
gd~~ NotEmpty type=Constant (game.types.board.RegionTypeDynamic.NotEmpty) => <regionTypeDynamic>, pack=game.types.board, label=NotEmpty, cls=game.types.board.RegionTypeDynamic, keyword=NotEmpty
gd~~ Own type=Constant (game.types.board.RegionTypeDynamic.Own) => <regionTypeDynamic>, pack=game.types.board, label=Own, cls=game.types.board.RegionTypeDynamic, keyword=Own
gd~~ NotOwn type=Constant (game.types.board.RegionTypeDynamic.NotOwn) => <regionTypeDynamic>, pack=game.types.board, label=NotOwn, cls=game.types.board.RegionTypeDynamic, keyword=NotOwn
gd~~ Enemy type=Constant (game.types.board.RegionTypeDynamic.Enemy) => <regionTypeDynamic>, pack=game.types.board, label=Enemy, cls=game.types.board.RegionTypeDynamic, keyword=Enemy
gd~~ NotEnemy type=Constant (game.types.board.RegionTypeDynamic.NotEnemy) => <regionTypeDynamic>, pack=game.types.board, label=NotEnemy, cls=game.types.board.RegionTypeDynamic, keyword=NotEnemy
gd~~ NoBasis type=Constant (game.types.board.BasisType.NoBasis) => <basisType>, pack=game.types.board, label=NoBasis, cls=game.types.board.BasisType, keyword=NoBasis
gd~~ Triangular type=Constant (game.types.board.BasisType.Triangular) => <basisType>, pack=game.types.board, label=Triangular, cls=game.types.board.BasisType, keyword=Triangular
gd~~ Square type=Constant (game.types.board.BasisType.Square) => <basisType>, pack=game.types.board, label=Square, cls=game.types.board.BasisType, keyword=Square
gd~~ Hexagonal type=Constant (game.types.board.BasisType.Hexagonal) => <basisType>, pack=game.types.board, label=Hexagonal, cls=game.types.board.BasisType, keyword=Hexagonal
gd~~ T33336 type=Constant (game.types.board.BasisType.T33336) => <basisType>, pack=game.types.board, label=T33336, cls=game.types.board.BasisType, keyword=T33336
gd~~ T33344 type=Constant (game.types.board.BasisType.T33344) => <basisType>, pack=game.types.board, label=T33344, cls=game.types.board.BasisType, keyword=T33344
gd~~ T33434 type=Constant (game.types.board.BasisType.T33434) => <basisType>, pack=game.types.board, label=T33434, cls=game.types.board.BasisType, keyword=T33434
gd~~ T3464 type=Constant (game.types.board.BasisType.T3464) => <basisType>, pack=game.types.board, label=T3464, cls=game.types.board.BasisType, keyword=T3464
gd~~ T3636 type=Constant (game.types.board.BasisType.T3636) => <basisType>, pack=game.types.board, label=T3636, cls=game.types.board.BasisType, keyword=T3636
gd~~ T4612 type=Constant (game.types.board.BasisType.T4612) => <basisType>, pack=game.types.board, label=T4612, cls=game.types.board.BasisType, keyword=T4612
gd~~ T488 type=Constant (game.types.board.BasisType.T488) => <basisType>, pack=game.types.board, label=T488, cls=game.types.board.BasisType, keyword=T488
gd~~ T31212 type=Constant (game.types.board.BasisType.T31212) => <basisType>, pack=game.types.board, label=T31212, cls=game.types.board.BasisType, keyword=T31212
gd~~ T333333_33434 type=Constant (game.types.board.BasisType.T333333_33434) => <basisType>, pack=game.types.board, label=T333333_33434, cls=game.types.board.BasisType, keyword=T333333_33434
gd~~ SquarePyramidal type=Constant (game.types.board.BasisType.SquarePyramidal) => <basisType>, pack=game.types.board, label=SquarePyramidal, cls=game.types.board.BasisType, keyword=SquarePyramidal
gd~~ HexagonalPyramidal type=Constant (game.types.board.BasisType.HexagonalPyramidal) => <basisType>, pack=game.types.board, label=HexagonalPyramidal, cls=game.types.board.BasisType, keyword=HexagonalPyramidal
gd~~ Concentric type=Constant (game.types.board.BasisType.Concentric) => <basisType>, pack=game.types.board, label=Concentric, cls=game.types.board.BasisType, keyword=Concentric
gd~~ Circle type=Constant (game.types.board.BasisType.Circle) => <basisType>, pack=game.types.board, label=Circle, cls=game.types.board.BasisType, keyword=Circle
gd~~ Spiral type=Constant (game.types.board.BasisType.Spiral) => <basisType>, pack=game.types.board, label=Spiral, cls=game.types.board.BasisType, keyword=Spiral
gd~~ Dual type=Constant (game.types.board.BasisType.Dual) => <basisType>, pack=game.types.board, label=Dual, cls=game.types.board.BasisType, keyword=Dual
gd~~ Brick type=Constant (game.types.board.BasisType.Brick) => <basisType>, pack=game.types.board, label=Brick, cls=game.types.board.BasisType, keyword=Brick
gd~~ Mesh type=Constant (game.types.board.BasisType.Mesh) => <basisType>, pack=game.types.board, label=Mesh, cls=game.types.board.BasisType, keyword=Mesh
gd~~ Morris type=Constant (game.types.board.BasisType.Morris) => <basisType>, pack=game.types.board, label=Morris, cls=game.types.board.BasisType, keyword=Morris
gd~~ Celtic type=Constant (game.types.board.BasisType.Celtic) => <basisType>, pack=game.types.board, label=Celtic, cls=game.types.board.BasisType, keyword=Celtic
gd~~ QuadHex type=Constant (game.types.board.BasisType.QuadHex) => <basisType>, pack=game.types.board, label=QuadHex, cls=game.types.board.BasisType, keyword=QuadHex
gd~~ Mover type=Constant (game.types.play.PrevType.Mover) => <prevType>, pack=game.types.play, label=Mover, cls=game.types.play.PrevType, keyword=Mover
gd~~ MoverLastTurn type=Constant (game.types.play.PrevType.MoverLastTurn) => <prevType>, pack=game.types.play, label=MoverLastTurn, cls=game.types.play.PrevType, keyword=MoverLastTurn
gd~~ InTurn type=Constant (game.types.play.RepetitionType.InTurn) => <repetitionType>, pack=game.types.play, label=InTurn, cls=game.types.play.RepetitionType, keyword=InTurn
gd~~ InGame type=Constant (game.types.play.RepetitionType.InGame) => <repetitionType>, pack=game.types.play, label=InGame, cls=game.types.play.RepetitionType, keyword=InGame
gd~~ Positional type=Constant (game.types.play.RepetitionType.Positional) => <repetitionType>, pack=game.types.play, label=Positional, cls=game.types.play.RepetitionType, keyword=Positional
gd~~ Situational type=Constant (game.types.play.RepetitionType.Situational) => <repetitionType>, pack=game.types.play, label=Situational, cls=game.types.play.RepetitionType, keyword=Situational
gd~~ Draw type=Constant (game.types.play.PassEndType.Draw) => <passEndType>, pack=game.types.play, label=Draw, cls=game.types.play.PassEndType, keyword=Draw
gd~~ NoEnd type=Constant (game.types.play.PassEndType.NoEnd) => <passEndType>, pack=game.types.play, label=NoEnd, cls=game.types.play.PassEndType, keyword=NoEnd
gd~~ Neutral type=Constant (game.types.play.RoleType.Neutral) => <roleType>, pack=game.types.play, label=Neutral, cls=game.types.play.RoleType, keyword=Neutral
gd~~ P1 type=Constant (game.types.play.RoleType.P1) => <roleType>, pack=game.types.play, label=P1, cls=game.types.play.RoleType, keyword=P1
gd~~ P2 type=Constant (game.types.play.RoleType.P2) => <roleType>, pack=game.types.play, label=P2, cls=game.types.play.RoleType, keyword=P2
gd~~ P3 type=Constant (game.types.play.RoleType.P3) => <roleType>, pack=game.types.play, label=P3, cls=game.types.play.RoleType, keyword=P3
gd~~ P4 type=Constant (game.types.play.RoleType.P4) => <roleType>, pack=game.types.play, label=P4, cls=game.types.play.RoleType, keyword=P4
gd~~ P5 type=Constant (game.types.play.RoleType.P5) => <roleType>, pack=game.types.play, label=P5, cls=game.types.play.RoleType, keyword=P5
gd~~ P6 type=Constant (game.types.play.RoleType.P6) => <roleType>, pack=game.types.play, label=P6, cls=game.types.play.RoleType, keyword=P6
gd~~ P7 type=Constant (game.types.play.RoleType.P7) => <roleType>, pack=game.types.play, label=P7, cls=game.types.play.RoleType, keyword=P7
gd~~ P8 type=Constant (game.types.play.RoleType.P8) => <roleType>, pack=game.types.play, label=P8, cls=game.types.play.RoleType, keyword=P8
gd~~ P9 type=Constant (game.types.play.RoleType.P9) => <roleType>, pack=game.types.play, label=P9, cls=game.types.play.RoleType, keyword=P9
gd~~ P10 type=Constant (game.types.play.RoleType.P10) => <roleType>, pack=game.types.play, label=P10, cls=game.types.play.RoleType, keyword=P10
gd~~ P11 type=Constant (game.types.play.RoleType.P11) => <roleType>, pack=game.types.play, label=P11, cls=game.types.play.RoleType, keyword=P11
gd~~ P12 type=Constant (game.types.play.RoleType.P12) => <roleType>, pack=game.types.play, label=P12, cls=game.types.play.RoleType, keyword=P12
gd~~ P13 type=Constant (game.types.play.RoleType.P13) => <roleType>, pack=game.types.play, label=P13, cls=game.types.play.RoleType, keyword=P13
gd~~ P14 type=Constant (game.types.play.RoleType.P14) => <roleType>, pack=game.types.play, label=P14, cls=game.types.play.RoleType, keyword=P14
gd~~ P15 type=Constant (game.types.play.RoleType.P15) => <roleType>, pack=game.types.play, label=P15, cls=game.types.play.RoleType, keyword=P15
gd~~ P16 type=Constant (game.types.play.RoleType.P16) => <roleType>, pack=game.types.play, label=P16, cls=game.types.play.RoleType, keyword=P16
gd~~ Team1 type=Constant (game.types.play.RoleType.Team1) => <roleType>, pack=game.types.play, label=Team1, cls=game.types.play.RoleType, keyword=Team1
gd~~ Team2 type=Constant (game.types.play.RoleType.Team2) => <roleType>, pack=game.types.play, label=Team2, cls=game.types.play.RoleType, keyword=Team2
gd~~ Team3 type=Constant (game.types.play.RoleType.Team3) => <roleType>, pack=game.types.play, label=Team3, cls=game.types.play.RoleType, keyword=Team3
gd~~ Team4 type=Constant (game.types.play.RoleType.Team4) => <roleType>, pack=game.types.play, label=Team4, cls=game.types.play.RoleType, keyword=Team4
gd~~ Team5 type=Constant (game.types.play.RoleType.Team5) => <roleType>, pack=game.types.play, label=Team5, cls=game.types.play.RoleType, keyword=Team5
gd~~ Team6 type=Constant (game.types.play.RoleType.Team6) => <roleType>, pack=game.types.play, label=Team6, cls=game.types.play.RoleType, keyword=Team6
gd~~ Team7 type=Constant (game.types.play.RoleType.Team7) => <roleType>, pack=game.types.play, label=Team7, cls=game.types.play.RoleType, keyword=Team7
gd~~ Team8 type=Constant (game.types.play.RoleType.Team8) => <roleType>, pack=game.types.play, label=Team8, cls=game.types.play.RoleType, keyword=Team8
gd~~ Team9 type=Constant (game.types.play.RoleType.Team9) => <roleType>, pack=game.types.play, label=Team9, cls=game.types.play.RoleType, keyword=Team9
gd~~ Team10 type=Constant (game.types.play.RoleType.Team10) => <roleType>, pack=game.types.play, label=Team10, cls=game.types.play.RoleType, keyword=Team10
gd~~ Team11 type=Constant (game.types.play.RoleType.Team11) => <roleType>, pack=game.types.play, label=Team11, cls=game.types.play.RoleType, keyword=Team11
gd~~ Team12 type=Constant (game.types.play.RoleType.Team12) => <roleType>, pack=game.types.play, label=Team12, cls=game.types.play.RoleType, keyword=Team12
gd~~ Team13 type=Constant (game.types.play.RoleType.Team13) => <roleType>, pack=game.types.play, label=Team13, cls=game.types.play.RoleType, keyword=Team13
gd~~ Team14 type=Constant (game.types.play.RoleType.Team14) => <roleType>, pack=game.types.play, label=Team14, cls=game.types.play.RoleType, keyword=Team14
gd~~ Team15 type=Constant (game.types.play.RoleType.Team15) => <roleType>, pack=game.types.play, label=Team15, cls=game.types.play.RoleType, keyword=Team15
gd~~ Team16 type=Constant (game.types.play.RoleType.Team16) => <roleType>, pack=game.types.play, label=Team16, cls=game.types.play.RoleType, keyword=Team16
gd~~ Each type=Constant (game.types.play.RoleType.Each) => <roleType>, pack=game.types.play, label=Each, cls=game.types.play.RoleType, keyword=Each
gd~~ Shared type=Constant (game.types.play.RoleType.Shared) => <roleType>, pack=game.types.play, label=Shared, cls=game.types.play.RoleType, keyword=Shared
gd~~ All type=Constant (game.types.play.RoleType.All) => <roleType>, pack=game.types.play, label=All, cls=game.types.play.RoleType, keyword=All
gd~~ Mover type=Constant (game.types.play.RoleType.Mover) => <roleType>, pack=game.types.play, label=Mover, cls=game.types.play.RoleType, keyword=Mover
gd~~ Next type=Constant (game.types.play.RoleType.Next) => <roleType>, pack=game.types.play, label=Next, cls=game.types.play.RoleType, keyword=Next
gd~~ Prev type=Constant (game.types.play.RoleType.Prev) => <roleType>, pack=game.types.play, label=Prev, cls=game.types.play.RoleType, keyword=Prev
gd~~ NonMover type=Constant (game.types.play.RoleType.NonMover) => <roleType>, pack=game.types.play, label=NonMover, cls=game.types.play.RoleType, keyword=NonMover
gd~~ Enemy type=Constant (game.types.play.RoleType.Enemy) => <roleType>, pack=game.types.play, label=Enemy, cls=game.types.play.RoleType, keyword=Enemy
gd~~ Friend type=Constant (game.types.play.RoleType.Friend) => <roleType>, pack=game.types.play, label=Friend, cls=game.types.play.RoleType, keyword=Friend
gd~~ Ally type=Constant (game.types.play.RoleType.Ally) => <roleType>, pack=game.types.play, label=Ally, cls=game.types.play.RoleType, keyword=Ally
gd~~ Player type=Constant (game.types.play.RoleType.Player) => <roleType>, pack=game.types.play, label=Player, cls=game.types.play.RoleType, keyword=Player
gd~~ StartOfMove type=Constant (game.types.play.WhenType.StartOfMove) => <whenType>, pack=game.types.play, label=StartOfMove, cls=game.types.play.WhenType, keyword=StartOfMove
gd~~ EndOfMove type=Constant (game.types.play.WhenType.EndOfMove) => <whenType>, pack=game.types.play, label=EndOfMove, cls=game.types.play.WhenType, keyword=EndOfMove
gd~~ StartOfTurn type=Constant (game.types.play.WhenType.StartOfTurn) => <whenType>, pack=game.types.play, label=StartOfTurn, cls=game.types.play.WhenType, keyword=StartOfTurn
gd~~ EndOfTurn type=Constant (game.types.play.WhenType.EndOfTurn) => <whenType>, pack=game.types.play, label=EndOfTurn, cls=game.types.play.WhenType, keyword=EndOfTurn
gd~~ StartOfRound type=Constant (game.types.play.WhenType.StartOfRound) => <whenType>, pack=game.types.play, label=StartOfRound, cls=game.types.play.WhenType, keyword=StartOfRound
gd~~ EndOfRound type=Constant (game.types.play.WhenType.EndOfRound) => <whenType>, pack=game.types.play, label=EndOfRound, cls=game.types.play.WhenType, keyword=EndOfRound
gd~~ StartOfPhase type=Constant (game.types.play.WhenType.StartOfPhase) => <whenType>, pack=game.types.play, label=StartOfPhase, cls=game.types.play.WhenType, keyword=StartOfPhase
gd~~ EndOfPhase type=Constant (game.types.play.WhenType.EndOfPhase) => <whenType>, pack=game.types.play, label=EndOfPhase, cls=game.types.play.WhenType, keyword=EndOfPhase
gd~~ StartOfGame type=Constant (game.types.play.WhenType.StartOfGame) => <whenType>, pack=game.types.play, label=StartOfGame, cls=game.types.play.WhenType, keyword=StartOfGame
gd~~ EndOfGame type=Constant (game.types.play.WhenType.EndOfGame) => <whenType>, pack=game.types.play, label=EndOfGame, cls=game.types.play.WhenType, keyword=EndOfGame
gd~~ StartOfMatch type=Constant (game.types.play.WhenType.StartOfMatch) => <whenType>, pack=game.types.play, label=StartOfMatch, cls=game.types.play.WhenType, keyword=StartOfMatch
gd~~ EndOfMatch type=Constant (game.types.play.WhenType.EndOfMatch) => <whenType>, pack=game.types.play, label=EndOfMatch, cls=game.types.play.WhenType, keyword=EndOfMatch
gd~~ StartOfSession type=Constant (game.types.play.WhenType.StartOfSession) => <whenType>, pack=game.types.play, label=StartOfSession, cls=game.types.play.WhenType, keyword=StartOfSession
gd~~ EndOfSession type=Constant (game.types.play.WhenType.EndOfSession) => <whenType>, pack=game.types.play, label=EndOfSession, cls=game.types.play.WhenType, keyword=EndOfSession
gd~~ Alternating type=Constant (game.types.play.ModeType.Alternating) => <modeType>, pack=game.types.play, label=Alternating, cls=game.types.play.ModeType, keyword=Alternating
gd~~ Simultaneous type=Constant (game.types.play.ModeType.Simultaneous) => <modeType>, pack=game.types.play, label=Simultaneous, cls=game.types.play.ModeType, keyword=Simultaneous
gd~~ Simulation type=Constant (game.types.play.ModeType.Simulation) => <modeType>, pack=game.types.play, label=Simulation, cls=game.types.play.ModeType, keyword=Simulation
gd~~ Win type=Constant (game.types.play.ResultType.Win) => <resultType>, pack=game.types.play, label=Win, cls=game.types.play.ResultType, keyword=Win
gd~~ Loss type=Constant (game.types.play.ResultType.Loss) => <resultType>, pack=game.types.play, label=Loss, cls=game.types.play.ResultType, keyword=Loss
gd~~ Draw type=Constant (game.types.play.ResultType.Draw) => <resultType>, pack=game.types.play, label=Draw, cls=game.types.play.ResultType, keyword=Draw
gd~~ Tie type=Constant (game.types.play.ResultType.Tie) => <resultType>, pack=game.types.play, label=Tie, cls=game.types.play.ResultType, keyword=Tie
gd~~ Abandon type=Constant (game.types.play.ResultType.Abandon) => <resultType>, pack=game.types.play, label=Abandon, cls=game.types.play.ResultType, keyword=Abandon
gd~~ Crash type=Constant (game.types.play.ResultType.Crash) => <resultType>, pack=game.types.play, label=Crash, cls=game.types.play.ResultType, keyword=Crash
gd~~ SupportMultiple type=Constant (game.types.play.PinType.SupportMultiple) => <pinType>, pack=game.types.play, label=SupportMultiple, cls=game.types.play.PinType, keyword=SupportMultiple
gd~~ PyramidalDrop type=Constant (game.types.play.GravityType.PyramidalDrop) => <gravityType>, pack=game.types.play, label=PyramidalDrop, cls=game.types.play.GravityType, keyword=PyramidalDrop
gd~~ Dominoes type=Constant (game.types.component.DealableType.Dominoes) => <dealableType>, pack=game.types.component, label=Dominoes, cls=game.types.component.DealableType, keyword=Dominoes
gd~~ Cards type=Constant (game.types.component.DealableType.Cards) => <dealableType>, pack=game.types.component, label=Cards, cls=game.types.component.DealableType, keyword=Cards
~~m~ Clubs type=Constant (game.types.component.SuitType.Clubs) => <suitType>, pack=game.types.component, label=Clubs, cls=game.types.component.SuitType, keyword=Clubs
~~m~ Spades type=Constant (game.types.component.SuitType.Spades) => <suitType>, pack=game.types.component, label=Spades, cls=game.types.component.SuitType, keyword=Spades
~~m~ Diamonds type=Constant (game.types.component.SuitType.Diamonds) => <suitType>, pack=game.types.component, label=Diamonds, cls=game.types.component.SuitType, keyword=Diamonds
~~m~ Hearts type=Constant (game.types.component.SuitType.Hearts) => <suitType>, pack=game.types.component, label=Hearts, cls=game.types.component.SuitType, keyword=Hearts
gd~~ Joker type=Constant (game.types.component.CardType.Joker) => <cardType>, pack=game.types.component, label=Joker, cls=game.types.component.CardType, keyword=Joker
gd~~ Ace type=Constant (game.types.component.CardType.Ace) => <cardType>, pack=game.types.component, label=Ace, cls=game.types.component.CardType, keyword=Ace
gd~~ Two type=Constant (game.types.component.CardType.Two) => <cardType>, pack=game.types.component, label=Two, cls=game.types.component.CardType, keyword=Two
gd~~ Three type=Constant (game.types.component.CardType.Three) => <cardType>, pack=game.types.component, label=Three, cls=game.types.component.CardType, keyword=Three
gd~~ Four type=Constant (game.types.component.CardType.Four) => <cardType>, pack=game.types.component, label=Four, cls=game.types.component.CardType, keyword=Four
gd~~ Five type=Constant (game.types.component.CardType.Five) => <cardType>, pack=game.types.component, label=Five, cls=game.types.component.CardType, keyword=Five
gd~~ Six type=Constant (game.types.component.CardType.Six) => <cardType>, pack=game.types.component, label=Six, cls=game.types.component.CardType, keyword=Six
gd~~ Seven type=Constant (game.types.component.CardType.Seven) => <cardType>, pack=game.types.component, label=Seven, cls=game.types.component.CardType, keyword=Seven
gd~~ Eight type=Constant (game.types.component.CardType.Eight) => <cardType>, pack=game.types.component, label=Eight, cls=game.types.component.CardType, keyword=Eight
gd~~ Nine type=Constant (game.types.component.CardType.Nine) => <cardType>, pack=game.types.component, label=Nine, cls=game.types.component.CardType, keyword=Nine
gd~~ Ten type=Constant (game.types.component.CardType.Ten) => <cardType>, pack=game.types.component, label=Ten, cls=game.types.component.CardType, keyword=Ten
gd~~ Jack type=Constant (game.types.component.CardType.Jack) => <cardType>, pack=game.types.component, label=Jack, cls=game.types.component.CardType, keyword=Jack
gd~~ Queen type=Constant (game.types.component.CardType.Queen) => <cardType>, pack=game.types.component, label=Queen, cls=game.types.component.CardType, keyword=Queen
gd~~ King type=Constant (game.types.component.CardType.King) => <cardType>, pack=game.types.component, label=King, cls=game.types.component.CardType, keyword=King
~~~~ Board type=Constant (metadata.graphics.no.NoBooleanType.Board) => <noBooleanType>, pack=metadata.graphics.no, label=Board, cls=metadata.graphics.no.NoBooleanType, keyword=Board
~~~~ Animation type=Constant (metadata.graphics.no.NoBooleanType.Animation) => <noBooleanType>, pack=metadata.graphics.no, label=Animation, cls=metadata.graphics.no.NoBooleanType, keyword=Animation
~~~~ Sunken type=Constant (metadata.graphics.no.NoBooleanType.Sunken) => <noBooleanType>, pack=metadata.graphics.no, label=Sunken, cls=metadata.graphics.no.NoBooleanType, keyword=Sunken
~~~~ HandScale type=Constant (metadata.graphics.no.NoBooleanType.HandScale) => <noBooleanType>, pack=metadata.graphics.no, label=HandScale, cls=metadata.graphics.no.NoBooleanType, keyword=HandScale
~~~~ Curves type=Constant (metadata.graphics.no.NoBooleanType.Curves) => <noBooleanType>, pack=metadata.graphics.no, label=Curves, cls=metadata.graphics.no.NoBooleanType, keyword=Curves
~~~~ MaskedColour type=Constant (metadata.graphics.no.NoBooleanType.MaskedColour) => <noBooleanType>, pack=metadata.graphics.no, label=MaskedColour, cls=metadata.graphics.no.NoBooleanType, keyword=MaskedColour
~~~~ DicePips type=Constant (metadata.graphics.no.NoBooleanType.DicePips) => <noBooleanType>, pack=metadata.graphics.no, label=DicePips, cls=metadata.graphics.no.NoBooleanType, keyword=DicePips
g~m~ Colour type=Constant (metadata.graphics.region.RegionColourType.Colour) => <regionColourType>, pack=metadata.graphics.region, label=Colour, cls=metadata.graphics.region.RegionColourType, keyword=Colour
g~m~ Style type=Constant (metadata.graphics.piece.PieceStyleType.Style) => <pieceStyleType>, pack=metadata.graphics.piece, label=Style, cls=metadata.graphics.piece.PieceStyleType, keyword=Style
~~~~ Rename type=Constant (metadata.graphics.piece.PieceNameType.Rename) => <pieceNameType>, pack=metadata.graphics.piece, label=Rename, cls=metadata.graphics.piece.PieceNameType, keyword=Rename
~~~~ ExtendName type=Constant (metadata.graphics.piece.PieceNameType.ExtendName) => <pieceNameType>, pack=metadata.graphics.piece, label=ExtendName, cls=metadata.graphics.piece.PieceNameType, keyword=ExtendName
~~~~ AddStateToName type=Constant (metadata.graphics.piece.PieceNameType.AddStateToName) => <pieceNameType>, pack=metadata.graphics.piece, label=AddStateToName, cls=metadata.graphics.piece.PieceNameType, keyword=AddStateToName
~~~~ Hidden type=Constant (metadata.graphics.piece.PieceNameType.Hidden) => <pieceNameType>, pack=metadata.graphics.piece, label=Hidden, cls=metadata.graphics.piece.PieceNameType, keyword=Hidden
g~m~ Reflect type=Constant (metadata.graphics.piece.PieceReflectType.Reflect) => <pieceReflectType>, pack=metadata.graphics.piece, label=Reflect, cls=metadata.graphics.piece.PieceReflectType, keyword=Reflect
g~m~ Colour type=Constant (metadata.graphics.piece.PieceColourType.Colour) => <pieceColourType>, pack=metadata.graphics.piece, label=Colour, cls=metadata.graphics.piece.PieceColourType, keyword=Colour
~~~~ ByValue type=Constant (metadata.graphics.piece.PieceScaleByType.ByValue) => <pieceScaleByType>, pack=metadata.graphics.piece, label=ByValue, cls=metadata.graphics.piece.PieceScaleByType, keyword=ByValue
g~m~ Families type=Constant (metadata.graphics.piece.PieceFamiliesType.Families) => <pieceFamiliesType>, pack=metadata.graphics.piece, label=Families, cls=metadata.graphics.piece.PieceFamiliesType, keyword=Families
g~m~ Scale type=Constant (metadata.graphics.piece.PieceScaleType.Scale) => <pieceScaleType>, pack=metadata.graphics.piece, label=Scale, cls=metadata.graphics.piece.PieceScaleType, keyword=Scale
g~m~ Rotate type=Constant (metadata.graphics.piece.PieceRotateType.Rotate) => <pieceRotateType>, pack=metadata.graphics.piece, label=Rotate, cls=metadata.graphics.piece.PieceRotateType, keyword=Rotate
~~~~ Background type=Constant (metadata.graphics.piece.PieceGroundType.Background) => <pieceGroundType>, pack=metadata.graphics.piece, label=Background, cls=metadata.graphics.piece.PieceGroundType, keyword=Background
~~~~ Foreground type=Constant (metadata.graphics.piece.PieceGroundType.Foreground) => <pieceGroundType>, pack=metadata.graphics.piece, label=Foreground, cls=metadata.graphics.piece.PieceGroundType, keyword=Foreground
~~~~ Hidden type=Constant (metadata.graphics.piece.PieceGroundType.Hidden) => <pieceGroundType>, pack=metadata.graphics.piece, label=Hidden, cls=metadata.graphics.piece.PieceGroundType, keyword=Hidden
g~m~ Colour type=Constant (metadata.graphics.player.PlayerColourType.Colour) => <playerColourType>, pack=metadata.graphics.player, label=Colour, cls=metadata.graphics.player.PlayerColourType, keyword=Colour
g~m~ Name type=Constant (metadata.graphics.player.PlayerNameType.Name) => <playerNameType>, pack=metadata.graphics.player, label=Name, cls=metadata.graphics.player.PlayerNameType, keyword=Name
~~m~ Board type=Constant (metadata.graphics.util.ContainerStyleType.Board) => <containerStyleType>, pack=metadata.graphics.util, label=Board, cls=metadata.graphics.util.ContainerStyleType, keyword=Board
~~m~ Hand type=Constant (metadata.graphics.util.ContainerStyleType.Hand) => <containerStyleType>, pack=metadata.graphics.util, label=Hand, cls=metadata.graphics.util.ContainerStyleType, keyword=Hand
~~m~ Deck type=Constant (metadata.graphics.util.ContainerStyleType.Deck) => <containerStyleType>, pack=metadata.graphics.util, label=Deck, cls=metadata.graphics.util.ContainerStyleType, keyword=Deck
~~m~ Dice type=Constant (metadata.graphics.util.ContainerStyleType.Dice) => <containerStyleType>, pack=metadata.graphics.util, label=Dice, cls=metadata.graphics.util.ContainerStyleType, keyword=Dice
~~m~ Boardless type=Constant (metadata.graphics.util.ContainerStyleType.Boardless) => <containerStyleType>, pack=metadata.graphics.util, label=Boardless, cls=metadata.graphics.util.ContainerStyleType, keyword=Boardless
~~m~ ConnectiveGoal type=Constant (metadata.graphics.util.ContainerStyleType.ConnectiveGoal) => <containerStyleType>, pack=metadata.graphics.util, label=ConnectiveGoal, cls=metadata.graphics.util.ContainerStyleType, keyword=ConnectiveGoal
~~m~ Mancala type=Constant (metadata.graphics.util.ContainerStyleType.Mancala) => <containerStyleType>, pack=metadata.graphics.util, label=Mancala, cls=metadata.graphics.util.ContainerStyleType, keyword=Mancala
~~m~ PenAndPaper type=Constant (metadata.graphics.util.ContainerStyleType.PenAndPaper) => <containerStyleType>, pack=metadata.graphics.util, label=PenAndPaper, cls=metadata.graphics.util.ContainerStyleType, keyword=PenAndPaper
~~m~ Shibumi type=Constant (metadata.graphics.util.ContainerStyleType.Shibumi) => <containerStyleType>, pack=metadata.graphics.util, label=Shibumi, cls=metadata.graphics.util.ContainerStyleType, keyword=Shibumi
~~m~ Spiral type=Constant (metadata.graphics.util.ContainerStyleType.Spiral) => <containerStyleType>, pack=metadata.graphics.util, label=Spiral, cls=metadata.graphics.util.ContainerStyleType, keyword=Spiral
~~m~ Isometric type=Constant (metadata.graphics.util.ContainerStyleType.Isometric) => <containerStyleType>, pack=metadata.graphics.util, label=Isometric, cls=metadata.graphics.util.ContainerStyleType, keyword=Isometric
~~m~ Puzzle type=Constant (metadata.graphics.util.ContainerStyleType.Puzzle) => <containerStyleType>, pack=metadata.graphics.util, label=Puzzle, cls=metadata.graphics.util.ContainerStyleType, keyword=Puzzle
~~m~ Agon type=Constant (metadata.graphics.util.ContainerStyleType.Agon) => <containerStyleType>, pack=metadata.graphics.util, label=Agon, cls=metadata.graphics.util.ContainerStyleType, keyword=Agon
~~m~ Backgammon type=Constant (metadata.graphics.util.ContainerStyleType.Backgammon) => <containerStyleType>, pack=metadata.graphics.util, label=Backgammon, cls=metadata.graphics.util.ContainerStyleType, keyword=Backgammon
~~m~ Chess type=Constant (metadata.graphics.util.ContainerStyleType.Chess) => <containerStyleType>, pack=metadata.graphics.util, label=Chess, cls=metadata.graphics.util.ContainerStyleType, keyword=Chess
~~m~ ChineseCheckers type=Constant (metadata.graphics.util.ContainerStyleType.ChineseCheckers) => <containerStyleType>, pack=metadata.graphics.util, label=ChineseCheckers, cls=metadata.graphics.util.ContainerStyleType, keyword=ChineseCheckers
~~m~ Connect4 type=Constant (metadata.graphics.util.ContainerStyleType.Connect4) => <containerStyleType>, pack=metadata.graphics.util, label=Connect4, cls=metadata.graphics.util.ContainerStyleType, keyword=Connect4
~~m~ Goose type=Constant (metadata.graphics.util.ContainerStyleType.Goose) => <containerStyleType>, pack=metadata.graphics.util, label=Goose, cls=metadata.graphics.util.ContainerStyleType, keyword=Goose
~~m~ Go type=Constant (metadata.graphics.util.ContainerStyleType.Go) => <containerStyleType>, pack=metadata.graphics.util, label=Go, cls=metadata.graphics.util.ContainerStyleType, keyword=Go
~~m~ Graph type=Constant (metadata.graphics.util.ContainerStyleType.Graph) => <containerStyleType>, pack=metadata.graphics.util, label=Graph, cls=metadata.graphics.util.ContainerStyleType, keyword=Graph
~~m~ HoundsAndJackals type=Constant (metadata.graphics.util.ContainerStyleType.HoundsAndJackals) => <containerStyleType>, pack=metadata.graphics.util, label=HoundsAndJackals, cls=metadata.graphics.util.ContainerStyleType, keyword=HoundsAndJackals
~~m~ Janggi type=Constant (metadata.graphics.util.ContainerStyleType.Janggi) => <containerStyleType>, pack=metadata.graphics.util, label=Janggi, cls=metadata.graphics.util.ContainerStyleType, keyword=Janggi
~~m~ Lasca type=Constant (metadata.graphics.util.ContainerStyleType.Lasca) => <containerStyleType>, pack=metadata.graphics.util, label=Lasca, cls=metadata.graphics.util.ContainerStyleType, keyword=Lasca
~~m~ Pachisi type=Constant (metadata.graphics.util.ContainerStyleType.Pachisi) => <containerStyleType>, pack=metadata.graphics.util, label=Pachisi, cls=metadata.graphics.util.ContainerStyleType, keyword=Pachisi
~~m~ Ploy type=Constant (metadata.graphics.util.ContainerStyleType.Ploy) => <containerStyleType>, pack=metadata.graphics.util, label=Ploy, cls=metadata.graphics.util.ContainerStyleType, keyword=Ploy
~~m~ Scripta type=Constant (metadata.graphics.util.ContainerStyleType.Scripta) => <containerStyleType>, pack=metadata.graphics.util, label=Scripta, cls=metadata.graphics.util.ContainerStyleType, keyword=Scripta
~~m~ Shogi type=Constant (metadata.graphics.util.ContainerStyleType.Shogi) => <containerStyleType>, pack=metadata.graphics.util, label=Shogi, cls=metadata.graphics.util.ContainerStyleType, keyword=Shogi
~~m~ SnakesAndLadders type=Constant (metadata.graphics.util.ContainerStyleType.SnakesAndLadders) => <containerStyleType>, pack=metadata.graphics.util, label=SnakesAndLadders, cls=metadata.graphics.util.ContainerStyleType, keyword=SnakesAndLadders
~~m~ Surakarta type=Constant (metadata.graphics.util.ContainerStyleType.Surakarta) => <containerStyleType>, pack=metadata.graphics.util, label=Surakarta, cls=metadata.graphics.util.ContainerStyleType, keyword=Surakarta
~~m~ Table type=Constant (metadata.graphics.util.ContainerStyleType.Table) => <containerStyleType>, pack=metadata.graphics.util, label=Table, cls=metadata.graphics.util.ContainerStyleType, keyword=Table
~~m~ Tafl type=Constant (metadata.graphics.util.ContainerStyleType.Tafl) => <containerStyleType>, pack=metadata.graphics.util, label=Tafl, cls=metadata.graphics.util.ContainerStyleType, keyword=Tafl
~~m~ Xiangqi type=Constant (metadata.graphics.util.ContainerStyleType.Xiangqi) => <containerStyleType>, pack=metadata.graphics.util, label=Xiangqi, cls=metadata.graphics.util.ContainerStyleType, keyword=Xiangqi
~~m~ UltimateTicTacToe type=Constant (metadata.graphics.util.ContainerStyleType.UltimateTicTacToe) => <containerStyleType>, pack=metadata.graphics.util, label=UltimateTicTacToe, cls=metadata.graphics.util.ContainerStyleType, keyword=UltimateTicTacToe
~~m~ Futoshiki type=Constant (metadata.graphics.util.ContainerStyleType.Futoshiki) => <containerStyleType>, pack=metadata.graphics.util, label=Futoshiki, cls=metadata.graphics.util.ContainerStyleType, keyword=Futoshiki
~~m~ Hashi type=Constant (metadata.graphics.util.ContainerStyleType.Hashi) => <containerStyleType>, pack=metadata.graphics.util, label=Hashi, cls=metadata.graphics.util.ContainerStyleType, keyword=Hashi
~~m~ Kakuro type=Constant (metadata.graphics.util.ContainerStyleType.Kakuro) => <containerStyleType>, pack=metadata.graphics.util, label=Kakuro, cls=metadata.graphics.util.ContainerStyleType, keyword=Kakuro
~~m~ Sudoku type=Constant (metadata.graphics.util.ContainerStyleType.Sudoku) => <containerStyleType>, pack=metadata.graphics.util, label=Sudoku, cls=metadata.graphics.util.ContainerStyleType, keyword=Sudoku
~~m~ Thin type=Constant (metadata.graphics.util.LineStyle.Thin) => <lineStyle>, pack=metadata.graphics.util, label=Thin, cls=metadata.graphics.util.LineStyle, keyword=Thin
~~m~ Thick type=Constant (metadata.graphics.util.LineStyle.Thick) => <lineStyle>, pack=metadata.graphics.util, label=Thick, cls=metadata.graphics.util.LineStyle, keyword=Thick
~~m~ ThinDotted type=Constant (metadata.graphics.util.LineStyle.ThinDotted) => <lineStyle>, pack=metadata.graphics.util, label=ThinDotted, cls=metadata.graphics.util.LineStyle, keyword=ThinDotted
~~m~ ThickDotted type=Constant (metadata.graphics.util.LineStyle.ThickDotted) => <lineStyle>, pack=metadata.graphics.util, label=ThickDotted, cls=metadata.graphics.util.LineStyle, keyword=ThickDotted
~~m~ ThinDashed type=Constant (metadata.graphics.util.LineStyle.ThinDashed) => <lineStyle>, pack=metadata.graphics.util, label=ThinDashed, cls=metadata.graphics.util.LineStyle, keyword=ThinDashed
~~m~ ThickDashed type=Constant (metadata.graphics.util.LineStyle.ThickDashed) => <lineStyle>, pack=metadata.graphics.util, label=ThickDashed, cls=metadata.graphics.util.LineStyle, keyword=ThickDashed
~~m~ Hidden type=Constant (metadata.graphics.util.LineStyle.Hidden) => <lineStyle>, pack=metadata.graphics.util, label=Hidden, cls=metadata.graphics.util.LineStyle, keyword=Hidden
~~m~ Default type=Constant (metadata.graphics.util.PuzzleHintLocationType.Default) => <puzzleHintLocationType>, pack=metadata.graphics.util, label=Default, cls=metadata.graphics.util.PuzzleHintLocationType, keyword=Default
~~m~ BetweenVertices type=Constant (metadata.graphics.util.PuzzleHintLocationType.BetweenVertices) => <puzzleHintLocationType>, pack=metadata.graphics.util, label=BetweenVertices, cls=metadata.graphics.util.PuzzleHintLocationType, keyword=BetweenVertices
~~m~ InnerEdges type=Constant (metadata.graphics.util.BoardGraphicsType.InnerEdges) => <boardGraphicsType>, pack=metadata.graphics.util, label=InnerEdges, cls=metadata.graphics.util.BoardGraphicsType, keyword=InnerEdges
~~m~ OuterEdges type=Constant (metadata.graphics.util.BoardGraphicsType.OuterEdges) => <boardGraphicsType>, pack=metadata.graphics.util, label=OuterEdges, cls=metadata.graphics.util.BoardGraphicsType, keyword=OuterEdges
~~m~ Phase0 type=Constant (metadata.graphics.util.BoardGraphicsType.Phase0) => <boardGraphicsType>, pack=metadata.graphics.util, label=Phase0, cls=metadata.graphics.util.BoardGraphicsType, keyword=Phase0
~~m~ Phase1 type=Constant (metadata.graphics.util.BoardGraphicsType.Phase1) => <boardGraphicsType>, pack=metadata.graphics.util, label=Phase1, cls=metadata.graphics.util.BoardGraphicsType, keyword=Phase1
~~m~ Phase2 type=Constant (metadata.graphics.util.BoardGraphicsType.Phase2) => <boardGraphicsType>, pack=metadata.graphics.util, label=Phase2, cls=metadata.graphics.util.BoardGraphicsType, keyword=Phase2
~~m~ Phase3 type=Constant (metadata.graphics.util.BoardGraphicsType.Phase3) => <boardGraphicsType>, pack=metadata.graphics.util, label=Phase3, cls=metadata.graphics.util.BoardGraphicsType, keyword=Phase3
~~m~ Symbols type=Constant (metadata.graphics.util.BoardGraphicsType.Symbols) => <boardGraphicsType>, pack=metadata.graphics.util, label=Symbols, cls=metadata.graphics.util.BoardGraphicsType, keyword=Symbols
~~m~ InnerVertices type=Constant (metadata.graphics.util.BoardGraphicsType.InnerVertices) => <boardGraphicsType>, pack=metadata.graphics.util, label=InnerVertices, cls=metadata.graphics.util.BoardGraphicsType, keyword=InnerVertices
~~m~ OuterVertices type=Constant (metadata.graphics.util.BoardGraphicsType.OuterVertices) => <boardGraphicsType>, pack=metadata.graphics.util, label=OuterVertices, cls=metadata.graphics.util.BoardGraphicsType, keyword=OuterVertices
~~m~ Piece type=Constant (metadata.graphics.util.ComponentStyleType.Piece) => <componentStyleType>, pack=metadata.graphics.util, label=Piece, cls=metadata.graphics.util.ComponentStyleType, keyword=Piece
~~m~ Tile type=Constant (metadata.graphics.util.ComponentStyleType.Tile) => <componentStyleType>, pack=metadata.graphics.util, label=Tile, cls=metadata.graphics.util.ComponentStyleType, keyword=Tile
~~m~ Card type=Constant (metadata.graphics.util.ComponentStyleType.Card) => <componentStyleType>, pack=metadata.graphics.util, label=Card, cls=metadata.graphics.util.ComponentStyleType, keyword=Card
~~m~ Die type=Constant (metadata.graphics.util.ComponentStyleType.Die) => <componentStyleType>, pack=metadata.graphics.util, label=Die, cls=metadata.graphics.util.ComponentStyleType, keyword=Die
~~m~ Domino type=Constant (metadata.graphics.util.ComponentStyleType.Domino) => <componentStyleType>, pack=metadata.graphics.util, label=Domino, cls=metadata.graphics.util.ComponentStyleType, keyword=Domino
~~m~ LargePiece type=Constant (metadata.graphics.util.ComponentStyleType.LargePiece) => <componentStyleType>, pack=metadata.graphics.util, label=LargePiece, cls=metadata.graphics.util.ComponentStyleType, keyword=LargePiece
~~m~ ExtendedShogi type=Constant (metadata.graphics.util.ComponentStyleType.ExtendedShogi) => <componentStyleType>, pack=metadata.graphics.util, label=ExtendedShogi, cls=metadata.graphics.util.ComponentStyleType, keyword=ExtendedShogi
~~m~ ExtendedXiangqi type=Constant (metadata.graphics.util.ComponentStyleType.ExtendedXiangqi) => <componentStyleType>, pack=metadata.graphics.util, label=ExtendedXiangqi, cls=metadata.graphics.util.ComponentStyleType, keyword=ExtendedXiangqi
~~m~ NativeAmericanDice type=Constant (metadata.graphics.util.ComponentStyleType.NativeAmericanDice) => <componentStyleType>, pack=metadata.graphics.util, label=NativeAmericanDice, cls=metadata.graphics.util.ComponentStyleType, keyword=NativeAmericanDice
~~m~ Always type=Constant (metadata.graphics.util.WhenScoreType.Always) => <whenScoreType>, pack=metadata.graphics.util, label=Always, cls=metadata.graphics.util.WhenScoreType, keyword=Always
~~m~ Never type=Constant (metadata.graphics.util.WhenScoreType.Never) => <whenScoreType>, pack=metadata.graphics.util, label=Never, cls=metadata.graphics.util.WhenScoreType, keyword=Never
~~m~ AtEnd type=Constant (metadata.graphics.util.WhenScoreType.AtEnd) => <whenScoreType>, pack=metadata.graphics.util, label=AtEnd, cls=metadata.graphics.util.WhenScoreType, keyword=AtEnd
~~m~ White type=Constant (metadata.graphics.util.colour.UserColourType.White) => <userColourType>, pack=metadata.graphics.util.colour, label=White, cls=metadata.graphics.util.colour.UserColourType, keyword=White
~~m~ Black type=Constant (metadata.graphics.util.colour.UserColourType.Black) => <userColourType>, pack=metadata.graphics.util.colour, label=Black, cls=metadata.graphics.util.colour.UserColourType, keyword=Black
~~m~ Grey type=Constant (metadata.graphics.util.colour.UserColourType.Grey) => <userColourType>, pack=metadata.graphics.util.colour, label=Grey, cls=metadata.graphics.util.colour.UserColourType, keyword=Grey
~~m~ LightGrey type=Constant (metadata.graphics.util.colour.UserColourType.LightGrey) => <userColourType>, pack=metadata.graphics.util.colour, label=LightGrey, cls=metadata.graphics.util.colour.UserColourType, keyword=LightGrey
~~m~ VeryLightGrey type=Constant (metadata.graphics.util.colour.UserColourType.VeryLightGrey) => <userColourType>, pack=metadata.graphics.util.colour, label=VeryLightGrey, cls=metadata.graphics.util.colour.UserColourType, keyword=VeryLightGrey
~~m~ DarkGrey type=Constant (metadata.graphics.util.colour.UserColourType.DarkGrey) => <userColourType>, pack=metadata.graphics.util.colour, label=DarkGrey, cls=metadata.graphics.util.colour.UserColourType, keyword=DarkGrey
~~m~ VeryDarkGrey type=Constant (metadata.graphics.util.colour.UserColourType.VeryDarkGrey) => <userColourType>, pack=metadata.graphics.util.colour, label=VeryDarkGrey, cls=metadata.graphics.util.colour.UserColourType, keyword=VeryDarkGrey
~~m~ Dark type=Constant (metadata.graphics.util.colour.UserColourType.Dark) => <userColourType>, pack=metadata.graphics.util.colour, label=Dark, cls=metadata.graphics.util.colour.UserColourType, keyword=Dark
~~m~ Red type=Constant (metadata.graphics.util.colour.UserColourType.Red) => <userColourType>, pack=metadata.graphics.util.colour, label=Red, cls=metadata.graphics.util.colour.UserColourType, keyword=Red
~~m~ Green type=Constant (metadata.graphics.util.colour.UserColourType.Green) => <userColourType>, pack=metadata.graphics.util.colour, label=Green, cls=metadata.graphics.util.colour.UserColourType, keyword=Green
~~m~ Blue type=Constant (metadata.graphics.util.colour.UserColourType.Blue) => <userColourType>, pack=metadata.graphics.util.colour, label=Blue, cls=metadata.graphics.util.colour.UserColourType, keyword=Blue
~~m~ Yellow type=Constant (metadata.graphics.util.colour.UserColourType.Yellow) => <userColourType>, pack=metadata.graphics.util.colour, label=Yellow, cls=metadata.graphics.util.colour.UserColourType, keyword=Yellow
~~m~ Pink type=Constant (metadata.graphics.util.colour.UserColourType.Pink) => <userColourType>, pack=metadata.graphics.util.colour, label=Pink, cls=metadata.graphics.util.colour.UserColourType, keyword=Pink
~~m~ Cyan type=Constant (metadata.graphics.util.colour.UserColourType.Cyan) => <userColourType>, pack=metadata.graphics.util.colour, label=Cyan, cls=metadata.graphics.util.colour.UserColourType, keyword=Cyan
~~m~ Brown type=Constant (metadata.graphics.util.colour.UserColourType.Brown) => <userColourType>, pack=metadata.graphics.util.colour, label=Brown, cls=metadata.graphics.util.colour.UserColourType, keyword=Brown
~~m~ DarkBrown type=Constant (metadata.graphics.util.colour.UserColourType.DarkBrown) => <userColourType>, pack=metadata.graphics.util.colour, label=DarkBrown, cls=metadata.graphics.util.colour.UserColourType, keyword=DarkBrown
~~m~ VeryDarkBrown type=Constant (metadata.graphics.util.colour.UserColourType.VeryDarkBrown) => <userColourType>, pack=metadata.graphics.util.colour, label=VeryDarkBrown, cls=metadata.graphics.util.colour.UserColourType, keyword=VeryDarkBrown
~~m~ Purple type=Constant (metadata.graphics.util.colour.UserColourType.Purple) => <userColourType>, pack=metadata.graphics.util.colour, label=Purple, cls=metadata.graphics.util.colour.UserColourType, keyword=Purple
~~m~ Magenta type=Constant (metadata.graphics.util.colour.UserColourType.Magenta) => <userColourType>, pack=metadata.graphics.util.colour, label=Magenta, cls=metadata.graphics.util.colour.UserColourType, keyword=Magenta
~~m~ Turquoise type=Constant (metadata.graphics.util.colour.UserColourType.Turquoise) => <userColourType>, pack=metadata.graphics.util.colour, label=Turquoise, cls=metadata.graphics.util.colour.UserColourType, keyword=Turquoise
~~m~ Orange type=Constant (metadata.graphics.util.colour.UserColourType.Orange) => <userColourType>, pack=metadata.graphics.util.colour, label=Orange, cls=metadata.graphics.util.colour.UserColourType, keyword=Orange
~~m~ LightOrange type=Constant (metadata.graphics.util.colour.UserColourType.LightOrange) => <userColourType>, pack=metadata.graphics.util.colour, label=LightOrange, cls=metadata.graphics.util.colour.UserColourType, keyword=LightOrange
~~m~ LightRed type=Constant (metadata.graphics.util.colour.UserColourType.LightRed) => <userColourType>, pack=metadata.graphics.util.colour, label=LightRed, cls=metadata.graphics.util.colour.UserColourType, keyword=LightRed
~~m~ DarkRed type=Constant (metadata.graphics.util.colour.UserColourType.DarkRed) => <userColourType>, pack=metadata.graphics.util.colour, label=DarkRed, cls=metadata.graphics.util.colour.UserColourType, keyword=DarkRed
~~m~ Burgundy type=Constant (metadata.graphics.util.colour.UserColourType.Burgundy) => <userColourType>, pack=metadata.graphics.util.colour, label=Burgundy, cls=metadata.graphics.util.colour.UserColourType, keyword=Burgundy
~~m~ LightGreen type=Constant (metadata.graphics.util.colour.UserColourType.LightGreen) => <userColourType>, pack=metadata.graphics.util.colour, label=LightGreen, cls=metadata.graphics.util.colour.UserColourType, keyword=LightGreen
~~m~ DarkGreen type=Constant (metadata.graphics.util.colour.UserColourType.DarkGreen) => <userColourType>, pack=metadata.graphics.util.colour, label=DarkGreen, cls=metadata.graphics.util.colour.UserColourType, keyword=DarkGreen
~~m~ LightBlue type=Constant (metadata.graphics.util.colour.UserColourType.LightBlue) => <userColourType>, pack=metadata.graphics.util.colour, label=LightBlue, cls=metadata.graphics.util.colour.UserColourType, keyword=LightBlue
~~m~ VeryLightBlue type=Constant (metadata.graphics.util.colour.UserColourType.VeryLightBlue) => <userColourType>, pack=metadata.graphics.util.colour, label=VeryLightBlue, cls=metadata.graphics.util.colour.UserColourType, keyword=VeryLightBlue
~~m~ DarkBlue type=Constant (metadata.graphics.util.colour.UserColourType.DarkBlue) => <userColourType>, pack=metadata.graphics.util.colour, label=DarkBlue, cls=metadata.graphics.util.colour.UserColourType, keyword=DarkBlue
~~m~ IceBlue type=Constant (metadata.graphics.util.colour.UserColourType.IceBlue) => <userColourType>, pack=metadata.graphics.util.colour, label=IceBlue, cls=metadata.graphics.util.colour.UserColourType, keyword=IceBlue
~~m~ Gold type=Constant (metadata.graphics.util.colour.UserColourType.Gold) => <userColourType>, pack=metadata.graphics.util.colour, label=Gold, cls=metadata.graphics.util.colour.UserColourType, keyword=Gold
~~m~ Silver type=Constant (metadata.graphics.util.colour.UserColourType.Silver) => <userColourType>, pack=metadata.graphics.util.colour, label=Silver, cls=metadata.graphics.util.colour.UserColourType, keyword=Silver
~~m~ Bronze type=Constant (metadata.graphics.util.colour.UserColourType.Bronze) => <userColourType>, pack=metadata.graphics.util.colour, label=Bronze, cls=metadata.graphics.util.colour.UserColourType, keyword=Bronze
~~m~ GunMetal type=Constant (metadata.graphics.util.colour.UserColourType.GunMetal) => <userColourType>, pack=metadata.graphics.util.colour, label=GunMetal, cls=metadata.graphics.util.colour.UserColourType, keyword=GunMetal
~~m~ HumanLight type=Constant (metadata.graphics.util.colour.UserColourType.HumanLight) => <userColourType>, pack=metadata.graphics.util.colour, label=HumanLight, cls=metadata.graphics.util.colour.UserColourType, keyword=HumanLight
~~m~ HumanDark type=Constant (metadata.graphics.util.colour.UserColourType.HumanDark) => <userColourType>, pack=metadata.graphics.util.colour, label=HumanDark, cls=metadata.graphics.util.colour.UserColourType, keyword=HumanDark
~~m~ Cream type=Constant (metadata.graphics.util.colour.UserColourType.Cream) => <userColourType>, pack=metadata.graphics.util.colour, label=Cream, cls=metadata.graphics.util.colour.UserColourType, keyword=Cream
~~m~ DeepPurple type=Constant (metadata.graphics.util.colour.UserColourType.DeepPurple) => <userColourType>, pack=metadata.graphics.util.colour, label=DeepPurple, cls=metadata.graphics.util.colour.UserColourType, keyword=DeepPurple
~~m~ PinkFloyd type=Constant (metadata.graphics.util.colour.UserColourType.PinkFloyd) => <userColourType>, pack=metadata.graphics.util.colour, label=PinkFloyd, cls=metadata.graphics.util.colour.UserColourType, keyword=PinkFloyd
~~m~ BlackSabbath type=Constant (metadata.graphics.util.colour.UserColourType.BlackSabbath) => <userColourType>, pack=metadata.graphics.util.colour, label=BlackSabbath, cls=metadata.graphics.util.colour.UserColourType, keyword=BlackSabbath
~~m~ KingCrimson type=Constant (metadata.graphics.util.colour.UserColourType.KingCrimson) => <userColourType>, pack=metadata.graphics.util.colour, label=KingCrimson, cls=metadata.graphics.util.colour.UserColourType, keyword=KingCrimson
~~m~ TangerineDream type=Constant (metadata.graphics.util.colour.UserColourType.TangerineDream) => <userColourType>, pack=metadata.graphics.util.colour, label=TangerineDream, cls=metadata.graphics.util.colour.UserColourType, keyword=TangerineDream
~~m~ BabyBlue type=Constant (metadata.graphics.util.colour.UserColourType.BabyBlue) => <userColourType>, pack=metadata.graphics.util.colour, label=BabyBlue, cls=metadata.graphics.util.colour.UserColourType, keyword=BabyBlue
~~m~ LightTan type=Constant (metadata.graphics.util.colour.UserColourType.LightTan) => <userColourType>, pack=metadata.graphics.util.colour, label=LightTan, cls=metadata.graphics.util.colour.UserColourType, keyword=LightTan
~~m~ Hidden type=Constant (metadata.graphics.util.colour.UserColourType.Hidden) => <userColourType>, pack=metadata.graphics.util.colour, label=Hidden, cls=metadata.graphics.util.colour.UserColourType, keyword=Hidden
~~m~ Spline type=Constant (metadata.graphics.util.CurveType.Spline) => <curveType>, pack=metadata.graphics.util, label=Spline, cls=metadata.graphics.util.CurveType, keyword=Spline
~~m~ Bezier type=Constant (metadata.graphics.util.CurveType.Bezier) => <curveType>, pack=metadata.graphics.util, label=Bezier, cls=metadata.graphics.util.CurveType, keyword=Bezier
~~m~ BasicController type=Constant (metadata.graphics.util.ControllerType.BasicController) => <controllerType>, pack=metadata.graphics.util, label=BasicController, cls=metadata.graphics.util.ControllerType, keyword=BasicController
~~m~ PyramidalController type=Constant (metadata.graphics.util.ControllerType.PyramidalController) => <controllerType>, pack=metadata.graphics.util, label=PyramidalController, cls=metadata.graphics.util.ControllerType, keyword=PyramidalController
~~m~ Default type=Constant (metadata.graphics.util.PuzzleDrawHintType.Default) => <puzzleDrawHintType>, pack=metadata.graphics.util, label=Default, cls=metadata.graphics.util.PuzzleDrawHintType, keyword=Default
~~m~ TopLeft type=Constant (metadata.graphics.util.PuzzleDrawHintType.TopLeft) => <puzzleDrawHintType>, pack=metadata.graphics.util, label=TopLeft, cls=metadata.graphics.util.PuzzleDrawHintType, keyword=TopLeft
~~m~ NextTo type=Constant (metadata.graphics.util.PuzzleDrawHintType.NextTo) => <puzzleDrawHintType>, pack=metadata.graphics.util, label=NextTo, cls=metadata.graphics.util.PuzzleDrawHintType, keyword=NextTo
~~m~ None type=Constant (metadata.graphics.util.PuzzleDrawHintType.None) => <puzzleDrawHintType>, pack=metadata.graphics.util, label=None, cls=metadata.graphics.util.PuzzleDrawHintType, keyword=None
~~m~ None type=Constant (metadata.graphics.util.ValueLocationType.None) => <valueLocationType>, pack=metadata.graphics.util, label=None, cls=metadata.graphics.util.ValueLocationType, keyword=None
~~m~ Corner type=Constant (metadata.graphics.util.ValueLocationType.Corner) => <valueLocationType>, pack=metadata.graphics.util, label=Corner, cls=metadata.graphics.util.ValueLocationType, keyword=Corner
~~m~ Top type=Constant (metadata.graphics.util.ValueLocationType.Top) => <valueLocationType>, pack=metadata.graphics.util, label=Top, cls=metadata.graphics.util.ValueLocationType, keyword=Top
~~m~ Middle type=Constant (metadata.graphics.util.ValueLocationType.Middle) => <valueLocationType>, pack=metadata.graphics.util, label=Middle, cls=metadata.graphics.util.ValueLocationType, keyword=Middle
~~m~ Square type=Constant (metadata.graphics.util.HoleType.Square) => <holeType>, pack=metadata.graphics.util, label=Square, cls=metadata.graphics.util.HoleType, keyword=Square
~~m~ Oval type=Constant (metadata.graphics.util.HoleType.Oval) => <holeType>, pack=metadata.graphics.util, label=Oval, cls=metadata.graphics.util.HoleType, keyword=Oval
~~m~ Default type=Constant (metadata.graphics.util.PieceStackType.Default) => <pieceStackType>, pack=metadata.graphics.util, label=Default, cls=metadata.graphics.util.PieceStackType, keyword=Default
~~m~ Ground type=Constant (metadata.graphics.util.PieceStackType.Ground) => <pieceStackType>, pack=metadata.graphics.util, label=Ground, cls=metadata.graphics.util.PieceStackType, keyword=Ground
~~m~ Reverse type=Constant (metadata.graphics.util.PieceStackType.Reverse) => <pieceStackType>, pack=metadata.graphics.util, label=Reverse, cls=metadata.graphics.util.PieceStackType, keyword=Reverse
~~m~ Fan type=Constant (metadata.graphics.util.PieceStackType.Fan) => <pieceStackType>, pack=metadata.graphics.util, label=Fan, cls=metadata.graphics.util.PieceStackType, keyword=Fan
~~m~ FanAlternating type=Constant (metadata.graphics.util.PieceStackType.FanAlternating) => <pieceStackType>, pack=metadata.graphics.util, label=FanAlternating, cls=metadata.graphics.util.PieceStackType, keyword=FanAlternating
~~m~ None type=Constant (metadata.graphics.util.PieceStackType.None) => <pieceStackType>, pack=metadata.graphics.util, label=None, cls=metadata.graphics.util.PieceStackType, keyword=None
~~m~ Backgammon type=Constant (metadata.graphics.util.PieceStackType.Backgammon) => <pieceStackType>, pack=metadata.graphics.util, label=Backgammon, cls=metadata.graphics.util.PieceStackType, keyword=Backgammon
~~m~ Count type=Constant (metadata.graphics.util.PieceStackType.Count) => <pieceStackType>, pack=metadata.graphics.util, label=Count, cls=metadata.graphics.util.PieceStackType, keyword=Count
~~m~ CountColoured type=Constant (metadata.graphics.util.PieceStackType.CountColoured) => <pieceStackType>, pack=metadata.graphics.util, label=CountColoured, cls=metadata.graphics.util.PieceStackType, keyword=CountColoured
~~m~ Ring type=Constant (metadata.graphics.util.PieceStackType.Ring) => <pieceStackType>, pack=metadata.graphics.util, label=Ring, cls=metadata.graphics.util.PieceStackType, keyword=Ring
~~m~ TowardsCenter type=Constant (metadata.graphics.util.PieceStackType.TowardsCenter) => <pieceStackType>, pack=metadata.graphics.util, label=TowardsCenter, cls=metadata.graphics.util.PieceStackType, keyword=TowardsCenter
~~m~ All type=Constant (metadata.graphics.util.EdgeType.All) => <edgeType>, pack=metadata.graphics.util, label=All, cls=metadata.graphics.util.EdgeType, keyword=All
~~m~ Inner type=Constant (metadata.graphics.util.EdgeType.Inner) => <edgeType>, pack=metadata.graphics.util, label=Inner, cls=metadata.graphics.util.EdgeType, keyword=Inner
~~m~ Outer type=Constant (metadata.graphics.util.EdgeType.Outer) => <edgeType>, pack=metadata.graphics.util, label=Outer, cls=metadata.graphics.util.EdgeType, keyword=Outer
~~m~ Interlayer type=Constant (metadata.graphics.util.EdgeType.Interlayer) => <edgeType>, pack=metadata.graphics.util, label=Interlayer, cls=metadata.graphics.util.EdgeType, keyword=Interlayer
g~m~ StyleThickness type=Constant (metadata.graphics.board.BoardStyleThicknessType.StyleThickness) => <boardStyleThicknessType>, pack=metadata.graphics.board, label=StyleThickness, cls=metadata.graphics.board.BoardStyleThicknessType, keyword=StyleThickness
g~m~ Colour type=Constant (metadata.graphics.board.BoardColourType.Colour) => <boardColourType>, pack=metadata.graphics.board, label=Colour, cls=metadata.graphics.board.BoardColourType, keyword=Colour
g~m~ Shape type=Constant (metadata.graphics.board.BoardShapeType.Shape) => <boardShapeType>, pack=metadata.graphics.board, label=Shape, cls=metadata.graphics.board.BoardShapeType, keyword=Shape
g~m~ PenAndPaper type=Constant (metadata.graphics.board.BoardStylePenAndPaperType.PenAndPaper) => <boardStylePenAndPaperType>, pack=metadata.graphics.board, label=PenAndPaper, cls=metadata.graphics.board.BoardStylePenAndPaperType, keyword=PenAndPaper
~~~~ Checkered type=Constant (metadata.graphics.board.BoardBooleanType.Checkered) => <boardBooleanType>, pack=metadata.graphics.board, label=Checkered, cls=metadata.graphics.board.BoardBooleanType, keyword=Checkered
~~~~ RedrawAfterMove type=Constant (metadata.graphics.board.BoardBooleanType.RedrawAfterMove) => <boardBooleanType>, pack=metadata.graphics.board, label=RedrawAfterMove, cls=metadata.graphics.board.BoardBooleanType, keyword=RedrawAfterMove
g~m~ Placement type=Constant (metadata.graphics.board.BoardPlacementType.Placement) => <boardPlacementType>, pack=metadata.graphics.board, label=Placement, cls=metadata.graphics.board.BoardPlacementType, keyword=Placement
g~m~ Style type=Constant (metadata.graphics.board.BoardStyleType.Style) => <boardStyleType>, pack=metadata.graphics.board, label=Style, cls=metadata.graphics.board.BoardStyleType, keyword=Style
g~m~ Placement type=Constant (metadata.graphics.hand.HandPlacementType.Placement) => <handPlacementType>, pack=metadata.graphics.hand, label=Placement, cls=metadata.graphics.hand.HandPlacementType, keyword=Placement
g~m~ Score type=Constant (metadata.graphics.show.ShowScoreType.Score) => <showScoreType>, pack=metadata.graphics.show, label=Score, cls=metadata.graphics.show.ShowScoreType, keyword=Score
~~~~ Pits type=Constant (metadata.graphics.show.ShowBooleanType.Pits) => <showBooleanType>, pack=metadata.graphics.show, label=Pits, cls=metadata.graphics.show.ShowBooleanType, keyword=Pits
~~~~ PlayerHoles type=Constant (metadata.graphics.show.ShowBooleanType.PlayerHoles) => <showBooleanType>, pack=metadata.graphics.show, label=PlayerHoles, cls=metadata.graphics.show.ShowBooleanType, keyword=PlayerHoles
~~~~ LocalStateHoles type=Constant (metadata.graphics.show.ShowBooleanType.LocalStateHoles) => <showBooleanType>, pack=metadata.graphics.show, label=LocalStateHoles, cls=metadata.graphics.show.ShowBooleanType, keyword=LocalStateHoles
~~~~ RegionOwner type=Constant (metadata.graphics.show.ShowBooleanType.RegionOwner) => <showBooleanType>, pack=metadata.graphics.show, label=RegionOwner, cls=metadata.graphics.show.ShowBooleanType, keyword=RegionOwner
~~~~ Cost type=Constant (metadata.graphics.show.ShowBooleanType.Cost) => <showBooleanType>, pack=metadata.graphics.show, label=Cost, cls=metadata.graphics.show.ShowBooleanType, keyword=Cost
~~~~ Hints type=Constant (metadata.graphics.show.ShowBooleanType.Hints) => <showBooleanType>, pack=metadata.graphics.show, label=Hints, cls=metadata.graphics.show.ShowBooleanType, keyword=Hints
~~~~ EdgeDirections type=Constant (metadata.graphics.show.ShowBooleanType.EdgeDirections) => <showBooleanType>, pack=metadata.graphics.show, label=EdgeDirections, cls=metadata.graphics.show.ShowBooleanType, keyword=EdgeDirections
~~~~ PossibleMoves type=Constant (metadata.graphics.show.ShowBooleanType.PossibleMoves) => <showBooleanType>, pack=metadata.graphics.show, label=PossibleMoves, cls=metadata.graphics.show.ShowBooleanType, keyword=PossibleMoves
~~~~ CurvedEdges type=Constant (metadata.graphics.show.ShowBooleanType.CurvedEdges) => <showBooleanType>, pack=metadata.graphics.show, label=CurvedEdges, cls=metadata.graphics.show.ShowBooleanType, keyword=CurvedEdges
~~~~ StraightEdges type=Constant (metadata.graphics.show.ShowBooleanType.StraightEdges) => <showBooleanType>, pack=metadata.graphics.show, label=StraightEdges, cls=metadata.graphics.show.ShowBooleanType, keyword=StraightEdges
g~m~ AsHoles type=Constant (metadata.graphics.show.ShowSiteDataType.AsHoles) => <showSiteDataType>, pack=metadata.graphics.show, label=AsHoles, cls=metadata.graphics.show.ShowSiteDataType, keyword=AsHoles
g~m~ Line type=Constant (metadata.graphics.show.ShowLineType.Line) => <showLineType>, pack=metadata.graphics.show, label=Line, cls=metadata.graphics.show.ShowLineType, keyword=Line
g~m~ Check type=Constant (metadata.graphics.show.ShowCheckType.Check) => <showCheckType>, pack=metadata.graphics.show, label=Check, cls=metadata.graphics.show.ShowCheckType, keyword=Check
~~~~ Sites type=Constant (metadata.graphics.show.ShowSiteType.Sites) => <showSiteType>, pack=metadata.graphics.show, label=Sites, cls=metadata.graphics.show.ShowSiteType, keyword=Sites
~~~~ Cell type=Constant (metadata.graphics.show.ShowSiteType.Cell) => <showSiteType>, pack=metadata.graphics.show, label=Cell, cls=metadata.graphics.show.ShowSiteType, keyword=Cell
g~m~ Piece type=Constant (metadata.graphics.show.ShowComponentType.Piece) => <showComponentType>, pack=metadata.graphics.show, label=Piece, cls=metadata.graphics.show.ShowComponentType, keyword=Piece
~~~~ State type=Constant (metadata.graphics.show.ShowComponentDataType.State) => <showComponentDataType>, pack=metadata.graphics.show, label=State, cls=metadata.graphics.show.ShowComponentDataType, keyword=State
~~~~ Value type=Constant (metadata.graphics.show.ShowComponentDataType.Value) => <showComponentDataType>, pack=metadata.graphics.show, label=Value, cls=metadata.graphics.show.ShowComponentDataType, keyword=Value
g~m~ Symbol type=Constant (metadata.graphics.show.ShowSymbolType.Symbol) => <showSymbolType>, pack=metadata.graphics.show, label=Symbol, cls=metadata.graphics.show.ShowSymbolType, keyword=Symbol
g~m~ Edges type=Constant (metadata.graphics.show.ShowEdgeType.Edges) => <showEdgeType>, pack=metadata.graphics.show, label=Edges, cls=metadata.graphics.show.ShowEdgeType, keyword=Edges
g~~* <int>{<int>} type=Structural (int) => <int>{<int>}, pack=game.functions.ints, label=int, cls=int, keyword=int


++++++++++++++++++++ RULES +++++++++++++++++++++++
gd~ <int>      ::= <%> | <dim.math.*> | <ints.math.*> | <dim.math.+> | 
               <ints.math.+> | <dim.math.-> | <ints.math.-> | <dim.math./> | 
               <ints.math./> | End | NoPiece | Nobody | Off | Undefined | 
               Unused | <dim.math.^> | <ints.math.^> | <dim.math.abs> | 
               <ints.math.abs> | <ahead> | <amount> | <iterator.between> | 
               <card.card> | <centrePoint> | <column> | <coord> | <cost> | 
               <count.count> | <counter> | <iterator.edge> | <dice.face> | 
               <iterator.from> | <handSite> | <iterator.hint> | <id> | 
               <ints.math.if> | int | <ints.last.last> | <layer> | <level> | 
               <mapEntry> | <matchScore> | <dim.math.max> | <ints.math.max> | 
               <dim.math.min> | <ints.math.min> | <mover> | <next> | 
               <nextPhase> | <pathExtent> | <board.phase> | <pips> | 
               <iterator.player> | <pot> | <prev> | <regionSite> | <rotation> | 
               <row> | <state.score> | <site> | <size> | <state> | 
               <iterator.to> | <toInt> | <topLevel> | <iterator.track> | 
               <trackSite> | <value> | <var> | <what> | <where> | <who>
gd~ <boolean>  ::= <!=> | <<> | <<=> | <=> | <>> | <>=> | <booleans.all.all> | 
               <deductionPuzzle.all.all> | <math.and> | boolean | <can> | 
               <forAll> | <booleans.math.if> | <booleans.is.is> | 
               <deductionPuzzle.is.is> | <booleans.no.no> | <not> | <math.or> | 
               <toBool> | <was> | <xor>
gd~ <float>    ::= <floats.math.*> | <floats.math.+> | <floats.math.-> | 
               <floats.math./> | <floats.math.^> | <floats.math.abs> | <cos> | 
               <exp> | float | <log> | <log10> | <floats.math.max> | 
               <floats.math.min> | <sin> | <sqrt> | <tan> | <toFloat>
gdm <int>      ::= int
gdm <boolean>  ::= boolean
gdm <float>    ::= float
gdm <string>   ::= string
gd~ <mode>     ::= (mode <modeType>)
~~~ <aPI>      ::= 
gd~ <region.math.union> ::= (union {<sites>}) | (union <sites> <sites>)
gd~ <region.math.difference> ::= (difference <sites> (<sites> | <int>))
gd~ <expand>   ::= (expand [<int> | <string>] (<sites> | 
               origin:<int>) [steps:<int>] [<absoluteDirection>] [<siteType>])
gd~ <region.math.intersection> ::= (intersection {<sites>}) | 
               (intersection <sites> <sites>)
gd~ <region.math.if> ::= (if <boolean> <sites> [<sites>])
g~~ <sitesPlayerType> ::= Hand | Invisible | Masked | Visible | Winning
g~~ <sitesIndexType> ::= Cell | Column | Edge | Empty | Layer | Phase | Row | State
g~~ <sitesSimpleType> ::= Board | Bottom | Centre | ConcaveCorners | ConvexCorners | 
               Corners | Hint | Inner | LastFrom | LastTo | Left | LineOfPlay | 
               Major | Minor | Outer | Pending | Perimeter | Playable | Right | 
               ToClear | Top
g~~ <lineOfSightType> ::= Empty | Farthest | Piece
g~~ <sitesMoveType> ::= Between | From | To
gd~ <sites>    ::= (sites <sitesSimpleType> [<siteType>]) | 
               (sites <sitesEdgeType>) | (sites Group [<siteType>] (at:<int> | 
               from:<sites>) [<direction>] [if:<boolean>]) | 
               (sites [<siteType>] [<int>] {{<stepType>}} [rotations:<boolean>]) 
               | (sites ({<int>} | <ints>)) | (sites <sitesMoveType> <moves>) | 
               (sites [<siteType>] {<string>}) | 
               (sites Pattern {<stepType>} [<siteType>] [from:<int>] [what:<int> 
               | whats:{<int>}]) | 
               (sites Hidden [<hiddenData>] [<siteType>] (to:<moves.player> | 
               to:<roleType>)) | (sites) | 
               (sites Crossing at:<int> [<moves.player> | <roleType>]) | 
               (sites Random [<sites>] [num:<int>]) | 
               (sites LargePiece [<siteType>] at:<int>) | 
               (sites Between [<direction>] [<siteType>] from:<int> [fromIncluded:<boolean>] to:<int> [toIncluded:<boolean>] [cond:<boolean>]) 
               | (sites Occupied (by:<moves.player> | 
               by:<roleType>) [container:<int> | 
               container:<string>] [component:<int> | component:<string> | 
               components:{<string>}] [top:<boolean>] [on:<siteType>]) | 
               (sites Incident <siteType> of:<siteType> at:<int> [owner:<moves.player> 
               | <roleType>]) | (sites Around [<siteType>] (<int> | 
               <sites>) [<regionTypeDynamic>] [distance:<int>] [<absoluteDirection>] [if:<boolean>] [includeSelf:<boolean>]) 
               | (sites Direction (from:<int> | 
               from:<sites>) [<direction>] [included:<boolean>] [stop:<boolean>] [stopIncluded:<boolean>] [distance:<int>] [<siteType>]) 
               | 
               (sites LineOfSight [<lineOfSightType>] [<siteType>] [at:<int>] [<direction>]) 
               | 
               (sites Loop [inside:<boolean>] [<siteType>] [surround:<roleType> 
               | {<roleType>}] [<direction>] [<int>] [<int> | <sites>]) | 
               (sites <sitesIndexType> [<siteType>] [<int>]) | 
               (sites Side [<siteType>] [<moves.player> | <roleType> | 
               <compassDirection>]) | 
               (sites Distance [<siteType>] [<relationType>] [<effect.step>] from:<int> <range>) 
               | (sites Start <moves.piece>) | 
               (sites <sitesPlayerType> [<siteType>] [<moves.player> | 
               <roleType>] [<nonDecision>] [<string>]) | 
               (sites [<moves.player> | <roleType>] [<siteType>] [<string>]) | 
               (sites Track [<moves.player> | 
               <roleType>] [<string>] [from:<int>] [to:<int>]) | (region int) | 
               (region <string> <container.board.board> {<string>}) | 
               (region) | (region {int}) | (region) | 
               (region <equipment.region>) | (region) | 
               <region.math.difference> | <expand> | <region.foreach.forEach> | 
               <region.math.if> | <region.math.intersection> | 
               <region.last.last> | <region.math.union>
g~~ <sitesEdgeType> ::= Angled | Axial | Horizontal | Slash | Slosh | Vertical
gd~ <region.last.last> ::= (last Between)
gd~ <region.foreach.forEach> ::= (forEach <sites> if:<boolean>) | 
               (forEach <ints> <sites>) | (forEach Team <sites>)
g~m <sites>    ::= 
g~~ <dim>      ::= 
gd~ <dim.math.min> ::= (min <dim> <dim>)
gd~ <dim.math.abs> ::= (abs <dim>)
gd~ <dim.math.*> ::= (* {<dim>}) | (* <dim> <dim>)
gd~ <dim.math.-> ::= (- <dim> <dim>)
gd~ <dim.math.max> ::= (max <dim> <dim>)
gd~ <dim.math.+> ::= (+ {<dim>}) | (+ <dim> <dim>)
gd~ <dim.math./> ::= (/ <dim> <dim>)
gd~ <dim.math.^> ::= (^ <dim> <dim>)
gd~ <dim>      ::= <dim.math.*> | <dim.math.+> | <dim.math.-> | <dim.math./> | 
               <dim.math.^> | <dim.math.abs> | int | <dim.math.max> | 
               <dim.math.min>
gd~ <booleans.all.all> ::= (all Sites <sites> if:<boolean>) | 
               (all <allSimpleType>) | (all Values <ints> if:<boolean>)
g~~ <allSimpleType> ::= DiceEqual | DiceUsed | Passed
gd~ <booleans.no.no> ::= (no Moves <roleType>)
gd~ <was>      ::= (was Pass)
gd~ <toBool>   ::= (toBool (<int> | <float>))
g~~ <boolean>  ::= 
gd~ <=>        ::= (= <sites> <sites>) | (= <int> (<int> | <roleType>))
gd~ <xor>      ::= (xor <boolean> <boolean>)
gd~ <!=>       ::= (!= <sites> <sites>) | (!= <int> (<int> | <roleType>))
gd~ <>>        ::= (> <int> <int>)
gd~ <not>      ::= (not <boolean>)
gd~ <>=>       ::= (>= <int> <int>)
gd~ <<>        ::= (< <int> <int>)
gd~ <math.and> ::= (and {<boolean>}) | (and <boolean> <boolean>)
gd~ <<=>       ::= (<= <int> <int>)
gd~ <booleans.math.if> ::= (if <boolean> <boolean> [<boolean>])
gd~ <math.or>  ::= (or {<boolean>}) | (or <boolean> <boolean>)
gd~ <can>      ::= (can Move <moves>)
~~~ <baseBooleanFunction> ::= <!=> | <<> | <<=> | <=> | <>> | <>=> | 
               <booleans.all.all> | <deductionPuzzle.all.all> | <math.and> | 
               <can> | <forAll> | <booleans.math.if> | <booleans.is.is> | 
               <deductionPuzzle.is.is> | <booleans.no.no> | <not> | <math.or> | 
               <toBool> | <was> | <xor>
g~~ <isPlayerType> ::= Active | Enemy | Friend | Mover | Next | Prev
g~~ <isGraphType> ::= LastFrom | LastTo
g~~ <isConnectType> ::= Blocked | Connected
g~~ <isStringType> ::= Decided | Proposed
g~~ <isComponentType> ::= Threatened | Within
gd~ <booleans.is.is> ::= (is Triggered <string> (<int> | <roleType>)) | 
               (is <isSimpleType>) | (is Crossing <int> <int>) | 
               (is <isStringType> <string>) | (is <isGraphType> <siteType>) | 
               (is Hidden [<hiddenData>] [<siteType>] at:<int> [level:<int>] (to:<moves.player> 
               | to:<roleType>)) | (is Repeat [<repetitionType>]) | 
               (is Pattern {<stepType>} [<siteType>] [from:<int>] [what:<int> | 
               whats:{<int>}]) | (is <isTreeType> (<moves.player> | 
               <roleType>)) | (is RegularGraph (<moves.player> | 
               <roleType>) [k:<int> | odd:<boolean> | even:<boolean>]) | 
               (is <isPlayerType> (<int> | <roleType>)) | 
               (is Line [<siteType>] <int> [<absoluteDirection>] [through:<int> 
               | throughAny:<sites>] [<roleType> | what:<int> | 
               whats:{<int>}] [exact:<boolean>] [contiguous:<boolean>] [if:<boolean>] [byLevel:<boolean>]) 
               | (is Loop [<siteType>] [surround:<roleType> | 
               {<roleType>}] [<direction>] [<int>] [<int> | 
               <sites>] [path:<boolean>]) | 
               (is Path <siteType> [from:<int>] (<moves.player> | 
               <roleType>) length:<range> [closed:<boolean>]) | 
               (is <isSiteType> [<siteType>] <int>) | (is In [<int> | 
               {<int>}] (<sites> | <ints>)) | (is <isIntegerType> [<int>]) | 
               (is <isComponentType> [<int>] [<siteType>] [at:<int> | 
               in:<sites>] [<moves>]) | 
               (is <isConnectType> [<int>] [<siteType>] [at:<int>] [<direction>] ({<sites>} 
               | <roleType> | <regionTypeStatic>)) | 
               (is Related <relationType> [<siteType>] <int> (<int> | 
               <sites>)) | (is Target [<int> | <string>] {<int>} [<int> | 
               {<int>}])
g~~ <isSiteType> ::= Empty | Occupied
g~~ <isIntegerType> ::= AnyDie | Even | Flat | Odd | PipsMatch | SidesMatch | Visited
g~~ <isSimpleType> ::= Cycle | Full | Pending
g~~ <isTreeType> ::= CaterpillarTree | SpanningTree | Tree | TreeCentre
gd~ <deductionPuzzle.all.all> ::= (all Different [<siteType>] [<sites>] [except:<int> 
               | excepts:{<int>}])
gd~ <forAll>   ::= (forAll <puzzleElementType> <boolean>)
g~~ <isPuzzleRegionResultType> ::= Count | Sum
gd~ <deductionPuzzle.is.is> ::= (is Unique [<siteType>]) | 
               (is <isPuzzleRegionResultType> [<siteType>] [<sites>] [of:<int>] [<string>] <int>) 
               | (is Solved)
g~~ <graph>    ::= 
gd~ <tri>      ::= (tri (<poly> | {<dim>})) | (tri [<triShapeType>] <dim> [<dim>])
g~~ <triShapeType> ::= Diamond | Hexagon | Limping | NoShape | Prism | Rectangle | 
               Square | Star | Triangle
gd~ <tiling>   ::= (tiling <tilingType> <dim> [<dim>]) | 
               (tiling <tilingType> (<poly> | {<dim>}))
g~~ <tilingType> ::= T31212 | T333333_33434 | T33336 | T33344 | T33434 | T3464 | 
               T3636 | T4612 | T488
~~m <tiling3464ShapeType> ::= Custom | Diamond | Hexagon | Limping | Prism | 
               Rectangle | Square | Star | Triangle
gd~ <quadhex>  ::= (quadhex <dim> [thirds:<boolean>])
gd~ <hex>      ::= (hex [<hexShapeType>] <dim> [<dim>]) | (hex (<poly> | {<dim>}))
g~~ <hexShapeType> ::= Diamond | Hexagon | Limping | NoShape | Prism | Rectangle | 
               Square | Star | Triangle
g~~ <basis>    ::= <brick> | <celtic> | <concentric> | <hex> | <quadhex> | 
               <rectangle> | <spiral> | <square> | <tiling> | <tri> | <wedge>
gd~ <celtic>   ::= (celtic (<poly> | {<dim>})) | (celtic <dim> [<dim>])
gd~ <square>   ::= (square [<squareShapeType>] <dim> [diagonals:<diagonalsType> | 
               pyramidal:<boolean>]) | (square (<poly> | 
               {<dim>}) [diagonals:<diagonalsType>])
g~~ <squareShapeType> ::= Diamond | Limping | NoShape | Rectangle | Square
g~~ <diagonalsType> ::= Alternating | Concentric | Implied | Radiating | Solid
g~~ <brickShapeType> ::= Diamond | Limping | Prism | Rectangle | Spiral | Square
gd~ <brick>    ::= (brick [<brickShapeType>] <dim> [<dim>] [trim:<boolean>])
gd~ <repeat>   ::= (repeat <dim> <dim> step:{{<float>}} (<poly> | {<poly>}))
gd~ <regular>  ::= (regular <basisType> <shapeType> <dim> [<dim>]) | 
               (regular [Star] <dim>)
gd~ <concentric> ::= (concentric (<concentricShapeType> | sides:<dim> | 
               {<dim>}) [rings:<dim>] [steps:<dim>] [midpoints:<boolean>] [joinMidpoints:<boolean>] [joinCorners:<boolean>] [stagger:<boolean>])
g~~ <concentricShapeType> ::= Hexagon | Square | Target | Triangle
gd~ <wedge>    ::= (wedge <dim> [<dim>])
gd~ <spiral>   ::= (spiral turns:<dim> sites:<dim> [clockwise:<boolean>])
gd~ <rectangle> ::= (rectangle <dim> [<dim>] [diagonals:<diagonalsType>])
gd~ <clip>     ::= (clip <graph> <poly>)
gd~ <subdivide> ::= (subdivide <graph> [min:<dim>])
gd~ <scale>    ::= (scale <float> [<float>] [<float>] <graph>)
gd~ <rotate>   ::= (rotate <float> <graph>)
gd~ <keep>     ::= (keep <graph> <poly>)
gd~ <operators.remove> ::= (remove <graph> <poly> [trimEdges:<boolean>]) | 
               (remove <graph> [cells:{{{<float>}}} | 
               cells:{<dim>}] [edges:{{{<float>}}} | 
               edges:{{<dim>}}] [vertices:{{<float>}} | 
               vertices:{<dim>}] [trimEdges:<boolean>])
gd~ <splitCrossings> ::= (splitCrossings <graph>)
gd~ <shift>    ::= (shift <float> <float> [<float>] <graph>)
gd~ <merge>    ::= (merge {<graph>} [connect:<boolean>]) | 
               (merge <graph> <graph> [connect:<boolean>])
gd~ <operators.add> ::= (add [<graph>] [vertices:{{<float>}}] [edges:{{{<float>}}} | 
               edges:{{<dim>}}] [edgesCurved:{{{<float>}}}] [cells:{{{<float>}}} 
               | cells:{{<dim>}}] [connect:<boolean>])
gd~ <intersect> ::= (intersect {<graph>}) | (intersect <graph> <graph>)
gd~ <operators.union> ::= (union {<graph>} [connect:<boolean>]) | 
               (union <graph> <graph> [connect:<boolean>])
gd~ <trim>     ::= (trim <graph>)
gd~ <makeFaces> ::= (makeFaces <graph>)
gd~ <layers>   ::= (layers <dim> <graph>)
gd~ <dual>     ::= (dual <graph>)
gd~ <complete> ::= (complete <graph> [eachCell:<boolean>])
gd~ <renumber> ::= (renumber [<siteType>] [<siteType>] [<siteType>] <graph>)
gd~ <recoordinate> ::= (recoordinate [<siteType>] [<siteType>] [<siteType>] <graph>)
gd~ <skew>     ::= (skew <float> <graph>)
gd~ <hole>     ::= (hole <graph> <poly>)
g~~ <cardSiteType> ::= Rank | Suit | TrumpRank | TrumpValue
gd~ <card.card> ::= (card <cardSiteType> at:<int> [level:<int>]) | (card TrumpSuit)
gd~ <size>     ::= (size [Group] [<siteType>] at:<int> [<direction>] [if:<boolean>]) 
               | (size LargePiece [<siteType>] (in:<sites> | at:<int>)) | 
               (size Stack [<siteType>] [in:<sites> | at:<int>]) | 
               (size [Territory] [<siteType>] (<roleType> | 
               <moves.player>) [<absoluteDirection>]) | (size Array <ints>)
g~m <int>      ::= 
gd~ <ints.math.min> ::= (min <ints>) | (min <int> <int>)
gd~ <ints.math.abs> ::= (abs <int>)
gd~ <ints.math.*> ::= (* ({<int>} | <ints>)) | (* <int> <int>)
gd~ <%>        ::= (% <int> <int>)
gd~ <ints.math.-> ::= (- [<int>] <int>)
gd~ <ints.math.max> ::= (max <ints>) | (max <int> <int>)
gd~ <ints.math.+> ::= (+ ({<int>} | <ints>)) | (+ <int> <int>)
gd~ <ints.math./> ::= (/ <int> <int>)
gd~ <ints.math.^> ::= (^ <int> <int>)
gd~ <ints.math.if> ::= (if <boolean> <int> <int>)
gd~ <value>    ::= (value Piece [<siteType>] at:<int> [level:<int>]) | 
               (value Player (<int> | <roleType>)) | (value Pending) | 
               (value) | (value Random <range>)
gd~ <matchScore> ::= (matchScore <roleType>)
g~~ <lastType> ::= From | To
gd~ <ints.last.last> ::= (last <lastType> [afterConsequence:<boolean>])
gd~ <pathExtent> ::= (pathExtent [<int>] [<int> | <sites>])
gd~ <who>      ::= (who [<siteType>] at:<int> [level:<int>])
gd~ <next>     ::= (next)
gd~ <counter>  ::= (counter)
gd~ <prev>     ::= (prev [<prevType>])
gd~ <var>      ::= (var [<string>])
gd~ <what>     ::= (what [<siteType>] at:<int> [level:<int>])
gd~ <mover>    ::= (mover)
gd~ <pot>      ::= (pot)
gd~ <amount>   ::= (amount (<roleType> | <moves.player>))
gd~ <state>    ::= (state [<siteType>] at:<int> [level:<int>])
gd~ <rotation> ::= (rotation [<siteType>] at:<int> [level:<int>])
gd~ <state.score> ::= (score (<moves.player> | <roleType>))
g~~ <countComponentType> ::= Pieces | Pips
g~~ <countSiteType> ::= Adjacent | Diagonal | Neighbours | Off | Orthogonal | Sites
g~~ <countSimpleType> ::= Active | Cells | Columns | Edges | Moves | MovesThisTurn | 
               Phases | Players | Rows | Trials | Turns | Vertices
gd~ <count.count> ::= (count <countComponentType> [<siteType>] [<roleType> | 
               of:<int>] [<string>] [in:<sites>]) | 
               (count Groups [<siteType>] [<direction>] [<roleType> | 
               of:<int> | if:<boolean>] [min:<int>]) | 
               (count [<countSiteType>] [<siteType>] [in:<sites> | at:<int> | 
               <string>]) | (count <countSimpleType> [<siteType>]) | 
               (count Stack [<stackDirection>] [<siteType>] (at:<int> | 
               to:<sites>) [if:<boolean>] [stop:<boolean>]) | 
               (count StepsOnTrack [<roleType> | <moves.player> | 
               <string>] [<int>] [<int>]) | 
               (count Steps [<siteType>] [<relationType>] [<effect.step>] <int> <int>) 
               | 
               (count Liberties [<siteType>] [at:<int>] [<direction>] [if:<boolean>])
gd~ <toInt>    ::= (toInt (<boolean> | <float>))
~~~ <baseIntFunction> ::= <%> | <ints.math.*> | <ints.math.+> | <ints.math.-> | 
               <ints.math./> | <ints.math.^> | <ints.math.abs> | <ahead> | 
               <amount> | <iterator.between> | <card.card> | <centrePoint> | 
               <column> | <coord> | <cost> | <count.count> | <counter> | 
               <iterator.edge> | <dice.face> | <iterator.from> | <handSite> | 
               <iterator.hint> | <id> | <ints.math.if> | <ints.last.last> | 
               <layer> | <level> | <mapEntry> | <matchScore> | 
               <ints.math.max> | <ints.math.min> | <mover> | <next> | 
               <nextPhase> | <pathExtent> | <board.phase> | <pips> | 
               <iterator.player> | <pot> | <prev> | <regionSite> | <rotation> | 
               <row> | <state.score> | <site> | <size> | <state> | 
               <iterator.to> | <toInt> | <topLevel> | <iterator.track> | 
               <trackSite> | <value> | <var> | <what> | <where> | <who>
gd~ <topLevel> ::= (topLevel [<siteType>] at:<int>)
gd~ <mapEntry> ::= (mapEntry [<string>] (<int> | <roleType>))
gd~ <id>       ::= (id <string>) | (id [<string>] <roleType>)
gd~ <where>    ::= (where Level <string> (<int> | 
               <roleType>) [state:<int>] [<siteType>] at:<int> [fromTop:<boolean>]) 
               | (where <int> [<siteType>]) | (where <string> (<int> | 
               <roleType>) [state:<int>] [<siteType>]) | 
               (where Level <int> [<siteType>] at:<int> [fromTop:<boolean>])
gd~ <ahead>    ::= (ahead [<siteType>] <int> [steps:<int>] [<direction>])
gd~ <regionSite> ::= (regionSite <sites> index:<int>)
gd~ <column>   ::= (column [<siteType>] of:<int>)
gd~ <centrePoint> ::= (centrePoint [<siteType>])
gd~ <board.phase> ::= (phase [<siteType>] of:<int>)
gd~ <cost>     ::= (cost [<siteType>] (at:<int> | in:<sites>))
gd~ <coord>    ::= (coord [<siteType>] row:<int> column:<int>) | 
               (coord [<siteType>] <string>)
gd~ <layer>    ::= (layer of:<int> [<siteType>])
gd~ <handSite> ::= (handSite (<int> | <roleType>) [<int>])
gd~ <row>      ::= (row [<siteType>] of:<int>)
gd~ <dice.face> ::= (face <int>)
gd~ <level>    ::= (level)
gd~ <iterator.player> ::= (player)
gd~ <site>     ::= (site)
gd~ <iterator.between> ::= (between)
gd~ <iterator.to> ::= (to)
gd~ <iterator.track> ::= (track)
gd~ <pips>     ::= (pips)
gd~ <iterator.hint> ::= (hint [<siteType>] [at:<int>])
gd~ <iterator.from> ::= (from [at:<whenType>])
gd~ <iterator.edge> ::= (edge) | (edge <int> <int>)
gd~ <trackSite> ::= (trackSite Move [from:<int>] [<roleType> | <moves.player> | 
               <string>] steps:<int>) | (trackSite EndSite [<moves.player> | 
               <roleType>] [<string>])
gd~ <directions.difference> ::= (difference <direction> <direction>)
gd~ <directions.if> ::= (if <boolean> <direction> <direction>)
~~~ <directions> ::= <directions.difference> | <directions> | <directions.if>
gd~ <directions> ::= (directions (<absoluteDirection> | {<absoluteDirection>})) | 
               (directions [<relativeDirection> | 
               {<relativeDirection>}] [of:<relationType>] [bySite:<boolean>]) | 
               (directions <siteType> from:<int> to:<int>) | 
               (directions Random <direction> num:<int>)
g~~ <float>    ::= 
gd~ <sin>      ::= (sin <float>)
gd~ <tan>      ::= (tan <float>)
gd~ <floats.math.min> ::= (min {<float>}) | (min <float> <float>)
gd~ <exp>      ::= (exp <float>)
gd~ <floats.math.abs> ::= (abs <float>)
gd~ <floats.math.*> ::= (* {<float>}) | (* <float> <float>)
gd~ <cos>      ::= (cos <float>)
gd~ <floats.math.-> ::= (- <float> <float>)
gd~ <floats.math.max> ::= (max {<float>}) | (max <float> <float>)
gd~ <floats.math.+> ::= (+ {<float>}) | (+ <float> <float>)
gd~ <floats.math./> ::= (/ <float> <float>)
gd~ <log>      ::= (log <float>)
gd~ <floats.math.^> ::= (^ <float> <float>)
gd~ <sqrt>     ::= (sqrt <float>)
gd~ <log10>    ::= (log10 <float>)
gd~ <toFloat>  ::= (toFloat (<boolean> | <int>))
~~~ <baseFloatFunction> ::= <floats.math.*> | <floats.math.+> | <floats.math.-> | 
               <floats.math./> | <floats.math.^> | <floats.math.abs> | <cos> | 
               <exp> | <log> | <log10> | <floats.math.max> | 
               <floats.math.min> | <sin> | <sqrt> | <tan> | <toFloat>
gd~ <values.values> ::= (values Remembered [<string>])
~~~ <baseIntArrayFunction> ::= <array> | <intArray.math.difference> | 
               <intArray.math.intersection> | <intArray.players.players> | 
               <results> | <rotations> | <sizes> | <team> | 
               <intArray.math.union> | <values.values>
gd~ <sizes>    ::= (sizes Group [<siteType>] [<direction>] [<roleType> | of:<int> | 
               if:<boolean>] [min:<int>])
g~~ <ints>     ::= 
gd~ <intArray.math.union> ::= (union {<ints>}) | (union <ints> <ints>)
gd~ <intArray.math.difference> ::= (difference <ints> (<ints> | <int>))
gd~ <results>  ::= (results (from:<int> | from:<sites>) (to:<int> | 
               to:<sites>) <int>)
gd~ <intArray.math.intersection> ::= (intersection {<ints>}) | 
               (intersection <ints> <ints>)
gd~ <rotations> ::= (rotations (<absoluteDirection> | {<absoluteDirection>}))
g~~ <playersManyType> ::= All | Ally | Enemy | Friend | NonMover
gd~ <intArray.players.players> ::= (players <playersTeamType> [if:<boolean>]) | 
               (players <playersManyType> [of:<int>] [if:<boolean>])
g~~ <playersTeamType> ::= Team1 | Team10 | Team11 | Team12 | Team13 | Team14 | 
               Team15 | Team16 | Team2 | Team3 | Team4 | Team5 | Team6 | 
               Team7 | Team8 | Team9
gd~ <array>    ::= (array <sites>)
gd~ <team>     ::= (team)
g~~ <range>    ::= 
gd~ <range>    ::= (range <int> <int>) | (range <int> <int>) | <exact> | 
               <range.math.max> | <range.math.min>
gd~ <range.math.min> ::= (min <int>)
gd~ <exact>    ::= (exact <int>)
gd~ <range.math.max> ::= (max <int>)
gd~ <end>      ::= (end (<endRule> | {<endRule>}))
g~~ <endRule>  ::= <end.forEach> | <end.if>
gd~ <payoffs>  ::= (payoffs {<payoff>})
gd~ <result>   ::= (result <roleType> <resultType>) | <byScore> | <payoffs>
gd~ <byScore>  ::= (byScore [{<end.score>}])
gd~ <end.forEach> ::= (forEach [<roleType> | Track] if:<boolean> <result>)
gd~ <end.if>   ::= (if <boolean> [<end.if> | {<end.if>}] [<result>])
~~~ <rule>     ::= 
g~~ <startRule> ::= <start.deal> | <forEach.forEach> | <place> | <start.set.set> | 
               <deductionPuzzle.set> | <split>
g~~ <setStartSitesType> ::= Cost | Count | Phase
g~~ <setStartPlayerType> ::= Amount | Score
gd~ <start.set.set> ::= (set <setStartSitesType> <int> [<siteType>] (at:<int> | 
               to:<sites>)) | 
               (set <roleType> [<siteType>] [{<int>}] [<sites>] [{<string>}]) | 
               (set <roleType> [<siteType>] [<int>] [coord:<string>]) | 
               (set Hidden [<hiddenData> | 
               {<hiddenData>}] [<siteType>] (at:<int> | 
               <sites>) [level:<int>] [<boolean>] to:<roleType>) | 
               (set <setStartPlayerType> [<roleType>] <int>) | 
               (set Team <int> {<roleType>}) | 
               (set RememberValue [<string>] (<int> | 
               <sites>) [unique:<boolean>])
gd~ <start>    ::= (start ({<startRule>} | <startRule>))
gd~ <start.deal> ::= (deal <dealableType> [<int>])
gd~ <forEach.forEach> ::= (forEach Player <startRule>) | 
               (forEach Value min:<int> max:<int> <startRule>) | 
               (forEach Site <sites> [if:<boolean>] <startRule>) | 
               (forEach <ints> <startRule>) | (forEach Team <startRule>)
gd~ <place>    ::= (place Random [<sites>] {<string>} [count:<int>] [state:<int>] [value:<int>] [<siteType>]) 
               | (place Stack (<string> | 
               items:{<string>}) [<string>] [<siteType>] [<int> | {<int>} | 
               <sites> | coord:<string> | {<string>}] [count:<int> | 
               counts:{<int>}] [state:<int>] [rotation:<int>] [value:<int>]) | 
               (place <string> [<siteType>] [{<int>}] [<sites>] [{<string>}] [counts:{<int>}] [state:<int>] [rotation:<int>] [value:<int>]) 
               | 
               (place <string> [<string>] [<siteType>] [<int>] [coord:<string>] [count:<int>] [state:<int>] [rotation:<int>] [value:<int>]) 
               | (place Random {<math.count>} <int> [<siteType>]) | 
               (place Random {<string>} [count:{<int>}] [state:<int>] [value:<int>] <int> [<siteType>])
gd~ <deductionPuzzle.set> ::= (set [<siteType>] {{<int>}})
gd~ <split>    ::= (split Deck)
gd~ <meta>     ::= (meta ({<metaRule>} | <metaRule>))
gd~ <gravity>  ::= (gravity [PyramidalDrop])
gd~ <meta.swap> ::= (swap)
gd~ <passEnd>  ::= (passEnd <passEndType>)
gd~ <noRepeat> ::= (noRepeat [<repetitionType>])
gd~ <pin>      ::= (pin SupportMultiple)
gd~ <automove> ::= (automove)
g~~ <metaRule> ::= <automove> | <gravity> | <noRepeat> | <passEnd> | <pin> | 
               <meta.swap>
gd~ <phase.phase> ::= (phase <string> [<roleType>] [<mode>] <play> [<end>] [<nextPhase> 
               | {<nextPhase>}])
gd~ <nextPhase> ::= (nextPhase [<roleType> | <moves.player>] [<boolean>] [<string>])
gd~ <play>     ::= (play <moves>)
g~~ <moves>    ::= <effect.add> | <addScore> | <allCombinations> | <logical.and> | 
               <append> | <apply> | <attract> | <avoidStoredState> | <bet> | 
               <claim> | <custodial> | <effect.deal> | <decision> | 
               <directionCapture> | <do> | <effect> | <enclose> | 
               <firstMoveOnTrack> | <flip> | <operators.foreach.forEach> | 
               <forget> | <fromTo> | <hop> | <logical.if> | <intervene> | 
               <leap> | <max.max> | <move> | <moveAgain> | <nonDecision> | 
               <note> | <operator> | <logical.or> | <pass> | <playCard> | 
               <priority> | <promote> | <propose> | <push> | <random> | 
               <remember> | <effect.remove> | <roll> | <satisfy> | <select> | 
               <effect.set.set> | <shoot> | <slide> | <sow> | <effect.step> | 
               <surround> | <swap.swap> | <take> | <trigger> | <vote> | <while>
gd~ <move>     ::= (move Step [<moves.from>] [<direction>] <moves.to> [stack:<boolean>] [<then>]) 
               | 
               (move Slide [<moves.from>] [<string>] [<direction>] [<moves.between>] [<moves.to>] [stack:<boolean>] [<then>]) 
               | 
               (move Shoot <moves.piece> [<moves.from>] [<absoluteDirection>] [<moves.between>] [<moves.to>] [<then>]) 
               | (move Select <moves.from> [<moves.to>] [<then>]) | 
               (move Swap Pieces [<int>] [<int>] [<then>]) | 
               (move Remove [<siteType>] (<int> | 
               <sites>) [level:<int>] [at:<whenType>] [count:<int>] [<then>]) | 
               (move Set TrumpSuit (<int> | 
               <intArray.math.difference>) [<then>]) | 
               (move Set NextPlayer (<moves.player> | <ints>) [<then>]) | 
               (move Set Rotation [<moves.to>] [{<int>} | 
               <int>] [previous:<boolean>] [next:<boolean>] [<then>]) | 
               (move <moves.from> <moves.to> [count:<int>] [copy:<boolean>] [stack:<boolean>] [<roleType>] [<then>]) 
               | (move Bet (<moves.player> | <roleType>) <range> [<then>]) | 
               (move <moveSiteType> [<moves.piece>] <moves.to> [count:<int>] [stack:<boolean>] [<then>]) 
               | 
               (move Swap Players (<int> <roleType>) (<int> <roleType>) [<then>]) 
               | (move <moveMessageType> (<string> | {<string>}) [<then>]) | 
               (move Promote [<siteType>] [<int>] <moves.piece> [<moves.player> 
               | <roleType>] [<then>]) | (move <moveSimpleType> [<then>]) | 
               (move Leap [<moves.from>] {{<stepType>}} [forward:<boolean>] [rotations:<boolean>] <moves.to> [<then>]) 
               | 
               (move Hop [<moves.from>] [<direction>] [<moves.between>] <moves.to> [stack:<boolean>] [<then>])
g~~ <moveSimpleType> ::= Pass | PlayCard
g~~ <moveMessageType> ::= Propose | Vote
g~~ <moveSiteType> ::= Add | Claim
g~~ <decision> ::= <move>
g~~ <operator> ::= <allCombinations> | <logical.and> | <append> | <logical.if> | 
               <logical.or>
g~~ <nonDecision> ::= <effect> | <operator>
gd~ <apply>    ::= (apply if:<boolean>) | (apply <nonDecision>) | 
               (apply if:<boolean> <nonDecision>)
gd~ <surround> ::= (surround [<moves.from>] [<relationType>] [<moves.between>] [<moves.to>] [except:<int>] [with:<moves.piece>] [<then>])
gd~ <slide>    ::= (slide [<moves.from>] [<string>] [<direction>] [<moves.between>] [<moves.to>] [stack:<boolean>] [<then>])
g~~ <setPlayerType> ::= Score | Value
g~~ <setSiteType> ::= Count | State | Value
gd~ <effect.set.set> ::= (set Rotation [<moves.to>] [{<int>} | 
               <int>] [previous:<boolean>] [next:<boolean>] [<then>]) | 
               (set <setPlayerType> (<moves.player> | 
               <roleType>) <int> [<then>]) | (set NextPlayer (<moves.player> | 
               <ints>) [<then>]) | (set TrumpSuit (<int> | 
               <intArray.math.difference>) [<then>]) | 
               (set Hidden [<hiddenData> | 
               {<hiddenData>}] [<siteType>] (at:<int> | 
               <sites>) [level:<int>] [<boolean>] (to:<moves.player> | 
               to:<roleType>) [<then>]) | 
               (set Team <int> {<roleType>} [<then>]) | 
               (set <setSiteType> [<siteType>] at:<int> <int> [<then>]) | 
               (set <setValueType> [<int>] [<then>]) | 
               (set Var [<string>] [<int>] [<then>]) | (set Pending [<int> | 
               <sites>] [<then>])
g~~ <setValueType> ::= Counter | Pot
gd~ <leap>     ::= (leap [<moves.from>] {{<stepType>}} [forward:<boolean>] [rotations:<boolean>] <moves.to> [<then>])
gd~ <while>    ::= (while <boolean> <moves> [<then>])
gd~ <avoidStoredState> ::= (avoidStoredState <moves> [<then>])
gd~ <firstMoveOnTrack> ::= (firstMoveOnTrack [<string>] [<roleType>] <moves> [<then>])
gd~ <priority> ::= (priority <moves> <moves> [<then>]) | 
               (priority {<moves>} [<then>])
g~~ <maxMovesType> ::= Captures | Moves
gd~ <max.max>  ::= (max <maxMovesType> <moves> [<then>]) | 
               (max Distance [<string>] [<roleType>] <moves> [<then>])
gd~ <do>       ::= (do <moves> [next:<moves>] [ifAfterwards:<boolean>] [<then>])
gd~ <custodial> ::= (custodial [<moves.from>] [<absoluteDirection>] [<moves.between>] [<moves.to>] [<then>])
gd~ <effect.remove> ::= (remove [<siteType>] (<int> | 
               <sites>) [level:<int>] [at:<whenType>] [count:<int>] [<then>])
gd~ <then>     ::= (then <nonDecision> [applyAfterAllMoves:<boolean>])
gd~ <trigger>  ::= (trigger <string> (<int> | <roleType>) [<then>])
gd~ <fromTo>   ::= (fromTo <moves.from> <moves.to> [count:<int>] [copy:<boolean>] [stack:<boolean>] [<roleType>] [<then>])
gd~ <push>     ::= (push [<moves.from>] <direction> [<then>])
gd~ <sow>      ::= (sow [<siteType>] [<int>] [count:<int>] [<string>] [owner:<int>] [if:<boolean>] [apply:<nonDecision>] [includeSelf:<boolean>] [origin:<boolean>] [skipIf:<boolean>] [backtracking:<boolean>] [<then>])
gd~ <enclose>  ::= (enclose [<siteType>] [<moves.from>] [<direction>] [<moves.between>] [numException:<int>] [<then>])
gd~ <effect.add> ::= (add [<moves.piece>] <moves.to> [count:<int>] [stack:<boolean>] [<then>])
gd~ <bet>      ::= (bet (<moves.player> | <roleType>) <range> [<then>])
gd~ <effect.deal> ::= (deal <dealableType> [<int>] [beginWith:<int>] [<then>])
gd~ <directionCapture> ::= (directionCapture [<moves.from>] [<moves.to>] [opposite:<boolean>] [<then>])
gd~ <forget>   ::= (forget Value [<string>] All [<then>]) | 
               (forget Value [<string>] <int> [<then>])
gd~ <moveAgain> ::= (moveAgain)
gd~ <swap.swap> ::= (swap Pieces [<int> <int>] [<then>]) | (swap Players (<int> | 
               <roleType>) (<int> | <roleType>) [<then>])
gd~ <addScore> ::= (addScore ({<int>} | {<roleType>}) {<int>} [<then>]) | 
               (addScore (<moves.player> | <roleType>) <int> [<then>])
gd~ <remember> ::= (remember Value [<string>] <int> [unique:<boolean>] [<then>]) | 
               (remember State [<then>])
gd~ <claim>    ::= (claim [<moves.piece>] <moves.to> [<then>])
gd~ <flip>     ::= (flip [<siteType>] [<int>] [<then>])
gd~ <take>     ::= (take Domino [<then>]) | (take Control (of:<roleType> | 
               of:<int>) (by:<roleType> | by:<int>) [at:<int> | 
               to:<sites>] [<siteType>] [<then>])
gd~ <note>     ::= (note [player:<int> | player:<roleType>] (<string> | <int> | 
               <ints> | <float> | <boolean> | <sites> | <range> | <direction> | 
               <graph>) [to:<moves.player> | to:<roleType>])
gd~ <vote>     ::= (vote (<string> | {<string>}) [<then>])
gd~ <effect.step> ::= (step [<moves.from>] [<direction>] <moves.to> [stack:<boolean>] [<then>])
gd~ <satisfy>  ::= (satisfy (<boolean> | {<boolean>}))
gd~ <random>   ::= (random {<float>} {<moves>})
gd~ <roll>     ::= (roll [<then>])
gd~ <playCard> ::= (playCard [<then>])
gd~ <select>   ::= (select <moves.from> [<moves.to>] [<then>])
gd~ <intervene> ::= (intervene [<moves.from>] [<absoluteDirection>] [<moves.between>] [<moves.to>] [<then>])
gd~ <promote>  ::= (promote [<siteType>] [<int>] <moves.piece> [<moves.player> | 
               <roleType>] [<then>])
gd~ <attract>  ::= (attract [<moves.from>] [<absoluteDirection>] [<then>])
g~~ <effect>   ::= <effect.add> | <addScore> | <attract> | <avoidStoredState> | 
               <bet> | <claim> | <custodial> | <effect.deal> | 
               <directionCapture> | <do> | <enclose> | <firstMoveOnTrack> | 
               <flip> | <operators.foreach.forEach> | <forget> | <fromTo> | 
               <hop> | <intervene> | <leap> | <max.max> | <moveAgain> | 
               <note> | <pass> | <playCard> | <priority> | <promote> | 
               <propose> | <push> | <remember> | <effect.remove> | <roll> | 
               <satisfy> | <select> | <effect.set.set> | <shoot> | <slide> | 
               <sow> | <effect.step> | <surround> | <swap.swap> | <take> | 
               <trigger> | <vote> | <while>
gd~ <hop>      ::= (hop [<moves.from>] [<direction>] [<moves.between>] <moves.to> [stack:<boolean>] [<then>])
gd~ <propose>  ::= (propose (<string> | {<string>}) [<then>])
gd~ <pass>     ::= (pass [<then>])
gd~ <shoot>    ::= (shoot <moves.piece> [<moves.from>] [<absoluteDirection>] [<moves.between>] [<moves.to>] [<then>])
gd~ <operators.foreach.forEach> ::= (forEach Value <ints> <moves> [<then>]) | 
               (forEach Site <sites> <moves> [noMoveYet:<moves>] [<then>]) | 
               (forEach Direction [<moves.from>] [<direction>] [<moves.between>] (<moves.to> 
               | <moves>) [<then>]) | 
               (forEach Die [<int>] [combined:<boolean>] [replayDouble:<boolean>] [if:<boolean>] <moves> [<then>]) 
               | 
               (forEach Group [<siteType>] [<direction>] [if:<boolean>] <moves> [<then>]) 
               | (forEach Team <moves> [<then>]) | 
               (forEach <ints> <moves> [<then>]) | 
               (forEach Player <moves> [<then>]) | 
               (forEach Piece [on:<siteType>] [<string> | 
               {<string>}] [container:<int> | 
               <string>] [<moves>] [<moves.player> | 
               <roleType>] [top:<boolean>] [<then>]) | 
               (forEach Value min:<int> max:<int> <moves> [<then>])
gd~ <append>   ::= (append <nonDecision> [<then>])
gd~ <allCombinations> ::= (allCombinations <moves> <moves> [<then>])
gd~ <logical.and> ::= (and <moves> <moves> [<then>]) | (and {<moves>} [<then>])
gd~ <logical.if> ::= (if <boolean> <moves> [<moves>] [<then>])
gd~ <logical.or> ::= (or {<moves>} [<then>]) | (or <moves> <moves> [<then>])
gd~ <rules.rules> ::= (rules [<meta>] [<start>] [<play>] phases:{<phase.phase>} [<end>]) 
               | (rules [<meta>] [<start>] <play> <end>)
gd~ <games>    ::= (games (<subgame> | {<subgame>}))
gd~ <subgame>  ::= (subgame <string> [<string>] [next:<int>] [result:<int>])
gd~ <match>    ::= (match <string> [<players>] <games> <end>) | (match <string>)
g~~ <item>     ::= <component> | <container> | <dominoes> | <hints> | <map> | 
               <regions>
gd~ <equipment> ::= (equipment {<item>})
gd~ <hints>    ::= (hints [<string>] {<equipment.hint>} [<siteType>])
gd~ <map>      ::= (map [<string>] {<int>} {<int>}) | (map [<string>] {<math.pair>})
gd~ <dominoes> ::= (dominoes [upTo:<int>])
gd~ <regions>  ::= (regions [<string>] [<roleType>] ({<int>} | <sites> | {<sites>} | 
               <regionTypeStatic> | {<regionTypeStatic>}) [<string>])
g~~ <container> ::= <container.board.board> | <deck> | <dice> | <other.hand>
gd~ <boardless> ::= (boardless <tilingBoardlessType> [<dim>])
gd~ <container.board.board> ::= (board <graph> [<board.track> | 
               {<board.track>}] [<equipment.values> | 
               {<equipment.values>}] [use:<siteType>]) | <boardless> | 
               <mancalaBoard> | <surakartaBoard>
gd~ <board.track> ::= (track <string> ({<int>} | <string>) [loop:<boolean>] [<int> | 
               <roleType>] [directed:<boolean>])
gd~ <surakartaBoard> ::= (surakartaBoard <graph> [loops:<int>] [from:<int>])
gd~ <mancalaBoard> ::= (mancalaBoard <int> <int> [store:<storeType>] [numStores:<int>] [<board.track> 
               | {<board.track>}])
gd~ <other.hand> ::= (hand <roleType> [size:<int>])
gd~ <deck>     ::= (deck [<roleType>] [cardsBySuit:<int>] [suits:<int>] [{<equipment.card>}])
gd~ <dice>     ::= (dice [d:<int>] [faces:{<int>} | facesByDie:{{<int>}} | 
               from:<int>] [<roleType>] num:<int> [biased:{<int>}])
gd~ <component.card> ::= (card <string> <roleType> <cardType> rank:<int> value:<int> trumpRank:<int> trumpValue:<int> suit:<int> [<moves>] [maxState:<int>] [maxCount:<int>] [maxValue:<int>])
gd~ <component> ::= (component <string> <roleType> {{<stepType>}} <directionFacing> <moves> <int> <int> <int>) 
               | <component.card> | <die> | <domino> | <component.piece> | 
               <tile>
gd~ <domino>   ::= (domino <string> <roleType> value:<int> value2:<int> [<moves>])
gd~ <path>     ::= (path from:<int> [slotsFrom:<int>] to:<int> [slotsTo:<int>] colour:<int>)
gd~ <tile>     ::= (tile <string> [<roleType>] [{<stepType>} | 
               {{<stepType>}}] [numSides:<int>] [slots:{<int>} | 
               slotsPerSide:<int>] [{<path>}] [<flips>] [<moves>] [maxState:<int>] [maxCount:<int>] [maxValue:<int>])
gd~ <component.piece> ::= (piece <string> [<roleType>] [<directionFacing>] [<flips>] [<moves>] [maxState:<int>] [maxCount:<int>] [maxValue:<int>])
gd~ <die>      ::= (die <string> <roleType> numFaces:<int> [<directionFacing>] [<moves>])
gd~ <end.score> ::= (score <roleType> <int>)
gd~ <payoff>   ::= (payoff <roleType> <float>)
gd~ <moves.player> ::= (player <int>)
gd~ <moves.between> ::= (between [before:<int>] [<range>] [after:<int>] [if:<boolean>] [trail:<int>] [<apply>])
gd~ <moves.to> ::= (to [<siteType>] [<sites> | 
               <int>] [level:<int>] [<rotations>] [if:<boolean>] [<apply>])
gd~ <flips>    ::= (flips <int> <int>)
gd~ <moves.piece> ::= (piece (<string> | <int> | {<string>} | {<int>}) [state:<int>])
gd~ <moves.from> ::= (from [<siteType>] [<sites> | 
               <int>] [level:<int>] [if:<boolean>])
~~~ <radial>   ::= (radial {<graphElement>} <absoluteDirection>)
~~~ <graphElement> ::= <graph.edge> | <graph.face> | <vertex>
~~~ <graph.face> ::= (face int)
~~~ <radials>  ::= (radials <siteType> int)
gd~ <graph>    ::= (graph <graph>) | 
               (graph vertices:{{<float>}} [edges:{{<int>}}]) | (graph) | 
               (graph) | <operators.add> | <basis> | <brick> | <celtic> | 
               <clip> | <complete> | <concentric> | <dual> | <hex> | <hole> | 
               <intersect> | <keep> | <layers> | <makeFaces> | <merge> | 
               <quadhex> | <recoordinate> | <regular> | <operators.remove> | 
               <renumber> | <repeat> | <rotate> | <scale> | <shift> | <skew> | 
               <spiral> | <splitCrossings> | <square> | <subdivide> | 
               <tiling> | <tri> | <trim> | <operators.union> | <wedge>
~~~ <perimeter> ::= (perimeter)
gd~ <poly>     ::= (poly {{<dim>}}) | (poly {{<float>}})
~~~ <trajectories> ::= (trajectories)
~~~ <steps>    ::= (steps <siteType> int)
~~~ <graph.step> ::= (step <graphElement> <graphElement>)
~~~ <measureGraph> ::= 
~~~ <properties> ::= (properties) | (properties) | (properties <properties>)
~~~ <bucket>   ::= (bucket)
~~~ <vertex>   ::= (vertex int) | (vertex int) | (vertex int) | (vertex int)
~~~ <situation> ::= (situation)
~~~ <graph.edge> ::= (edge int <vertex> <vertex>)
~~~ <itemScore> ::= (itemScore int)
gd~ <math.pair> ::= (pair <string> <string>) | (pair <roleType> <roleType>) | 
               (pair <roleType> <int>) | (pair <int> <int>) | 
               (pair <string> <roleType>) | (pair <roleType> <landmarkType>) | 
               (pair <roleType> <string>) | (pair <int> <string>)
gd~ <math.count> ::= (count <string> <int>)
g~~ <direction> ::= <absoluteDirection> | <directions.difference> | <directions> | 
               <directions.if> | <relativeDirection>
g~~ <stackDirection> ::= FromBottom | FromTop
g~~ <directionFacing> ::= <absoluteDirection> | <directions> | <directions.if> | 
               <relativeDirection>
~~~ <directionType> ::= (directionType <directionFacing>)
g~~ <relativeDirection> ::= BL | BLL | BLLL | BR | BRR | BRRR | Backward | 
               Backwards | FL | FLL | FLLL | FR | FRR | FRRR | Forward | 
               Forwards | Leftward | Leftwards | OppositeDirection | 
               Rightward | Rightwards | SameDirection
g~~ <absoluteDirection> ::= Adjacent | All | Angled | Axial | Base | CCW | CW | D | 
               DE | DN | DNE | DNW | DS | DSE | DSW | DW | Diagonal | 
               Downward | E | ENE | ESE | In | N | NE | NNE | NNW | NW | 
               OffDiagonal | Orthogonal | Out | Rotational | S | SE | SSE | 
               SSW | SW | SameLayer | Support | U | UE | UN | UNE | UNW | US | 
               USE | USW | UW | Upward | W | WNW | WSW
~~~ <rotationalDirection> ::= CCW | CW | In | Out
g~~ <compassDirection> ::= E | ENE | ESE | N | NE | NNE | NNW | NW | S | SE | SSE | 
               SSW | SW | W | WNW | WSW
~~~ <spatialDirection> ::= D | DE | DN | DNE | DNW | DS | DSE | DSW | DW | U | UE | 
               UN | UNE | UNW | US | USE | USW | UW
~~~ <util.dummy> ::= 
gd~ <equipment.card> ::= (card <cardType> rank:<int> value:<int> [trumpRank:<int>] [trumpValue:<int>] [biased:<int>])
gd~ <equipment.values> ::= (values <siteType> <range>)
gd~ <equipment.hint> ::= (hint <int> [<int>]) | (hint {<int>} [<int>])
gd~ <players.player> ::= (player <directionFacing>)
gd~ <players>  ::= (players <int>) | (players {<players.player>})
~~~ <types.dummy> ::= 
~~~ <gameType> ::= 
g~~ <hiddenData> ::= Count | Rotation | State | Value | What | Who
g~m <shapeType> ::= Circle | Cross | Custom | Diamond | Hexagon | Limping | 
               NoShape | Polygon | Prism | Quadrilateral | Rectangle | 
               Regular | Rhombus | Spiral | Square | Star | Triangle | Wedge | 
               Wheel
g~~ <tilingBoardlessType> ::= Hexagonal | Square | Triangular
g~~ <stepType> ::= F | L | R
g~~ <regionTypeStatic> ::= AllDirections | AllSites | Columns | Corners | 
               Diagonals | HintRegions | Layers | Regions | Rows | Sides | 
               SidesNoCorners | SubGrids | Touching | Vertices
g~m <relationType> ::= Adjacent | All | Diagonal | OffDiagonal | Orthogonal
g~~ <puzzleElementType> ::= Cell | Edge | Hint | Vertex
g~~ <storeType> ::= Inner | None | Outer
g~m <siteType> ::= Cell | Edge | Vertex
g~~ <landmarkType> ::= BottomSite | CentreSite | FirstSite | LastSite | LeftSite | 
               RightSite | Topsite
g~~ <regionTypeDynamic> ::= Empty | Enemy | NotEmpty | NotEnemy | NotOwn | Own
g~~ <basisType> ::= Brick | Celtic | Circle | Concentric | Dual | Hexagonal | 
               HexagonalPyramidal | Mesh | Morris | NoBasis | QuadHex | 
               Spiral | Square | SquarePyramidal | T31212 | T333333_33434 | 
               T33336 | T33344 | T33434 | T3464 | T3636 | T4612 | T488 | 
               Triangular
g~~ <prevType> ::= Mover | MoverLastTurn
g~~ <repetitionType> ::= InGame | InTurn | Positional | Situational
g~~ <passEndType> ::= Draw | NoEnd
g~m <roleType> ::= All | Ally | Each | Enemy | Friend | Mover | Neutral | Next | 
               NonMover | P1 | P10 | P11 | P12 | P13 | P14 | P15 | P16 | P2 | 
               P3 | P4 | P5 | P6 | P7 | P8 | P9 | Player | Prev | Shared | 
               Team1 | Team10 | Team11 | Team12 | Team13 | Team14 | Team15 | 
               Team16 | Team2 | Team3 | Team4 | Team5 | Team6 | Team7 | Team8 | 
               Team9
g~~ <whenType> ::= EndOfGame | EndOfMatch | EndOfMove | EndOfPhase | EndOfRound | 
               EndOfSession | EndOfTurn | StartOfGame | StartOfMatch | 
               StartOfMove | StartOfPhase | StartOfRound | StartOfSession | 
               StartOfTurn
g~~ <modeType> ::= Alternating | Simulation | Simultaneous
g~~ <resultType> ::= Abandon | Crash | Draw | Loss | Tie | Win
g~~ <dealableType> ::= Cards | Dominoes
~~m <suitType> ::= Clubs | Diamonds | Hearts | Spades
g~~ <cardType> ::= Ace | Eight | Five | Four | Jack | Joker | King | Nine | Queen | 
               Seven | Six | Ten | Three | Two
gd~ <game>     ::= (game <string>) | 
               (game <string> <players> [<mode>] <equipment> <rules.rules>) | 
               <match>
~~m <ai>       ::= (ai [<bestAgent>] [<heuristics>] [<features>])
~~m <aIItem>   ::= 
~~m <misc.pair> ::= (pair <string> <float>)
~~m <bestAgent> ::= (bestAgent <string>)
~~m <featureSet> ::= (featureSet <roleType> {<misc.pair>})
~~m <features> ::= (features [{<featureSet>}]) | (features [<featureSet>])
~~m <influence> ::= (influence [transformation:<heuristicTransformation>] [weight:<float>])
~~m <currentMoverHeuristic> ::= (currentMoverHeuristic [transformation:<heuristicTransformation>] [weight:<float>])
~~m <playerRegionsProximity> ::= (playerRegionsProximity [transformation:<heuristicTransformation>] [weight:<float>] player:<int> [pieceWeights:{<misc.pair>}])
~~m <heuristicTerm> ::= <centreProximity> | <componentValues> | <cornerProximity> | 
               <currentMoverHeuristic> | <influence> | 
               <lineCompletionHeuristic> | <material> | <mobilitySimple> | 
               <nullHeuristic> | <ownRegionsCount> | <playerRegionsProximity> | 
               <playerSiteMapCount> | <regionProximity> | <terms.score> | 
               <sidesProximity>
~~m <playerSiteMapCount> ::= (playerSiteMapCount [transformation:<heuristicTransformation>] [weight:<float>])
~~m <cornerProximity> ::= (cornerProximity [transformation:<heuristicTransformation>] [weight:<float>] [pieceWeights:{<misc.pair>}])
~~m <ownRegionsCount> ::= (ownRegionsCount [transformation:<heuristicTransformation>] [weight:<float>])
~~m <nullHeuristic> ::= (nullHeuristic)
~~m <centreProximity> ::= (centreProximity [transformation:<heuristicTransformation>] [weight:<float>] [pieceWeights:{<misc.pair>}])
~~m <sidesProximity> ::= (sidesProximity [transformation:<heuristicTransformation>] [weight:<float>] [pieceWeights:{<misc.pair>}])
~~m <lineCompletionHeuristic> ::= (lineCompletionHeuristic [transformation:<heuristicTransformation>] [weight:<float>] [targetLength:<int>])
~~m <mobilitySimple> ::= (mobilitySimple [transformation:<heuristicTransformation>] [weight:<float>])
~~m <componentValues> ::= (componentValues [transformation:<heuristicTransformation>] [weight:<float>] [pieceWeights:{<misc.pair>}] [boardOnly:<boolean>])
~~m <regionProximity> ::= (regionProximity [transformation:<heuristicTransformation>] [weight:<float>] region:<int> [pieceWeights:{<misc.pair>}])
~~m <terms.score> ::= (score [transformation:<heuristicTransformation>] [weight:<float>])
~~m <material> ::= (material [transformation:<heuristicTransformation>] [weight:<float>] [pieceWeights:{<misc.pair>}] [boardOnly:<boolean>])
~~m <heuristics> ::= (heuristics [<heuristicTerm>]) | 
               (heuristics [{<heuristicTerm>}])
~~m <tanh>     ::= (tanh)
~~m <heuristicTransformation> ::= 
~~m <divNumInitPlacement> ::= (divNumInitPlacement)
~~m <logisticFunction> ::= (logisticFunction)
~~m <divNumBoardSites> ::= (divNumBoardSites)
~~m <metadataItem> ::= 
~~m <infoItem> ::= 
~~m <info>     ::= (info (<infoItem> | {<infoItem>}))
~~m <version>  ::= (version <string>)
~~m <author>   ::= (author <string>)
~~m <credit>   ::= (credit <string>)
~~m <aliases>  ::= (aliases {<string>})
~~m <publisher> ::= (publisher <string>)
~~m <origin>   ::= (origin <string>)
~~m <classification> ::= (classification <string>)
~~m <source>   ::= (source <string>)
~~m <description> ::= (description <string>)
~~m <date>     ::= (date <string>)
~~m <database.rules> ::= (rules <string>)
~~m <metadata> ::= (metadata [<info>] [<graphics>] [<ai>])
~~m <graphics.no.no> ::= (no <noBooleanType> [<boolean>])
~~m <noBooleanType> ::= Animation | Board | Curves | DicePips | HandScale | 
               MaskedColour | Sunken
~~m <region.region> ::= (region Colour [<string>] [<roleType>] [<siteType>] [{<int>} 
               | 
               <int>] [<sites>] [regionSiteType:<siteType>] [<colour>] [scale:<float>])
~~m <pieceNameType> ::= AddStateToName | ExtendName | Hidden | Rename
~~m <piece.piece> ::= (piece <pieceGroundType> [<roleType>] [<string>] [state:<int>] image:<string> [fillColour:<colour>] [edgeColour:<colour>] [scale:<float>]) 
               | (piece Families {<string>}) | 
               (piece <pieceNameType> [<roleType>] [piece:<string>] [state:<int>] [<string>]) 
               | (piece Style [<roleType>] [<string>] <componentStyleType>) | 
               (piece Scale [<roleType>] [<string>] <float>) | 
               (piece Rotate [<roleType>] [<string>] degrees:<int>) | 
               (piece Reflect [<roleType>] [<string>] [vertical:<boolean>] [horizontal:<boolean>]) 
               | 
               (piece Colour [<roleType>] [<string>] [state:<int>] [value:<int>] [fillColour:<colour>] [strokeColour:<colour>] [secondaryColour:<colour>])
~~m <pieceGroundType> ::= Background | Foreground | Hidden
~~m <player.player> ::= (player Name <roleType> <string>) | 
               (player Colour <roleType> <colour>)
~~m <graphics> ::= (graphics (<graphicsItem> | {<graphicsItem>}))
~~m <containerStyleType> ::= Agon | Backgammon | Board | Boardless | Chess | 
               ChineseCheckers | Connect4 | ConnectiveGoal | Deck | Dice | 
               Futoshiki | Go | Goose | Graph | Hand | Hashi | 
               HoundsAndJackals | Isometric | Janggi | Kakuro | Lasca | 
               Mancala | Pachisi | PenAndPaper | Ploy | Puzzle | Scripta | 
               Shibumi | Shogi | SnakesAndLadders | Spiral | Sudoku | 
               Surakarta | Table | Tafl | UltimateTicTacToe | Xiangqi
~~~ <edgeInfoGUI> ::= (edgeInfoGUI <lineStyle>)
~~m <lineStyle> ::= Hidden | Thick | ThickDashed | ThickDotted | Thin | ThinDashed | 
               ThinDotted
~~~ <scoreDisplayInfo> ::= (scoreDisplayInfo <whenScoreType> <roleType> <int> <string>) 
               | (scoreDisplayInfo)
~~~ <valueDisplayInfo> ::= (valueDisplayInfo <valueLocationType> boolean boolean) | 
               (valueDisplayInfo)
~~m <puzzleHintLocationType> ::= BetweenVertices | Default
~~m <boardGraphicsType> ::= InnerEdges | InnerVertices | OuterEdges | 
               OuterVertices | Phase0 | Phase1 | Phase2 | Phase3 | Symbols
~~m <componentStyleType> ::= Card | Die | Domino | ExtendedShogi | ExtendedXiangqi | 
               LargePiece | NativeAmericanDice | Piece | Tile
~~m <whenScoreType> ::= Always | AtEnd | Never
~~m <userColourType> ::= BabyBlue | Black | BlackSabbath | Blue | Bronze | Brown | 
               Burgundy | Cream | Cyan | Dark | DarkBlue | DarkBrown | 
               DarkGreen | DarkGrey | DarkRed | DeepPurple | Gold | Green | 
               Grey | GunMetal | Hidden | HumanDark | HumanLight | IceBlue | 
               KingCrimson | LightBlue | LightGreen | LightGrey | LightOrange | 
               LightRed | LightTan | Magenta | Orange | Pink | PinkFloyd | 
               Purple | Red | Silver | TangerineDream | Turquoise | 
               VeryDarkBrown | VeryDarkGrey | VeryLightBlue | VeryLightGrey | 
               White | Yellow
~~~ <colourRoutines> ::= (colourRoutines)
~~m <colour>   ::= (colour <int> <int> <int>) | (colour <int> <int> <int> <int>) | 
               (colour <string>) | (colour <userColourType>)
~~m <curveType> ::= Bezier | Spline
~~m <controllerType> ::= BasicController | PyramidalController
~~m <puzzleDrawHintType> ::= Default | NextTo | None | TopLeft
~~~ <metadataFunctions> ::= (metadataFunctions)
~~m <valueLocationType> ::= Corner | Middle | None | Top
~~m <holeType> ::= Oval | Square
~~m <pieceStackType> ::= Backgammon | Count | CountColoured | Default | Fan | 
               FanAlternating | Ground | None | Reverse | Ring | TowardsCenter
~~m <edgeType> ::= All | Inner | Interlayer | Outer
~~~ <metadataImageInfo> ::= (metadataImageInfo int <siteType> <string> float) | 
               (metadataImageInfo int <siteType> <string> float) | 
               (metadataImageInfo {<int>} float {<float>} <siteType> <curveType>) 
               | (metadataImageInfo {<int>} <siteType> float) | 
               (metadataImageInfo int <siteType> <string> float) | 
               (metadataImageInfo int <siteType> <siteType> float) | 
               (metadataImageInfo int <siteType> <boardGraphicsType>) | 
               (metadataImageInfo int <siteType> <string> float float int float float) 
               | 
               (metadataImageInfo int <siteType> <string> float int float float) 
               | (metadataImageInfo int <siteType> <string> float int)
~~m <graphics.board.board> ::= (board <boardBooleanType> [<boolean>]) | 
               (board StyleThickness <boardGraphicsType> <float>) | 
               (board Style PenAndPaper replaceComponentsWithFilledCells:<boolean>) 
               | (board Style <containerStyleType>) | 
               (board Placement [scale:<float>] [offsetX:<float>] [offsetY:<float>]) 
               | (board Shape <shapeType>) | 
               (board Colour <boardGraphicsType> <colour>) | 
               (board <pieceGroundType> [image:<string>] [fillColour:<colour>] [edgeColour:<colour>] [scale:<float>] [scaleX:<float>] [scaleY:<float>] [rotation:<int>] [offsetX:<float>] [offsetY:<float>])
~~m <boardBooleanType> ::= Checkered | RedrawAfterMove
~~m <autoPass> ::= (autoPass <boolean>)
~~m <stackType> ::= (stackType [<roleType>] [<string>] [<int>] [<siteType>] [sites:{<int>} 
               | 
               site:<int>] [state:<int>] <pieceStackType> [<float>] [limit:<int>])
~~m <suitRanking> ::= (suitRanking {<suitType>})
~~m <hiddenImage> ::= (hiddenImage <string>)
~~m <graphicsItem> ::= 
~~m <adversarialPuzzle> ::= (adversarialPuzzle [<boolean>])
~~m <hintLocation> ::= (hintLocation <puzzleHintLocationType>)
~~m <drawHint> ::= (drawHint <puzzleDrawHintType>)
~~m <hand.hand> ::= (hand Placement <roleType> [scale:<float>] [offsetX:<float>] [offsetY:<float>] [vertical:<boolean>])
~~m <show>     ::= (show Edges [<edgeType>] [<relationType>] [connection:<boolean>] [<lineStyle>] [<colour>]) 
               | 
               (show Line {{<int>}} [<siteType>] [<colour>] [scale:<float>] [curve:{<float>}] [<curveType>]) 
               | 
               (show Symbol <string> [<string>] [<roleType>] [<siteType>] [{<int>} 
               | 
               <int>] [<sites>] [<boardGraphicsType>] [fillColour:<colour>] [edgeColour:<colour>] [scale:<float>] [rotation:<int>] [offsetX:<float>] [offsetY:<float>]) 
               | (show AsHoles {<int>} <holeType>) | 
               (show Score [<whenScoreType>] [<roleType>] [<int>] [<string>]) | 
               (show Check [<roleType>] [<string>]) | 
               (show Piece <showComponentDataType> [<roleType>] [<string>] [<valueLocationType>] [offsetImage:<boolean>] [valueOutline:<boolean>]) 
               | (show <showBooleanType> [<boolean>])
~~m <showBooleanType> ::= Cost | CurvedEdges | EdgeDirections | Hints | 
               LocalStateHoles | Pits | PlayerHoles | PossibleMoves | 
               RegionOwner | StraightEdges
~~~ <showSiteType> ::= Cell | Sites
~~m <showComponentDataType> ::= State | Value
~~~ <directionUniqueName> ::= CCW | CW | D | DE | DN | DNE | DNW | DS | DSE | DSW | 
               DW | E | ENE | ESE | In | N | NE | NNE | NNW | NW | Out | S | 
               SE | SSE | SSW | SW | U | UE | UN | UNE | UNW | US | USE | USW | 
               UW | W | WNW | WSW
g~~ <ints>     ::= {<int>} | <array> | <intArray.math.difference> | 
               <intArray.math.intersection> | <intArray.players.players> | 
               <regions> | <results> | <rotations> | <sizes> | <team> | 
               <intArray.math.union> | <values.values>

