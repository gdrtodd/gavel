5x5 intersecting lines, forming a grid Diagonals in each quadrant. A triangular appendage, the apex being the midpoint of one of the sides of the grid. A line from the apex to the midpoint of the base, and a line bisecting this line and intersecting with the midpoints of the two sides of the triangle. There are fourteen "dog" pieces and one "jaguar" piece. The jaguar attempts to capture all of the dogs by hopping over them. The dogs attempt to surround the jaguar and block it from moving. Pieces move from the points where lines intersect to adjacent points along the lines on the board. The objective of the player 1 is to capture all the dogs.
(game "Adugo" (players 2) (equipment {(board (merge (shift 0 2 (square 5 diagonals:Alternating)) (wedge 3)) use:Vertex) (piece "Jaguar" P1 (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to)))))) (piece "Dog" P2 (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Dog2" (difference (expand (sites Top) steps:2) (sites {"C5"}))) (place "Jaguar1" coord:"C5")}) (play (forEach Piece)) (end {(if (no Moves Next) (result Next Loss)) (if (<= (count Pieces P2) 0) (result P2 Loss))}))) 
Played on the Fox and Geese board, but the top arm of the cross is surrounded by a double line, indicating it is a fortress, in which one player puts two officers. The opponent has 24 pieces, which occupy the points outside the fortress. Officers may capture one of the opponent's pieces by hopping over it to an empty space immediately on the opposite side of the opponent's piece. If the officer does not capture when it is possible, it is huffed. The soldiers win by occupying all of the points in the fortress or by blocking the officers from being able to move; the officers win by capturing enough soldiers to prevent this.
(game "Asalto" (players 2) (equipment {(board (merge (shift 0 (/ (- 7 3) 2) (rectangle 3 7 diagonals:Alternating)) (shift (/ (- 7 3) 2) 0 (rectangle 7 3 diagonals:Alternating))) use:Vertex) (piece "Marker" P1 (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to)))))) (piece "Marker" P2 (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Marker1" (sites {"C6" "E6"})) (place "Marker2" (union (expand (union (sites Right) (sites Left))) (expand (sites Bottom) steps:3)))}) (play (if (is Mover P1) (do (forEach Site (sites From (forEach Piece "Marker" (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))))) (remember Value "From" (site))) next:(forEach Piece) (then (and (if (!= 0 (count Sites in:(sites (values Remembered "From")))) (if (= 1 (count Steps (last From) (last To))) (and (forEach Site (sites (values Remembered "From")) (remove (site))) (if (is In (last From) (sites (values Remembered "From"))) (remove (last To)))))) (forget Value All)))) (forEach Piece))) (end {(if (no Pieces P2) (result P1 Win)) (if (or (or (no Pieces P1) (no Moves P1)) (all Sites (expand (sites Top) steps:2) if:(= (who at:(site)) P2))) (result P2 Win))}))) 
5x5 intersecting lines, with diagonals drawn in the four quadrants of the board. Two triangles, their apices intersecting the main board at opposite midpoints. The bast of the triangle is bisected by a line drawn from the apex, and this line is bisected and intersects with the other two sides of the triangle. One player plays as two tigers, which can be placed anywhere on the board, and the other player plays as 32 goats, which begin on the four central points of the quadrants of the square board, eight per stack. Players alternate turns moving a piece to an empty adjacent spot along the lines. The goats move one at a time from their stacks, and cannot be restacked once they have been moved. The tiger may capture a goat by hopping over it to an empty spot immediately on the opposite side of an adjacent goat. Multiple captures in one turn are allowed, but a tiger cannot hop over a stack of goats and hop over it again in the opposite direction. When tigers hop over a stack of goats, only one goat is captured. The goats win by blocking the tigers from being able to move; the tigers win by capturing all the goats.
(game "Bagh Bandi" (players 2) (equipment {(board (merge {(square 5 diagonals:Alternating) (shift 0 4 (rotate 180 (wedge 3))) (shift 0 -2 (wedge 3))}) use:Vertex) (piece "Goat" P2 (move Step (to if:(is Empty (to))))) (piece "Tiger" P1 (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) (difference Orthogonal OppositeDirection) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))) (regions "CentralSites" (sites {6 8 16 18})) (hand P1)}) (rules (start {(place Stack "Tiger1" (handSite P1) count:2) (place Stack "Goat2" 6 count:8) (place Stack "Goat2" 8 count:8) (place Stack "Goat2" 16 count:8) (place Stack "Goat2" 18 count:8)}) phases:{(phase "Placement" P1 (play (move (from (handSite P1)) (to (sites Empty)) (then (if (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site))))) (moveAgain))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (or (move Hop (from (last To)) (difference Orthogonal OppositeDirection) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) (difference Orthogonal OppositeDirection) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))) (move Pass)) (forEach Piece top:True))))} (end {(if (no Moves P1) (result P2 Win)) (if (no Pieces P2) (result P1 Win))}))) 
5x5 board, played on intersections, with diagonals for each quadrant of the board. One player plays with two tiger pieces, placed on the midpoints of two opposite sides. The other player plays with twenty goats, divided into four stacks of five, placed in the center of each quadrant. The goats move first. Goats may move one at a time to any adjacent vacant spot. More than one goat can be placed on the goats' starting spots, but not elsewhere. The tiger moves in the same manner, but also may capture a piece by hopping over it. Multiple captures can be made on the same turn with subsequent hops, but only the top goat in a stack is captured when a tiger leaps over it. The goal of the goats is to surround the tigers so they cannot move; when one tiger is blocked the other must be blocked on the next turn. The goal of the tigers is to capture all the goats. 
(game "Bagh Batti" (players 2) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (piece "Goat" P1 (move Step (to if:(is Empty (to))))) (piece "Tiger" P2 (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))))}) (rules (start {(place Stack "Goat1" (sites {"B2" "D2" "B4" "D4"}) counts:{5 5 5 5}) (place "Tiger2" (sites {"C1" "C5"}))}) (play (if (is Prev Mover) (or (move Pass) (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))) (forEach Piece top:True))) (end {(if (no Moves P2) (result P1 Win)) (if (no Pieces P1) (result P2 Win))}))) 
5x5 board, played on intersections, with lines forming a diamond shape connecting the midpoints of the edges of the board. One player plays with two tiger pieces, placed on the midpoints of two opposite sides. The other player plays with twenty goats, divided into four stacks of five, placed on the next adjacent spot to the tigers on the diamond. The goats move first. Goats may move one at a time to any adjacent vacant spot. The tiger may move in the same manner, but also may capture a piece by hopping over it. Multiple captures can be made on the same turn with subsequent hops, but only the top goat in a stack is captured when a tiger leaps over it. The goal of the goats is to surround the tigers so they cannot move; the goal of the tigers is to capture all the goats. Initiallly, the tigers are placed at opposite sites of the top and the bottom of the board. Played on a board with the diagonals forming a diamond. The tiger can jump a sequence of pieces to capture.
(game "Bagh Guti" (players 2) (equipment {(board (makeFaces (remove (square 5 diagonals:Alternating) edges:{{{0 0} {1 1}} {{1 1} {2 2}} {{2 2} {3 3}} {{3 3} {4 4}} {{4 0} {3 1}} {{3 1} {2 2}} {{2 2} {1 3}} {{1 3} {0 4}}})) use:Vertex) (piece "Goat" P1 (move Step (to if:(is Empty (to))))) (piece "Tiger" P2 (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))))}) (rules (start {(place Stack "Goat1" (sites {"B2" "D2" "B4" "D4"}) counts:{5 5 5 5}) (place "Tiger2" (sites {"C1" "C5"}))}) (play (if (is Prev Mover) (or (move Pass) (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))) (forEach Piece top:True))) (end {(if (no Moves P2) (result P1 Win)) (if (no Pieces P1) (result P2 Win))}))) 
5x5 board, played on intersections of the lines, with diagonals for each quadrant of the board. One player plays with a tiger piece, placed anywhere on the board. The other player plays with 21 goats, placed on the central point of the board. The goats move first. Goats may move one at a time to any adjacent vacant spot along the lines of the board. The tiger moves in the same manner, but also may capture a piece by hopping over it to an empty space immediate on the opposite side of a goat. The tiger may hop the stack of goats, but may only capture one. The goal of the goats is to surround the tiger so it cannot move. The goal of the tiger is to capture all the goats. 
(game "Bagha Guti" (players 2) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (piece "Goat" P2 (move Step (to if:(is Empty (to))))) (piece "Tiger" P1 (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))))) (hand P1)}) (rules (start {(place Stack "Goat2" 12 count:21) (place "Tiger1" (handSite P1))}) phases:{(phase "Opening" P1 (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase "Movement")) (phase "Movement" (play (forEach Piece top:True)))} (end {(if (no Moves P1) (result P2 Win)) (if (no Pieces P2) (result P1 Win))}))) 
Played on 5x5 grid including diagonals and pieces are played on the intersections of the lines. One player has four tigers, placed on the corners, and the other has up to 20 goats, placed on the board on a free space. Tigers and goats can move to an adjacent intersection along the lines on the board. Tigers may capture goats by hopping over them. The game ends when tigers have captured all of the goats or the goats block the tigers from being able to move. The objective of the player 2 is to capture all the tigers.
(game "Baghchal" (players 2) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (hand P1) (piece "Goat" P1 (move Step (to if:(is Empty (to))))) (piece "Tiger" P2 (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to))))))}) (rules (start {(place "Tiger2" (sites Corners)) (place "Goat1" (handSite P1) count:20)}) phases:{(phase "Placement" P1 (play (move (from (handSite P1)) (to (sites Empty)))) (nextPhase (all Sites (sites Hand P1) if:(= 0 (count Cell at:(site)))))) (phase "Movement" (play (forEach Piece)))} (end {(if (no Moves Next) (result Next Loss)) (if (<= (count Pieces P1) 0) (result P1 Loss))}))) 
An isosceles triangle, with a line intersecting the two equal sides, another line drawn from the apex to the midpoint of this line. A line extending below the base, and another line perpendicular to this one. One player plays as the tiger, and another player as three goats. The tiger begins at the apex of the triangle, the goats on the three points on the bottom line (the two ends and the place where it intersects with the other line. Players alternate turns moving a piece to an empty adjacent spot. The tiger may capture a goat by hopping over it to an empty adjacent spot along the lines of the board. The tiger wins by capturing all of the goats; the goats win by blocking the tiger from being able to move.
(game "Bam Blang Beh Khla" (players 2) (equipment {(board (add (remove (merge {(shift 0.4 -1 (scale 0.6 (rectangle 1 3))) (shift 0.2 0 (scale 0.8 2 (wedge 2))) (shift 0 -0.5 (scale 1 2.5 (wedge 2)))}) edges:{{3 8} {3 7} {3 9}}) edges:{{6 9} {4 7} {1 8}}) use:Vertex) (piece "Tiger" P1 (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to)))))) (piece "Goat" P2 (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Tiger1" (sites Top)) (place "Goat2" (sites Bottom))}) (play (forEach Piece)) (end {(if (no Moves P1) (result P2 Win)) (if (no Pieces P2) (result P1 Win))}))) 
5x5 intersecting lines, with diagonals in each 3x3 quadrant of the board. On one end, a square with diagonals, with one corner as the midpoint of one of the sides of the main board. On the opposite side, a triangle, with a line bisecting the base and another bisecting this line and intersecting with the other two sides of the triangle. The triangle's apex is the midpoint of the opposite side as the square. One player plays with two larger pieces, the Bulls, which start at the points where the triangle and square intersect with the main board. The other player plays with 24 smaller pieces. Eight of these begin on the points surrounding the central point of the board, the rest are in the hand. Players alternate turns. The Bulls move to an empty adjacent spot, the other player places one of the pieces from their hand onto the board. When all of these pieces are on the board, the player may move one of the pieces to an empty adjacent spot. The Bull may captured one of the smaller pieces my hopping over it onto an empty space. The goal of the Bulls is to capture all of the smaller pieces. The goal of the player with the smaller pieces is to corner the bulls so they cannot move. Doing so in the triangle and the square is a better win than cornering the Bulls on the main board.
(game "Bouge Shodra" (players 2) (equipment {(board (merge (merge (shift 0 2 (square 5 diagonals:Alternating)) (wedge 3)) (rotate 45 (shift 1.5 6.2 (square 2 diagonals:Solid)))) use:Vertex) (hand P1) (piece "Marker" P1 (move Step (to if:(is Empty (to))))) (piece "Bull" P2 (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))))}) (rules (start {(place "Bull2" (sites {"C3" "C7"})) (place "Marker1" (difference (expand (sites Centre)) (centrePoint))) (place "Marker1" (handSite P1) count:16)}) phases:{(phase "Placement" P1 (play (move (from (handSite P1)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand P1) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end {(if (no Moves P2) (result P1 Win)) (if (no Pieces P1) (result P2 Win))}))) 
One player is the rabbit, and the other player plays with twelve other pieces. They may also play with either ten or eleven pieces instead of twelve. The pieces move along the lines. The goal is to corner the rabbit so that it cannot move. The rabbit may hop over the other pieces to capture them. The rabbit wins by reducing the opponent to nine pieces. Played on a Alquerque Board. The hare can jump to capture.
(game "Cercar La Liebre" (players 2) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (piece "Counter" P1 (move Step (to if:(is Empty (to))))) (piece "Hare" P2 (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (if (is Prev Mover) (move Pass) (move Step (to if:(is Empty (to)))))))}) (rules (start {(place "Counter1" (union {(expand (sites Bottom)) (sites {"A3" "E3"})})) (place "Hare2" (centrePoint))}) (play (forEach Piece)) (end {(if (no Moves Next) (result Next Loss)) (if (<= (count Pieces P1) 9) (result P1 Loss))}))) 
One player plays with one piece "presumably the coyote," the other with the other twelve pieces, placed on intersections of the lines. Pieces move to an adjacent intersection connected to the present position by a line. The "coyote" may take the opponent's pieces by hopping over them. Multiple captures are allowed if possible, Captures are obligatory. The goal of the coyote is to capture all of the opponent's pieces; the other player's goal is to block the coyote so it cannot move. The coyote can jump to capture.
(game "Coyote" (players 2) (equipment {(board (rectangle 5 5 diagonals:Radiating) use:Vertex) (piece "Sheep" P1 (move Step (to if:(is Empty (to))))) (piece "Coyote" P2 (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (if (is Prev Mover) (move Pass) (move Step (to if:(is Empty (to)))))))}) (rules (start {(place "Sheep1" (union (expand (sites Bottom)) (sites {"A3" "E3"}))) (place "Coyote2" (centrePoint))}) (play (forEach Piece)) (end {(if (no Moves Next) (result Next Loss)) (if (<= (count Pieces P1) 9) (result P1 Loss))}))) 
Played with three "leopards" and fifteen "dogs." The pieces are placed on the intersections of the lines, and move along the lines to the next intersection. The game starts with the leopards on the board, but in the beginning the player controlling the dogs places one dog on an intersection until they are all on the board. After this, the dogs move in the same manner as the leopards. The leopard can hop over a dog as in draughts, capturing it. The leopard wins the game if it captures more than half of the dogs, the dogs win if they block the leopard from being able to move. Played on the normal board.
(game "Demala Diviyan Keliya" (players 2) (equipment {(board (add (remove (merge (shift 0 2 (scale 8 2 (rectangle 3 2))) (scale 1 2 (wedge 5 4))) edges:{{0 1} {2 3} {4 5}}) edges:{{0 15} {18 1} {2 11} {14 3} {4 7} {10 5}}) use:Vertex) (hand P2) (piece "Tiger" P1 (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to)))))) (piece "Dog" P2 (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Tiger1" {"H5" "G4" "I4"}) (place "Dog2" (handSite P2) count:15)}) phases:{(phase "Placement" P2 (play (move (from (handSite P2)) (to (sites Empty)))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)) (end {(if (no Moves Next) (result Next Loss)) (if (<= (count Pieces P2) 7) (result P2 Loss))}))})) 
One player has two leopards, the other has 24 cows. Play begins by each player taking turns to place their pieces, and then can move to one adjacent intersection. Leopards capture cows by hopping over them. Leopards win by capturing all the cows, cows win by blocking the leopards from moving. The leopard can jump to capture.
(game "Diviyan Keliya" (players 2) (equipment {(board (merge {(shift 2 2 (square 5 diagonals:Alternating)) (shift 2 0 (wedge 3)) (shift 5 3 (rotate 90 (wedge 3))) (shift 2 6 (rotate 180 (wedge 3))) (shift -1 3 (rotate 270 (wedge 3)))}) use:Vertex) (hand Each) (piece "Leopard" P1) (piece "Cow" P2 (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Leopard1" "Hand1" count:2) (place "Cow2" "Hand2" count:24)}) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) {(nextPhase P1 (all Sites (sites Hand P1) if:(= 0 (count Cell at:(site)))) "MovementP1") (nextPhase P2 (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "MovementP2")}) (phase "MovementP1" P1 (play (forEach Piece "Leopard" (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to)))))))) (phase "MovementP2" P2 (play (forEach Piece)))} (end (if (no Moves Next) (result Next Loss))))) 
5x5 intersecting lines with diagonals drawn in the quadrants. One player plays as one hunter, placed in the central spot. The other player plays as twelve birds, which are placed in the two rows closest to the player and the two spots on the right hand side in the central row. The hunter may move in any direction along the lines of the board. The hunter may capture birds by hopping over them to an empty spot on the opposite side along the lines of the board. The birds may move forward orthogonally or diagonally. The birds win by blocking the hunter from being able to move; the hunter wins by capturing all of the birds or when it is no longer possible for the birds to capture the hunter.
(game "El Cazador" (players {(player S) (player N)}) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (piece "Human" P1 (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to)))))) (piece "Hen" P2 (move Step (directions {Rightward Leftward Forwards}) (to if:(is Empty (to)))))}) (rules (start {(place "Human1" (centrePoint)) (place "Hen2" (union {(expand (sites Bottom)) (sites {"D3" "E3"})}))}) (play (forEach Piece)) (end {(if (no Moves P1) (result P2 Win)) (if (no Pieces P2) (result P1 Win))}))) 
5x5 intersecting lines, with diagonals drawn in the quadrants. One player plays as one dog, which is a large stone, and the other as twelve goats, which are smaller stones. The goats begin on the two rows closest to the player to which they belong, and on the right hand spots in the central row. The dog begins in the central space. The dog moves first. The dog may move in any direction along the lines of the board. It may capture a goat by hopping over it to an empty adjacent spot on the opposite side of the goat, according to the lines of the board. Multiple captures are allowed. The goats move one space forward orthogonally or diagonally, or sideways, along the lines of the board. When all of the goats are unable to move forward anymore and all are are in spaces being equivalent to the starting position on the opposite side of the board, they may then commence moving in the opposite direction toward their original starting position, but not backwards with respect to this direction. The dog wins by capturing all the goats; the goats win by blocking the dog from being able to move.
(game "El Perro" (players 2) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (piece "Goat" P2 (move Step (if (= (value Player Mover) 1) (directions {S SE SW E W}) (directions {N NE NW E W})) (to if:(is Empty (to))))) (piece "Dog" P1 (or (move Hop (from (from)) Adjacent (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))) (move Step (to if:(is Empty (to))))))}) (rules (start {(place "Goat2" (union (intersection (union (sites Left) (sites Right)) (sites Row 2)) (expand (sites Bottom)))) (place "Dog1" (sites Centre))}) (play (if (is Prev Mover) (or (move Hop (from (last To)) Adjacent (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))) (move Pass)) (forEach Piece) (then (if (not (can Move (forEach Piece (move Step (if (= (value Player P2) 1) (directions {S SE SW}) (directions {N NE NW})) (to if:(is Empty (to)))) P2))) (set Value P2 (if (= (value Player P2) 1) 0 1)))))) (end {(if (no Moves P1) (result P2 Win)) (if (no Pieces P2) (result P1 Win))}))) 
Five squares which are each divided with lines connecting the midpoints of their sides and diagonals. The five squares are arranged in a cross-shaped board. One player plays as two foxes the other as twenty hens. The hens begin on the twenty spaces on one half of the board, the foxes on the bottom two corners of the square on the opposite arm of the cross. The foxes may move in any direction, and hop over a hen to an empty space immediately adjacent on the opposite side of the hen along the lines of the board to capture. The hens may not move backward. The foxes win by capturing all the hens, the hens win by occupying all of the spaces in the square of the arm of the cross opposite from where they began.
(game "El Zorro" (players {(player N) (player S)}) (equipment {(board (merge (shift 0 (/ (- 7 3) 2) (rectangle 3 7 diagonals:Alternating)) (shift (/ (- 7 3) 2) 0 (rectangle 7 3 diagonals:Alternating))) use:Vertex) (piece "Fox" P1 (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to)))))) (piece "Hen" P2 (move Step (directions {Rightward Leftward Forwards}) (to if:(is Empty (to)))))}) (rules (start {(place "Hen2" (union (sites Top) (expand (sites Row 4)))) (place "Fox1" (intersection (union (sites Column 4) (sites Column 2)) (sites Bottom)))}) (play (forEach Piece)) (end {(if (all Sites (expand (sites Bottom) steps:2) if:(= (who at:(site)) P2)) (result P2 Win)) (if (no Pieces P2) (result P1 Win))}))) 
The game is played on a cruciform board adapted from an Alquerque board. One player plays as the fox, the other as the geese. The geese begin in a set starting position; the person playing as the fox may choose any available spot to place the fox as their first move. Players move as in Alquerque, but only the fox can hop to capture. The goal of the geese is to block the fox from being able to move; the fox's goal is to capture all of the geese. The game starts with 13 geese.
(game "Fox and Geese" (players 2) (equipment {(board (merge (shift 0 (/ (- 7 3) 2) (rectangle 3 7 diagonals:Alternating)) (shift (/ (- 7 3) 2) 0 (rectangle 7 3 diagonals:Alternating))) use:Vertex) (hand P1) (piece "Fox" P1 (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to)))))) (piece "Goose" P2 (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Goose2" (union (expand (sites Bottom)) (sites Row 2))) (place "Fox1" (handSite P1))}) phases:{(phase "Placement" P1 (play (move (from (handSite P1)) (to (sites Empty)))) (nextPhase (all Sites (sites Hand P1) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end {(if (no Moves Next) (result Next Loss)) (if (no Pieces P2) (result P2 Win))}))) 
7x7 board, with an X in each corner space, the middle space along each side, and the central space. Black plays with thirteen pieces, white plays with ten. Black places the first piece on the central square, then players alternate turns placing a piece on their own half of the board. When all of the pieces are placed, players alternate turns moving pieces one space orthogonally. A piece is captured when it is surrounded on two opposite sides by opponent's pieces, or if it is in the corner and there are two opponent's pieces blocking it from moving. Capturing cannot happen in the placement phase. Black wins if it can block white from being able to move. White wins if it is impossible for black to block them.
(game "Gala (Buginese)" (players 2) (equipment {(board (square 7)) (piece "Marker" Each (move Step Orthogonal (to if:(is Empty (to))) (then (and (custodial (from (last To)) Orthogonal (between (max 1) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Friend (who at:(to))))) (surround (from (last To)) Orthogonal (between if:(and (is Enemy (who at:(between))) (is In (between) (sites Corners))) (apply (remove (between)))) (to if:(is Friend (who at:(to))))))))) (hand Each) (regions "HalfBoard" P1 (expand (sites Bottom) steps:3)) (regions "HalfBoard" P2 (expand (sites Top) steps:3))}) (rules (start {(place "Marker1" (handSite P1) count:13) (place "Marker2" (handSite P2) count:10)}) phases:{(phase "CentrePlacing" P1 (play (move (from (handSite P1)) (to (centrePoint)))) (nextPhase "Placement")) (phase "Placement" P2 (play (if (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site))))) (move (from (handSite Mover)) (to (intersection (sites Empty) (sites Mover)))) (move Pass))) (nextPhase (and (all Sites (sites Hand P1) if:(= 0 (count Cell at:(site)))) (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site))))) "Movement")) (phase "Movement" (play (forEach Piece)) (end {(if (no Moves P2) (result P1 Win)) (if (< (count Pieces P1) 2) (result P2 Win))}))})) 
5x5 board. Markings in the central square, each corner square, and the central square of each side. Black plays with thirteen pieces, white plays with ten. Black places the first piece on the central square, then players alternate turns placing a piece on their own half of the board. When all of the pieces are placed, players alternate turns moving pieces on space orthogonally. A piece is captured when it is surrounded on two opposite sides by opponent's pieces. Black wins if it can block white from being able to move. White wins if it is impossible for black to block them.
(game "Gala" (players 2) (equipment {(board (square 5)) (hand Each) (regions P1 (expand (sites Bottom) steps:2)) (regions P2 (expand (sites Top) steps:2)) (regions "MarkedCells" (union {(sites Centre) (sites Corners) (intersection (sites Outer) (sites Row (row of:(centrePoint)))) (intersection (sites Outer) (sites Column (column of:(centrePoint))))})) (piece "Marker" Each (move Step Orthogonal (to if:(is Empty (to)))))}) (rules (start {(place "Marker1" (handSite P1) count:10) (place "Marker2" (handSite P2) count:12) (place "Marker2" (centrePoint))}) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (intersection (sites Empty) (sites Mover))))) (nextPhase (and (all Sites (sites Hand P1) if:(= 0 (count Cell at:(site)))) (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site))))) "Movement")) (phase "Movement" (play (forEach Piece (then (custodial (from (last To)) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Friend (who at:(to)))))))) (end {(if (no Moves P1) (result P2 Win)) (if (< (count Pieces P2) 2) (result P1 Win))}))})) 
28 squares arranged in a cross-shaped board. Diagonals are drawn in each 2x2 square. Pieces are played on the lines of the board. One player plays as a single fox, placed on the center of the third line from the top of one arm of the cross. The other player plays as eighteen geese, placed on the points on the opposite arm of the cross and the first horizontal line of the horizontal arms of the cross. Players alternate turns moving a piece to an empty adjacent spot along the lines of the board. The geese may not move backward. The fox may capture a goose by hopping over it to an empty spot immediately on the opposite side of the goose along the lines of the board. The geese win by blocking the fox from being able to move. The fox wins by capturing all the geese. 
(game "Gasetavl (Gedved)" (players 2) (equipment {(board (merge (shift 0 (/ (- 9 3) 2) (rectangle 3 9 diagonals:Alternating)) (shift (/ (- 9 3) 2) 0 (rectangle 9 3 diagonals:Alternating))) use:Vertex) (piece "Fox" P1 (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to)))))) (piece "Geese" P2 N (move Step (directions {Rightward Forwards Leftward}) (to if:(is Empty (to)))))}) (rules (start {(place "Fox1" coord:"E7") (place "Geese2" (sites {"D1" "E1" "F1" "D2" "E2" "F2" "D3" "E3" "F3" "A4" "B4" "C4" "D4" "E4" "F4" "G4" "H4" "I4"}))}) (play (forEach Piece)) (end {(if (no Moves P1) (result P2 Win)) (if (no Pieces P2) (result P1 Win))}))) 
Twenty squares arranged in a cross shape, with diagonals in each square. The pieces are played on the intersections of the lines. Two foxes are placed on the outer corners of one of the arms of the cross, and twenty geese are placed on the points in the opposite arm, as well as the first two long lines in the perpendicular arms. Players alternate turns moving a piece to an empty spot along the lines on the board. The geese cannot move backward. The foxes may hop over a goose to an empty adjacent spot immediately on the opposite side of it along the lines on the board. The geese win by blocking the foxes from being able to move. The foxes win by capturing all the geese.
(game "Gasetavl" (players 2) (equipment {(board (merge (shift 0 (/ (- 7 3) 2) (rectangle 3 7 diagonals:Solid)) (shift (/ (- 7 3) 2) 0 (rectangle 7 3 diagonals:Solid))) use:Vertex) (piece "Fox" P1 (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to)))))) (piece "Geese" P2 N (move Step (directions {Rightward Forwards Leftward}) (to if:(is Empty (to)))))}) (rules (start {(place "Fox1" (sites {"G9" "I7"})) (place "Geese2" (sites {"A3" "B2" "C1" "B4" "C3" "D2" "A7" "B6" "C5" "D4" "E3" "F2" "G1" "B8" "C7" "D6" "E5" "F4" "G3" "H2"}))}) (play (forEach Piece)) (end {(if (no Moves P1) (result P2 Win)) (if (no Pieces P2) (result P1 Win))}))) 
Two concentric circles, with four radii from the outer circle to in the center, dividing the circles into four equal parts. There are four arcs, each of which bisects a radius between where each radius intersects the circumference of each circle, the arc also intersecting with the outer circle's circumference. One player plays as a bear, which begins on the central point, the other as three hunters, which begin on any three points on the inner circle. The bear plays first. Players alternate turns moving a piece to an empty adjacent spot along the lines. When the bear is unable to move, the game ends and the players play again, switching sides. The player who lasts longest while playing as the bear wins. The game has two rounds.
(game "Gioco dell'Orso" (players 2) (equipment {(board (add (concentric {1 4 12}) edges:{{6 8} {9 11} {12 14} {5 15}}) use:Vertex) (piece "Human" Each (move Step (to if:(is Empty (to))))) (piece "Bear" Each (move Step (to if:(is Empty (to))))) (hand Each)}) (rules (start {(place "Human1" (handSite P1) count:3) (place "Bear2" (sites Centre))}) phases:{(phase "PlacementP1" (play (move (from (handSite P1)) (to (intersection (sites Empty) (sites {1 2 3 4}))) (then (if (not (all Sites (sites Hand P1) if:(= 0 (count Cell at:(site))))) (moveAgain))))) (nextPhase (all Sites (sites Hand P1) if:(= 0 (count Cell at:(site)))) "HuntingP2")) (phase "HuntingP2" (play (forEach Piece (then (if (not (can Move (move Step (from (where "Bear" P2)) (to if:(is Empty (to)))))) (and {(addScore P2 (- (count Moves) 3)) (remove (sites Occupied by:All container:"Board")) (add (piece "Bear1") (to (sites Centre))) (add (piece "Human2") (to (handSite P2)) count:3)}))))) (nextPhase (= 1 (count Sites in:(sites Occupied by:All container:"Board"))) "PlacementP2")) (phase "PlacementP2" (play (move (from (handSite P2)) (to (intersection (sites Empty) (sites {1 2 3 4}))) (then (if (not (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site))))) (moveAgain))))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "HuntingP1")) (phase "HuntingP1" (play (forEach Piece (then (if (not (can Move (move Step (from (where "Bear" P1)) (to if:(is Empty (to)))))) (addScore P1 (- (count Moves) (+ (score P2) 6))))))) (end (if (!= 0 (score P1)) (byScore))))})) 
Players take turns moving their pieces. Black starts. Players may: Move one or two empty spaces in any direction, or hop over one ring marker in any direction into an empty space. multiple jumps. White may capture an opponent's piece by moving onto its space from an adjacent one. Both the white and black pieces are removed from play. After moving or capturing, the moving player places a hole-in-the-ice ring marker on the moving tokens starting space and any empty space passed over. The goal for the white player is to capture both black tokens. The goal for the black player is to isolate at least one of their pieces so that it cannot be captured. If both players cannot play, black wins.
(game "Go with the Floe" (players 2) (equipment {(board (keep (square 8) (poly {{-3 4} {4 -3} {11 4} {4 11}}))) (piece "Seal" P1 N (or (move Slide (between (max 2) trail:(id "Disc0"))) (move Hop (between if:(= (what at:(between)) (id "Disc0" Neutral))) (to if:(is Empty (to))) (then (add (piece "Disc0") (to (last From))))))) (piece "Bear" P2 (or {(move Slide (between (max 2) trail:(id "Disc0"))) (move Hop (between if:(= (what at:(between)) (id "Disc0" Neutral))) (to if:(is Empty (to))) (then (add (piece "Disc0") (to (last From))))) (move Step (to if:(= (what at:(to)) (id "Seal1" P1)) (apply (remove (to)))) (then (and (remove (last To)) (add (piece "Disc0") (to (last From))))))})) (piece "Disc" Neutral)}) (rules (start {(place "Bear2" {"G2" "G7"}) (place "Seal1" {"B2" "B7"})}) (play (forEach Piece)) (end {(if (= (count Sites in:(sites Occupied by:All)) 0) (result P2 Win)) (if (and (no Moves P1) (not (can Move (forEach Piece "Bear" (step (to if:(= (what at:(to)) (id "Seal1" P1)))))))) (result P1 Win)) (if (all Passed) (result P1 Win))}))) 
Square board, divided into eight equal triangles, with the central horizonal line extended past the square on either side and lines connecting the end point to the two nearby cornes of the square One player plays as the hare, the other player as three hounds. Players take turns placing one of their pieces on the board. When a player has placed all their pieces, they move to an adjacent empty spot. When the hounds block the hare from being able to move, the hounds win.  The game has an ending condition only for P1.
(game "Haretavl" (players 2) (equipment {(board (merge {(rectangle 3 3 diagonals:Alternating) (shift 1.5 0.5 (rotate -90 (wedge 2))) (shift -1.5 0.5 (rotate 90 (wedge 2)))}) use:Vertex) (hand Each) (piece "Dog" P1 (move Step (to if:(is Empty (to))))) (piece "Hare" P2 (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Dog1" (handSite P1) count:3) (place "Hare2" (handSite P2))}) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end {(if (no Moves P2) (result P1 Win))}))) 
The game is played on a triangle board divided in half on its height and then in thirds with lines crossing the height perpendicularly. One player plays as the tiger, and the other plays as seven leopards. The tiger plays their piece on a point where lines intersect first, and then on subsequent turns the leopards are placed one-by-one. Moves occur along the lines to an adjacent intersection. The tiger captures may capture a leopard by hopping over it. The tiger's goal is to capture four of the leopards; the leopards' goal is to block the tiger so it cannot move. Played on the board described in Ludovici and Parker.
(game "Hat Diviyan Keliya" (players 2) (equipment {(board (scale 1 2 (wedge 4)) use:Vertex) (hand Each) (piece "Tiger" P1 (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to)))))) (piece "Leopard" P2 (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Tiger1" (handSite P1) count:1) (place "Leopard2" (handSite P2) count:7)}) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)) (end {(if (no Moves Next) (result Next Loss)) (if (<= (count Pieces P2) 3) (result P2 Loss))}))})) 
A triangle, with a line drawn from the apex to the base, and two lines drawn through the height connecting the opposite two sides. One player plays as one tiger, the other as five lambs. The tiger begins on the apex of the triangle. The tiger moves to an empty adjacent spot along the lines of the board. The player who plays as the lambs plays first, placing a lamb on an empty spot on the board, and then the tiger player moves. When all of the lambs are placed, the lambs move in the same manner as the tiger. The tiger may capture a lamb by hopping over it to an empty space on the opposite adjacent side of the lamb along the lines on the board. The lambs win when they block the tiger from being able to move, the tiger wins by capturing enough lambs so that it cannot be blocked.
(game "Huli-Mane Ata" (players 2) (equipment {(board (scale 1 2 (wedge 4 3)) use:Vertex) (hand P1) (piece "Lamb" P1 (move Step (to if:(is Empty (to))))) (piece "Tiger" P2 (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))))}) (rules (start {(place "Lamb1" (handSite P1) count:5) (place "Tiger2" (sites Top))}) phases:{(phase "Opening" P1 (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end {(if (no Moves P2) (result P1 Win)) (if (< (count Pieces P1) 4) (result P2 Win))}))) 
3x5 intersecting lines, with diagonals in the four quadrants created. On either short end, an arc connects the two corner points, and the center line is extended to the arc. One player plays as four hounds, which begin on the four points to the left side of the board. The other player plays as one hare, which begins on the point where the center line and the second line cross. Players alternate turns moving a piece to an empty adjacent spot along the lines. The hounds may only move forward. The hounds win when they block the hare from being able to move. The game has an ending condition only for P2.
(game "Hund efter Hare (Thy)" (players 2) (equipment {(board (remove (add (merge {(rectangle 3 5) (shift 1 0 (scale 0.5 (rectangle 5 1))) (shift 3 0 (scale 0.5 (rectangle 5 1))) (shift -1 1 (rectangle 1 7))}) edges:{{0 15} {15 7} {7 18} {18 14} {17 4} {7 17} {7 16} {16 10} {19 10} {0 19} {20 14} {20 4} {12 16} {16 5} {5 15} {15 2} {2 17} {17 9} {9 18} {18 12}}) edges:{{11 6} {6 1} {13 8} {8 3}}) use:Vertex) (piece "Hare" P1 (move Step (to if:(is Empty (to))))) (piece "Dog" P2 E (move Step Forwards (to if:(is Empty (to)))))}) (rules (start {(place "Hare1" coord:"C3") (place "Dog2" (sites {"B3" "B1" "A3" "B5"}))}) (play (forEach Piece)) (end {(if (no Moves P1) (result P2 Win))}))) 
Three diamonds in a row, the central one connecting to the others one opposite corners. A horizontal line connects the top corners of the diamonds, another horizontal line connects the bottom corners of the diamonds, and a longer horizontal line connects all the middle corners. The outer two diamonds have vertical lines connecting their top and bottom corners. One player plays as three hounds, which begin on the outer corner and top and bottom corner of one of the end diamonds. The other player plays as one hare, which begins on the central point of the same diamond. Players alternate turns moving a piece to an empty adjacent spot along the lines of the board. The Hare moves first. The hounds win by blocking the hare from being able to move. The game has an ending condition only for P2.
(game "Hund efter Hare (Vendsyssel)" (players 2) (equipment {(board (add (merge {(add (remove (rectangle 1 7) vertices:{3}) edges:{{2 3}}) (scale 2 (shift 0.5 -0.5 (rectangle 1 3))) (scale 2 (shift 0.5 0.5 (rectangle 1 3)))}) edges:{{0 9} {0 6} {11 5} {5 8} {1 6} {1 9} {4 11} {4 8} {9 2} {2 7} {6 2} {2 10} {10 3} {3 8} {7 3} {3 11}}) use:Vertex) (piece "Hare" P1 (move Step (to if:(is Empty (to))))) (piece "Dog" P2 (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Hare1" coord:"B2") (place "Dog2" (sites {"A2" "B1" "B3"}))}) (play (forEach Piece)) (end {(if (no Moves P1) (result P2 Win))}))) 
Square board, divided into eight equal triangles, and a circle around the square, touching it at the corners, One player plays as the hare, the other player as three hounds. Players take turns placing one of their pieces on the board. When a player has placed all their pieces, they move to an adjacent empty spot. When the hounds block the hare from being able to move, the hounds win.  The First player moves only when all the pieces are placed.
(game "Hyvn aetter Hare" (players 2) (equipment {(board (splitCrossings (merge (shift 0.5 0.5 (scale 0.707 (concentric {1 8}))) (square 2))) use:Vertex) (piece "Hare" P1 (move Step (to if:(is Empty (to))))) (piece "Dog" P2 (move Step (to if:(is Empty (to))))) (hand Each)}) (rules (start {(place "Hare1" (handSite P1) count:1) (place "Dog2" (handSite P2) count:3)}) phases:{(phase "Placement" (play (if (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site))))) (move (from (handSite Mover)) (to (sites Empty))))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)) (end (if (no Moves Next) (result Next Loss))))})) 
3x3 intersecting lines, with triangles extending on opposite ends of the large square and the central line extending to the apices. One player plays as the notched stick, called the hare, and the other as three sharp sticks, known as the hounds. Players alternate turns placing a piece on the board. When a player has placed all of their pieces on the board, they move one of their pieces to an empty adjacent spot along the lines. When the hounds block the hare from being able to move, the hounds win. The game has an ending condition only for P1.
(game "Janes Soppi" (players 2) (equipment {(board (merge {(rectangle 3 3) (shift 1.5 0.5 (rotate -90 (wedge 2))) (shift -1.5 0.5 (rotate 90 (wedge 2)))}) use:Vertex) (hand Each) (piece "Hound" P1 (move Step (to if:(is Empty (to))))) (piece "Hare" P2 (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Hound1" (handSite P1) count:3) (place "Hare2" (handSite P2))}) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end {(if (no Moves P2) (result P1 Win))}))) 
The board consists of three instersecting lines, with diagonals drawn in the square formed. On opposite ends of the square, the central line is extended beyond the square and lines drawn from the adjacent corners to the end of this line, forming two triangles at opposite ends. One player takes the part of three white towers, the other the part of a single black army piece. First the army moves their piece, then the towers move one of their pieces, play alternating thereafter until the game is ended. A tower piece may move one step along a marked line in any forward or sideways direction. Tower pieces cannot move backwards, diagonally or otherwise, towards the end of the board from which they started. The army may move one step in any direction along a marked line. The army wins by passing the towers and reaching the end of the board from which they started. The towers win by trapping the army so that it cannot move in its turn. The towers can move in sideway and forwards (including diagonal and orthogonal forward). The army can move in all the directions. The army can not move. The game is played according to the rules of Lucas with the pieces already on the board. 
(game "Jeu Militaire" (players 2) (equipment {(board (rotate 90 (merge {(rectangle 3 3 diagonals:Alternating) (shift 1.5 0.5 (rotate -90 (wedge 2))) (shift -1.5 0.5 (rotate 90 (wedge 2)))})) use:Vertex) (piece "Pawn" P1 (move Step (to if:(is Empty (to))))) (piece "Pawn" P2 N (move Step (directions {Forwards Rightward Leftward}) (to if:(is Empty (to))))) (regions "Home" P2 (sites {"B1" "C2" "A2"})) (regions "Home" P1 (sites {"B2"}))}) (rules (start {(place "Pawn1" (sites P1)) (place "Pawn2" (sites P2))}) (play (forEach Piece)) (end {(if (no Moves P1) (result P2 Win)) (if (is In (where "Pawn" P1) (sites P2)) (result P1 Win))}))) 
8x8 Draughts board. One player plays with two foxes, the other with twelve or more hens, played on the white squares. The hens begin on the rows closest to the player; the foxes begin, one each on the left and right end of the row farthest from the hens. Hens move one space forward diagonally, the foxes move one space diagonally forward or backward. Foxes must alternate turns, i.e., when one fox moves, the other fox must move on the next turn. The foxes may capture a hen by hopping over it to an empty space diagonally on the other side of it. The hens win by blocking the foxes from being able to move; the foxes win by capturing all the hens. 
(game "Jeu de Renard (Two Foxes)" (players 2) (equipment {(board (square 8)) (piece "Fox" P1 (if (= (state at:(from)) 1) (or (move Step Diagonal (to if:(is Empty (to)))) (move Hop Diagonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (then (and (forEach Site (sites Occupied by:Mover) (if (= (state at:(site)) 0) (set State at:(site) 1))) (set State at:(last To) 0))))) (piece "Hen" P2 N (move Step (directions {FR FL}) (to if:(is Empty (to)))))}) (rules (start {(place "Fox1" (intersection (sites Top) (union (sites Left) (difference (expand (sites Right)) (sites Right)))) state:1) (place "Hen2" (difference (expand (sites Bottom) steps:2) (sites Phase 0)))}) phases:{(phase "Opening" P1 (play (forEach Piece (or (move Step Diagonal (to if:(is Empty (to)))) (move Hop Diagonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (then (set State at:(last To) 0))))) (nextPhase "Movement")) (phase "Movement" (play (forEach Piece)))} (end {(if (no Moves P1) (result P2 Win)) (if (no Pieces P2) (result P1 Win))}))) 
8x8 Draughts board. One player plays with a single fox, the other with twelve hens, played on the white squares. The hens begin on the first three rows; the fox may begin on whatever spot the player chooses. Hens move one space forward diagonally, the fox moves one space diagonally forward or backward. The fox may capture a hen by hopping over it to an empty space diagonally on the other side of it. The hens win by blocking the fox from being able to move; the fox wins by capturing all the hens.
(game "Jeu de Renard" (players 2) (equipment {(board (square 8)) (piece "Fox" P1 (or (move Step Diagonal (to if:(is Empty (to)))) (move Hop Diagonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))))) (piece "Hen" P2 N (move Step (directions {FR FL}) (to if:(is Empty (to))))) (hand P1)}) (rules (start {(place "Fox1" (handSite P1)) (place "Hen2" (difference (expand (sites Bottom) steps:2) (sites Phase 0)))}) phases:{(phase "Placement" P1 (play (move (from (handSite Mover)) (to (difference (sites Empty) (sites Phase 0))))) (nextPhase "Movement")) (phase "Movement" (play (forEach Piece)))} (end {(if (no Moves P1) (result P2 Win)) (if (no Pieces P2) (result P1 Win))}))) 
Played on cross-shaped board, made of five squares, each divided into four squares and with the diagonals of the larger squares drawn. One player plays as thirteen hens, which begin on the points on one of the arms of the cross and along the line immediately perpendicular to that arm. The other player plays as one fox, which can be placed on any empty point of the board. Players alternate turns moving to an empty adjacent spot along the lines of the board. The hens, however, can only move in a forward direction. The fox may hop over an adjacent hen to an empty spot immediately on the opposite side of the hen along the lines of the board. The fox wins by capturing all the hens, the hens win by blocking the fox from being able to move.
(game "Jeu du Renard et de la Poule" (players 2) (equipment {(board (merge (shift 0 (/ (- 7 3) 2) (rectangle 3 7 diagonals:Alternating)) (shift (/ (- 7 3) 2) 0 (rectangle 7 3 diagonals:Alternating))) use:Vertex) (hand P1) (piece "Fox" P1 (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Step (to if:(is Empty (to)))))) (piece "Hen" P2 N (move Step Forwards (to if:(is Empty (to)))))}) (rules (start {(place "Fox1" (handSite P1)) (place "Hen2" (union (expand (sites Bottom)) (sites Row 2)))}) phases:{(phase "Placement" P1 (play (move (from (handSite P1)) (to (sites Empty)))) (nextPhase (all Sites (sites Hand P1) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end {(if (no Moves Next) (result Next Loss)) (if (no Pieces P2) (result P2 Win))}))) 
5x5 intersecting lines, with the diagonals of every 2x2 square formed. On one side, a triangle, with the apex intesecting with the midpoint of that side. There is a line from the apex to the midpoint of the triangle's base, and another interior triangle, connecting the base of the larger triangle with the midpoints of the sides of the larger triangle. One player plays as the Taisho ("general"), the other as sixteen musashi ("soliders"). The Taisho begins in the central point, the musashi on each point of the perimeter of the square board. Players take turns moving from one point to an adjacent point along the lines on the board. The Taisho may capture a musashi by hopping over it. The Taisho wins if it captures all the musashi. The musashi win if they are able to immobilize the Taisho. 
(game "Juroku Musashi" (players 2) (equipment {(board (add (merge (scale 2 (square 5 diagonals:Alternating)) (shift 2 -2 (wedge 3))) vertices:{{3 -2} {5 -2}} edges:{{25 31} {25 29} {27 29} {27 32}}) use:Vertex) (piece "Marker" P1 (move Step (to if:(is Empty (to))))) (piece "Marker" P2 (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to))))))}) (rules (start {(place "Marker1" (difference (sites Outer) (expand (sites Bottom)))) (place "Marker2" (ahead (centrePoint) N))}) (play (forEach Piece)) (end {(if (no Moves P2) (result P1 Win)) (if (no Pieces P1) (result P2 Win))}))) 
Played on a five-pointed star shaped board. One player plays with one piece, the "tiger," and the other plays with seven pieces, the "kaooas." The player with the kaooas attempt to checkmate the tiger by moving to one of the points where the lines of the board intersect. The tiger captures kaooas by hopping over them. The tiger wins by capturing all the kaooas. The game starts with 7 discs for the second player.
(game "Kaooa" (players 2) (equipment {(board (splitCrossings (regular Star 5)) use:Vertex) (hand Each) (piece "Marker" P1 (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Step (to if:(is Empty (to)))))) (piece "Marker" P2 (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Marker1" (handSite P1) count:1) (place "Marker2" (handSite P2) count:7)}) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)) (end (if (no Moves Next) (result Next Loss))))})) 
One player has a single piece, the other has twelve, playing as jackrabbits. The player playing as the jackrabbits attempts to move all of their pieces to the opposite side of the board until they form the same configuration as the starting position on the opposite side. Pieces move orthogonally to accomplish this. The opponent's goal is to capture one of the jackrabbits by hopping over it.
(game "Ko-app-paw-na" (players 2) (equipment {(board (square 5) use:Vertex) (piece "Rabbit" P1 (move Step (to if:(is Empty (to))))) (piece "Counter" P2 (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to)))))) (regions P1 (union (expand (sites Top)) (sites {"A3" "E3"})))}) (rules (start {(place "Rabbit1" (union (expand (sites Bottom)) (sites {"A3" "E3"}))) (place "Counter2" (centrePoint))}) (play (forEach Piece)) (end {(if (= (sites P1) (sites Occupied by:P1)) (result P1 Win)) (if (= (count Pieces P1) 11) (result P2 Win))}))) 
12x12 checkered board. One player plays with six "cattle" or "dogs," the other plays as the "leopard." The cattle start on the white spaces along one side of the board, the leopard may be placed on any white square. Cattle move one space forward diagonally. The leopard may move one or two spaces diagonally in any one direction. If the leopard moves past the line of cattle, the leopard wins. If the cattle block the leopard from being able to move, the cattle win.
(game "Koti Keliya" (players 2) (equipment {(board (square 12)) (piece "Leopard" P1 (move Slide Diagonal (between (max 2)))) (piece "Cow" P2 N (move Step (directions {FR FL}) (to if:(is Empty (to)))))}) (rules (start {(place "Cow2" (difference (sites Bottom) (sites Phase 0)))}) phases:{(phase "Placement" (play (move Add (to (intersection (sites Phase 1) (sites Empty))))) (nextPhase (not (no Pieces P1)) "Movement")) (phase "Movement" (play (forEach Piece)))} (end {(if (and (no Moves P1) (is Mover P1)) (result P2 Win)) (if (= 0 (count Sites in:(forEach (sites Occupied by:P2) if:(< (row of:(site)) (row of:(where "Leopard" P1)))))) (result P1 Win))}))) 
5x5 intersecting lines, with diagonals drawn in each quadrant. One player plays as four tigers, places on the four corners of the board. The other player plays as twenty goats, which are placed on the remaining points, leaving the central point open. Players alternate turns moving a piece to an empty adjacent point along the lines. The tigers may capture a goat by hopping over it to an empty adjacent spot immediately on the opposite side of the goat along the lines. The tigers win when they capture all of the goats; the goats win by blocking the tigers from being able to move. 
(game "Kulaochal" (players 2) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (piece "Tiger" P1 (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))))) (piece "Goat" P2 (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Tiger1" (sites Corners)) (place "Goat2" (difference (sites Board) (union (sites Corners) (sites Centre))))}) (play (forEach Piece)) (end {(if (no Moves P1) (result P2 Win)) (if (no Pieces P2) (result P1 Win))}))) 
A square, with diagonals and lines connecting the midpoints. Two triangles on opposite sides of the triangle. One player plays as three galgos, which are placed on the three points of one of the triangles. The other player plays as one hare, which begins on the point between two of the galgos. The hare may move in any direction along the lines on the board, but must move to the central point of the board on its first move. The galgos may move forward orthogonally or diagonally; they may never move horizontally and may only move backwards if the galgo which starts on the apex of the triangle has moved and the piece to move backwards has not yet moved. If the galgos block the hare from being able to move, they win, if the hare moves past the galgos it wins.
(game "La Liebre Perseguida" (players 2) (equipment {(board (rotate 90 (merge {(rectangle 3 3 diagonals:Alternating) (shift 1.5 0.5 (rotate -90 (wedge 2))) (shift -1.5 0.5 (rotate 90 (wedge 2)))})) use:Vertex) (piece "Hare" P1 (move Step Orthogonal (to if:(is Empty (to))))) (piece "Rabbit" P2 N (or (if (= (state at:(from)) 1) (move Step Backwards (to if:(and (is In (to) (sites Bottom)) (is Empty (to)))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (move Step Forwards (to if:(is Empty (to))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0)))))) (regions "Home" P2 (sites {"B1" "C2" "A2"})) (regions "Home" P1 (sites {"B2"}))}) (rules (start {(place "Hare1" (sites P1)) (place "Rabbit2" (sites P2) state:1)}) (play (forEach Piece)) (end {(if (no Moves P1) (result P2 Win)) (if (is In (where "Hare" P1) (sites P2)) (result P1 Win))}))) 
5x5 grid, with diagonals in each quadrant. A triangle, with the apex connecting to the midpoint of one side of the grid. A line is drawn connecting the apex of the triangle to the midpoint of its base, and another triangle is drawn within the triangle connecting the midpoints of the larger triangle. One player plays as twelve dogs, arranged on the lower two rows of points and the two outer points on the central line; the other plays as one jaguar, placed on the apex of the smaller triangle. The jaguar moves first. Pieces move to an empty adjacent space along the lines of the board. The jaguar may hop over an adjacent dog to an empty space immediately on the opposite side of it, capturing the dog. Dogs cannot capture. The dogs win by blocking the jaguar so it cannot move; the jaguar wins when only six dogs remain. 
(game "La Yagua" (players 2) (equipment {(board (add (rotate 180 (merge (shift 0 2 (square 5 diagonals:Alternating)) (wedge 3))) edges:{{27 29} {29 25}}) use:Vertex) (piece "Jaguar" P1 (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to)))))) (piece "Dog" P2 (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Dog2" (union (expand (sites Bottom) steps:1) (sites {"A3" "E3"}))) (place "Jaguar1" coord:"C7")}) (play (forEach Piece)) (end {(if (no Moves Next) (result Next Loss)) (if (<= (count Pieces P2) 6) (result P2 Loss))}))) 
4x4 board. One player plays as four tigers, which begin the board placed in the four corner spaces. The other player plays as twelve oxen. The first move is made by placing one of the oxen on an empty space, followed by a move by the tiger closest to the ox. Players continue alternating moves, the oxen player placing an ox and the tiger player moving a tiger. When moving, pieces move to an empty adjacent spot orthogonally. Once all of the oxen are placed, the players alternate turns moving their pieces on the board. Pieces may capture another piece by hopping over an adjacent opponent's piece to an empty space immediately on the opposite side of it. Tigers capture orthogonally, oxen capture diagonally. Oxen may also capture a tiger by blocking it from being able to move. The oxen win by reducing the tigers to two.
(game "Len Cua Kin Ngoa" (players 2) (equipment {(board (square 4)) (hand P1) (piece "Ox" P1 (or (move Hop Diagonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step Orthogonal (to if:(is Empty (to)))))) (piece "Tiger" P2 (or (move Hop Orthogonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step Orthogonal (to if:(is Empty (to))))))}) (rules (start {(place "Ox1" (handSite P1) count:12) (place "Tiger2" (sites Corners))}) phases:{(phase "Placement" P1 (play (move (from (handSite P1)) (to (sites Empty)) (then (forEach Site (sites Occupied by:Next) (if (not (can Move (or (step (from (site)) Orthogonal (to if:(is Empty (to)))) (hop (from (site)) Orthogonal (between if:(= (who at:(between)) P1) (apply (remove (between)))) (to if:(is Empty (to))))))) (remove (site))))))) (nextPhase (all Sites (sites Hand P1) if:(= 0 (count Cell at:(site)))) "MovementP1")) (phase "MovementP1" P1 (play (forEach Piece (then (forEach Site (sites Occupied by:Next) (if (not (can Move (or (step (from (site)) Orthogonal (to if:(is Empty (to)))) (hop (from (site)) Orthogonal (between if:(= (who at:(between)) P1) (apply (remove (between)))) (to if:(is Empty (to))))))) (remove (site)))))))) (phase "FirstTigerMovement" P2 (play (forEach Piece (if (= (count Steps (from) (last To)) (min (results from:(last To) to:(sites Corners) (count Steps (from) (to))))) (or (move Hop Orthogonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to)))))))) (nextPhase Mover "MovementP2")) (phase "MovementP2" P2 (play (forEach Piece)))} (end {(if (no Pieces P1) (result P2 Win)) (if (>= 2 (count Pieces P2)) (result P1 Win))}))) 
The board has no extension and joined diagonals. Haretavl rules. The board has no extension and joined diagonals. Haretavl rules.
(game "Ludus Coriovalli" (players 2) (equipment {(board (add (merge {(scale 2 1 (rectangle 1 3)) (rectangle 2 1) (shift 4 0 (rectangle 2 1)) (shift 4 1.5 (rectangle 2 1)) (shift 0 1.5 (rectangle 2 1)) (scale 2 1 (shift 0 2.5 (rectangle 1 3)))}) edges:{{3 7} {5 4} {9 1} {3 1} {1 4} {5 9} {9 7}}) use:Vertex) (hand Each) (piece "Dog" P1 (move Step (to if:(is Empty (to))))) (piece "Hare" P2 (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Dog1" (handSite P1) count:3) (place "Hare2" (handSite P2))}) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end {(if (no Moves P2) (result P1 Win)) (if (or (>= (count Moves) (- (value MoveLimit) 10)) (>= (count Turns) (- (value TurnLimit) 5))) (result P2 Win))}))) 
5x5 intersecting lines, with diagonals in each 3x3 quadrant. One player plays with two tigers, which begin on the central spot. The other player plays as 24 goats. The goats play first, and may place a piece on any empty spot. The tigers move to an empty spot any distance along the lines on the board, or may hop over an adjacent goat to capture it, provided there is an empty spot immediately on the other side of the goat. Once all of the goats are placed, they may move along the lines to an empty adjacent spot. If the tigers cannot move, the goats win. The tigers win by capturing all the goats.
(game "Main Tapak Empat" (players 2) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (piece "Goat" P1 (move Step (to if:(is Empty (to))))) (piece "Tiger" P2 (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to)))))) (hand P1)}) (rules (start {(place Stack "Tiger2" (centrePoint)) (place Stack "Goat1" (handSite P1) count:24)}) phases:{(phase "Placement" P1 (play (move (from (handSite P1)) (to (sites Empty)))) (nextPhase (all Sites (sites Hand P1) if:(= 0 (count Cell at:(site)))))) (phase "Movement" (play (forEach Piece)))} (end {(if (no Moves P2) (result P1 Win)) (if (no Pieces P1) (result P2 Win))}))) 
Played on cross-shaped board, made of five squares, each divided into four squares and with the diagonals of the larger squares drawn. One player plays with thirteen pieces situated on every point of one arm of the cross and along the line immediately perpendicular to that arm. The other plays as the Punipeki, which is placed on any empty spot on the first turn. Pieces move along the lines to an adjacent empty spot. The Punipeki may jump over an adjacent piece to capture it. The Punipeki wins if it can capture all the opponent's pieces, the other player wins by blocking the Punipeki from moving.
(game "Manu" (players 2) (equipment {(board (merge (shift 0 (/ (- 7 3) 2) (rectangle 3 7 diagonals:Alternating)) (shift (/ (- 7 3) 2) 0 (rectangle 7 3 diagonals:Alternating))) use:Vertex) (hand P1) (piece "Stick" P1 (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to)))))) (piece "Marker" P2 (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Marker2" (union (expand (sites Bottom)) (sites Row 2))) (place "Stick1" (handSite P1))}) phases:{(phase "Placement" P1 (play (move (from (handSite P1)) (to (sites Empty)))) (nextPhase (all Sites (sites Hand P1) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end {(if (no Moves Next) (result Next Loss)) (if (no Pieces P2) (result P2 Win))}))) 
5x5 intersecting lines, with diagonals in each quadrant. Two triangles, the apexes of which intersect with the square at the midpoint of opposite sides. One line bisecting two sides of the triangle. One player plays as twenty people, stacked five each in the four points where the diagonals cross in each quadrant. The other player plays as two tigers, which are placed on the midpoints of the sides without triangles. Players alternate turns moving one piece to an adjacent spot along the lines of the board. The tiger may hop over one of the people to an empty point on the opposite side immediately adjacent to it along the lines of the board. When the tiger hops over one of the stacks, it captures only one of the people. The tigers win by capturing all the people, the people win by blocking the tigers from being able to move.
(game "Mao Naga Tiger Game" (players 2) (equipment {(board (merge {(square 5 diagonals:Alternating) (shift 0 4 (rotate 180 (wedge 3))) (shift 0 -2 (wedge 3))}) use:Vertex) (piece "Human" P1 (move Step (to if:(is Empty (to))))) (piece "Tiger" P2 (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))))}) (rules (start {(place Stack "Human1" (sites {"B4" "B6" "D4" "D6"}) count:5) (place "Tiger2" (sites {"A5" "E5"}))}) (play (forEach Piece top:True)) (end {(if (no Moves P2) (result P1 Win)) (if (no Pieces P1) (result P2 Win))}))) 
One player plays as the tigers (five in number), the other as the sheep (fifteen in number). They take turns placing the pieces on the intersections of the lines. When all of the player's pieces are on the board, the piece may move to any adjacent intersection along the connecting lines. The tiger hops over a sheep to capture it. The goal of the tiger is to capture all of the sheep; the sheep try to prevent all of the tigers from moving.
(game "Merimueng-rimueng-do" (players 2) (equipment {(board (scale 1.4 1 (remove (scale 1 2 (wedge 5 6)) edges:{{0 1} {0 6}} vertices:{24 19})) use:Vertex) (hand Each) (piece "Tiger" P1 (or {(move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to)))) (move Hop (between (exact 3) if:(and (!= (row of:(between)) (row of:(from))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Hop (between (exact 4) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))})) (piece "Sheep" P2 (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Tiger1" (handSite P1) count:5) (place "Sheep2" (handSite P2) count:15)}) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)) (end {(if (no Moves Next) (result Next Loss)) (if (no Pieces P2) (result P2 Win))}))})) 
5x5 intersecting lines, with diagonals drawn in the four quadrants of the board. Two triangles, their apices intersecting the main board at opposite midpoints. The bast of the triangle is bisected by a line drawn from the apex, and this line is bisected and intersects with the other two sides of the triangle. one player plays as two tigers, which start on the central point. The other player has 23 sheep, eight of which start on the board, on the points immediately adjacent to the tigers. Pieces move one space along the lines to an empty adjacent spot. The tigers may capture an unbroken line of sheep in one direction, provided there is an unoccupied space at the opposite end of the line. The player with the sheep replaces any captured sheep from those remaining in their hand. The tigers win when they capture all of the sheep; the sheep win when they block the tigers from being able to move.
(game "Merimueng-rimueng" (players 2) (equipment {(board (merge {(square 5 diagonals:Alternating) (shift 0 4 (rotate 180 (wedge 3))) (shift 0 -2 (wedge 3))}) use:Vertex) (hand P2) (piece "Tiger" P1 (or {(move Step (to if:(is Empty (to)))) (move Hop (between (range 1 9) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))})) (piece "Sheep" P2 (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Sheep2" (difference (expand (sites Centre)) (centrePoint))) (place Stack "Sheep2" (handSite P2) count:15) (place Stack "Tiger1" (sites Centre) counts:{2})}) phases:{(phase "Movement" (play (forEach Piece top:True)) (end {(if (no Moves P1) (result P2 Win)) (if (no Pieces P2) (result P1 Win))}) (nextPhase (and (not (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site))))) (< (count Sites in:(sites Occupied by:P2 container:"Board")) 8)) "Placement")) (phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)) (then (moveAgain)))) (nextPhase (or (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) (= (count Sites in:(sites Occupied by:P2 container:"Board")) 8)) "Movement"))})) 
Played on cross-shaped board, made of five squares, each divided into four squares and with the diagonals of the larger squares drawn. One player plays with one larger piece, the Oke-mow, placed on the central point, and the other player with thirteen pieces situated on every point of one arm of the cross and along the line immediately perpendicular to that arm. Pieces move along the lines to an adjacent empty spot. The Oke-mow may jump over an adjacent piece to capture it. Multiple captures are allowed. The Oke-mow wins if it can capture all the opponent's pieces, the other player wins by blocking the Oke-mow from moving. 
(game "Musinaykahwhanmetowaywin" (players 2) (equipment {(board (merge (shift 0 (/ (- 7 3) 2) (rectangle 3 7 diagonals:Alternating)) (shift (/ (- 7 3) 2) 0 (rectangle 7 3 diagonals:Alternating))) use:Vertex) (piece "Marker" P1 (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Step (to if:(is Empty (to)))))) (piece "Disc" P2 (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Disc2" (union (expand (sites Bottom)) (sites Row 2))) (place "Marker1" (centrePoint))}) (play (if (is Prev Mover) (or (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Pass)) (forEach Piece))) (end {(if (no Moves P1) (result P2 Win)) (if (no Pieces P2) (result P1 Win))}))) 
A triangle, with two lines drawn from the apex to the base. A rectangle is drawn across the triangle, and another line connecting the midpoints of the short sides of the rectangle. One player plays as three tigers, the other as seventeen people. One tiger begins on the apex of the triangle and the other two may be placed anywhere. Players alternate turns, with the person playing as the people first placing a person on the board, and then one of the tigers moving to an empty adjacent spot along the lines of the board. When all of the people have been placed, the people move on the board in the same fashion. The tigers may capture one of the people by jumping over it to an empty adjacent spot immediately on the opposite side of one of the people along the lines of the board. The tigers win when they capture enough people so that the people cannot block the tiger, the people win when they can block the tiger from being able to move.
(game "Mysore Tiger Game (Three Tigers)" (players 2) (equipment {(board (add (remove (merge (shift 0 2 (scale 8 2 (rectangle 3 2))) (scale 1 2 (wedge 5 4))) edges:{{0 1} {2 3} {4 5}}) edges:{{0 15} {18 1} {2 11} {14 3} {4 7} {10 5}}) use:Vertex) (hand Each) (piece "Human" P2 (move Step (to if:(is Empty (to))))) (piece "Tiger" P1 (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))))}) (rules (start {(place "Human2" (handSite P2) count:17) (place "Tiger1" (sites Top)) (place "Tiger1" (handSite P1) count:2)}) phases:{(phase "Opening" P1 (play (move (from (handSite Mover)) (to (sites Empty)) (then (if (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site))))) (moveAgain))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Opening" P2 (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end {(if (no Moves P1) (result P2 Win)) (if (no Pieces P2) (result P1 Win))}))) 
5x5 intersecting lines, with diagonals in each quadrant. At the midpoint of each side, the apex of a triangle. A line is drawn from the apex to the base of each triangle, and another line bisecting this one and the two opposite sides of the triangle. One player plays as two tigers, the other as 25 people. One tiger begins on the central point, and the other may be placed anywhere on the board. Players alternate turns, with the person playing as the people first placing a person on the board, and then one of the tigers moving to an empty adjacent spot along the lines of the board. When all of the people have been placed, the people move on the board in the same fashion. The tigers may capture one of the people by jumping over it to an empty adjacent spot immediately on the opposite side of one of the people along the lines of the board. The tigers win when they capture enough people so that the people cannot block the tiger, the people win when they can block the tiger from being able to move. 
(game "Mysore Tiger Game (Two Tigers)" (players 2) (equipment {(board (merge {(shift 2 2 (square 5 diagonals:Alternating)) (shift 2 0 (wedge 3)) (shift 5 3 (rotate 90 (wedge 3))) (shift 2 6 (rotate 180 (wedge 3))) (shift -1 3 (rotate 270 (wedge 3)))}) use:Vertex) (hand Each) (piece "Human" P2 (move Step (to if:(is Empty (to))))) (piece "Tiger" P1 (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))))}) (rules (start {(place "Human2" (handSite P2) count:25) (place "Tiger1" (sites Centre)) (place "Tiger1" (handSite P1))}) phases:{(phase "Opening" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end {(if (no Moves P1) (result P2 Win)) (if (no Pieces P2) (result P1 Win))}))) 
A triangle, with a point in the center and lines connecting it to the apex and the midpoints of the two sides which meet at the apex. One person plays as the tiger, which begins on the apex. The other person plays as three people. Players alternate turns, with the person playing as the people first placing a person on the board, and then the tiger moving to an empty adjacent spot along the lines of the board. When all of the people have been placed, the people move on the board in the same fashion. The tiger may capture one of the people by jumping over it to an empty adjacent spot immediately on the opposite side of one of the people along the lines of the board. The tiger wins when it captures one person, the people win when they can block the tiger from being able to move.
(game "Mysore Tiger Game" (players 2) (equipment {(board (add (remove (scale 1 2 (wedge 3)) vertices:{5}) edges:{{4 5}}) use:Vertex) (hand P1) (piece "Human" P1 (move Step (to if:(is Empty (to))))) (piece "Tiger" P2 (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))))}) (rules (start {(place "Human1" (handSite P1) count:3) (place "Tiger2" (sites Top))}) phases:{(phase "Opening" P1 (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end {(if (no Moves P2) (result P1 Win)) (if (< (count Pieces P1) 3) (result P2 Win))}))) 
Rectangular board, with 32 points along each long side. Lines connect the points opposite each other, as well as a diagonal line connecting each point on the left to the next highest point on the right (e.g., the first left point with the second right point, the second left point with the third right point, an so on). One player plays as the calf, which begins in the bottom right corner. The second player plays as two children, which begin in the bottom left corner and the second point on the right. Players alternate turns moving one of their pieces to an empty adjacent spot on the board along the lines. The children move first, and cannot move backward during the game. The calf can move in any direction. The children win by forcing the calf to move to the top left corner of the board, the calf wins by returning to its starting point after first having left it.
(game "Neg Tugal Tuux" (players 2) (equipment {(board (add (scale 15 1 (rectangle 32 2)) edges:{{0 3} {2 5} {4 7} {6 9} {8 11} {10 13} {12 15} {14 17} {16 19} {18 21} {20 23} {22 25} {24 27} {26 29} {28 31} {30 33} {32 35} {34 37} {36 39} {38 41} {40 43} {42 45} {44 47} {46 49} {48 51} {50 53} {52 55} {54 57} {56 59} {58 61} {60 63}}) use:Vertex) (piece "Cow" P2 (move Step (to if:(is Empty (to))))) (piece "Human" P1 (move Step (to if:(and (is Empty (to)) (>= 1 (- (from) (to)))))))}) (rules (start {(place "Cow2" 1) (place "Human1" (sites {0 3}))}) (play (forEach Piece)) (end {(if (and (is Mover P2) (= 1 (where "Cow2" P2))) (result P2 Win)) (if (= 62 (where "Cow2" P2)) (result P1 Win))}))) 
Cross-shaped board made of five squares. The four squares of the arms have diagonals and lines connecting the midpoints of opposite sides. The central square has diagonals and a line connecting the central point with the midpoint of the lower side. One player plays with nineteen pieces, which begin on the uppermost nineteen points. The other player plays with two pieces, which begin on the central space and the one immediately below it. The player with two pieces goes first. Pieces move along the lines of the board to an empty adjacent spot. The player with two pieces may capture an adjacent opponent's piece by hopping over it to an empty spot immediately on the opposite side of it. The player with two pieces wins by capturing all of the opponent's pieces; the player with nineteen pieces wins by blocking the opponent from being able to move.
(game "Nuktagaq" (players 2) (equipment {(board (remove (merge (shift 0 (/ (- 7 3) 2) (rectangle 3 7 diagonals:Alternating)) (shift (/ (- 7 3) 2) 0 (rectangle 7 3 diagonals:Alternating))) edges:{{17 10} {9 10} {10 11}}) use:Vertex) (hand P1) (piece "Marker" P1 (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to)))))) (piece "Marker" P2 (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Marker2" (difference (expand (sites Top) steps:4) (union (sites Row 2) (sites Centre)))) (place "Marker1" (sites Direction from:(sites Centre) S included:True distance:1))}) (play (forEach Piece)) (end {(if (no Moves Next) (result Next Loss)) (if (no Pieces P2) (result P2 Win))}))) 
5x5 board, played on intersections of the lines, with diagonals for each quadrant of the board. One player plays as four tigers, the other as twenty goats. The tigers begin, two on the top two corners of the board, and two in the centers of the two bottom quadrants. Four of the goats are placed on any available points. The tigers move first, to an empty adjacent spot along the lines on the board. The player playing as the goats places one of the remaining goats on any available point. The goats cannot move until all of the goats are placed. Once they are all placed, the goats move as the tigers do. The tigers alone may capture a goat by hopping over it to an empty spot immediately opposite a goat. The tigers win by capturing all the goats; the goats win by blocking the tigers from being able to move.
(game "Orissa Tiger Game (Four Tigers)" (players 2) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (piece "Goat" P1 (move Step (to if:(is Empty (to))))) (piece "Tiger" P2 (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))))) (hand P1)}) (rules (start {(place "Goat1" (handSite P1) count:20) (place "Tiger2" (sites {"A5" "E5" "B2" "D2"}))}) phases:{(phase "Placement" P1 (play (move (from (handSite P1)) (to (sites Empty)) (then (if (< 16 (count Cell at:(handSite P1))) (moveAgain))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end {(if (no Moves P2) (result P1 Win)) (if (no Pieces P1) (result P2 Win))}))) 
5x5 lines, intersecting to form a square. Diagonals are drawn in the four quadrants of the board. One triangle, its apex intersecting the main board at the midpoint of one side. The base of the triangle is bisected by a line drawn from the apex, and this line is bisected and intersects with the other two sides of the triangle. One player plays as the tiger, placed on the central point of the triangle, and the other plays as twelve goats, which begin on the first two rows of points opposite the triangle and on the outer two points in the third row. The tiger moves first. Pieces move to an empty adjacent spot along the lines on the board. The tiger alone may capture a goat by hopping over it to an empty spot immediately opposite a goat. The tiger wins by capturing all the goats; the goats win by blocking the tiger from being able to move.
(game "Orissa Tiger Game (One Tiger)" (players 2) (equipment {(board (rotate 180 (merge (shift 0 2 (square 5 diagonals:Alternating)) (wedge 3))) use:Vertex) (piece "Tiger" P1 (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))))) (piece "Goat" P2 (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Tiger1" (sites {"C6"})) (place "Goat2" (union (expand (sites Bottom)) (sites {"A3" "E3"})))}) (play (forEach Piece)) (end {(if (no Moves P1) (result P2 Win)) (if (no Pieces P2) (result P1 Win))}))) 
To be reconstructed. Rules as inferred by Murray 1951. One player is the bean, and the other player plays with twelve corn kernels. The corn kernels move along the lines. The goal is to corner the bean so that it cannot move. The bean may hop over the corn kernels to capture them or move to an adjacent empty point along the lines. The bean wins by reducing the opponent to nine corn kernels. The coyote can jump to capture.
(game "Pon Chochotl" (players 2) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (piece "Corn" P1 (move Step (to if:(is Empty (to))))) (piece "Bean" P2 (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (if (is Prev Mover) (move Pass) (move Step (to if:(is Empty (to)))))))}) (rules (start {(place "Corn1" (union {(expand (sites Bottom)) (sites {"A3" "E3"})})) (place "Bean2" (centrePoint))}) (play (forEach Piece)) (end {(if (no Moves Next) (result Next Loss)) (if (<= (count Pieces P1) 9) (result P1 Loss))}))) 
A triangle, with a line drawn from the apex to the base. A rectangle intersects with the triangle, and has a line connecting the midpoints of the short sides. One player plays as the tiger(s), one to four in number. The other player plays as five to 23 goats (or dogs, or lambs). The tiger begins on the apex of the triangle, and any other tigers on the spots adjacent to the apex. The tiger player moves by moving a piece to an empty adjacent spot along the lines of the board. The goat player begins the game by placing a goat on an empty point on the board, and then the tiger player moves. When all of the goats are placed, they move like the tiger. The tiger may capture a goat by hopping over it to an empty spot on the opposite adjacent side of the goat along the lines of the board. The goats win by blocking the tiger(s) from being able to move; the tiger(s) win by capturing enough goats to prevent them from blocking it/them. 1 Tiger. 5 Goats.
(game "Pulijudamu" (players 2) (equipment {(board (add (remove (merge (scale 1 2 (wedge 5 3)) (shift 0 2 (scale 8 2 (rectangle 3 2)))) edges:{{17 18} {15 16} {13 14}}) edges:{{13 7} {15 4} {17 1} {3 18} {6 16} {9 14}}) use:Vertex) (hand Each) (piece "Goat" P2 (move Step (to if:(is Empty (to))))) (piece "Tiger" P1 (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))))}) (rules (start {(place "Goat2" (handSite P2) count:5) (place "Tiger1" (handSite P1) count:1)}) phases:{(phase "Opening" P1 (play (move (from (handSite Mover)) (to (if (= 0 (count Sites in:(intersection (sites Top) (sites Occupied by:Mover)))) (sites Top) (intersection (sites Empty) (sites {1 2 3})))) (then (if (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site))))) (moveAgain))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Opening" P2 (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end {(if (no Moves P1) (result P2 Win)) (if (no Pieces P2) (result P1 Win))}))) 
Cross-shaped board, made of four 3x3 intersecting lines with diagonals. One player plays as the fox, which begins on the central space of the board. The other player plays as the lambs, who start in the spaces of one arm of the cross and the line of seven spots in front of that arm. Players alternate turns moving their pieces along the lines. The fox may capture one lamb by hopping over it in a straight line to an empty space on the opposite side of it. The fox wins by capturing seven lambs, the lambs win by blocking the fox so it cannot move.
(game "Refskak" (players 2) (equipment {(board (merge (shift 0 (/ (- 7 3) 2) (rectangle 3 7 diagonals:Alternating)) (shift (/ (- 7 3) 2) 0 (rectangle 7 3 diagonals:Alternating))) use:Vertex) (piece "Lamb" P1 (move Step (to if:(is Empty (to))))) (piece "Fox" P2 (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to))))))}) (rules (start {(place "Fox2" (centrePoint)) (place "Lamb1" (union (expand (sites Bottom) steps:2) (sites {"A3" "B3" "F3" "G3"})))}) (play (forEach Piece)) (end {(if (no Moves Next) (result Next Loss)) (if (<= (count Pieces P1) 6) (result P1 Loss))}))) 
Played on cross-shaped board, made of five squares, each divided into four squares and with the diagonals of the larger squares drawn. One player plays as seventeen hens, which begin on the points on one of the arms of the cross and along the line immediately perpendicular to that arm, and on the two outermost points on the left and right arms. The other player plays as one fox, which starts on the central point of the board. Players alternate turns moving to an empty adjacent spot along the lines of the board. The hens, however, can only move in a forward or horizontal direction. The fox hops over an adjacent hen to an empty spot immediately on the opposite side of the hen along the lines of the board. At the beginning of the game, the players choose whether to allow the fox the ability to make multiple captures in one turn. If the fox is able to capture but does not, the opponent adds another hen on an empty point in the bottom row. If there is no empty spot on the bottom row, the player waits until there is one to place the new hen. The fox wins by capturing all of the hens or by moving to the furthest line on the hens' side of the board. The hens win by blocking the fox from being able to move.  The fox can capture one single piece.
(game "Renard et les Poules" (players 2) (equipment {(board (merge (shift 0 (/ (- 7 3) 2) (rectangle 3 7 diagonals:Alternating)) (shift (/ (- 7 3) 2) 0 (rectangle 7 3 diagonals:Alternating))) use:Vertex) (hand P1) (piece "Fox" P1 S (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to)))))) (piece "Hen" P2 N (move Step (directions {Forwards Rightward Leftward}) (to if:(is Empty (to)))))}) (rules (start {(place "Fox1" (centrePoint)) (place "Hen2" (union {(expand (sites Bottom)) (sites Row 2) (sites {"A4" "G4" "A5" "G5"})}))}) phases:{(phase "FoxPhase" P1 (play (do (set Pending (sites To (forEach Piece "Fox" (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))))) next:(forEach Piece (then (if (and (is Pending) (not (is In (last To) (sites Pending)))) (if (< (value Player Mover) 0) (set Value Mover 1) (set Value Mover (+ 1 (value Player Mover)))))))))) (phase "HenPhase" P2 (play (if (and (> (value Player Prev) 0) (!= 0 (count Sites in:(intersection (sites Empty) (sites Bottom))))) (move Add (to (intersection (sites Empty) (sites Bottom))) (then (and (set Value Prev (- (value Player Prev) 1)) (moveAgain)))) (forEach Piece))))} (end {(if (no Moves P1) (result P1 Loss)) (if (or (is In (where "Fox" P1) (sites Bottom)) (no Pieces P2)) (result P1 Win))}))) 
5x5 intersecting lines, with diagonals in each quadrant. Two triangles, the apexes of which intersect with the square at the midpoint of opposite sides. One line bisecting the base of the triangle, and another bisecting this line. One player plays as the tiger, which is placed on the apex of either triangle. The other player plays as 24 people, nine of which begin on the nine central points of the board. To begin, the person playing as the tiger removes three of the people from their starting position and places them on any points on the board. The person playing as the people then places one of the remaining people on an empty spot on the board. The tiger then moves to an empty adjacent spot along the lines of the board. Play continues like this until all of the people are placed, at which point the people move to an adjacent empty spot on the board as well. On its turn, the tiger may hop over a line of people to an empty spot on the other side of the line, following the lines of the board and only if the number of people in the line is odd. The tiger wins if it captures all the people; the people win when they block the tiger from being able to move.
(game "Rimau-Rimau (One Tiger)" (players 2) (equipment {(board (merge {(square 5 diagonals:Alternating) (shift 0 4 (rotate 180 (wedge 3))) (shift 0 -2 (wedge 3))}) use:Vertex) (hand Each) (piece "Tiger" P1 (or {(move Step (to if:(is Empty (to)))) (move Hop (between (range 1 9) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(and (is Empty (to)) (is Even (count Steps (from) (to))))))})) (piece "human" P2 (move Step (to if:(is Empty (to)))))}) (rules (start {(place "human2" (expand (sites Centre))) (place "human2" (handSite P2) count:15) (place "Tiger1" (handSite P1))}) phases:{(phase "PlacementTiger" P1 (play (move (from (handSite P1)) (to (sites {"C3" "C7"})) (then (moveAgain)))) (nextPhase Mover "MoveHuman")) (phase "MoveHuman" P1 (play (move (from (intersection (expand (sites Centre)) (sites Occupied by:Next))) (to (difference (sites Empty) (expand (sites Centre)))) (then (if (< 6 (count Sites in:(intersection (expand (sites Centre)) (sites Occupied by:Next)))) (moveAgain))))) (nextPhase Mover (= 6 (count Sites in:(intersection (expand (sites Centre)) (sites Occupied by:Next)))) "Movement")) (phase "PlacementHuman" P2 (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)) (end {(if (no Moves P1) (result P2 Win)) (if (no Pieces P2) (result P1 Win))}))})) 
5x5 intersecting lines, with diagonals in each quadrant. Two triangles, the apexes of which intersect with the square at the midpoint of opposite sides. One line bisecting the base of the triangle, and another bisecting this line. One player plays as two tigers, the other as 23 people. One of the tigers begins on any spot on the board. Eight of the people begin on the spots surrounding the central point of the board. The tiger player, on their first turn, removes one of the people and then places the second tiger anywhere on the board. The people then play, placing one of the remaining people on an empty spot on the board. On the tiger's turn, the player may move one of the tigers to an empty adjacent spot along the lines of the board. The tiger may also capture a person by hopping over it to an empty adjacent spot immediately on the opposite side of it along the lines of the board. When all of the people are placed, they move to an empty adjacent spot along the lines of the board on their turn. The tigers win by capturing all the people; the people win by blocking both tigers from being able to move. The two tigers start in the hand.
(game "Rimau-Rimau (Two Tigers)" (players 2) (equipment {(board (merge {(square 5 diagonals:Alternating) (shift 0 4 (rotate 180 (wedge 3))) (shift 0 -2 (wedge 3))}) use:Vertex) (hand Each) (piece "Tiger" P1 (or {(move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))})) (piece "human" P2 (move Step (to if:(is Empty (to)))))}) (rules (start {(place "human2" (difference (expand (sites Centre)) (centrePoint))) (place "human2" (handSite P2) count:16) (place "Tiger1" (handSite P1) count:2)}) phases:{(phase "PlacementFirstTiger" P1 (play (move (from (handSite P1)) (to (sites Empty)) (then (moveAgain)))) (nextPhase Mover "RemoveHuman")) (phase "RemoveHuman" P1 (play (move Remove (intersection (sites Board) (sites Occupied by:Next)) (then (moveAgain)))) (nextPhase Mover "PlacementSecondTiger")) (phase "PlacementSecondTiger" P1 (play (move (from (handSite P1)) (to (sites Empty)))) (nextPhase Mover "Movement")) (phase "PlacementHuman" P2 (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)) (end {(if (no Moves P1) (result P2 Win)) (if (no Pieces P2) (result P1 Win))}))})) 
5x5 intersecting lines, with diagonals drawn in the four quadrants of the board. Two triangles, their apices intersecting the main board at opposite midpoints. The base of the triangle is bisected by a line drawn from the apex, and this line is bisected and intersects with the other two sides of the triangle. One player plays as the Rimoe (king), which starts on the central point. The other player has 24 pieces, eight of which start on the board, on the points immediately adjacent to the Rimoe. The Rimoe plays first, and takes one of the opponent's pieces by hopping over it to an empty spot immediately behind it in a straight line. The Rimoe captures in this way any uninterrupted line of pieces with an odd number. The Rimoe cannot capture a line of pieces with an even number. When the Rimoe cannot capture, it moves one to an empty adjacent space along the lines of the board. The other player places on of their remaining pieces on the board on their turn. When there are no more pieces left to place, the player moves one of the pieces to an empty adjacent spot along the lines. The Rimoe wins by capturing all of the opponent's pieces; the opponent wins by blocking the Rimoe from being able to move. The game is played with one Rimoe able to hop an odd number of enemy pieces.
(game "Rimoe" (players 2) (equipment {(board (merge {(square 5 diagonals:Alternating) (shift 0 4 (rotate 180 (wedge 3))) (shift 0 -2 (wedge 3))}) use:Vertex) (piece "King" P1 (priority {(move Hop (between (range 1 9) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(and (is Empty (to)) (is Even (count Steps (from) (to)))))) (move Step (to if:(is Empty (to))))})) (piece "Marker" P2 (move Step (to if:(is Empty (to))))) (hand Each)}) (rules (start {(place "King1" (centrePoint) count:1) (place "Marker2" (handSite P2) count:16) (place "Marker2" (difference (expand (sites Centre)) (centrePoint)))}) phases:{(phase "Placement" P2 (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end {(if (no Moves P1) (result P2 Win)) (if (no Pieces P2) (result P1 Win))}))) 
5x5 board, played on intersections, with diagonals for each quadrant of the board. One player plays with two tiger pieces, placed on the midpoints of two opposite sides. The other player plays with nineteen goats, divided into three stacks of five and one stack of four, placed in the center of each quadrant. The goats move first. Goats may move one at a time to any adjacent vacant spot. More than one goat can be placed on the goats' starting spots, but not elsewhere. The tiger moves in the same manner, but also may capture a piece by hopping over it. Multiple captures can be made on the same turn with subsequent hops, but only the top goat in a stack is captured when a tiger leaps over it. The goal of the goats is to surround the tigers so they cannot move. The goal of the tigers is to capture all the goats. 
(game "Sher Bakar" (players 2) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (piece "Goat" P1 (move Step (to if:(or (and (is In (to) (sites "StartingSitesGoats")) (is Friend (who at:(to)))) (is Empty (to)))))) (piece "Tiger" P2 (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))))) (regions "StartingSitesGoats" (sites {"B2" "D2" "D4" "B4"}))}) (rules (start {(place "Tiger2" (sites {"C1" "C5"})) (place Stack "Goat1" (sites {"B2" "D2" "D4"}) count:5) (place Stack "Goat1" (sites {"B4"}) count:4)}) (play (if (is Prev Mover) (or (move Pass) (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))) (forEach Piece top:True))) (end {(if (no Moves P2) (result P1 Win)) (if (no Pieces P1) (result P2 Win))}))) 
An isosceles triangle, with the height of the triangle and two lines, which bisect the sides of the triangle, but intersect the height at the same point, roughly central, such that they are at an angle but do not bisect it. One player plays as the tiger, which begins at the apex of the triangle, the other as four goats, which begin on the central point. The goats play first, removing one of the pieces from the stack to an adjacent empty spot. The tiger moves along the lines to an empty adjacent spot. The goats also move in this way. Goats may only be stacked on the central point. The tiger may capture a goat by jumping over it, and a jump from one side of the triangle to the opposite side, over the central point, is allowed. The goats win by blocking the tiger from being able to move, the tiger wins by capturing one goat.
(game "Sher Bakr" (players 2) (equipment {(board (rotate 180 (add (remove (scale 1 2 (wedge 3)) vertices:{2}) vertices:{{2 1.333}} edges:{{4 6} {6 0} {1 6} {6 2}})) use:Vertex) (hand Each) (piece "Goat" P1 (move Step (to if:(or (is Empty (to)) (and (= (to) (centrePoint)) (is Friend (who at:(to)))))))) (piece "Tiger" P2 (or {(move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (if (and {(= (from) 2) (is Enemy (who at:(centrePoint))) (is Empty 1)}) (move (from 2) (to 1) (then (remove (centrePoint))))) (if (and {(= (from) 1) (is Enemy (who at:(centrePoint))) (is Empty 2)}) (move (from 1) (to 2) (then (remove (centrePoint)))))}))}) (rules (start {(place Stack "Goat1" (centrePoint) count:4) (place Stack "Tiger2" 0)}) (play (forEach Piece top:True)) (end {(if (no Moves P2) (result P1 Win)) (if (= 3 (count Pieces P1)) (result P2 Win))}))) 
Board with 5x5 lines, diagonals drawn in the four quadrants of the board, and a triangle at the top, connecting the apex with the three central points at the top edge, and a line perpendicularly bisecting the height of the triangle. One player plays as the general, placed in the central position. The other player plays with sixteen pieces, arranged on the perimeter points of the square. Pieces move one spot along the lines on the board. The general may capture pieces when it moves into a space that is surrounded on two opposite sides, along the lines on the board, thus capturing the pieces on either side of it. Conversely, the general can be captured by surrounding it on two opposite sides with pieces. Only the general may enter the triangle. The goal of the general is to capture all of the opponent's pieces, the goal of the person playing with sixteen pieces is to capture the general. If the general becomes trapped in the triangle, the opponent wins.
(game "Shi Liu Kan Tsiang Kun" (players 2) (equipment {(board (merge (scale 2 (square 5 diagonals:Alternating)) (shift 2 8 (rotate 180 (wedge 3)))) use:Vertex) (piece "General" P1 (move Step (to if:(is Empty (to))) (then (intervene (from (last To)) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))))) (piece "Marker" P2 (move Step (to if:(and (not (is In (to) (expand (sites Top)))) (is Empty (to)))) (then (custodial (from (last To)) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Friend (who at:(to))))))))}) (rules (start {(place "General1" (ahead (centrePoint) S)) (place "Marker2" (difference (sites Outer) (expand (sites Top))))}) (play (forEach Piece)) (end {(if (no Pieces P2) (result P1 Win)) (if (no Pieces P1) (result P2 Win)) (if (and {(is In (where "General" P1) (expand (sites Top))) (>= (count Pieces P2) 2) (= (who at:(coord "D5")) P2)}) (result P2 Win))}))) 
5x5 intersecting lines, with the diagonals of every 2x2 square formed. On one side, a diamond intersects with the central point of that side, with diagonals drawn in the diamond. One player plays as the monk, placed at the intersection of the diamond and the main board. The other player plays as fifteen water pieces, placed on each point along the perimeter of the main board. Players take turns moving their pieces to one adjacent point following the lines on the board. The monk may capture two water pieces by moving to an empty space between two water pieces. The goal of the water pieces is to trap the monk on the far point of the diamond. The monk wins by capturing all of the water.
(game "Shui Yen Ho-Shang" (players 2) (equipment {(board (merge (rotate 45 (shift 1.5 4.2 (square 2 diagonals:Solid))) (square 5 diagonals:Alternating)) use:Vertex) (piece "Marker" P1 (move Step (to if:(is Empty (to))))) (piece "Marker" P2 (move Step (to if:(is Empty (to))) (then (intervene (from (last To)) (to if:(is Enemy (who at:(to))) (apply (remove (to))))))))}) (rules (start {(place "Marker2" coord:"C5") (place "Marker1" (difference (sites Outer) (sites {"B6" "C7" "D6"})))}) (play (forEach Piece)) (end {(if (no Pieces P1) (result P2 Win)) (if (and (no Moves P2) (is In (where "Marker" P2) (sites {"C7"}))) (result P1 Win))}))) 
5x5 intersecting lines, with diagonals drawn in each quadrant. One player plays as four tigers, which begin on the four corners of the board. The other player plays as twenty goats, which begin off the board. Play begins by placing one of the goats on an empty spot. The other player then moves the tiger to an empty adjacent spot along the lines on the board. The tiger may hop over an adjacent goat, to an empty space on the opposite adjacent side of the goat along the lines. Play continues like this until all of the goats are placed, after which the goats also move to one adjacent spot along the lines. The tigers win by capturing all of the goats; the goats win by blocking the tigers from being able to move.
(game "Sumi Naga Game (Hunt)" (players 2) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (piece "Goat" P1 (move Step (to if:(is Empty (to))))) (piece "Tiger" P2 (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))))) (hand P1)}) (rules (start {(place "Goat1" (handSite P1) count:20) (place "Tiger2" (sites Corners))}) phases:{(phase "Placement" P1 (play (move (from (handSite P1)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Moving")) (phase "Moving" (play (forEach Piece)))} (end {(if (no Moves P2) (result P1 Win)) (if (no Pieces P1) (result P2 Win))}))) 
Played on a 5x5 board. There are 3 'Musketeer' pieces and 22 'Enemy' pieces. Musketeers can only move by capturing enemies on any adjacent space. Enemies can only move to empty adjacent spaces. Enemies win if all three musketeers are ever on the same line or column. Musketeers win as soon as they run out of legal moves.
(game "Three Musketeers" (players 2) (equipment {(board (square 5)) (piece "Musketeer" P1 (move Step Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Enemy" P2 (move Step Orthogonal (to if:(is Empty (to)))))}) (rules (start {(place "Musketeer1" {"A1" "C3" "E5"}) (place "Enemy2" (difference (sites Board) (sites {"A1" "C3" "E5"})))}) (play (forEach Piece)) (end {(if (no Moves P1) (result P1 Win)) (if (and (is Mover P1) (is Line 3 Orthogonal contiguous:False)) (result P2 Win))}))) 
A square, with lines bisecting the sides drawn to the center. A circle is drawn around the central point. arcs are drawn inside the square around the midpoints of the sides and the corners. Diagonals are drawn from the corner arcs to the central circle. One player plays as the hare, one player plays as the hunter and two hounds. The hare begins on the central spot, and the hunter and hounds are placed on three of the points on the central circle. Pieces move to an empty adjacent spot along the lines of the board. The hare moves first. When the hunter and hounds prevent the hare from being able to move, the game ends and the players switch roles. The game has two rounds.
(game "To Kinegi tou Lagou" (players 2) (equipment {(board (add (remove (remove (merge {(concentric {1 8}) (shift 0 -5 (concentric {1 4})) (shift 0 5 (concentric {1 4})) (shift -5 0 (concentric {1 4})) (shift 5 0 (concentric {1 4})) (shift 5 5 (concentric {1 8})) (shift 5 -5 (concentric {1 8})) (shift -5 -5 (concentric {1 8})) (shift -5 5 (concentric {1 8}))}) vertices:{20 18 27 11 48 49 50 51 52 41 42 43 44 45 34 35 36 37 30 59 58 57 64 63}) edges:{{0 1} {0 7} {0 5} {0 3} {33 35} {30 29} {27 25} {39 37}}) edges:{{15 8} {22 6} {4 12} {19 2} {18 36} {38 20} {40 14} {16 26} {28 24} {23 32} {31 11} {10 34} {5 30} {3 35} {39 1} {27 7}}) use:Vertex) (piece "Human" Each (move Step (to if:(is Empty (to))))) (piece "Dog" Each (move Step (to if:(is Empty (to))))) (piece "Hare" Each (move Step (to if:(is Empty (to))))) (hand Each size:2)}) (rules (start {(place "Hare2" (centrePoint)) (place "Human1" (handSite P1)) (place "Dog1" (handSite P1 1) count:2)}) phases:{(phase "PlacementP1" (play (move (from (sites Hand P1) if:(is Occupied (from))) (to (sites {1 2 3 4 5 6 7 8}) if:(is Empty (to))) (then (if (not (all Sites (sites Hand P1) if:(= 0 (count Cell at:(site))))) (moveAgain))))) (nextPhase (all Sites (sites Hand P1) if:(= 0 (count Cell at:(site)))) "HuntingP2")) (phase "HuntingP2" (play (forEach Piece (then (if (not (can Move (step (from (where "Hare" P2)) (to if:(is Empty (to)))))) (and {(addScore P2 (- (count Moves) 3)) (remove (sites Occupied by:All container:"Board")) (add (piece "Hare1") (to (sites Centre))) (add (piece "Human2") (to (handSite P2))) (add (piece "Dog2") (to (handSite P2 1)) count:2)}))))) (nextPhase (= 1 (count Sites in:(sites Occupied by:All container:"Board"))) "PlacementP2")) (phase "PlacementP2" (play (move (from (sites Hand P2) if:(is Occupied (from))) (to (intersection (sites Empty) (sites {1 2 3 4 5 6 7 8})) if:(is Empty (to))) (then (if (not (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site))))) (moveAgain))))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "HuntingP1")) (phase "HuntingP1" (play (forEach Piece (then (if (not (can Move (step (from (where "Hare" P1)) (to if:(is Empty (to)))))) (addScore P1 (- (count Moves) (+ (score P2) 6))))))) (end (if (!= 0 (score P1)) (byScore))))})) 
Two arcs which meet, in the shape of a horn, curving to the left. Nine points along the left side, and eight along the right, with one at the apex. Zig-zag lines connect points on either side of the board, connecting the first on the left to the first on the right, the first on the right to the second on the left, the second on the left to the second on the right, and so on. One player plays as the cow and the calf (black). The cow begins on the first point on the left, the calf on the second point on the right. The other player plays as two children (white), which begin on the second point on the left and the first point on the right. Players alternate turns moving a piece to an empty adjacent spot along the lines on the board. The cow never moves from its position. The calf plays first. The calf wins when it reaches the cow; the children win when they force the calf onto the apex of the board (the pasture).
(game "Uxrijn Ever" (players 2) (equipment {(board (graph vertices:{{0 0} {5 0} {0.17 1} {4.65 1} {0.3 2} {4.3 2} {0.38 3} {3.9 3} {0.25 4} {3.5 4} {-0.13 5} {2.97 5} {-0.75 6} {2.2 6} {-1.47 7} {0.95 7} {-2.22 8} {-3 9}} edges:{{0 1} {0 2} {2 4} {4 6} {6 8} {8 10} {10 12} {12 14} {14 16} {16 17} {1 3} {3 5} {5 7} {7 9} {9 11} {11 13} {13 15} {1 2} {2 3} {3 4} {4 5} {5 6} {6 7} {7 8} {8 9} {9 10} {10 11} {11 12} {12 13} {13 14} {14 15} {15 16} {15 17}}) use:Vertex) (piece "Cow" P1) (piece "Calf" P1 (move Step (to if:(or (= (what at:(to)) (id "Cow" P1)) (is Empty (to))) (apply (remove (to)))))) (piece "Human" P2 (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Cow1" 0) (place "Calf1" 3) (place "Human2" (sites {1 2}))}) (play (forEach Piece)) (end {(if (is In (where "Calf" P1) (sites Top)) (result P2 Win)) (if (= 1 (count Sites in:(sites Occupied by:P1))) (result P1 Win))}))) 
Four pieces are the sheep; they are placed on the dark squares along one side of the board. one piece is the wolf; it is placed on any dark square on the side opposite the sheep. The goal of the wolf is to reach one of the sheep's original spaces, the sheep's goal is to block the wolf from doing so. Sheep move diagonally forward one square, the wolf moves diagonally forward or backward one square.
(game "Wolf and Sheep" (players 2) (equipment {(board (square 8)) (piece "Sheep" P1 N (move Step (directions {FR FL}) (to if:(is Empty (to))))) (piece "Wolf" P2 (move Step Diagonal (to if:(is Empty (to)))))}) (rules (start {(place "Wolf2" {"D8"}) (place "Sheep1" {"A1" "C1" "E1" "G1"})}) (play (forEach Piece)) (end {(if (and (no Moves P2) (is Mover P2)) (result P1 Win)) (if (is In (where "Wolf" P2) (sites Bottom)) (result P2 Win))}))) 
8x8 checkered board. One player plays as four sheep (white pieces), which begin on the four dark squares on one side of the board. The other player plays as one wolf (black piece), which can be placed on any dark space on the board. Players alternate turns moving a piece to an empty adjacent dark square on the board. The sheep move forward only but the wolf may also move backward. The goal of the sheep is to block the wolf from being able to move, the goal of the wolf is to move beyond the line of sheep.
(game "Wolf und Schaaf" (players 2) (equipment {(board (square 8)) (piece "Sheep" P2 N (move Step (directions {FR FL}) (to if:(is Empty (to))))) (piece "Wolf" P1 (move Step Diagonal (to if:(is Empty (to))))) (hand P1)}) (rules (start {(place "Wolf1" (handSite P1)) (place "Sheep2" {"A1" "C1" "E1" "G1"})}) phases:{(phase "Placement" P1 (play (move (from (handSite P1)) (to (intersection (sites Phase 0) (sites Empty))))) (nextPhase "Movement")) (phase "Movement" (play (forEach Piece)))} (end {(if (and (no Moves P1) (is Mover P1)) (result P2 Win)) (if (= 0 (count Sites in:(forEach (sites Occupied by:P2) if:(<= (row of:(site)) (row of:(where "Wolf" P1)))))) (result P1 Win))}))) 
5x5 intersecting lines with diagonals in each quadrant. A triangle, the apex intersecting with the apex of one of the sides. A line is drawn from the apex to the midpoint of the base of the triangle. A line bisects this line, connecting the midpoints of the sides of the triangle, One player plays as one jaguar, which begins on the center of the base of the large triangle's base. The other player plays as fifteen dogs, which begin on the points of the three ranks of the bottom half of the square portion of the board. The jaguar moves first. Pieces move to an empty adjacent space along the lines of the board. The jaguar may hop over an adjacent dog to an empty space immediately on the opposite side of it, capturing the dog. Dogs cannot capture. The dogs win by blocking the jaguar so it cannot move; the jaguar wins when only six dogs remain. 
(game "Yaguarete Kora" (players 2) (equipment {(board (rotate 180 (merge (shift 0 2 (square 5 diagonals:Alternating)) (wedge 3))) use:Vertex) (piece "Jaguar" P1 (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))))) (piece "Dog" P2 (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Jaguar1" coord:"C6") (place "Dog2" (expand (sites Bottom) steps:2))}) (play (forEach Piece)) (end {(if (no Moves P1) (result P1 Loss)) (if (<= (count Pieces P2) 6) (result P1 Win))}))) 
5x9 intersecting lines; with a triangle formed by lines drawn from the second and fourth line of one of the short sides of the rectangle, with the base and a line bisecting the base of the triangle. One player plays as the General, placed on the central space of the rectangle, and the other player plays as 26 Rebels, places on the intersections of the second, third, and fourth of the long lines. Pieces move one space orthogonally. The General may capture one of the Rebels by hopping over it to an empty space. The General wins by capturing all the Rebels. The Rebels win by blocking the General from moving. P1 wins in blocking P2 to move. P2 wins in capturing by hopping all the pieces of P1.
(game "Yeung Luk Sz' Kon Tseung Kwan" (players 2) (equipment {(board (merge (rectangle 9 5) (shift 1 8 (scale 0.5 (wedge 3)))) use:Vertex) (piece "Marker" P1 (move Step (to if:(is Empty (to))))) (piece "Marker" P2 (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to))))))}) (rules (start {(place "Marker1" (union {(sites Column 1) (difference (sites Column 3) (union (sites Centre) (expand (sites Top)))) (sites Column 5)})) (place "Marker2" (centrePoint))}) (play (forEach Piece)) (end {(if (no Pieces P1) (result P2 Win)) (if (no Moves P2) (result P1 Win))}))) 
Boards consist of a grid of 3x4 squares and a continuation of the central row in the grid that extends for 8 further squares. The game is played with two astragals as dice: one from a sheep and one from an ox. The sheep astragal provides the base value for the roll, and the ox astragal serves as a bonus. Rolls of the sheep astragal produce values of 1, 2 ,3 or 4. The ox astragal produces a "yes" or "no" value. If "no" is rolled, the values remain the same. If "yes" is rolled, the value of the first roll is boosted to 5, 6, 7, or 10, respectively. These rules are proposed by Finkel based on the values of moves provided in the cuneiform tablets (Finkel 2007: 21–22). Each player starts play on one of the right corners of the 3x4 grid, proceeding left down that row to the opposite corner, and then right down the central track, which both players use, with the goal of moving off the end of the track. If a player lands on a square occupied by the opponent, the opponent's piece is removed from the board and may reenter on a subsequent turn. Rosettes on certain squares in the central track mark spaces where a player is safe from being sent to the beginning. Rosettes in the corners allow a player to roll again when a player lands on them. A player wins when they remove all seven of their pieces from the board by rolling the exact number of spaces left in the track, plus one. Rules from Seleucid.
(game "20 Squares" (players 2) (equipment {(board (merge (rectangle 3 4) (shift 0 1 (rectangle 1 12))) {(track "Track1" "20,3,W,N1,E,End" P1 directed:True) (track "Track2" "21,12,W,S1,E,End" P2 directed:True)}) (dice facesByDie:{{1 2 3 4} {0 1}} num:2) (hand Each) (regions "Replay" (sites {"A1" "A3" "D2" "H2" "L2"})) (piece "UrPiece" Each (if (= (trackSite Move steps:(if (= 0 (face 23)) (face 22) (if (= 1 (face 22)) (+ (face 22) 5) (if (= 2 (face 22)) (+ (face 22) 6) (if (= 3 (face 22)) (+ (face 22) 7) (+ (face 22) 10)))))) -2) (move Remove (from)) (if (!= (trackSite Move steps:(if (= 0 (face 23)) (face 22) (if (= 1 (face 22)) (+ (face 22) 5) (if (= 2 (face 22)) (+ (face 22) 6) (if (= 3 (face 22)) (+ (face 22) 7) (+ (face 22) 10)))))) -1) (if (or (is Empty (trackSite Move steps:(if (= 0 (face 23)) (face 22) (if (= 1 (face 22)) (+ (face 22) 5) (if (= 2 (face 22)) (+ (face 22) 6) (if (= 3 (face 22)) (+ (face 22) 7) (+ (face 22) 10))))))) (and (not (is Friend (who at:(trackSite Move steps:(if (= 0 (face 23)) (face 22) (if (= 1 (face 22)) (+ (face 22) 5) (if (= 2 (face 22)) (+ (face 22) 6) (if (= 3 (face 22)) (+ (face 22) 7) (+ (face 22) 10))))))))) (not (is In (trackSite Move steps:(if (= 0 (face 23)) (face 22) (if (= 1 (face 22)) (+ (face 22) 5) (if (= 2 (face 22)) (+ (face 22) 6) (if (= 3 (face 22)) (+ (face 22) 7) (+ (face 22) 10)))))) (sites "Replay"))))) (move (from) (to (trackSite Move steps:(if (= 0 (face 23)) (face 22) (if (= 1 (face 22)) (+ (face 22) 5) (if (= 2 (face 22)) (+ (face 22) 6) (if (= 3 (face 22)) (+ (face 22) 7) (+ (face 22) 10)))))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite (who at:(to))))))) (then (if (is In (last To) (sites "Replay")) (moveAgain))))))))}) (rules (start {(place "UrPiece1" (handSite P1) count:7) (place "UrPiece2" (handSite P2) count:7)}) (play (do (roll) next:(or (forEach Piece) (forEach Piece container:(mover))))) (end (if (no Pieces Mover) (result Mover Win))))) 
Five pieces per player. The goal is to reach hole thirty with all five of the player's pieces. Each player has either the left or the right track. Movement is decided by dice. If a piece lands on a space with a connecting line, the piece must move backward along that line, never forward. Holes 15 and 25 are special holes, which grant a second roll. The game is using stick dices. Parallel Connections board. Rules from Carnarvon and Carter.
(game "58 Holes" (players 2) (equipment {(board (graph vertices:{{9 27} {9 24} {9 21} {9 18} {9 15} {9 12} {9 9} {9 6} {9 3} {9 0} {3 0} {3 2} {3 4} {3 6} {3 8} {3 10} {3 12} {3 14} {3 16} {3 18} {3 20} {3 22} {3 24} {3 26} {3 28} {4 30} {6 31} {8 32} {10 33} {15 27} {15 24} {15 21} {15 18} {15 15} {15 12} {15 9} {15 6} {15 3} {15 0} {21 0} {21 2} {21 4} {21 6} {21 8} {21 10} {21 12} {21 14} {21 16} {21 18} {21 20} {21 22} {21 24} {21 26} {21 28} {20 30} {18 31} {16 32} {14 33} {12 33}} edges:{{0 1} {1 2} {2 3} {3 4} {4 5} {5 6} {6 7} {7 8} {8 9} {9 10} {10 11} {11 12} {12 13} {13 14} {14 15} {15 16} {16 17} {17 18} {18 19} {19 20} {20 21} {21 22} {22 23} {23 24} {24 25} {25 26} {26 27} {27 28} {28 58} {29 30} {30 31} {31 32} {32 33} {33 34} {34 35} {35 36} {36 37} {37 38} {38 39} {39 40} {40 41} {41 42} {42 43} {43 44} {44 45} {45 46} {46 47} {47 48} {48 49} {49 50} {50 51} {51 52} {52 53} {53 54} {54 55} {55 56} {56 57} {57 58}}) {(track "Track1" {59 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 58} P1 directed:True) (track "Track2" {60 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58} P2 directed:True)} use:Vertex) (hand Each) (dice d:2 from:0 num:4) (regions "Replay" {14 24 43 53}) (piece "Marker" Each (if (= (trackSite Move steps:(count Pips)) 58) (move Remove (from)) (if (!= (trackSite Move steps:(count Pips)) -1) (if (is Empty (trackSite Move steps:(count Pips))) (move (from) (to (trackSite Move steps:(count Pips))) (then (and (if (is In (last To) (sites "Replay")) (moveAgain)) (if (!= (last To) (mapEntry (last To))) (if (is Empty (mapEntry (last To))) (move (from (last To)) (to (mapEntry (last To))))))))))))) (map {(pair 19 5) (pair 9 7) (pair 48 34) (pair 38 36)})}) (rules (start {(place "Marker1" (handSite P1) count:5) (place "Marker2" (handSite P2) count:5)}) (play (do (roll) next:(or (forEach Piece) (forEach Piece container:(mover))))) (end (if (no Pieces Mover) (result Mover Win))))) 
7x7 board. The central square, as well as the central square on each edge of the board, is marked with an X. Two to four players. Four pieces per player. Four cowries used as dice, the values are equal to the number of mouths which land face up; when all mouths are down the value = 8 and a "grace," all mouths up = a grace. Throws giving a grace also allow the player to throw again. Players are not obliged to play their throws if they do not wish to. Pieces enter the board with a grace on the marked square on the edge closest to the player. Pieces move along the outer squares of the board in an anti-clockwise direction. Upon reaching the square before the marked square where the player enters their pieces, the track proceeds in the left corner (respective to the player) of the next concentric track of squares, and proceeds in a clockwise spiraling track toward the central marked square. When a player's piece lands on a square occupied by an opponent's piece, the opponent's piece is removed from the board, and the player gains another throw. Pieces cannot be removed from the board if they are resting on a marked square. Players may enter their pieces onto the board when an opponent's piece is resting on their starting place. This first player to move all of their pieces to the central square by exact throws wins. The game involves 2 players.
(game "Ashta-kashte" (players 2) (equipment {(board (square 7) {(track "Track1" "27,N,W,S,E,N2,SW1,W4,N4,E4,S3,W3,N2,E2,S1,W1" P1 directed:True) (track "Track2" "21,S,E,N,W,S2,NE1,E4,S4,W4,N3,E3,S2,W2,N1,E1" P2 directed:True)}) (piece "Paddle" Each (if (and (is In (from) (sites Board)) (!= (trackSite Move steps:(mapEntry "Throw" (count Pips))) -1)) (move (from (from) level:(level)) (to (trackSite Move steps:(mapEntry "Throw" (count Pips))) (apply if:(and (not (is In (to) (sites "ProtectedSites"))) (is Enemy (who at:(to)))) (and (fromTo (from (to)) (to (handSite (who at:(to))))) (moveAgain))))) (then (if (= 24 (last To)) (remove (last To)))))) (hand Each) (dice d:2 from:0 num:4) (map {(pair 1 "G4") (pair 2 "A4") (pair 3 "D1") (pair 4 "D7")}) (map "Throw" {(pair 0 8)}) (regions "ProtectedSites" (sites {0 3 6 21 27 3 45 42 48 24}))}) (rules (start {(place Stack "Paddle1" (handSite P1) count:4) (place Stack "Paddle2" (handSite P2) count:4)}) (play (do (roll) next:(or {(forEach Piece) (move Pass) (if (and (is In (count Pips) (array {0 4})) (!= 0 (who at:(handSite Mover)))) (move (from (handSite Mover)) (to (mapEntry Mover))))}) (then (if (is In (count Pips) (array {0 4})) (moveAgain))))) (end (if (no Pieces Mover) (result Mover Win))))) 
To be reconstructed. The rules implemented here are suggested by Jenny Kile as follows: Besides being an 8x8 squared board, the board consists of certain marked spaces which denote safety, entry, or exit for players. The four corners, the four central squares, and two center squares on each side are crosscut, like shown. Two, three, or four people can play the game. If two players are playing, each would sit on one side of the board and enter their two pieces onto the center crosscut squares along the outer side The object of the game is to be the first player to enter and exit both his pieces. A player exits his piece once reaching the center squares.  The version of the game played with 2 players.
(game "Ashtapada" (players 2) (equipment {(board (square 8) {(track "Track1" "3,E,N,W,S,E1,N6,E5,S5,W4,N4,E3,S3,W1" 1 directed:True) (track "Track2" "60,W,S,E,N,W1,S6,W5,N5,E4,S4,W3,N3,E1" 2 directed:True) (track "Track3" "31,N,W,S,E,N1,W6,N5,E5,S4,W4,N3,E3,S1" 3 directed:True) (track "Track4" "32,S,E,N,W,S1,E6,S5,W5,N4,E4,S3,W3,N1" 4 directed:True)}) (dice d:2 from:0 num:4) (hand Each) (map "DieValue" {(pair 4 8)}) (map "Entry" {(pair P1 "D1") (pair P2 "E8")}) (map "Exit" {(pair P1 "E3") (pair P2 "D6")}) (regions "Protect" (sites {"A1" "A4" "A5" "A8" "D1" "D4" "D5" "D8" "E1" "E4" "E5" "E8" "H1" "H4" "H5" "H8"})) (piece "Disc" Each (if (!= (trackSite Move steps:(mapEntry "DieValue" (count Pips))) -1) (if (if (is In (trackSite Move steps:(mapEntry "DieValue" (count Pips))) (sites "Protect")) (not (is Enemy (who at:(trackSite Move steps:(mapEntry "DieValue" (count Pips)))))) True) (move (from) (to (trackSite Move steps:(mapEntry "DieValue" (count Pips))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite (who at:(to)))))))))))}) (rules (start {(place "Disc1" (handSite P1) count:2) (place "Disc2" (handSite P2) count:2)}) (play (do (if (not (is Prev Mover)) (roll)) next:(if (is Prev Mover) (or (forEach Piece (if (= (from) (mapEntry "Exit" Mover)) (move Remove (from)) (if (!= (trackSite Move steps:1) -1) (if (if (is In (trackSite Move steps:1) (sites "Protect")) (not (is Enemy (who at:(trackSite Move steps:1)))) True) (move (from) (to (trackSite Move steps:1) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite (who at:(to)))))))))))) (if (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site))))) (move (from (handSite Mover)) (to (mapEntry "Entry" Mover) if:(not (is Enemy (who at:(to)))))))) (if (can Move (forEach Piece)) (forEach Piece (then (if (= (count Pips) 3) (moveAgain)))) (move Pass (then (if (= (count Pips) 3) (moveAgain)))))))) (end (if (no Pieces Mover) (result Mover Win))))) 
Four 3x4 rectangles, arranged in a cross shape, with a large central square which has diagonals, and spaces in the four corners between each arm of the cross. Four players, played on two teams, with team members sitting on opposite sides of the board. Four pieces per player, with the colors red, black, yellow, and green. Six cowrie shells used as dice: five are white and one is yellow. The number of the mouths which are face-up determine the value of the throw, except for a throw of 3 when one of the cowries with the mouth down is the yellow one, in which case the throw is known as So-hatara, and counts as 4, but allows special moves because it is actually considered four individual throws of 1. When the player throws 1, 5, or So-hatara, the player receives an extra throw. A 1, 5, or So-hatara must be thrown to enter a piece on the board. The entirety of a throw must be used to move one piece, but separate throws in a turn can each be used individually to move a different piece. This does not apply when So-hatara is one of the throws; in this case, the total of the throw can be subdivided however the player sees fit. Pieces enter the board from the center, moving down the central track of their arm, then in an anti-clockwise direction around the board, and then back up the central row of their arm of the board to the central square. If a player lands on a space occupied by a piece of the opposing team, the opponent's piece is sent back to start. Pieces resting on the corner spaces between the arms of the cross cannot be sent to start in any circumstance. The first team who places all of their pieces in the central square wins. 
(game "Asi Keliya" (players 4) (equipment {(board (merge {(add (add (merge {(rectangle 3 4) (shift 7 0 (rectangle 3 4)) (shift 3.5 3.5 (rotate 90 (rectangle 3 4))) (shift 3.5 -3.5 (rotate 90 (rectangle 3 4)))}) vertices:{{5.5 1.5}}) edges:{{4 76} {35 76} {19 76} {20 76}}) (shift 3 3 (square 1)) (shift 7 3 (square 1)) (shift 3 -1 (square 1)) (shift 7 -1 (square 1))}) {(track "Track1" "6,52,S,E,N3,E,N1,E,N,W3,N1,W1,N,W,S3,W1,S1,W,S,E3,S1,E1,S,E1,N3,End" P1 directed:True) (track "Track2" "7,11,W,S1,E3,S1,E1,S,E,N3,E1,N1,E,N,W3,N,W1,N,W2,S3,W1,S1,W,S1,E3,End" P2 directed:True) (track "Track3" "17,39,N,W1,S3,W1,S1,W,S,E3,S1,E1,S,E,N3,E,N1,E,N,W3,N,W1,N,W1,S3,End" P3 directed:True) (track "Track4" "21,26,E,N1,W3,N1,W1,N,W,S3,W1,S1,W,S,E3,S1,E1,S,E,N3,E1,N1,E,N1,W3,End" P4 directed:True)}) (piece "Marker" Each (if (= (trackSite Move steps:(count Pips)) -2) (move Remove (from)) (if (!= (trackSite Move steps:(count Pips)) -1) (if (or (is Empty (trackSite Move steps:(count Pips))) (and (is Enemy (who at:(trackSite Move steps:(count Pips)))) (not (is In (trackSite Move steps:(count Pips)) (sites "SafeSites"))))) (move (from) (to (trackSite Move steps:(count Pips)) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite (who at:(to)))))))))))) (hand Each) (dice d:2 from:0 num:6) (map {(pair P1 6) (pair P2 7) (pair P3 17) (pair P4 21)}) (regions "SafeSites" (sites {3 19 16 34}))}) (rules (start {(set Team 1 {P1 P3}) (set Team 2 {P2 P4}) (place "Marker" "Hand" count:4)}) (play (do (if (not (is Pending)) (roll)) next:(or (if (or (and (= (count Pips) 3) (= 0 (face 65))) (is In (count Pips) (sites {1 5}))) (move (from (handSite Mover)) (to (mapEntry (mover)) if:(is Empty (mapEntry (mover)))))) (if (or (is Pending) (and (= (count Pips) 3) (= 0 (face 65)))) (forEach Die if:(!= (pips) 0) (forEach Piece (if (= (trackSite Move steps:(pips)) -2) (move Remove (from)) (if (!= (trackSite Move steps:(pips)) -1) (if (or (is Empty (trackSite Move steps:(pips))) (and (is Enemy (who at:(trackSite Move steps:(pips)))) (not (is In (trackSite Move steps:(pips)) (sites "SafeSites"))))) (move (from) (to (trackSite Move steps:(pips)) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite (who at:(to)))))))))))) (then (if (not (all DiceUsed)) (and (set Pending) (moveAgain))))) (forEach Piece))) (then (if (or (and (= (count Pips) 3) (= 0 (face 65))) (is In (count Pips) (sites {1 5}))) (moveAgain))))) (end (if (no Pieces TeamMover) (result TeamMover Win))))) 
The game is played on a board with twelve points on either side. The points form a continuous track in a horseshoe shape; each player progresses in opposite directions (one from their bottom right to the top right, the other from their bottom left to their top left. Each player has 15 pieces. The starting position is as such, number the points from the origin of each player's track: Point six: five pieces Point 8: three pieces Point 13: five pieces Point 24: two pieces Play begins by each player rolling one die; the player with the highest roll plays first and plays the numbers on this first roll. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. If doubles are rolled, the player must play the number on each die twice. Players cannot end their move on a point with multiple opposing pieces. If a player ends the turn on a point with one opposing piece, that piece is placed in the middle of the board (not on a point) and must reenter the board according the the next die roll, counting the origin point as a move of 1. They cannot reenter on a point with two or more pieces. No other pieces can move until all of the pieces belonging to that player are removed from the center. When all of a player's pieces are on their final 6 points, they may start removing pieces from the board. They can do so by rolling a 6 to move from the 6th point, and so on down to 1. Players must use all available moves presented by the dice. The first player to remove all of their pieces wins.
(game "Backgammon" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {6 12 11 10 9 8 7 5 4 3 2 1 0 13 14 15 16 17 18 20 21 22 23 24 25 -2} P1 directed:True) (track "Track2" {19 25 24 23 22 21 20 18 17 16 15 14 13 0 1 2 3 4 5 7 8 9 10 11 12 -2} P2 directed:True)} use:Vertex) (dice num:2) (regions P1 {20 21 22 23 24 25}) (regions P2 {7 8 9 10 11 12}) (map {(pair 1 6) (pair 2 19)}) (piece "Disc" Each (forEach Die replayDouble:True if:(and {(!= (pips) 0) (!= (trackSite Move from:(from) steps:(pips)) -1) (not (= (trackSite Move from:(from) steps:(pips)) -2))}) (move (from (from)) (to (trackSite Move from:(from) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (next)))))))))}) (rules (start {(place Stack "Disc1" 0 count:5) (place Stack "Disc1" 12 count:2) (place Stack "Disc1" 17 count:3) (place Stack "Disc1" 20 count:5) (place Stack "Disc2" 4 count:3) (place Stack "Disc2" 7 count:5) (place Stack "Disc2" 13 count:5) (place Stack "Disc2" 25 count:2)}) (play (do (if (not (is Prev Mover)) (roll)) next:(if (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover))) (forEach Die replayDouble:True if:(!= (pips) 0) (forEach Site (sites Occupied by:Mover) (if (and (is Occupied (site)) (!= (trackSite Move from:(site) steps:(pips)) -1)) (if (= (trackSite Move from:(site) steps:(pips)) -2) (move Remove (site)) (move (from (site)) (to (trackSite Move from:(site) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (next))))))))) noMoveYet:(firstMoveOnTrack "Track" Mover (if (and (is Friend (who at:(site))) (< (trackSite Move from:(site) steps:(pips)) 0)) (move Remove (site)))) (then (if (not (all DiceUsed)) (moveAgain))))) (max Distance "Track" Mover (if (is Empty (mapEntry (mover))) (forEach Piece top:True) (forEach Die replayDouble:True if:(!= (pips) 0) (move (from (mapEntry (mover))) (to (trackSite Move from:(mapEntry (mover)) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (next)))))))) (then (if (not (all DiceUsed)) (if (can Move (if (is Empty (mapEntry (mover))) (forEach Piece top:True) (forEach Die replayDouble:True if:(!= (pips) 0) (move (from (mapEntry (mover))) (to (trackSite Move from:(mapEntry (mover)) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (next)))))))))) (moveAgain))))))))) (end (if (no Pieces Mover) (result Mover Win))))) 
2x12 board, divided in half, where the spaces are rendered as points. Fifteen pieces per player. Two six-sided dice. Both players begin on the same side of the board, one player with fifteen pieces on the rightmost point, the other player with fourteen pieces on the point behind it, and one on the point behind that. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. On each throw the player also plays a throw of 6 in addition to the throw presented by the dice. Pieces move in an anti-clockwise direction around the board. A piece cannot move to a point that is occupied by more than one of the opponent's pieces. If a piece lands on a point occupied by a single piece belonging to the opponent, the opponent's piece is removed from the board and must enter again from the leftmost point in the row where the pieces began. A piece may be borne off the board when a throw is greater than the number of points left on the board. The first player to bear all of their pieces off the board wins.
(game "Baralie" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {6 0 1 2 3 4 5 7 8 9 10 11 12 25 24 23 22 21 20 18 17 16 15 14 13} P1 directed:True) (track "Track2" {19 0 1 2 3 4 5 7 8 9 10 11 12 25 24 23 22 21 20 18 17 16 15 14 13} P2 directed:True)} use:Vertex) (dice num:2) (map {(pair 1 19) (pair 2 6)}) (piece "Disc" Each)}) (rules (start {(place Stack "Disc1" 12 count:15) (place Stack "Disc2" 11 count:14) (place Stack "Disc2" 10)}) (play (do (if (not (is Prev Mover)) (roll)) next:(if (all DiceUsed) (forEach Site (sites Occupied by:Mover) (if (= (trackSite Move from:(site) steps:6) -1) (move Remove (site)) (move (from (site)) (to (trackSite Move from:(site) steps:6) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (mover))))))))) (forEach Die if:(!= (pips) 0) (forEach Site (sites Occupied by:Mover) (if (= (trackSite Move from:(site) steps:(pips)) -1) (move Remove (site)) (move (from (site)) (to (trackSite Move from:(site) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (mover))))))))) (then (moveAgain)))))) (end (if (no Pieces Mover) (result Mover Win))))) 
Four 3x8 rectangles, arranged in a cross. In the outer rows of each arm, the third square from the outer corners is marked with an X. In two opposite arms, the bottom left corner is marked with "", called bange. Two players. Four pieces per player. Six cowrie shells, used as dice. The throws are as follows: six mouths up (bara) = 12, and the player is granted another throw; five mouths up (bange) = 25 plus another throw, or 24 in addition to entering a piece on the first space of the track, or a piece can enter on the bange plus another throw; four mouths up (arba) = 4; three mouths up (t'laite) = 3; two mouths up (doi) = 2; one mouth up (dust) = 11 plus another throw, or 10 in addition to entering a piece on the first square of the track, or a piece can enter on the X in the right hand row of the player's arm and the player gets another throw; all mouths down (shaka) = 6 plus another throw. Players begin in opposite arms of the cross that do not contain the bange. Pieces enter the board on the top square of the central row of their arm, proceed down that row, then continue in an anti-clockwise direction around the board, until returning to the central track in the player's arm and proceeding toward the central square of the board. The player moves the pieces according to the throws. A piece must move the full value of a single throw, unless one of the throws allows the entering of a piece. When a piece lands on a space occupied by an opponent's piece, the opponent's piece is removed from the board and must re-enter from the beginning. Pieces resting on squares marked with X cannot be sent back to start in this way. Two opposing pieces cannot occupy the same safe space, but two pieces belonging to the same player may. Pieces entering the central row of the player's arm are placed on their side to indicate they are moving toward the goal, rather than just starting. Pieces enter the central space (the kitchen) by throwing a dust or bange from the final space in the central row. When this is thrown, and the player has other pieces on the board, the piece waiting to enter the kitchen uses the point normally used to enter pieces to exit, and the remaining value of the throw can be used by other pieces. The first player to remove all four pieces from the board wins.
(game "Bargese" (players 2) (equipment {(board (add (hole (merge (shift 0 (/ (- 19 3) 2) (rectangle 3 19)) (shift (/ (- 19 3) 2) 0 (rectangle 19 3))) (poly {{8 8} {8 11} {11 11} {11 8}})) cells:{{8 28 48 68 69 70 71 51 31 11 10 9}}) {(track "Track1" "26,W,S,E,8,S,E,N,11,E,N,W,53,N,W,S,42,W,S1,E7,End" P1 directed:True) (track "Track2" "27,E,N,W,53,N,W,S,42,W,S,E,8,S,E,N,11,E,N1,W7,End" P2 directed:True)}) (hand Each) (dice d:2 from:0 num:6) (piece "Pawn" Each (if (and {(>= 0 (var "EnteredPiece")) (= (trackSite Move from:(from) steps:1) -2) (or (= (mapEntry "Throw" (count Pips)) 25) (= (mapEntry "Throw" (count Pips)) 11))}) (move Remove (from) level:(level) (then (set Var "EnteredPiece" 1))) (if (and (>= 0 (var "EnteredPiece")) (= (trackSite Move from:(from) steps:2) -2)) (move (from (from)) (to (trackSite Move from:(from) steps:1))) (move (from (from) level:(level)) (to (trackSite Move from:(from) steps:(if (< 0 (var "EnteredPiece")) (- (mapEntry "Throw" (count Pips)) 1) (mapEntry "Throw" (count Pips)))) if:(not (and (is In (to) (sites "SafeSites")) (is Enemy (who at:(to))))) (apply (if (is Enemy (who at:(to))) (forEach Level (to) FromTop (fromTo (from (to) level:(level)) (to (handSite (who at:(to) level:(level))))))))) (then (set Var "EnteredPiece" 0)))))) (map "Throw" {(pair 0 6) (pair 1 11) (pair 2 2) (pair 3 3) (pair 4 4) (pair 5 25) (pair 6 12)}) (map "DefaultEntry" {(pair P1 26) (pair P2 27)}) (map "XEntry" {(pair P1 2) (pair P2 48)}) (regions "SafeSites" (sites {60 62 16 48 87 89 37 2}))}) (rules (start {(place Stack "Pawn1" (handSite P1) count:4) (place Stack "Pawn2" (handSite P2) count:4)}) (play (do (if (>= 0 (var "EnteredPiece")) (roll)) next:(if (can Move (or {(if (and {(>= 0 (var "EnteredPiece")) (is Occupied (handSite Mover)) (= (mapEntry "Throw" (count Pips)) 25)}) (move (from (handSite Mover)) (to (mapEntry "DefaultEntry" Mover)) (then (set Var "EnteredPiece" 1)))) (if (and {(>= 0 (var "EnteredPiece")) (is Occupied (handSite Mover)) (= (mapEntry "Throw" (count Pips)) 11)}) (move (from (handSite Mover)) (to (mapEntry "DefaultEntry" Mover)) (then (set Var "EnteredPiece" 1)))) (if (and {(>= 0 (var "EnteredPiece")) (is Occupied (handSite Mover)) (= (mapEntry "Throw" (count Pips)) 11)}) (move (from (handSite Mover)) (to (mapEntry "XEntry" Mover)))) (forEach Piece)})) (or {(if (and {(>= 0 (var "EnteredPiece")) (is Occupied (handSite Mover)) (= (mapEntry "Throw" (count Pips)) 25)}) (move (from (handSite Mover)) (to (mapEntry "DefaultEntry" Mover)) (then (set Var "EnteredPiece" 1)))) (if (and {(>= 0 (var "EnteredPiece")) (is Occupied (handSite Mover)) (= (mapEntry "Throw" (count Pips)) 11)}) (move (from (handSite Mover)) (to (mapEntry "DefaultEntry" Mover)) (then (set Var "EnteredPiece" 1)))) (if (and {(>= 0 (var "EnteredPiece")) (is Occupied (handSite Mover)) (= (mapEntry "Throw" (count Pips)) 11)}) (move (from (handSite Mover)) (to (mapEntry "XEntry" Mover)))) (forEach Piece)}) (move Pass (then (set Var "EnteredPiece" 0)))) (then (if (is In (mapEntry "Throw" (count Pips)) (sites {12 25 11 6})) (moveAgain))))) (end (if (no Pieces Mover) (result Mover Win))))) 
Four 3x8 rectangles, arranged in a cross. The third square in the outer rows of each arm, counting from the outer corners, are marked. Four players, each with four pieces. Pieces enter the board from the center of the board, down the central row of the player's arm, around the board in an anti-clockwise direction, and then back up the central row to the central space. Six cowries used as dice, the throws are as follows: one mouth up = 10; two mouths up = 2; three mouths up = 3; four mouths up = 4; five mouths up = 25; six mouths up = 12; zero mouths up = 6. Throws of 10 and 25 allow a player to enter a piece onto the board. When a piece lands on a space occupied by an opponent's piece, the opponent's piece is sent back to start. Pieces on the same spot as another piece belonging to the player and pieces on marked squares are safe from being sent to start. The player who moves all of their pieces off the board first wins.
(game "Barjis" (players 4) (equipment {(board (add (hole (merge (shift 0 (/ (- 19 3) 2) (rectangle 3 19)) (shift (/ (- 19 3) 2) 0 (rectangle 19 3))) (poly {{8 8} {8 11} {11 11} {11 8}})) cells:{{8 28 48 68 69 70 71 51 31 11 10 9}}) {(track "Track1" "96,9,S,E1,N,11,E,N,W,53,N,W,S,42,W,S,E,8,S,E1,N8" P1 directed:True) (track "Track2" "96,26,W,S,E,8,S,E,N,11,E,N,W,53,N,W,S,42,W,S1,E8" P2 directed:True) (track "Track3" "96,52,N,W,S,42,W,S,E,8,S,E,N,11,E,N,W,53,N,W1,S8" P3 directed:True) (track "Track4" "96,27,E,N,W,53,N,W,S,42,W,S,E,8,S,E,N,11,E,N1,W8" P4 directed:True)}) (hand Each) (dice d:2 from:0 num:6) (piece "Pawn" Each (if (= (trackSite Move steps:(mapEntry "Throw" (count Pips))) -1) (move Remove (from)) (move (from (from)) (to (trackSite Move steps:(mapEntry "Throw" (count Pips))) if:(or (is Empty (to)) (and (is Enemy (who at:(to))) (not (is In (to) (sites "SafeSites"))))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite (who at:(to)))))))))) (map "Throw" {(pair 0 6) (pair 1 10) (pair 2 2) (pair 3 3) (pair 4 4) (pair 5 25) (pair 6 12)}) (regions "SafeSites" (sites {60 62 16 48 87 89 37 2}))}) (rules (start (place "Pawn" "Hand" count:4)) (play (do (roll) next:(or (forEach Piece) (if (and (is In (mapEntry "Throw" (count Pips)) (array {10 25})) (is Occupied (handSite Mover))) (move (from (handSite Mover)) (to (centrePoint) if:(not (is Friend (who at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite (who at:(to)))))))))))) (end (if (no Pieces Mover) (result Mover Win))))) 
Played on a Tables board with sockets for the pieces instead of points. Fifteen pieces per player. Three six-sided dice. Players move according to the number on each die by moving one piece the value on one die, another piece the value on another die, and another piece the value on the final die, by moving one piece the value of two of the die subsequently, and a second piece the value of the remaining die, or one piece the value of each die subsequently. Pieces begin off the board. Players must enter all of their pieces onto one half of the board (one player entering in the quadrant to their right and the other player's entering into the quadrant on their left), according to the throws of the dice. Once a player has entered all of their pieces, they move through all of the quadrants of the board toward the quadrant where the opponent entered their pieces. A piece landing on a space with a single opponent's piece sends the opponent's piece back to start, and it must be reentered. Once players enter all of their pieces into the final quadrant, they may bear off their pieces. They can do so by rolling a 6 to move from the sixth point, and so on down to 1. Throughout the game, a player must use the maximum number of moves presented by the dice. The first player to remove all of their pieces wins. 
(game "Buffa de Baldrac" (players 2) (equipment {(board (merge {(rectangle 1 6) (shift 7 0 (rectangle 1 6)) (shift 0 6 (rectangle 1 6)) (shift 7 6 (rectangle 1 6))}) {(track "Track1" {0 1 2 3 4 5 6 7 8 9 10 11 23 22 21 20 19 18 17 16 15 14 13 12 -2} P1 directed:True) (track "Track2" {12 13 14 15 16 17 18 19 20 21 22 23 11 10 9 8 7 6 5 4 3 2 1 0 -2} P2 directed:True)} use:Vertex) (dice d:6 num:3) (piece "Disc" Each (or (forEach Die combined:True if:(and (!= (pips) 0) (<= 0 (trackSite Move from:(from) steps:(pips)))) (move (from (from)) (to (trackSite Move from:(from) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next)))))) (then (if (not (all DiceUsed)) (moveAgain)))) (if (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover "LastQuadrant"))) (forEach Die combined:True if:(and (!= (pips) 0) (= (trackSite Move from:(from) steps:(pips)) -2)) (move Remove (from)) (then (if (not (all DiceUsed)) (moveAgain))))))) (regions "FirstQuadrant" P1 (sites {0 1 2 3 4 5})) (regions "FirstQuadrant" P2 (sites {12 13 14 15 16 17})) (regions "LastQuadrant" P1 (sites {12 13 14 15 16 17})) (regions "LastQuadrant" P2 (sites {0 1 2 3 4 5})) (map "StartTrack" {(pair P1 0) (pair P2 12)}) (hand Each)}) (rules (start {(place Stack "Disc1" (handSite P1) count:15) (place Stack "Disc2" (handSite P2) count:15)}) (play (max Moves (do (if (not (is Prev Mover)) (roll)) next:(if (is Occupied (handSite Mover)) (forEach Die combined:True if:(and (!= (pips) 0) (is In (trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1)) (sites Mover "FirstQuadrant"))) (move (from (handSite Mover)) (to (trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))))) (then (if (not (all DiceUsed)) (moveAgain)))) (forEach Piece top:True))))) (end (if (no Pieces Mover) (result Mover Win))))) 
2x12 board, divided in half. Spaces on each side take the form of semi-circular sockets, into which the pieces fit. Fifteen pieces per player. One player places all of their pieces on the sixth point of one of the quadrants of the board, and the other player places all of their pieces on the fifth point of the same quadrant. Three six-sided dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. Players move the pieces along the same track around the board, which ends on the quadrant on the other side of the board from the starting quadrant. When a piece is moved to a space occupied by a piece belonging to the opponent, the opponent's piece is sent back to the starting point. The first player to bear off all of their pieces from the board wins. All the pieces start in the first quadrant. The game involves 3 dice.
(game "Cab e Quinal" (players 2) (equipment {(board (merge {(rectangle 1 6) (shift 7 0 (rectangle 1 6)) (shift 0 6 (rectangle 1 6)) (shift 7 6 (rectangle 1 6))}) {(track "Track1" {24 0 1 2 3 4 5 6 7 8 9 10 11 23 22 21 20 19 18 17 16 15 14 13 12} P1 directed:True) (track "Track2" {25 0 1 2 3 4 5 6 7 8 9 10 11 23 22 21 20 19 18 17 16 15 14 13 12} P2 directed:True)} use:Vertex) (dice d:6 num:3) (hand Each) (piece "Disc" Each (forEach Die if:(!= (pips) 0) (if (= (trackSite Move steps:(pips)) -1) (move Remove (from)) (if (or (not (is Enemy (who at:(trackSite Move steps:(pips))))) (= 1 (size Stack at:(trackSite Move steps:(pips))))) (move (from) (to (trackSite Move steps:(pips)) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite (who at:(to))))))))))))}) (rules (start {(place Stack "Disc1" 5 count:15) (place Stack "Disc2" 4 count:15)}) (play (do (if (not (is Prev Mover)) (roll)) next:(or (forEach Piece top:True) (forEach Piece container:(mover) top:True) (then (if (or (= (value Player Mover) -1) (not (all DiceUsed))) (moveAgain) (if (and (all DiceUsed) (= (value Player Mover) 1)) (set Value Mover -1))))))) (end {(if (no Pieces Mover) (result Mover Win)) (if (and (no Moves P1) (no Moves P2)) (result Mover Draw))}))) 
Four 3x8 rectangles arranged in a cross with a large empty square in the center. Two teams of two players, or by two players playing with two sets of pieces. The pieces move along the outer track of the board according to the throw of three four-sided dice with values of 1, 2, 5 and 6. The values of each die must be played individually, except in certain cases. Each player has four pieces, which begin on the sixth and seventh space of the central row and the seventh and eight space in the right hand row of the arm of the board belonging to the player. If a piece lands on a space occupied by an opponent, the opponent's piece is sent back to the starting position. If two of a player's pieces are on the same space, they cannot be sent to the beginning. In addition, when three pieces are on the same spaces, if triple sixes are thrown the pieces may move twelve spaces together. The same rule applies for threes and twos, moving six and four, respectively. After completing a circuit of the board, the pieces then move into the central row of squares in the arm where the player began. The player must then move off all of their pieces by an exact roll. If a player has removed all of their pieces from the board and their partner is still playing, the player rolls on what would be their turn and the partner moves according to these rolls in addition to their own turn. The player or team to remove all of their pieces from the board first wins. 
(game "Chaupar" (players 4) (equipment {(board (add (hole (merge (shift 0 (/ (- 19 3) 2) (rectangle 3 19)) (shift (/ (- 19 3) 2) 0 (rectangle 19 3))) (poly {{8 8} {8 11} {11 11} {11 8}})) cells:{{8 28 48 68 69 70 71 51 31 11 10 9}}) {(track "Track1" "61,S,E,N,11,E,N,W,53,N,W,S,42,W,S,E,8,54,E1,N7,End" P1 directed:True) (track "Track2" "21,W,S,E,8,S,E,N,11,E,N,W,53,N,W,S,42,W,S1,E7,End" P2 directed:True) (track "Track3" "88,N,W,S,42,W,S,E,8,S,E,N,11,E,N,W,53,N,W1,S7,End" P3 directed:True) (track "Track4" "32,E,N,W,53,N,W,S,42,W,S,E,8,S,E,N,11,E,N1,W7,End" P4 directed:True)}) (dice d:4 faces:{1 2 5 6} num:3) (map "Start" {(pair P1 61) (pair P2 21) (pair P3 88) (pair P4 32)}) (piece "Pawn" Each (or (if (and {(= 0 (count MovesThisTurn)) (all DiceEqual) (or {(is AnyDie 6) (is AnyDie 3) (is AnyDie 2)}) (= 3 (count Pieces of:(mover) in:(sites {(from)})))}) (move (from (from) level:(level)) (to (trackSite Move from:(from) "Track" steps:(* 2 (face 97)))) (then (forEach Level (last From) FromTop (if (is Mover (who at:(last From) level:(level))) (fromTo (from (last From) level:(level)) (to (last To)))))))) (forEach Die if:(!= (pips) 0) (if (= (trackSite Move from:(from) "Track" steps:(pips)) -2) (move Remove (from) level:(level)) (move (from (from) level:(level)) (to (trackSite Move from:(from) "Track" steps:(pips))))) (then (if (not (all DiceUsed)) (moveAgain)))) (then (forEach Level (last To) FromTop (if (and (is Enemy (who at:(last To) level:(level))) (= 1 (count Pieces of:(who at:(last To) level:(level)) in:(sites {(last To)})))) (fromTo (from (last To) level:(level)) (to (mapEntry "Start" (who at:(last To) level:(level))))))))))}) (rules (start {(set Team 1 {P1 P3}) (set Team 2 {P2 P4}) (place Stack "Pawn1" (sites {61 58 59 56})) (place Stack "Pawn2" (sites {21 20 0 1})) (place Stack "Pawn3" (sites {91 88 93 90})) (place Stack "Pawn4" (sites {33 32 49 50}))}) (play (do (if (not (is Prev Mover)) (roll)) next:(if (no Pieces Mover) (if (is Mover P1) (forEach Piece (or (if (and {(= 0 (count MovesThisTurn)) (all DiceEqual) (or {(is AnyDie 6) (is AnyDie 3) (is AnyDie 2)}) (= 3 (count Pieces of:(mover) in:(sites {(from)})))}) (move (from (from) level:(level)) (to (trackSite Move from:(from) "Track3" steps:(* 2 (face 97)))) (then (forEach Level (last From) FromTop (if (is Mover (who at:(last From) level:(level))) (fromTo (from (last From) level:(level)) (to (last To)))))))) (forEach Die if:(!= (pips) 0) (if (= (trackSite Move from:(from) "Track3" steps:(pips)) -2) (move Remove (from) level:(level)) (move (from (from) level:(level)) (to (trackSite Move from:(from) "Track3" steps:(pips))))) (then (if (not (all DiceUsed)) (moveAgain)))) (then (forEach Level (last To) FromTop (if (and (is Enemy (who at:(last To) level:(level))) (= 1 (count Pieces of:(who at:(last To) level:(level)) in:(sites {(last To)})))) (fromTo (from (last To) level:(level)) (to (mapEntry "Start" (who at:(last To) level:(level))))))))) P3) (if (is Mover P3) (forEach Piece (or (if (and {(= 0 (count MovesThisTurn)) (all DiceEqual) (or {(is AnyDie 6) (is AnyDie 3) (is AnyDie 2)}) (= 3 (count Pieces of:(mover) in:(sites {(from)})))}) (move (from (from) level:(level)) (to (trackSite Move from:(from) "Track1" steps:(* 2 (face 97)))) (then (forEach Level (last From) FromTop (if (is Mover (who at:(last From) level:(level))) (fromTo (from (last From) level:(level)) (to (last To)))))))) (forEach Die if:(!= (pips) 0) (if (= (trackSite Move from:(from) "Track1" steps:(pips)) -2) (move Remove (from) level:(level)) (move (from (from) level:(level)) (to (trackSite Move from:(from) "Track1" steps:(pips))))) (then (if (not (all DiceUsed)) (moveAgain)))) (then (forEach Level (last To) FromTop (if (and (is Enemy (who at:(last To) level:(level))) (= 1 (count Pieces of:(who at:(last To) level:(level)) in:(sites {(last To)})))) (fromTo (from (last To) level:(level)) (to (mapEntry "Start" (who at:(last To) level:(level))))))))) P1) (if (is Mover P4) (forEach Piece (or (if (and {(= 0 (count MovesThisTurn)) (all DiceEqual) (or {(is AnyDie 6) (is AnyDie 3) (is AnyDie 2)}) (= 3 (count Pieces of:(mover) in:(sites {(from)})))}) (move (from (from) level:(level)) (to (trackSite Move from:(from) "Track2" steps:(* 2 (face 97)))) (then (forEach Level (last From) FromTop (if (is Mover (who at:(last From) level:(level))) (fromTo (from (last From) level:(level)) (to (last To)))))))) (forEach Die if:(!= (pips) 0) (if (= (trackSite Move from:(from) "Track2" steps:(pips)) -2) (move Remove (from) level:(level)) (move (from (from) level:(level)) (to (trackSite Move from:(from) "Track2" steps:(pips))))) (then (if (not (all DiceUsed)) (moveAgain)))) (then (forEach Level (last To) FromTop (if (and (is Enemy (who at:(last To) level:(level))) (= 1 (count Pieces of:(who at:(last To) level:(level)) in:(sites {(last To)})))) (fromTo (from (last To) level:(level)) (to (mapEntry "Start" (who at:(last To) level:(level))))))))) P2) (forEach Piece (or (if (and {(= 0 (count MovesThisTurn)) (all DiceEqual) (or {(is AnyDie 6) (is AnyDie 3) (is AnyDie 2)}) (= 3 (count Pieces of:(mover) in:(sites {(from)})))}) (move (from (from) level:(level)) (to (trackSite Move from:(from) "Track4" steps:(* 2 (face 97)))) (then (forEach Level (last From) FromTop (if (is Mover (who at:(last From) level:(level))) (fromTo (from (last From) level:(level)) (to (last To)))))))) (forEach Die if:(!= (pips) 0) (if (= (trackSite Move from:(from) "Track4" steps:(pips)) -2) (move Remove (from) level:(level)) (move (from (from) level:(level)) (to (trackSite Move from:(from) "Track4" steps:(pips))))) (then (if (not (all DiceUsed)) (moveAgain)))) (then (forEach Level (last To) FromTop (if (and (is Enemy (who at:(last To) level:(level))) (= 1 (count Pieces of:(who at:(last To) level:(level)) in:(sites {(last To)})))) (fromTo (from (last To) level:(level)) (to (mapEntry "Start" (who at:(last To) level:(level))))))))) P4)))) (forEach Piece)))) (end (if (no Pieces TeamMover) (result TeamMover Win))))) 
2x12 board, with spaces as points, divided in two. Fifteen pieces per player. Two six-sided die. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. The lowest value of the dice must be played; if it cannot, the player does not move. When a player throws doubles, they play the values on each die, as well as the values on the opposite side of the dice (I.e., double 6 if double 1 is thrown, 5 if 2, 3 if 4). However, the values on the bottom can only be played if all of the top values are played. The first double throw is only played once, but every subsequent double throw is played twice, and the top values must be played twice before using the bottom values. Bottom values do not have to be played, or only some of the bottom values may be played if the player wishes. In addition, an extra throw is granted for the second and subsequent throws of doubles. Players enter their pieces onto opposite sections of the board, and proceed around the board toward the section where the opponent enters the board, and then bearing pieces off the board. A player may not land on a point with two or more of the opponent's pieces. A player's piece may land on a point with a single opponent's piece. The opponent's piece is removed from the board and must enter again. The first player to remove all of their pieces from the board wins. 
(game "Contrare Puff" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {26 12 11 10 9 8 7 5 4 3 2 1 0 13 14 15 16 17 18 20 21 22 23 24 25} P1 directed:True) (track "Track2" {27 25 24 23 22 21 20 18 17 16 15 14 13 0 1 2 3 4 5 7 8 9 10 11 12} P2 directed:True)} use:Vertex) (dice d:6 num:2) (piece "Disc" Each (forEach Die replayDouble:(= 1 (value Player Mover)) if:(!= (pips) 0) (if (= (trackSite Move from:(from) steps:(pips)) -1) (move Remove (from)) (move (from (from)) (to (trackSite Move from:(from) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite (who at:(to))))))))) (then (if (not (all DiceUsed)) (moveAgain) (if (= 1 (value Player Mover)) (if (and (all DiceEqual) (= 0 (size Array (values Remembered)))) (and (moveAgain) (set Var "PlayOpposite" 1))) (set Value Mover 1)))))) (hand Each)}) (rules (start {(place Stack "Disc1" (handSite P1) count:15) (place Stack "Disc2" (handSite P2) count:15)}) (play (do (if (or (is Pending) (not (is Prev Mover))) (roll)) next:(if (= 1 (var "PlayOpposite")) (or {(forEach Piece (forEach Value (values Remembered "Opposite") (if (= (trackSite Move from:(from) steps:(value)) -1) (move Remove (from)) (move (from (from)) (to (trackSite Move from:(from) steps:(value)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply (and (if (is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next)))) (forget Value "Opposite" (value)))))) (then (if (!= 0 (size Array (values Remembered "Opposite"))) (moveAgain) (and {(set Var "PlayOpposite" 0) (set Pending) (moveAgain)}))))) top:True) (forEach Piece container:(mover) (forEach Value (values Remembered "Opposite") (if (= (trackSite Move from:(from) steps:(value)) -1) (move Remove (from)) (move (from (from)) (to (trackSite Move from:(from) steps:(value)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply (and (if (is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next)))) (forget Value "Opposite" (value)))))) (then (if (!= 0 (size Array (values Remembered "Opposite"))) (moveAgain) (and {(set Var "PlayOpposite" 0) (set Pending) (moveAgain)}))))) top:True) (move Pass (then (and {(forget Value "Opposite" All) (set Var "PlayOpposite" 0) (set Pending) (moveAgain)})))}) (do (if (and {(= 0 (count MovesThisTurn)) (all DiceEqual) (= 1 (value Player Mover))}) (and (remember Value "Opposite" (- 7 (face 28))) (remember Value "Opposite" (- 7 (face 28))))) next:(or (forEach Piece top:True) (forEach Piece container:(mover) top:True)))))) (end (if (no Pieces Mover) (result Mover Win))))) 
2x12 board, divided in half. Spaces on each side take the form of semi-circular sockets, into which the pieces fit. Twelve pieces per player. Pieces begin on one half of a player's side of the board (the half to the left of one player, and to the right of the other player), two per space, stacked on top of one another. Three dice. To begin, a player must first unstack their pieces, by rolling the number of the space on which the stack is located, and thus removing the stack, but keeping the piece on the same space. Once complete, pieces move in a track the long way around the board toward the portion where the opponent begins. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. No more than two pieces can occupy a space at a time. When a piece lands on a space occupied by a single piece of the opponent, the opponent's piece is removed from the board. Players attempt to bear off their pieces by rolling the exact number of spaces left on the board, plus one. When unstacking the pieces in the beginning or when bearing off at the end, if the player cannot play their roll but the opponent is able, the opponent may use the roll. The first player to bear off all of their pieces wins. 
(game "Doblet" (players 2) (equipment {(board (merge {(rectangle 1 6) (shift 7 0 (rectangle 1 6)) (shift 0 6 (rectangle 1 6)) (shift 7 6 (rectangle 1 6))}) {(track "Track1" {0 1 2 3 4 5 6 7 8 9 10 11 23 22 21 20 19 18 17 16 15 14 13 12 -2} P1 directed:True) (track "Track2" {12 13 14 15 16 17 18 19 20 21 22 23 11 10 9 8 7 6 5 4 3 2 1 0 -2} P2 directed:True)} use:Vertex) (dice d:6 num:3) (piece "Disc" Each (forEach Die if:(!= (pips) 0) (if (= (trackSite Move steps:(pips)) -2) (move Remove (from)) (move (from) (to (trackSite Move steps:(pips)) if:(< (size Stack at:(trackSite Move steps:(pips))) 2) (apply (if (is Enemy (who at:(to))) (remove (to))))))))) (map "StartTrack" {(pair P1 0) (pair P2 12)})}) (rules (start {(place Stack "Disc1" (sites {0 1 2 3 4 5}) count:2 state:1) (place Stack "Disc2" (sites {12 13 14 15 16 17}) count:2 state:1)}) phases:{(phase "UnStacking" (play (do (if (not (is Prev Mover)) (roll)) next:(forEach Die if:(!= (pips) 0) (if (= (state at:(trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) 1) (move Select (from (trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) (then (and {(set State at:(last To) 0) (if (not (all DiceUsed)) (moveAgain))}))))))) (nextPhase Mover (all Sites (sites Occupied by:Mover) if:(not (= (state at:(site)) 1))) "BearingOff")) (phase "BearingOff" (play (do (if (not (is Prev Mover)) (roll)) next:(forEach Piece top:True) (then (if (and (not (was Pass)) (not (all DiceUsed))) (moveAgain))))))} (end (if (no Pieces Mover) (result Mover Win))))) 
Played on a nxn board. Each player has n-1 cars, that can move either forward or up and down. Cars can leave the board once they have reached the opposite edge. First player to run out of legal moves wins. The game is played on a 3x3 board.
(game "Dodgem" (players 2) (equipment {(board (square 3)) (piece "Car" P1 E (if (is In (from) (sites Right)) (move Remove (from)) (move Step (directions {Forward Leftward Rightward}) (to if:(is Empty (to)))))) (piece "Car" P2 N (if (is In (from) (sites Top)) (move Remove (from)) (move Step (directions {Forward Leftward Rightward}) (to if:(is Empty (to))))))}) (rules (start {(place "Car1" (difference (sites Left) (sites {"A1"}))) (place "Car2" (difference (sites Bottom) (sites {"A1"})))}) (play (forEach Piece)) (end (if (no Pieces Mover) (result Mover Win))))) 
2x12 board, divided in half, where the spaces are rendered as points. Fifteen pieces per player. Two six-sided dice. Play occurs only in two quadrants of the board, opposite one another, a player's pieces only leaving their quadrant to bear off. Two pieces are stacked each on the first three points, and three are stacked in the second three points. Players use throws to unstack pieces on their points, unstacking one piece per die which corresponds to that point. Doubles allow the player to unstack or bear off a number of pieces equal to the total number of the throw. When all of the pieces are unstacked, that player may begin bearing their pieces off. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. The first player to bear off all their pieces wins. 
(game "Dubblets" (players 2) (equipment {(board (merge {(rectangle 1 6) (shift 7 0 (rectangle 1 6)) (shift 0 6 (rectangle 1 6)) (shift 7 6 (rectangle 1 6))}) {(track "Track1" {0 1 2 3 4 5} P1 directed:True) (track "Track2" {12 13 14 15 16 17} P2 directed:True)} use:Vertex) (dice d:6 num:2) (piece "Disc" Each (forEach Die if:(!= (pips) 0) (if (= (trackSite Move steps:(pips)) -1) (move Remove (from)) (move (from) (to (trackSite Move steps:(pips))))))) (hand Each) (map "StartTrack" {(pair P1 0) (pair P2 12)})}) (rules (start {(place Stack "Disc1" (sites {0 1 2}) count:2) (place Stack "Disc1" (sites {3 4 5}) count:3) (place Stack "Disc2" (sites {12 13 14}) count:2) (place Stack "Disc2" (sites {15 16 17}) count:3)}) phases:{(phase "UnStacking" (play (do (if (not (is Prev Mover)) (roll)) next:(if (or (< 0 (var "Double")) (all DiceEqual)) (do (if (>= 0 (var "Double")) (set Var "Double" (count Pips))) next:(forEach Site (sites Occupied by:Mover) (if (= (state at:(site)) 0) (move Select (from (site)) (then (if (= 3 (size Stack at:(last To))) (forEach Level (last To) (set State at:(last To) level:(level) 1)) (forEach Level (last To) (set State at:(last To) level:(level) 2))))) (if (= (state at:(site)) 1) (move Select (from (site)) (then (forEach Level (last To) (set State at:(last To) level:(level) 2)))))) (then (and (if (< 1 (var "Double")) (moveAgain)) (set Var "Double" (- (var "Double") 1)))))) (forEach Die if:(!= (pips) 0) (or (if (= (state at:(trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) 0) (move Select (from (trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) (then (and (if (= 3 (size Stack at:(last To))) (forEach Level (last To) (set State at:(last To) level:(level) 1)) (forEach Level (last To) (set State at:(last To) level:(level) 2))) (if (not (all DiceUsed)) (moveAgain)))))) (if (= (state at:(trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) 1) (move Select (from (trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) (then (and (forEach Level (last To) (set State at:(last To) level:(level) 2)) (if (not (all DiceUsed)) (moveAgain))))))))))) (nextPhase Mover (all Sites (sites Occupied by:Mover) if:(not (or (= (state at:(site)) 0) (= (state at:(site)) 1)))) "BearingOff")) (phase "BearingOff" (play (do (if (not (is Prev Mover)) (roll)) next:(if (or (< 0 (var "Double")) (all DiceEqual)) (do (if (>= 0 (var "Double")) (set Var "Double" (count Pips))) next:(forEach Site (sites Occupied by:Mover) (move Remove (site)) (then (and (if (< 1 (var "Double")) (moveAgain)) (set Var "Double" (- (var "Double") 1)))))) (forEach Piece top:True)) (then (if (not (all DiceUsed)) (moveAgain))))) (end (if (no Pieces Mover) (result Mover Win))))})) 
Four players. Circular board, with 24 semi-circular sockets along the circumference, divided into four sections of six. Twelve pieces per player; the player's colors are green, red, black, and white, the sections to which they enter are in that order anti-clockwise around the board. Three seven-sided dice. Play proceeds in an anti-clockwise fashion around the board, as is the order of player turns. Players enter their pieces on the board according to the throws of the dice. The player must enter all of their pieces, and then attempt to move all of their pieces in the section of the board belonging to the player sitting opposite them. Once the player achieves this, they begin bearing their pieces off the board. When a piece lands on a spot occupied by a single piece belonging to the opponent, the opponent's piece is returned to the place where it started. When a player bears off all their pieces, they win.
(game "El Mundo" (players 4) (equipment {(board (concentric {24}) {(track "Track1" {24 0 2 4 6 8 10 12 14 16 18 20 22 23 21 19 17 15 13} P1 directed:True) (track "Track2" {25 12 14 16 18 20 22 23 21 19 17 15 13 11 9 7 5 3 1} P2 directed:True) (track "Track3" {26 23 21 19 17 15 13 11 9 7 5 3 1 0 2 4 6 8 10} P3 directed:True) (track "Track4" {27 11 9 7 5 3 1 0 2 4 6 8 10 12 14 16 18 20 22} P4 directed:True)} use:Vertex) (dice d:7 num:3) (regions "Mundo" P1 {23 21 19 17 15 13}) (regions "Mundo" P2 {11 9 7 5 3 1}) (regions "Mundo" P3 {0 2 4 6 8 10}) (regions "Mundo" P4 {12 14 16 18 20 22}) (piece "Marker" Each (forEach Die if:(!= (pips) 0) (if (and (no Pieces Mover in:(union (sites Hand Mover) (difference (sites Board) (sites Mover "FinalQuadrant")))) (= (trackSite Move from:(from) steps:(pips)) -1)) (move Remove (from)) (move (from (from)) (to (trackSite Move from:(from) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite (who at:(to))))))))) (then (if (not (all DiceUsed)) (moveAgain))))) (map "Entry" {(pair P1 0) (pair P2 6) (pair P3 12) (pair P4 18)}) (hand Each) (regions "FinalQuadrant" P1 (sites {13 15 17 19 21 23})) (regions "FinalQuadrant" P2 (sites {1 3 5 7 9 11})) (regions "FinalQuadrant" P3 (sites {10 8 6 4 2 0})) (regions "FinalQuadrant" P4 (sites {22 20 18 16 14 12}))}) (rules (start {(place Stack "Marker1" (handSite P1) count:12) (place Stack "Marker2" (handSite P2) count:12) (place Stack "Marker3" (handSite P3) count:12) (place Stack "Marker4" (handSite P4) count:12)}) (play (do (if (not (is Prev Mover)) (roll)) next:(or (forEach Piece top:True) (forEach Piece container:(mover) top:True)))) (end (if (no Pieces Mover) (result Mover Win))))) 
2x12 board, divided in half. Spaces on each side take the form of semi-circular sockets, into which the pieces fit. Fifteen pieces per player. Three six-sided dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. One player begins with all of their pieces on the space furthest to the left on their side, the other with their pieces on the point directly opposite it. Pieces move in opposite directions around the board, toward the point where the opponent's pieces begin, and bearing off the board from there. A player cannot have two of their pieces on the same spot in the starting quadrant. When a piece lands on the same space as a single opponent's piece, the opponent's piece is sent back to where it began. The first person to bear off all their pieces wins. If players move their pieces such that they fill up all the points in a quadrant, and the other fills up all of the points in an adjacent quadrant such that neither player can move, the game is a draw. It is a prime win when one player has twelve pieces arranged on consecutive points so that the other player cannot pass them. When the player sends four pieces back to the beginning while preserving this state, it is a prime win.
(game "Emperador" (players 2) (equipment {(board (merge {(rectangle 1 6) (shift 7 0 (rectangle 1 6)) (shift 0 6 (rectangle 1 6)) (shift 7 6 (rectangle 1 6))}) {(track "Track1" {24 0 1 2 3 4 5 6 7 8 9 10 11 23 22 21 20 19 18 17 16 15 14 13 12} P1 directed:True) (track "Track2" {25 12 13 14 15 16 17 18 19 20 21 22 23 11 10 9 8 7 6 5 4 3 2 1 0} P2 directed:True)} use:Vertex) (dice d:6 num:3) (hand Each) (regions "StartingQuadrant" P1 (sites {0 1 2 3 4 5})) (regions "StartingQuadrant" P2 (sites {12 13 14 15 16 17})) (piece "Disc" Each (forEach Die if:(!= (pips) 0) (if (= (trackSite Move steps:(pips)) -1) (move Remove (from)) (if (or {(is Empty (trackSite Move steps:(pips))) (and (is Friend (who at:(trackSite Move steps:(pips)))) (if (is In (to) (sites Mover "StartingQuadrant")) (not (= 1 (size Stack at:(trackSite Move steps:(pips))))) True)) (and (is Enemy (who at:(trackSite Move steps:(pips)))) (= 1 (size Stack at:(trackSite Move steps:(pips)))))}) (move (from) (to (trackSite Move steps:(pips)) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite (who at:(to))))))))))))}) (rules (start {(place Stack "Disc1" 0 count:15) (place Stack "Disc2" 12 count:15)}) (play (do (if (not (is Prev Mover)) (roll)) next:(or (forEach Piece top:True) (forEach Piece container:(mover) top:True) (then (if (not (all DiceUsed)) (moveAgain)))))) (end {(if (no Pieces Mover) (result Mover Win)) (if (and (no Moves P1) (no Moves P2)) (result Mover Draw))}))) 
2x12 board, divided in half. Spaces on each side take the form of semi-circular sockets, into which the pieces fit. Fifteen pieces per player. Play begins with thirteen pieces on the seventh point of the track, and two pieces on the twelfth point. Three six-sided dice. Players move pieces according to the value of each individual die. Play moves around the board through starting from the quadrant where the pieces begin, through the one where the opponent's pieces begin, and then through the remaining quadrant on the opponent's side of the board, where the pieces are borne off the board. When a piece lands on a spot occupied by a single piece of the opponent, the opponent's piece is sent back to its starting quadrant. If a player's piece is sent back to start, but all of the spaces in their starting quadrant are occupied by the opponent's pieces, the player loses automatically. Also, any roll that allows the player to only move to spaces occupied by the opponent results in an automatic loss for the player. Otherwise, the first player to bear off all their pieces wins.
(game "Fallas" (players 2) (equipment {(board (merge {(rectangle 1 6) (shift 7 0 (rectangle 1 6)) (shift 0 6 (rectangle 1 6)) (shift 7 6 (rectangle 1 6))}) {(track "Track1" {0 1 2 3 4 5 6 7 8 9 10 11 23 22 21 20 19 18 17 16 15 14 13 12} P1 directed:True) (track "Track2" {12 13 14 15 16 17 18 19 20 21 22 23 11 10 9 8 7 6 5 4 3 2 1 0} P2 directed:True)} use:Vertex) (dice d:6 num:3) (piece "Disc" Each (forEach Die if:(!= (pips) 0) (if (= (trackSite Move from:(from) steps:(pips)) -1) (move Remove (from)) (move (from (from)) (to (trackSite Move from:(from) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply (if (is Enemy (who at:(to))) (if (= (count Sites in:(difference (sites Next "StartQuadrant") (union (sites {(to)}) (sites Occupied by:Mover)))) 0) (and (remove (to)) (trigger "StartQuadrantFull" Next)) (fromTo (from (to)) (to (if (and (!= (to) (regionSite (sites Next "StartQuadrant") index:0)) (not (is Friend (who at:(regionSite (sites Next "StartQuadrant") index:0))))) (regionSite (sites Next "StartQuadrant") index:0) (if (and (!= (to) (regionSite (sites Next "StartQuadrant") index:1)) (not (is Friend (who at:(regionSite (sites Next "StartQuadrant") index:1))))) (regionSite (sites Next "StartQuadrant") index:1) (if (and (!= (to) (regionSite (sites Next "StartQuadrant") index:2)) (not (is Friend (who at:(regionSite (sites Next "StartQuadrant") index:2))))) (regionSite (sites Next "StartQuadrant") index:2) (if (and (!= (to) (regionSite (sites Next "StartQuadrant") index:3)) (not (is Friend (who at:(regionSite (sites Next "StartQuadrant") index:3))))) (regionSite (sites Next "StartQuadrant") index:3) (if (and (!= (to) (regionSite (sites Next "StartQuadrant") index:4)) (not (is Friend (who at:(regionSite (sites Next "StartQuadrant") index:4))))) (regionSite (sites Next "StartQuadrant") index:4) (if (and (!= (to) (regionSite (sites Next "StartQuadrant") index:5)) (not (is Friend (who at:(regionSite (sites Next "StartQuadrant") index:5))))) (regionSite (sites Next "StartQuadrant") index:5) (regionSite (sites Next "StartQuadrant") index:6))))))))))))))) (then (if (not (all DiceUsed)) (moveAgain))))) (regions "StartQuadrant" P1 (sites {6 7 8 9 10 11})) (regions "StartQuadrant" P2 (sites {18 19 20 21 22 23}))}) (rules (start {(place Stack "Disc1" 7 count:13) (place Stack "Disc1" 11 count:2) (place Stack "Disc2" 19 count:13) (place Stack "Disc2" 23 count:2)}) (play (do (if (not (is Prev Mover)) (roll)) next:(forEach Piece))) (end {(if (no Pieces Mover) (result Mover Win)) (if (is Triggered "StartQuadrantFull" P1) (result P2 Win)) (if (is Triggered "StartQuadrantFull" P2) (result P1 Win)) (if (and (not (is Prev Mover)) (no Moves Mover)) (result Mover Loss))}))) 
Played on a standard Backgammon board. Each player has fifteen pieces, which all begin on the leftmost point on each player's side of the board. Both players move anti-clockwise around the board. Both players roll one die, and the player with the higher number plays first. If it is played after another game, the winner of the previous game goes first. The player rolls two die and begins play with that roll. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. When doubles are thrown, they are played twice. If a player can only play one number but not both, they must play the higher number, if possible. To begin, each player may only move one piece, until it passes the opponent's starting point, after which any pieces can be moved. Pieces may only be moved to an empty point or one occupied by another piece belonging to the player. Players may not block all six points in either player's starting quadrant. If a player has blocked six points in a row, and the opponent has moved all of their pieces to the point adjacent to the blocked points, the player must move to unblock one of the points. Once a player has moved all of their pieces into the final six points of their track, they may begin bearing off. They do so by rolling a number equal to the number of points left in the track, plus one. If they cannot bear off, they must make a legal move with a piece that cannot bear off. If no such move is available, then they must bear off the piece which is furthest from the goal. The first player to bear off all their pieces wins the game and gets one point. If the winner bears off all their pieces before the opponent bears off any, they get two points. 
(game "Fevga" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {0 1 2 3 4 5 7 8 9 10 11 12 25 24 23 22 21 20 18 17 16 15 14 13 -2} P1 directed:True) (track "Track2" {25 24 23 22 21 20 18 17 16 15 14 13 0 1 2 3 4 5 7 8 9 10 11 12 -2} P2 directed:True)} use:Vertex) (dice num:2) (regions "Home" P1 {20 21 22 23 24 25}) (regions "Home" P2 {7 8 9 10 11 12}) (regions "Side" P1 {0 1 2 3 4 5 6 7 8 9 10 11 12}) (regions "Side" P2 {13 14 15 16 17 18 19 20 21 22 23 24 25}) (map {(pair 1 0) (pair 2 25)}) (piece "Disc" Each (forEach Die replayDouble:True if:(and {(!= (pips) 0) (!= (trackSite Move from:(from) steps:(pips)) -1) (!= (trackSite Move from:(from) steps:(pips)) -2)}) (if (or {(not (= (from) (mapEntry (mover)))) (and (= (from) (mapEntry (mover))) (!= (topLevel at:(from)) 13)) (not (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover "Side"))))}) (move (from (from)) (to (trackSite Move from:(from) steps:(pips)) if:(not (is Enemy (who at:(to)))))))))}) (rules (start {(place Stack "Disc1" 0 count:15) (place Stack "Disc2" 25 count:15)}) (play (do (if (not (is Prev Mover)) (roll)) next:(if (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover "Home"))) (forEach Die replayDouble:True if:(!= (pips) 0) (forEach Site (sites Occupied by:Mover) (if (and (is Occupied (site)) (!= (trackSite Move from:(site) steps:(pips)) -1)) (if (= (trackSite Move from:(site) steps:(pips)) -2) (move Remove (site)) (move (from (site)) (to (trackSite Move from:(site) steps:(pips)) if:(not (is Enemy (who at:(to)))))))) noMoveYet:(firstMoveOnTrack "Track" Mover (if (and (is Friend (who at:(site))) (< (trackSite Move from:(site) steps:(pips)) 0)) (move Remove (site)))) (then (if (not (all DiceUsed)) (moveAgain))))) (max Distance "Track" Mover (forEach Piece top:True (then (if (not (all DiceUsed)) (moveAgain)))))))) (end (if (no Pieces Mover) (byScore {(score P1 (if (is Mover P1) (if (= (size Stack in:(sites Occupied by:P2)) 15) 2 1) 0)) (score P2 (if (is Mover P2) (if (= (size Stack in:(sites Occupied by:P1)) 15) 2 1) 0))}))))) 
The game is played on a board with twelve points on either side. The points form a continuous track in a horseshoe shape; each player progresses in opposite directions (one from their bottom right to the top right, the other from their bottom left to their top left. Each player has 15 pieces. The starting position is as such, numbering the points from the origin of each player's track: Point six: five pieces. Point 8: three pieces. Point 13: five pieces. Point 24: two pieces. Play begins by each player rolling one die; the player who rolls the highest plays first, and then rolls again to begin play. Players move according to the number on each die by moving one piece the number on one die and another the number on the other die, or by moving one piece twice (once for each die). If doubles are rolled, the player must play the number on each die twice. Players cannot end their move on a point with multiple opposing pieces. If a player ends the turn on a point with one opposing piece, that piece is placed in the middle of the board (not on a point) and must reenter the board according the the next die roll, counting the origin point as a move of one. They cannot reenter on a point with two or more pieces. No other pieces can move until all of the pieces belonging to that player are removed from the center. When all of a player's pieces are on their final six points, they may start removing pieces from the board. They can do so by rolling a 6 to move from the 6th point, and so on down to 1. Players must use all available moves presented by the dice. The first player to remove all of their pieces wins. 
(game "Frangieh" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {6 12 11 10 9 8 7 5 4 3 2 1 0 13 14 15 16 17 18 20 21 22 23 24 25 -2} P1 directed:True) (track "Track2" {19 25 24 23 22 21 20 18 17 16 15 14 13 0 1 2 3 4 5 7 8 9 10 11 12 -2} P2 directed:True)} use:Vertex) (dice num:2) (regions P1 {20 21 22 23 24 25}) (regions P2 {7 8 9 10 11 12}) (map {(pair 1 6) (pair 2 19)}) (piece "Disc" Each (forEach Die replayDouble:True if:(and {(!= (pips) 0) (!= (trackSite Move from:(from) steps:(pips)) -1) (!= (trackSite Move from:(from) steps:(pips)) -2)}) (move (from (from)) (to (trackSite Move from:(from) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (next)))))))))}) (rules (start {(place Stack "Disc1" 0 count:5) (place Stack "Disc1" 12 count:2) (place Stack "Disc1" 17 count:3) (place Stack "Disc1" 20 count:5) (place Stack "Disc2" 4 count:3) (place Stack "Disc2" 7 count:5) (place Stack "Disc2" 13 count:5) (place Stack "Disc2" 25 count:2)}) (play (do (if (not (is Prev Mover)) (roll)) next:(if (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover))) (forEach Die replayDouble:True if:(!= (pips) 0) (forEach Site (sites Occupied by:Mover) (if (and (is Occupied (site)) (!= (trackSite Move from:(site) steps:(pips)) -1)) (if (= (trackSite Move from:(site) steps:(pips)) -2) (move Remove (site)) (move (from (site)) (to (trackSite Move from:(site) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (next))))))))) noMoveYet:(firstMoveOnTrack "Track" Mover (if (and (is Friend (who at:(site))) (< (trackSite Move from:(site) steps:(pips)) 0)) (move Remove (site)))) (then (if (not (all DiceUsed)) (moveAgain))))) (if (is Empty (mapEntry (mover))) (forEach Piece top:True) (forEach Die replayDouble:True if:(!= (pips) 0) (move (from (mapEntry (mover))) (to (trackSite Move from:(mapEntry (mover)) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (next)))))))) (then (if (not (all DiceUsed)) (if (can Move (if (is Empty (mapEntry (mover))) (forEach Piece top:True) (forEach Die replayDouble:True if:(!= (pips) 0) (move (from (mapEntry (mover))) (to (trackSite Move from:(mapEntry (mover)) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (next)))))))))) (moveAgain)))))))) (end (if (no Pieces Mover) (result Mover Win))))) 
The game is played on a board with twelve points on either side. The points form a continuous track in a horseshoe shape; each player progresses in opposite directions (one from their bottom right to the top right, the other from their bottom left to their top left). Each player has fifteen pieces, which all begin on the first point of their track. Three dice are used. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. When a player rolls triples, the throw is played three times. If a player throws a pair among the three dice, they play the dice as normal if the third die has a greater value than the value which appears twice. If the value of the third die is lower, the player plays the doubles twice and the single value once. When a piece lands on a point with a single piece belonging to the opponent, the opponent's piece is removed from the board and must enter again from the quadrant of the board from which it began. When a piece reaches the end of the track, it may bear off the board with a throw greater than the number of points remaining in the track. The player who bears off all their pieces first wins. 
(game "Garanguet" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {6 12 11 10 9 8 7 5 4 3 2 1 0 13 14 15 16 17 18 20 21 22 23 24 25} P1 directed:True) (track "Track2" {19 25 24 23 22 21 20 18 17 16 15 14 13 0 1 2 3 4 5 7 8 9 10 11 12} P2 directed:True)} use:Vertex) (dice num:3) (piece "Disc" Each) (map {(pair 1 6) (pair 2 19)}) (regions "Home" P1 {7 8 9 10 11 12}) (regions "Home" P2 {20 21 22 23 24 25})}) (rules (start {(place Stack "Disc1" 12 count:15) (place Stack "Disc2" 25 count:15)}) (play (do (if (not (is Prev Mover)) (roll)) next:(if (all DiceEqual) (forEach Site (sites Occupied by:Mover) (if (= (trackSite Move from:(site) steps:(/ (count Pips) 3)) -1) (move Remove (site)) (move (from (site)) (to (trackSite Move from:(site) steps:(/ (count Pips) 3)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (next)))))))) (then (if (< (value Player Mover) 8) (and (moveAgain) (if (< (value Player Mover) 0) (set Value Mover 1) (set Value Mover (+ 1 (value Player Mover))))) (set Value Mover 0)))) (if (or {(and (= (face 26) (face 27)) (> (face 26) (face 28))) (and (= (face 26) (face 28)) (> (face 26) (face 27))) (and (= (face 27) (face 28)) (> (face 27) (face 26)))}) (or (if (not (and (= (value Player Mover) 0) (!= (count MovesThisTurn) 0))) (forEach Site (sites Occupied by:Mover) (if (= (trackSite Move from:(site) steps:(if (and (= (face 26) (face 27)) (> (face 26) (face 28))) (face 26) (if (and (= (face 26) (face 28)) (> (face 26) (face 27))) (face 26) (face 27)))) -1) (move Remove (site)) (move (from (site)) (to (trackSite Move from:(site) steps:(if (and (= (face 26) (face 27)) (> (face 26) (face 28))) (face 26) (if (and (= (face 26) (face 28)) (> (face 26) (face 27))) (face 26) (face 27)))) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (next)))))))) (then (and (if (< (count MovesThisTurn) 4) (moveAgain)) (if (< (value Player Mover) 3) (if (< (value Player Mover) 0) (set Value Mover 1) (set Value Mover (+ 1 (value Player Mover)))) (set Value Mover 0)))))) (if (or (or (= (count MovesThisTurn) (value Player Mover)) (and (= (count MovesThisTurn) 0) (< (value Player Mover) 0))) (and (!= (count MovesThisTurn) 0) (= (value Player Mover) 0))) (forEach Site (sites Occupied by:Mover) (if (= (trackSite Move from:(site) steps:(if (and (= (face 26) (face 27)) (> (face 26) (face 28))) (face 28) (if (and (= (face 26) (face 28)) (> (face 26) (face 27))) (face 27) (face 26)))) -1) (move Remove (site)) (move (from (site)) (to (trackSite Move from:(site) steps:(if (and (= (face 26) (face 27)) (> (face 26) (face 28))) (face 28) (if (and (= (face 26) (face 28)) (> (face 26) (face 27))) (face 27) (face 26)))) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (next)))))))) (then (if (< (count MovesThisTurn) 4) (moveAgain) (set Value Mover 0)))))) (forEach Die if:(!= (pips) 0) (forEach Site (sites Occupied by:Mover) (if (= (trackSite Move from:(site) steps:(pips)) -1) (move Remove (site)) (move (from (site)) (to (trackSite Move from:(site) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (next)))))))) (then (if (not (all DiceUsed)) (moveAgain))))))))) (end (if (no Pieces Mover) (result Mover Win))))) 
Played on a board with 36 holes arranged in a square, with a gap in the center of each side. There are arcs of five holes branching from opposite corners. Can be played with two to four players, who can also play on teams. One or two pieces per player. Four stick dice are used, with one marked side. Each die is marked differently for a different value: 4, 6, 14, 15. The throws are as follows: All marked sides up = 5; three marked sides up = 3; two marked sides up = 2, one marked side up = the value of the marked side; zero marked sides up = 10. Players’ pieces enter on the branching arcs. The second piece cannot enter before the first one leaves the arc. Each player can choose which direction they wish to move around the board, but they must continue in this direction for the rest of the game. If a player lands on the same spot as the opponent, the opponent’s piece is removed from the board and must re-enter. Player must make an exact throw to get a piece off the board after reentering the arc from the spot where the player entered the board. The player to get both of their pieces off the board first wins. 2 players. Each player has 2 pieces.
(game "Ghingskoot" (players 2) (equipment {(board (add (merge {(shift -1.25 -0.34 (rotate 30 (rectangle 6 1))) (rectangle 1 5) (rectangle 5 1) (shift 0 6 (rectangle 5 1)) (shift 0 10 (rectangle 1 5)) (shift 7 0 (rectangle 1 5)) (shift 7 10 (rectangle 1 5)) (shift 11 0 (rectangle 5 1)) (shift 11 6 (rectangle 5 1)) (shift 12.25 5.33 (rotate 30 (rectangle 6 1)))}) edges:{{13 14} {22 28} {37 36} {9 23}}) {(track "TrackCW1" "46,5,SSE,N,E,S,W,NNW,End" P1 directed:True) (track "TrackCCW1" "46,5,SSE,E,N,W,S,NNW,End" P1 directed:True) (track "TrackCW2" "47,41,NNW,S,W,N,E,SSE,End" P2 directed:True) (track "TrackCCW2" "47,41,NNW,W,S,E,N,SSE,End" P2 directed:True)} use:Vertex) (regions "AllSites" (sites Board)) (regions "Arc" P1 (sites {1 2 3 4 5})) (regions "Arc" P2 (sites {41 42 43 44 45})) (regions "AllSitesDifferentThanArc" (difference (sites Board) (union {(sites P1 "Arc") (sites P2 "Arc") (sites {0 32})}))) (dice d:2 facesByDie:{{0 4} {0 6} {0 14} {0 15}} num:4) (piece "Marker" Each (if (= (state at:(from)) 0) (if (or (!= (from) (handSite Mover)) (and (= (from) (handSite Mover)) (all Sites (sites Mover "Arc") if:(!= (who at:(site)) Mover)))) (or (if (= (trackSite Move "TrackCW" steps:(mapEntry "Throw" (count Pips))) -2) (move Remove (from)) (if (!= (trackSite Move "TrackCW" steps:(mapEntry "Throw" (count Pips))) -1) (if (not (is Friend (who at:(trackSite Move "TrackCW" steps:(mapEntry "Throw" (count Pips)))))) (move (from) (to (trackSite Move "TrackCW" steps:(mapEntry "Throw" (count Pips))) (apply if:(is Enemy (who at:(to))) (and (set State at:(to) 0) (fromTo (from (to)) (to (handSite Next))))))))) (then (if (and (= (state at:(last To)) 0) (is In (last To) (sites "AllSitesDifferentThanArc"))) (set State at:(last To) 1)))) (if (= (trackSite Move "TrackCCW" steps:(mapEntry "Throw" (count Pips))) -2) (move Remove (from)) (if (!= (trackSite Move "TrackCCW" steps:(mapEntry "Throw" (count Pips))) -1) (if (not (is Friend (who at:(trackSite Move "TrackCCW" steps:(mapEntry "Throw" (count Pips)))))) (move (from) (to (trackSite Move "TrackCCW" steps:(mapEntry "Throw" (count Pips))) (apply if:(is Enemy (who at:(to))) (and (set State at:(to) 0) (fromTo (from (to)) (to (handSite Next))))))))) (then (if (and (= (state at:(last To)) 0) (is In (last To) (sites "AllSitesDifferentThanArc"))) (set State at:(last To) 2)))))) (if (= (if (= (state at:(from)) 2) (trackSite Move "TrackCCW" steps:(mapEntry "Throw" (count Pips))) (trackSite Move "TrackCW" steps:(mapEntry "Throw" (count Pips)))) -2) (move Remove (from)) (if (!= (if (= (state at:(from)) 2) (trackSite Move "TrackCCW" steps:(mapEntry "Throw" (count Pips))) (trackSite Move "TrackCW" steps:(mapEntry "Throw" (count Pips)))) -1) (if (not (is Friend (who at:(if (= (state at:(from)) 2) (trackSite Move "TrackCCW" steps:(mapEntry "Throw" (count Pips))) (trackSite Move "TrackCW" steps:(mapEntry "Throw" (count Pips))))))) (move (from) (to (if (= (state at:(from)) 2) (trackSite Move "TrackCCW" steps:(mapEntry "Throw" (count Pips))) (trackSite Move "TrackCW" steps:(mapEntry "Throw" (count Pips)))) (apply if:(is Enemy (who at:(to))) (and (set State at:(to) 0) (fromTo (from (to)) (to (handSite Next)))))))))))) (hand Each) (map "Throw" {(pair 0 10) (pair 39 5) (pair 24 3) (pair 25 3) (pair 35 3) (pair 33 3) (pair 10 2) (pair 18 2) (pair 19 2) (pair 20 2) (pair 21 2) (pair 29 2)})}) (rules (start (place "Marker" "Hand" count:2)) (play (do (roll) next:(or (forEach Piece) (forEach Piece container:(mover))))) (end (if (no Pieces Mover) (result Mover Win))))) 
The game is played on a board with twelve points on either side. The points form a continuous track in a horseshoe shape; each player progresses in opposite directions (one from their bottom right to the top right, the other from their bottom left to their top left). Each player has fifteen pieces, which all begin on the first point of their track. Two dice are used. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. The maximum number of pieces per point is two, except for the starting point. Placing pieces on the twelfth point of a player's side is only allowed when it can be achieved by two pieces on the same dice roll. A player's pieces only actually move on the player's half of the board; points are awarded for any hypothetical move that would move a player's pieces along the imagined track onto the opponent's side of the board that would land on a point with a lone opposing piece (a "hit"). The player then moves pieces on their side of the board that are able to move. If the hypothetical hit is in the opponents' nearest half of the board according to the track, the player scores two points, four points if it was achieved by rolling doubles. If the hit is in the further half of the opponent's side of the board, the player scores four or six if made by doubles. Players play until one scores twelve points. The first player to win twelve games wins.
(match "Grand Trictrac" (players 2) (games {(subgame "GrandTrictracSubgame")}) (end {(if (>= (matchScore P1) 12) (result P1 Win)) (if (>= (matchScore P2) 12) (result P2 Win))})) 
3x14 board. Fourteen pieces per player, placed in the outer rows of the board. Two knucklebones used as dice. Players move their pieces according to the throws of the knucklebones. Pieces move in a boustrophedon path along the board. The first player to remove their pieces from the board wins.
(game "Had" (players 2) (equipment {(board (rectangle 3 14) {(track "Track1" "0,E,N1,W,N1,E" P1 directed:True) (track "Track2" "41,W,S1,E,S1,W" P2 directed:True)}) (dice d:4 num:2) (piece "Marker" Each (if (= (trackSite Move steps:(count Pips)) -1) (move Remove (from)) (move (from) (to (trackSite Move steps:(count Pips)) if:(is Empty (to))))))}) (rules (start {(place "Marker1" (sites Bottom)) (place "Marker2" (sites Top))}) (play (do (roll) next:(forEach Piece))) (end (if (no Pieces Mover) (result Mover Win))))) 
2x12 board, divided in half, where the spaces are rendered as points. Fifteen pieces per player. Three six-sided dice. The points form a continuous track in a horseshoe shape; each player progresses in opposite directions, one from their bottom right to the top right, the other from their bottom left to their top left. Pieces begin on the board, five each on the sixth, seventh, and eighth point in their track. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. A piece cannot move to a point that is occupied by more than one of the opponent's pieces. If a piece lands on a point occupied by a single piece belonging to the opponent, the opponent's piece is removed from the board and must enter again from the beginning of the player's track. A piece may be borne off the board when a throw is greater than the number of points left on the board. The first player to bear all of their pieces off the board wins. 
(game "Imperial" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {6 12 11 10 9 8 7 5 4 3 2 1 0 13 14 15 16 17 18 20 21 22 23 24 25} P1 directed:True) (track "Track2" {19 25 24 23 22 21 20 18 17 16 15 14 13 0 1 2 3 4 5 7 8 9 10 11 12} P2 directed:True)} use:Vertex) (dice num:3) (map {(pair 1 19) (pair 2 6)}) (piece "Disc" Each)}) (rules (start {(place Stack "Disc1" 10 count:5) (place Stack "Disc1" 11 count:5) (place Stack "Disc1" 12 count:5) (place Stack "Disc2" 23 count:5) (place Stack "Disc2" 24 count:5) (place Stack "Disc2" 25 count:5)}) (play (do (if (not (is Prev Mover)) (roll)) next:(forEach Die if:(!= (pips) 0) (forEach Site (sites Occupied by:Mover) (if (= (trackSite Move from:(site) steps:(pips)) -1) (move Remove (site)) (move (from (site)) (to (trackSite Move from:(site) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (mover))))))))) (then (if (not (all DiceUsed)) (moveAgain)))))) (end (if (no Pieces Mover) (result Mover Win))))) 
2x12 board, divided in half, where the spaces are rendered as points. Fifteen pieces per player. Pieces begin on the leftmost point on their opponent's side of the board. Two six-sided dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. When doubles are thrown, the player may move the value of one of the die (n), n times (e.g., double sixes allows a player to move 6 six times, double twos allow a player to move 2 twice). Each player progresses in a clockwise direction around the board, to bear off upon reaching the final point on the opposite side of the board from which the player started. This first piece must reach the opposite quadrant of the board from where it started before the player may enter any other pieces. In the quadrant where the players enter their pieces, that player may only have two or more pieces on a point on a maximum of two points. When a piece lands on a point occupied by a single opponent's piece, The opponent's piece is removed from the board and must enter the board again. When all of the player's pieces have entered the opposite quadrant from the one in which they entered, they may begin to bear off. The first player to bear off all their pieces wins. It is considered a double win if the player bears off all their pieces before the opponent bears off any. 
(game "Jacquet de Versailles" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {6 13 14 15 16 17 18 20 21 22 23 24 25 12 11 10 9 8 7 5 4 3 2 1 0} P1 directed:True) (track "Track2" {19 12 11 10 9 8 7 5 4 3 2 1 0 13 14 15 16 17 18 20 21 22 23 24 25} P2 directed:True)} use:Vertex) (dice num:2) (piece "Disc" Each) (map {(pair 1 6) (pair 2 19)}) (regions "Home" P1 {13 14 15 16 17 18}) (regions "Home" P2 {12 11 10 9 8 7}) (regions "OppositeQuadrant" P1 {0 1 2 3 4 5}) (regions "OppositeQuadrant" P2 {20 21 22 23 24 25})}) (rules (start {(place Stack "Disc1" 13 count:15) (place Stack "Disc2" 12 count:15)}) (play (do (do (if (not (is Prev Mover)) (roll)) next:(if (all DiceEqual) (forEach Site (sites Occupied by:Mover) (if (and (= (trackSite Move from:(site) steps:(/ (count Pips) 2)) -1) (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover "OppositeQuadrant")))) (move Remove (site)) (if (or (!= (site) (trackSite Move from:(mapEntry (mover)) steps:1)) (and (= (site) (trackSite Move from:(mapEntry (mover)) steps:1)) (or {(all Sites (difference (sites Board) (trackSite Move from:(mapEntry (mover)) steps:1)) if:(!= (who at:(site)) (mover))) (is Occupied (mapEntry (mover))) (< (size Stack at:(trackSite Move from:(mapEntry (mover)) steps:1)) 14) (not (all Sites (sites Mover "OppositeQuadrant") if:(!= (who at:(site)) (mover))))}))) (move (from (site)) (to (trackSite Move from:(site) steps:(/ (count Pips) 2)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (next))))))))) (then (if (< (value Player Mover) (- (/ (count Pips) 2) 1)) (and (moveAgain) (if (< (value Player Mover) 0) (set Value Mover 1) (set Value Mover (+ 1 (value Player Mover))))) (set Value Mover 0)))) (forEach Die if:(!= (pips) 0) (forEach Site (sites Occupied by:Mover) (if (and (= (trackSite Move from:(site) steps:(pips)) -1) (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover "OppositeQuadrant")))) (move Remove (site)) (if (or (!= (site) (trackSite Move from:(mapEntry (mover)) steps:1)) (and (= (site) (trackSite Move from:(mapEntry (mover)) steps:1)) (or {(all Sites (difference (sites Board) (trackSite Move from:(mapEntry (mover)) steps:1)) if:(!= (who at:(site)) (mover))) (is Occupied (mapEntry (mover))) (< (size Stack at:(trackSite Move from:(mapEntry (mover)) steps:1)) 14) (not (all Sites (sites Mover "OppositeQuadrant") if:(!= (who at:(site)) (mover))))}))) (move (from (site)) (to (trackSite Move from:(site) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (next)))))))))) (then (if (not (all DiceUsed)) (moveAgain)))))) ifAfterwards:(<= (count Sites in:(forEach (intersection (sites Occupied by:Mover) (sites Mover "Home")) if:(>= (size Stack at:(site)) 2))) 2))) (end {(if (no Pieces Mover) (byScore {(score P1 (if (is Mover P1) (if (= (size Stack in:(sites Occupied by:P2)) 15) 2 1) 0)) (score P2 (if (is Mover P2) (if (= (size Stack in:(sites Occupied by:P1)) 15) 2 1) 0))}))}))) 
2x12 board, divided in half, where the spaces are rendered as points. Fifteen pieces per player. Pieces begin on the leftmost point on their opponent's side of the board. Two six-sided dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. When doubles are thrown, the player plays the throw twice. Each player progresses in a clockwise direction around the board, to bear off upon reaching the final point on the opponent's side of the board. One piece must reach the opposite quadrant of the board from where it entered before the player may place more than one piece on a point. When a piece lands on a point occupied by a single opponent's piece, the opponent's piece is removed from the board and must enter the board again. When all of the player's pieces have entered the opposite quadrant from the one in which they entered, they may begin to bear off. The first player to bear off all their pieces wins.
(game "Jacquet" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {6 13 14 15 16 17 18 20 21 22 23 24 25 12 11 10 9 8 7 5 4 3 2 1 0} P1 directed:True) (track "Track2" {19 12 11 10 9 8 7 5 4 3 2 1 0 13 14 15 16 17 18 20 21 22 23 24 25} P2 directed:True)} use:Vertex) (dice num:2) (piece "Disc" Each) (map {(pair 1 6) (pair 2 19)}) (regions "Home" P1 {13 14 15 16 17 18}) (regions "Home" P2 {12 11 10 9 8 7}) (regions "OppositeQuadrant" P1 {0 1 2 3 4 5}) (regions "OppositeQuadrant" P2 {20 21 22 23 24 25})}) (rules (start {(place Stack "Disc1" 13 count:15) (place Stack "Disc2" 12 count:15)}) (play (do (if (not (is Prev Mover)) (roll)) next:(forEach Die replayDouble:True if:(!= (pips) 0) (forEach Site (sites Occupied by:Mover) (if (and (= (trackSite Move from:(site) steps:(pips)) -1) (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover "OppositeQuadrant")))) (move Remove (site)) (if (if (!= (site) (trackSite Move from:(mapEntry (mover)) steps:1)) True (or {(all Sites (difference (sites Board) (trackSite Move from:(mapEntry (mover)) steps:1)) if:(!= (who at:(site)) (mover))) (is Occupied (mapEntry (mover))) (< (size Stack at:(trackSite Move from:(mapEntry (mover)) steps:1)) 14) (not (all Sites (sites Mover "OppositeQuadrant") if:(!= (who at:(site)) (mover))))})) (move (from (site)) (to (trackSite Move from:(site) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (next)))))))))) (then (if (not (all DiceUsed)) (moveAgain)))))) (end (if (no Pieces Mover) (result Mover Win))))) 
The game is played on a board with twelve points on either side. The points form a continuous track in a horseshoe shape; each player progresses in opposite directions (one from their bottom right to the top right, the other from their bottom left to their top left. Two six-sided die. Each player has 15 pieces. Each player's fifteen pieces begin on the first point of their track. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. If doubles are rolled, the player must play the number on each die twice. Play begins with each player throwing the dice. The player who obtains the higher number goes first, except when doubles are thrown, then the opponent must throw higher doubles. The player who wins the opening throw moves the opponent's pieces according to the value of this throw. Play then continues as usual. A piece cannot land on a space occupied by one of the opponent's pieces. Pieces move around the board to the opposite quadrants from the player's starting position. Players may bear a piece off the board once it reaches one of the final six points on the board. Until all of the player's remaining pieces are on the final six points, the player may only bear off a piece on one of the final six spaces by throwing exactly one more than the number of remaining points. The player who bears off all of their pieces wins. The winning player's score equals the number of the opponent's pieces which are left on the board. In addition, whenever a player is unable to move and the opponent is able to, the opponent gains five points. Play continues until one player's score reaches 31. 
(match "Julbahar" (players 2) (games (subgame "JulbaharSubgame" result:(score Mover))) (end {(if (>= (matchScore P1) 31) (result P1 Win)) (if (>= (matchScore P2) 31) (result P2 Win))})) 
One horizontal row of eleven squares, the central square marked with an X. From this central square, extending vertically, eleven more squares, making a row of twelve in total. The fifth square and the final square in this row are marked with an X. An arc of five squares extend left and down from the final square of the vertical row. From the fifth row of the vertical row, a square with twelve squares per side. The corner squares are marked with an X, the central two squares of the left, right, and top side are marked with one X across both squares. Two or four players; when there are four players they play on two teams of two. Three cowrie shells per player, used as pieces. Six cowrie shells used as dice; the throws = the number of mouths that land face up. Players move their pieces onto the board and around the circuit according to the throws of the cowries. Teams start on opposite ends of the bottom row of squares, up the vertical line to the square, in opposite directions around the square, then up the remaining part of the vertical row and down the arc, and off the board. When a piece lands on a space occupied by an opponent's piece, the opponent's piece is sent back and must enter the board again. Pieces are safe from being sent back if they rest on a marked square. The first team to remove all of their pieces from the board wins.  The game involves 4 players.
(game "Kawade Kelia" (players 4) (equipment {(board (merge {(rectangle 1 12) (shift 3.5 3.25 (scale 1 1.5 (rotate 90 (rectangle 1 4)))) (shift 0 7 (rectangle 1 12)) (shift -5.5 12.5 (rotate 90 (rectangle 1 12))) (shift 2.5 10.5 (rotate 90 (rectangle 1 6))) (shift 5.5 12.5 (rotate 90 (rectangle 1 12))) (shift 0 18 (rectangle 1 11)) (shift 1 11 (rotate 45 (rectangle 1 4))) (shift 5 13 (graph vertices:{{0 0} {0 1} {-0.94 0.26} {-0.23 -0.44}} edges:{{0 1} {1 2} {2 3} {3 0}}))}) {(track "Track1" "71,0,E5,N5,E,N,W,S,E5,N,WSW,SW,End" P1 directed:True) (track "Track2" "72,11,W6,N5,W,N,E,S,W6,N,WSW,SW,End" P2 directed:True) (track "Track3" "73,0,E5,N5,E,N,W,S,E5,N,WSW,SW,End" P3 directed:True) (track "Track4" "74,11,W6,N5,W,N,E,S,W6,N,WSW,SW,End" P4 directed:True)}) (piece "Paddle" Each (if (= (trackSite Move steps:(count Pips)) -2) (move Remove (from)) (if (!= (trackSite Move steps:(count Pips)) -1) (if (or {(is Empty (trackSite Move steps:(count Pips))) (is Friend (who at:(trackSite Move steps:(count Pips)))) (and (is Enemy (who at:(trackSite Move steps:(count Pips)))) (not (is In (trackSite Move steps:(count Pips)) (sites "Protect"))))}) (move (from (from) level:(level)) (to (trackSite Move steps:(count Pips)) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite (who at:(to)))))))))))) (dice d:2 from:0 num:6) (hand Each) (regions "Protect" (sites {5 17 19 27 41 57 46 62 63 34 35 51 52}))}) (rules (start {(place Stack "Paddle1" (handSite P1) count:3) (place Stack "Paddle2" (handSite P2) count:3) (place Stack "Paddle3" (handSite P3) count:3) (place Stack "Paddle4" (handSite P4) count:3) (set Team 1 {P1 P3}) (set Team 2 {P2 P4})}) (play (do (roll) next:(or (forEach Piece) (forEach Piece container:(mover) top:True)))) (end {(if (no Pieces TeamMover) (result TeamMover Win))}))) 
2x12 board, divided in half, where the spaces are rendered as points. Fifteen pieces per player. Two six-sided dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. The players enter their pieces on the board on the points corresponding to the throws of the dice. A player who rolls a number corresponding to a point on the opponent's side of the board that contains a piece should remove the piece from the opponent's point, which must be reentered. If the player fails to do so, they lose instantly. Otherwise, players continue to place their pieces until all are on the board, and they then bear the pieces off from the same quadrant of the board. The first player to bear off all their pieces wins.
(game "Ketch-Dolt" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {26 12 11 10 9 8 7} P1 directed:True) (track "Track2" {27 25 24 23 22 21 20} P2 directed:True)} use:Vertex) (dice d:6 num:2) (piece "Disc" Each (or (if (is Empty (handSite Mover)) (forEach Die if:(!= (pips) 0) (if (= (trackSite Move from:(from) "Track" steps:(pips)) -1) (do (if (if (is Mover P1) (= 1 (size Stack at:(trackSite Move from:(mapEntry "Start" P2) "Track2" steps:(- (pips) 1)))) (= 1 (size Stack at:(trackSite Move from:(mapEntry "Start" P1) "Track1" steps:(- (pips) 1))))) (trigger "ShouldCapture" Mover)) next:(move Remove (from)))) (then (if (not (all DiceUsed)) (moveAgain))))) (forEach Die if:(!= (pips) 0) (or (if (if (is Mover P1) (= 1 (size Stack at:(trackSite Move from:(mapEntry "Start" P2) "Track2" steps:(- (pips) 1)))) (= 1 (size Stack at:(trackSite Move from:(mapEntry "Start" P1) "Track1" steps:(- (pips) 1))))) (move (from (if (is Mover P1) (trackSite Move from:(mapEntry "Start" P2) "Track2" steps:(- (pips) 1)) (trackSite Move from:(mapEntry "Start" P1) "Track1" steps:(- (pips) 1)))) (to (handSite Next)))) (move (from (from)) (to (trackSite Move from:(from) "Track" steps:(pips)) (apply (if (if (is Mover P1) (= 1 (size Stack at:(trackSite Move from:(mapEntry "Start" P2) "Track2" steps:(- (pips) 1)))) (= 1 (size Stack at:(trackSite Move from:(mapEntry "Start" P1) "Track1" steps:(- (pips) 1))))) (trigger "ShouldCapture" Mover)))))) (then (if (not (all DiceUsed)) (moveAgain)))))) (hand Each) (map "Start" {(pair P1 12) (pair P2 25)})}) (rules (start {(place Stack "Disc1" (handSite P1) count:15) (place Stack "Disc2" (handSite P2) count:15)}) (play (do (if (not (is Prev Mover)) (roll)) next:(or (forEach Piece) (forEach Piece container:(mover))))) (end {(if (is Triggered "ShouldCapture" P1) (result P1 Loss)) (if (is Triggered "ShouldCapture" P2) (result P2 Loss)) (if (no Pieces Mover) (result Mover Win))}))) 
Played on a board with 36 holes arranged in a square, with a gap in the center of each side. There are two semi circles of five holes on the outside of two opposite corners of the board. The central space of these semicircles is marked. One or two pieces per player. Four stick dice are used, with one marked side. Each die is marked differently for a different value: 4, 6, 14, 15. The throws are as follows: All marked sides up = 5; three marked sides up = 3; two marked sides up = 2, one marked side up = the value of the marked side; zero marked sides up = 10. Players’ pieces enter on the branching arcs. The second piece cannot enter before the first one leaves the arc. Players move in opposite directions around the board. If a player lands on the same spot as the opponent, the opponent’s piece is removed from the board and must re-enter. Player must make an exact throw to get a piece off the board. The player to get both of their pieces around the board, and then to reach the marked space with an exact throw. When a piece is in the hole before the marked space, they may throw anything but 14 or 15 to exit the board. The first player to remove their piece(s) from the board wins. Each player has 2 pieces.
(game "Kints" (players 2) (equipment {(board (add (merge {(shift -1.25 -0.34 (rotate 30 (rectangle 6 1))) (rectangle 1 5) (rectangle 5 1) (shift 0 6 (rectangle 5 1)) (shift 0 10 (rectangle 1 5)) (shift 7 0 (rectangle 1 5)) (shift 7 10 (rectangle 1 5)) (shift 11 0 (rectangle 5 1)) (shift 11 6 (rectangle 5 1)) (shift 12.25 5.33 (rotate 30 (rectangle 6 1)))}) edges:{{13 14} {22 28} {37 36} {9 23}}) {(track "Track1" "46,5,SSE,N,E,S,W,NNW2,End" P1 directed:True) (track "Track2" "47,41,NNW,W,S,E,N,SSE2,End" P2 directed:True)} use:Vertex) (regions "AllSites" (sites Board)) (regions "Arc" P1 (sites {1 2 3 4 5})) (regions "Arc" P2 (sites {41 42 43 44 45})) (dice d:2 facesByDie:{{0 4} {0 6} {0 14} {0 15}} num:4) (piece "Marker" Each (if (or (!= (from) (handSite Mover)) (and (= (from) (handSite Mover)) (all Sites (sites Occupied by:Mover) if:(not (is In (site) (sites Mover "Arc")))))) (if (= (trackSite Move steps:(mapEntry "Throw" (count Pips))) -2) (move Remove (from)) (if (!= (trackSite Move steps:(mapEntry "Throw" (count Pips))) -1) (if (not (is Friend (who at:(trackSite Move steps:(mapEntry "Throw" (count Pips)))))) (move (from) (to (trackSite Move steps:(mapEntry "Throw" (count Pips))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next))))))))))) (hand Each) (map "Throw" {(pair 0 10) (pair 39 5) (pair 24 3) (pair 25 3) (pair 35 3) (pair 33 3) (pair 10 2) (pair 18 2) (pair 19 2) (pair 20 2) (pair 21 2) (pair 29 2)})}) (rules (start (place "Marker" "Hand" count:2)) (play (do (roll) next:(or (forEach Piece) (forEach Piece container:(mover))))) (end (if (no Pieces Mover) (result Mover Win))))) 
2x12 board, with spaces as points, divided in two. Fifteen pieces per player, which start stacked, two on the players' first three points and three in the next three points. Two six-sided dice. Players unstack the pieces by moving pieces off of the stack, but remaining on the same point, according to the throws of the dice. The value of the throw indicates the number of the point which can be unstacked. For example, a throw of 1 and 4 allows the player to unstack the pieces on points 1 and 4. Doubles allow the player to unstack all pieces on that point. The player then bears off the pieces from this quadrant of the board. Players bear off the pieces in the same manner as they were unstacked. The first player to bear off all their pieces wins. 
(game "Kiz Tavlasi" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {7 8 9 10 11 12} P1 directed:True) (track "Track2" {18 17 16 15 14 13} P2 directed:True)} use:Vertex) (dice d:6 num:2) (piece "Disc" Each (forEach Die if:(!= (pips) 0) (if (= (trackSite Move steps:(pips)) -1) (move Remove (from)) (move (from) (to (trackSite Move steps:(pips))))))) (map "StartTrack" {(pair P1 7) (pair P2 18)})}) (rules (start {(place Stack "Disc1" (sites {7 8 9}) count:2) (place Stack "Disc1" (sites {10 11 12}) count:3) (place Stack "Disc2" (sites {13 14 15}) count:3) (place Stack "Disc2" (sites {16 17 18}) count:2)}) phases:{(phase "UnStacking" (play (do (if (not (is Prev Mover)) (roll)) next:(forEach Die if:(!= (pips) 0) (or (if (= (state at:(trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) 0) (move Select (from (trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) (then (and (if (= 3 (size Stack at:(last To))) (forEach Level (last To) (set State at:(last To) level:(level) 1)) (forEach Level (last To) (set State at:(last To) level:(level) 2))) (if (not (all DiceUsed)) (moveAgain)))))) (if (= (state at:(trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) 1) (move Select (from (trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) (then (and (forEach Level (last To) (set State at:(last To) level:(level) 2)) (if (not (all DiceUsed)) (moveAgain)))))))))) (nextPhase Mover (all Sites (sites Occupied by:Mover) if:(not (or (= (state at:(site)) 0) (= (state at:(site)) 1)))) "BearingOff")) (phase "BearingOff" (play (do (if (or (all DiceEqual) (not (is Prev Mover))) (roll)) next:(forEach Piece top:True) (then (if (not (all DiceUsed)) (moveAgain))))) (end (if (no Pieces Mover) (result Mover Win))))})) 
Each player begins at the end of one of the "wings" on the board. Two pieces per player. Moves are determined by the throw of two sticks with a rounded side and a flat side. Rolls are as follows: two round sides up= 1, one flat and one round =2, two flat sides =3, plus another throw. Players move their pieces the appropriate number of spaces onto the board. When a piece is in the central four spaces of the main part of the board, pieces may be taken. A piece is taken when the opponent lands on the same space as a piece, sending it back to the beginning. In these central four squares, the player may choose to proceed upward again either on the first or second space, but may not change direction again. A player may cross the "bridge" to the other four spaces by throwing a 3, always stopping on the first space after the bridge, regardless of whether thre . The player then may move to the space closest to them, if a roll allows, where they are safe, and then to the apex point of the board, where they may also be sent to start if the opponent lands there. From there, they must give an exact throw to exit the board. The first player to remove both of their pieces wins. The game is played again, and the first player to win three games is the winner. Rules from Seleucid.
(game "Knossos Game" (players 2) (equipment {(board (merge {(rectangle 1 4) (shift 1 1 (rectangle 1 2)) (shift 0 -2 (rectangle 3 1)) (shift 3 -2 (rectangle 3 1)) (shift 1.5 4 (scale 2 (rectangle 2 1))) (shift 0 5 (scale 3 (rectangle 1 2)))}) {(track "TrackBottom1" "14,6,7,0,1,4") (track "TrackBottom2" "15,8,9,3,2,5") (track "TrackOpposite1" "7,0,1,2,5") (track "TrackOpposite2" "9,3,2,1,4") (track "TrackCross1" "0,1,4,10,12,11") (track "TrackCross2" "3,2,5,10,13,11") (track "TrackTop1" "10,12,11,End") (track "TrackTop2" "10,13,11,End")} use:Vertex) (dice d:2 from:0 num:2) (piece "RoundPawn" Each (or {(if (= (trackSite Move "TrackBottom1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -2) (move Remove (from)) (if (and (!= (trackSite Move "TrackBottom1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -1) (not (is Friend (who at:(trackSite Move "TrackBottom1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))))))) (move (from) (to (trackSite Move "TrackBottom1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next)))))))) (if (= (trackSite Move "TrackBottom2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -2) (move Remove (from)) (if (and (!= (trackSite Move "TrackBottom2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -1) (not (is Friend (who at:(trackSite Move "TrackBottom2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))))))) (move (from) (to (trackSite Move "TrackBottom2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next)))))))) (if (= (trackSite Move "TrackOpposite1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -2) (move Remove (from)) (if (and (!= (trackSite Move "TrackOpposite1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -1) (not (is Friend (who at:(trackSite Move "TrackOpposite1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))))))) (move (from) (to (trackSite Move "TrackOpposite1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next)))))))) (if (= (trackSite Move "TrackOpposite2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -2) (move Remove (from)) (if (and (!= (trackSite Move "TrackOpposite2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -1) (not (is Friend (who at:(trackSite Move "TrackOpposite2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))))))) (move (from) (to (trackSite Move "TrackOpposite2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next)))))))) (if (is Mover P1) (if (= (trackSite Move "TrackTop1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -2) (move Remove (from)) (if (and (!= (trackSite Move "TrackTop1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -1) (not (is Friend (who at:(trackSite Move "TrackTop1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))))))) (move (from) (to (trackSite Move "TrackTop1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next)))))))) (if (= (trackSite Move "TrackTop2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -2) (move Remove (from)) (if (and (!= (trackSite Move "TrackTop2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -1) (not (is Friend (who at:(trackSite Move "TrackTop2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))))))) (move (from) (to (trackSite Move "TrackTop2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next))))))))) (if (and {(not (is Friend (who at:10))) (= 3 (if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) (not (is In (from) (sites "TopSites")))}) (if (or (can Move (if (= (trackSite Move "TrackCross1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -2) (move Remove (from)) (if (and (!= (trackSite Move "TrackCross1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -1) (not (is Friend (who at:(trackSite Move "TrackCross1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))))))) (move (from) (to (trackSite Move "TrackCross1" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next))))))))) (can Move (if (= (trackSite Move "TrackCross2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -2) (move Remove (from)) (if (and (!= (trackSite Move "TrackCross2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) -1) (not (is Friend (who at:(trackSite Move "TrackCross2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))))))) (move (from) (to (trackSite Move "TrackCross2" steps:(if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next)))))))))) (move (from) (to 10 (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next))))))))})) (hand Each) (regions "TopSites" (sites {10 11 12 13}))}) (rules (start (place "RoundPawn" "Hand" count:2)) (play (do (roll) next:(or (forEach Piece) (forEach Piece container:(mover))) (then (if (no Pieces Mover) (and (addScore Mover 1) (if (!= (score Mover) 2) (and {(forEach Site (sites Occupied by:All container:"Board") (remove (site))) (if (!= 0 (who at:(handSite P1))) (remove (handSite P1))) (if (!= 0 (who at:(handSite P2))) (remove (handSite P2))) (add (piece (id "RoundPawn" P1)) (to (handSite P1)) count:2) (add (piece (id "RoundPawn" P2)) (to (handSite P2)) count:2)}))) (if (= 3 (if (= 2 (count Pips)) 1 (if (= 1 (count Pips)) 2 3))) (moveAgain)))))) (end (if (= (score Mover) 3) (result Mover Win))))) 
Two players. Four pieces per player, played with four stick dice. They are round on one side, flat on the other, and the round side of one has horizontal stripes, another has cross-hatching, the other two remaining blank. The throws are as follows: One flat side up = 1; two flat sides and at least one blank round side up = 2; two flat sides and both marked round sides up = 35; four flat sides up = 5; four round sides up = 10; three flat sides and one blank round side up = 3; three flat sides and cross-hatched round side up = 15; three flat sides and striped round side up = 20. The throw may only be applied to one piece. Pieces enter from the midpoint of the sides and proceed along the track in the middle, then back to the edge following that track and making a circuit of the board, returning back to the center when it has traveled along the entire perimeter. If a piece lands exactly on the points where the tracks cross in the center, the piece starts again from the beginning, but remains in the center of the board until it does so. The goal is for pieces to pass the points where the center tracks intersect after traveling all the way around the board with all four pieces. If a player lands on the same space as an opponent's piece, the opponent's piece must again start from the beginning. 
(game "Kolica Atarakua" (players 2) (equipment {(board (add (merge {(rectangle 1 10) (shift 0 9 (rectangle 1 10)) (shift -1 -1 (square 2)) (shift 9 -1 (square 2)) (rectangle 10 1) (shift 9 0 (rectangle 10 1)) (shift -1 9 (square 2)) (shift 9 9 (square 2)) (shift 5 0 (rectangle 6 1)) (shift 0 5 (rectangle 1 6)) (shift 4 4 (rectangle 1 6)) (shift 4 4 (rectangle 6 1))}) vertices:{{1 1} {1 8} {8 1} {8 8} {4.5 4.5}}) {(track "Track1" "69,5,N,W,N,W,S,65,11,E,N,W,67,41,S,E,N,66,8,W,S,E,64,26,N4,E3,68,56" P1 directed:True) (track "Track2" "70,14,S,E,S,E,N,66,8,W,S,E,64,26,N,W,S,65,11,E,N,W,67,41,S4,W3,68,56" P2 directed:True)} use:Vertex) (dice d:2 from:0 num:4) (piece "Marker" Each (if (= (trackSite Move from:(from) steps:(if (= 1 (count Pips)) 1 (if (= 4 (count Pips)) 5 (if (= 0 (count Pips)) 10 (if (= 2 (count Pips)) (if (or (= 0 (face 73)) (= 0 (face 74))) 2 35) (if (or (= 0 (face 73)) (= 0 (face 74))) 3 (if (= 0 (face 71)) 20 15))))))) -1) (move Remove (from) level:(level)) (move (from (from) level:(level)) (to (trackSite Move from:(from) steps:(if (= 1 (count Pips)) 1 (if (= 4 (count Pips)) 5 (if (= 0 (count Pips)) 10 (if (= 2 (count Pips)) (if (or (= 0 (face 73)) (= 0 (face 74))) 2 35) (if (or (= 0 (face 73)) (= 0 (face 74))) 3 (if (= 0 (face 71)) 20 15))))))) if:True (apply (if (is Enemy (who at:(to))) (forEach Level (to) FromTop (fromTo (from (to) level:(level)) (to (handSite (who at:(to) level:(level))))))))) (then (if (is In (last To) (sites "RemoveSites")) (fromTo (from (last To)) (to (handSite (mover))))))))) (hand Each) (regions "RemoveSites" (sites {51 56}))}) (rules (start {(place Stack "Marker1" (handSite P1) count:4) (place Stack "Marker2" (handSite P2) count:4)}) (play (do (roll) next:(or (forEach Piece) (forEach Piece container:(mover))))) (end (if (no Pieces Mover) (result Mover Win))))) 
2x12 board, with the spaces rendered as points, divided into half. Fifteen pieces per player, which begin on the rightmost point, with respect to the player, on the opposite side of the board from which they sit. Two six-sided dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. A throw of doubles forces the player to play the throw twice. More than two pieces of the same player may not occupy a point on the starting side of the board. The player cannot move past the penultimate point on the opposite side of the board until five pieces have been moved from the starting point. A single opponent's piece may be removed from the board when a player's piece lands on it, and the opponent's piece must reenter the board. Pieces cannot move to a point occupied by two opponent's piece. A piece cannot reenter then board on a point occupied by another piece, whether belonging to the player or the opponent. When all of a player's pieces have reached the final quadrant of the board, the player may begin to remove them from the table. The player who bears off their pieces scores two points. 
(game "Kotra" (players 2) (equipment {(board (merge {(rectangle 1 6) (shift 7 0 (rectangle 1 6)) (shift 0 6 (rectangle 1 6)) (shift 7 6 (rectangle 1 6))}) {(track "Track1" {11 10 9 8 7 6 5 4 3 2 1 0 12 13 14 15 16 17 18 19 20 21 22 23 -2} P1 directed:True) (track "Track2" {12 13 14 15 16 17 18 19 20 21 22 23 11 10 9 8 7 6 5 4 3 2 1 0 -2} P2 directed:True)} use:Vertex) (dice d:6 num:2) (piece "Disc" Each (forEach Die replayDouble:True if:(!= (pips) 0) (if (= (trackSite Move from:(from) steps:(pips)) -2) (if (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover "FinalQuadrant"))) (move Remove (from))) (move (from (from)) (to (trackSite Move from:(from) steps:(pips)) if:(and {(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (if (not (is In (to) (sites Mover "StartingSide"))) True (> 2 (size Stack at:(to)))) (if (not (is In (to) (sites Mover "AfterPenultimate"))) True (>= 10 (count Pieces in:(sites {(handSite Mover) (mapEntry "Entry" Mover)}))))}) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next))))))) (then (if (not (all DiceUsed)) (moveAgain))))) (hand Each) (regions "FinalQuadrant" P1 (sites {18 19 20 21 22 23})) (regions "FinalQuadrant" P2 (sites {0 1 2 3 4 5})) (regions "StartingSide" P1 (sites {0 1 2 3 4 5 6 7 8 9 10 11})) (regions "StartingSide" P2 (sites {12 13 14 15 16 17 18 19 20 21 22 23})) (regions "AfterPenultimate" P1 (sites {23})) (regions "AfterPenultimate" P2 (sites {0})) (map "Entry" {(pair P1 11) (pair P2 12)})}) (rules (start {(place Stack "Disc1" 11 count:15) (place Stack "Disc2" 12 count:15)}) (play (do (if (not (is Prev Mover)) (roll)) next:(or (if (is Occupied (handSite Mover)) (forEach Die replayDouble:True if:(!= (pips) 0) (move (from (handSite Mover)) (to (trackSite Move from:(mapEntry "Entry" Mover) steps:(- (pips) 1)) if:(is Empty (to)))) (then (if (not (all DiceUsed)) (moveAgain))))) (forEach Piece top:True)) (then (if (no Pieces Mover) (set Score Mover 2))))) (end (if (no Pieces Mover) (result Mover Win))))) 
2x12 board, with spaces as points, divided in two. Fifteen pieces per player. Two six-sided die. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. The lowest value of the dice must be played; if it cannot, the player does not move. When a player throws doubles, they play the values on each die, as well as the values on the opposite side of the dice (I.e., double 6 if double 1 is thrown, 5 if 2, 3 if 4). However, the values on the bottom can only be played if all of the top values are played. The first double throw is only played once, but every subsequent double throw is played twice, and the top values must be played twice before using the bottom values. Bottom values do not have to be played, or only some of the bottom values may be played if the player wishes. In addition, an extra throw is granted for the second and subsequent throws of doubles. Players enter their pieces onto the same section of the board, and proceed around the board to the point opposite the starting point, and then off the board. A player may not land on a point with two or more of the opponent's pieces. A player's piece may land on a point with a single opponent's piece. The opponent's piece is removed from the board and must enter again. The first player to remove all of their pieces from the board wins.
(game "Lange Puff" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {26 25 24 23 22 21 20 18 17 16 15 14 13 0 1 2 3 4 5 7 8 9 10 11 12} P1 directed:True) (track "Track2" {27 25 24 23 22 21 20 18 17 16 15 14 13 0 1 2 3 4 5 7 8 9 10 11 12} P2 directed:True)} use:Vertex) (dice d:6 num:2) (piece "Disc" Each (forEach Die replayDouble:(= 1 (value Player Mover)) if:(!= (pips) 0) (if (= (trackSite Move from:(from) steps:(pips)) -1) (move Remove (from)) (move (from (from)) (to (trackSite Move from:(from) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next))))))) (then (if (not (all DiceUsed)) (moveAgain) (if (= 1 (value Player Mover)) (if (and (all DiceEqual) (= 0 (size Array (values Remembered)))) (and (moveAgain) (set Var "PlayOpposite" 1))) (set Value Mover 1)))))) (hand Each)}) (rules (start {(place Stack "Disc1" (handSite P1) count:15) (place Stack "Disc2" (handSite P2) count:15)}) (play (do (if (or (is Pending) (not (is Prev Mover))) (roll)) next:(if (= 1 (var "PlayOpposite")) (or {(forEach Piece (forEach Value (values Remembered "Opposite") (if (= (trackSite Move from:(from) steps:(value)) -1) (move Remove (from)) (move (from (from)) (to (trackSite Move from:(from) steps:(value)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply (and (if (is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next)))) (forget Value "Opposite" (value)))))) (then (if (!= 0 (size Array (values Remembered "Opposite"))) (moveAgain) (and {(set Var "PlayOpposite" 0) (set Pending) (moveAgain)}))))) top:True) (forEach Piece container:(mover) (forEach Value (values Remembered "Opposite") (if (= (trackSite Move from:(from) steps:(value)) -1) (move Remove (from)) (move (from (from)) (to (trackSite Move from:(from) steps:(value)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply (and (if (is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next)))) (forget Value "Opposite" (value)))))) (then (if (!= 0 (size Array (values Remembered "Opposite"))) (moveAgain) (and {(set Var "PlayOpposite" 0) (set Pending) (moveAgain)}))))) top:True) (move Pass (then (and {(forget Value "Opposite" All) (set Var "PlayOpposite" 0) (set Pending) (moveAgain)})))}) (do (if (and {(= 0 (count MovesThisTurn)) (all DiceEqual) (= 1 (value Player Mover))}) (and (remember Value "Opposite" (- 7 (face 28))) (remember Value "Opposite" (- 7 (face 28))))) next:(or (forEach Piece top:True) (forEach Piece container:(mover) top:True)))))) (end (if (no Pieces Mover) (result Mover Win))))) 
2x12 board, divided in half. Spaces on each side take the form of semi-circular sockets, into which the pieces fit. Fifteen pieces per player. One player places fourteen of their pieces on the first point of the table to their right closest to them, with the other piece on the point opposite it on the other side of the board. The other player places three pieces on each of the four spots following the spot with the other player's fourteen, two on the spot following this, and one on the opposite end of the row of spots where the opponent's single piece is located. Two six-sided dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. Players move along the spaces of the board toward the spot where the first player's single piece is located, and from there they bear off. Pieces cannot be hit as in similar games. If a player cannot play the value on a die (or on both dice), the opponent may play it. The first player to bear off all of their pieces wins.
(game "Laquet" (players 2) (equipment {(board (merge {(rectangle 1 6) (shift 7 0 (rectangle 1 6)) (shift 0 6 (rectangle 1 6)) (shift 7 6 (rectangle 1 6))}) (track "Track1" {11 10 9 8 7 6 5 4 3 2 1 0 12 13 14 15 16 17 18 19 20 21 22 23} directed:True) use:Vertex) (dice d:6 num:2) (piece "Disc" Each (forEach Die if:(!= (pips) 0) (if (= (trackSite Move steps:(pips)) -1) (move Remove (from)) (if (not (is Enemy (who at:(trackSite Move steps:(pips))))) (move (from) (to (trackSite Move steps:(pips))))))))}) (rules (start {(place Stack "Disc1" 11 count:14) (place Stack "Disc1" 23) (place Stack "Disc2" (sites {7 8 9 10}) count:3) (place Stack "Disc2" 6 count:2) (place Stack "Disc2" 12)}) (play (do (if (and (not (is Pending)) (not (is Prev Mover))) (roll)) next:(if (can Move (forEach Piece)) (forEach Piece top:True (then (if (not (all DiceUsed)) (moveAgain)))) (move Pass (then (set Pending)))))) (end (if (no Pieces Mover) (result Mover Win))))) 
Four 3x5 grids, arranged in four corners of a rectangular board. Three pieces per player. Five cowrie shells used as dice; the value of the throw equaling the number of the mouths which land face up. Players begin by entering their pieces onto the board from the square in the central row of the grid to their right. A single piece may be entered with a throw of 1, or all of the player's pieces may be entered with a throw of 5. Throws of 1 and 5 grant the player another throw, and pieces are moved only after all of the players throws are made. Play proceeds down the central row where the pieces entered, in an anti-clockwise direction until reaching the bottom right hand corner of the left grid, at which point the track continues on the opponent's side of the board from the top right corner of the left board (with respect to the current player), proceeding around the opponent's grids in an anti-clockwise direction until reaching the top left square of the opponent's right grid. At this point, the piece returns to the player's own right grid, on the bottom left corner, and proceeding in an anti-clockwise direction into the central row, and off the board once moving past the final space. When a player lands on a space occupied by an opponent's piece, the opponent's piece is removed from the board and must re-enter as before. Pieces are safe from being sent back when resting on the left two corners of each grid on the left and the right two corners of each grid on the right. The first player to remove all of their pieces from the board wins. 
(game "Len Doat" (players 2) (equipment {(board (merge {(rectangle 3 5) (shift 7.5 0 (rectangle 3 5)) (shift 0 3.5 (rectangle 3 5)) (shift 7.5 3.5 (rectangle 3 5))}) {(track "Track1" "20,E,N,W,14,W,S,E,44,W,S,E,45,E,N,W,15,E,N1,W,End" P1 directed:True) (track "Track2" "39,W,S,E,45,E,N,W,15,E,N,W,14,W,S,E,44,W,S1,E,End" P2 directed:True)}) (dice d:2 from:0 num:5) (hand Each) (piece "Marker" Each (if (= (trackSite Move steps:(value Player Mover)) -2) (move Remove (from)) (if (!= (trackSite Move steps:(value Player Mover)) -1) (if (if (not (is Enemy (who at:(trackSite Move steps:(value Player Mover))))) True (not (is In (trackSite Move steps:(value Player Mover)) (sites "Protect")))) (move (from) (to (trackSite Move steps:(value Player Mover)) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next)) count:(count at:(to))))) (then (if (or (= 1 (value Player Mover)) (= 5 (value Player Mover))) (and (moveAgain) (set Value Mover -2))))))))) (map "EntrySite" {(pair P1 (coord "F2")) (pair P2 (coord "E5"))}) (regions "Protect" (sites {"A1" "A3" "A4" "A6" "J1" "J3" "J4" "J6"}))}) (rules (start (place "Marker" "Hand" count:3)) (play (if (can Move (if (< (value Player Mover) 0) (do (roll) next:(if (= (value Player Mover) -2) (do (set Value Mover (count Pips)) next:(if (and (= (value Player Mover) 1) (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))))) (move (from (handSite Mover)) (to (mapEntry "EntrySite" (mover))) (then (and (moveAgain) (set Value Mover -2)))) (if (and (= (value Player Mover) 5) (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))))) (move (from (handSite Mover)) (to (mapEntry "EntrySite" (mover))) count:(count Cell at:(handSite Mover)) (then (and (moveAgain) (set Value Mover -2)))) (forEach Piece)) (then (if (!= (value Player Mover) -2) (set Value Mover -1))))) (move Pass (then (set Value Mover (count Pips)))))) (if (and (= (value Player Mover) 1) (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))))) (move (from (handSite Mover)) (to (mapEntry "EntrySite" (mover))) (then (and (moveAgain) (set Value Mover -2)))) (if (and (= (value Player Mover) 5) (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))))) (move (from (handSite Mover)) (to (mapEntry "EntrySite" (mover))) count:(count Cell at:(handSite Mover)) (then (and (moveAgain) (set Value Mover -2)))) (forEach Piece)) (then (if (!= (value Player Mover) -2) (set Value Mover -1)))))) (if (< (value Player Mover) 0) (do (roll) next:(if (= (value Player Mover) -2) (do (set Value Mover (count Pips)) next:(if (and (= (value Player Mover) 1) (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))))) (move (from (handSite Mover)) (to (mapEntry "EntrySite" (mover))) (then (and (moveAgain) (set Value Mover -2)))) (if (and (= (value Player Mover) 5) (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))))) (move (from (handSite Mover)) (to (mapEntry "EntrySite" (mover))) count:(count Cell at:(handSite Mover)) (then (and (moveAgain) (set Value Mover -2)))) (forEach Piece)) (then (if (!= (value Player Mover) -2) (set Value Mover -1))))) (move Pass (then (set Value Mover (count Pips)))))) (if (and (= (value Player Mover) 1) (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))))) (move (from (handSite Mover)) (to (mapEntry "EntrySite" (mover))) (then (and (moveAgain) (set Value Mover -2)))) (if (and (= (value Player Mover) 5) (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))))) (move (from (handSite Mover)) (to (mapEntry "EntrySite" (mover))) count:(count Cell at:(handSite Mover)) (then (and (moveAgain) (set Value Mover -2)))) (forEach Piece)) (then (if (!= (value Player Mover) -2) (set Value Mover -1))))) (move Pass (then (and (if (or (= 1 (value Player Mover)) (= 5 (value Player Mover))) (and (moveAgain) (set Value Mover -2))) (if (!= (value Player Mover) -2) (set Value Mover -1))))))) (end (if (no Pieces Mover) (result Mover Win))))) 
2x12 board, divided in half. Spaces on each side take the form of semi-circular sockets, into which the pieces fit. Twelve pieces per player. Two dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. Each player enters their pieces into their home section of the board (to the left of one player, to the right of the other player, and move pieces along a horseshoe-shaped track around the board toward the other player's home space. At the beginning of play, the first player will choose one quadrant of the board, and the goal of the game will be for one player to move two pieces onto each of the six places in that quadrant. When a piece lands on a space occupied by a single piece of the opponent, the opponent's piece is removed from the board, and must be reentered. The quadrant selected is the top left one.
(game "Los Doze Canes" (players 2) (equipment {(board (merge {(rectangle 1 6) (shift 7 0 (rectangle 1 6)) (shift 0 6 (rectangle 1 6)) (shift 7 6 (rectangle 1 6))}) {(track "Track1" {24 0 1 2 3 4 5 6 7 8 9 10 11 23 22 21 20 19 18 17 16 15 14 13 12} P1 directed:True) (track "Track2" {25 12 13 14 15 16 17 18 19 20 21 22 23 11 10 9 8 7 6 5 4 3 2 1 0} P2 directed:True)} use:Vertex) (dice d:6 num:2) (piece "Disc" Each (forEach Die if:(!= (pips) 0) (if (or (not (is Enemy (who at:(trackSite Move steps:(pips))))) (= 1 (size Stack at:(trackSite Move steps:(pips))))) (move (from) (to (trackSite Move steps:(pips)) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next))))))))) (hand Each)}) (rules (start {(place Stack "Disc1" (handSite P1) count:12) (place Stack "Disc2" (handSite P2) count:12)}) (play (do (if (not (is Prev Mover)) (roll)) next:(or (forEach Piece top:True) (forEach Piece container:(mover) top:True) (then (if (not (all DiceUsed)) (moveAgain)))))) (end {(if (and {(= 2 (size Stack at:18)) (= 2 (size Stack at:19)) (= 2 (size Stack at:20)) (= 2 (size Stack at:21)) (= 2 (size Stack at:22)) (= 2 (size Stack at:23)) (= 0 (count Sites in:(difference (sites Occupied by:Mover) (sites {18 19 20 21 22 23}))))}) (result Mover Win)) (if (and (< 2 (size Stack at:12)) (< 2 (size Stack at:0))) (result Mover Draw))}))) 
2x12 board, divided in half. Spaces on each side take the form of points. Fifteen pieces per player. Three six-sided dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. One player begins with all of their pieces on the space furthest to the left on their side, the other with their pieces on the point directly opposite it. Pieces move in opposite directions around the board, toward the point where the opponent's pieces begin, and bearing off the board from there. A player cannot have two of their pieces on the same spot in the starting quadrant. When a piece lands on the same space as a single opponent's piece, the opponent's piece is sent back to where it began. The first person to bear off all their pieces wins.  
(game "Ludus Anglicorum" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {6 0 1 2 3 4 5 7 8 9 10 11 12 25 24 23 22 21 20 18 17 16 15 14 13 12} P1 directed:True) (track "Track2" {19 12 13 14 15 16 17 18 20 21 22 23 24 25 12 11 10 9 8 7 5 4 3 2 1 0} P2 directed:True)} use:Vertex) (dice num:3) (map {(pair 1 19) (pair 2 6)}) (piece "Disc" Each) (regions P1 {0 1 2 3 4 5}) (regions P2 {13 14 15 16 17 18})}) (rules (start {(place Stack "Disc1" 0 count:15) (place Stack "Disc2" 13 count:15)}) (play (do (if (not (is Prev Mover)) (roll)) next:(forEach Die if:(!= (pips) 0) (forEach Site (sites Occupied by:Mover) (if (= (trackSite Move from:(site) steps:(pips)) -1) (move Remove (site)) (move (from (site)) (to (trackSite Move from:(site) steps:(pips)) if:(or (and (is Enemy (who at:(to))) (= 1 (size Stack at:(to)))) (and (if (not (is In (to) (sites Mover))) True (is Empty (to))) (not (is Enemy (who at:(to)))))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (mover))))))))) (then (if (not (all DiceUsed)) (moveAgain)))))) (end (if (no Pieces Mover) (result Mover Win))))) 
2x12 board, divided in half. Spaces on each side take the form of points. Fifteen pieces per player. Three six-sided dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. One player begins with all of their pieces on the space furthest to the left on their side, the other with their pieces on the point directly opposite it. Pieces move in opposite directions around the board, only on the left half of the board where the pieces begin, toward the point where the opponent's pieces begin, and bearing off the board from there. A player cannot have two of their pieces on the same spot in the starting quadrant. When a piece lands on the same space as an opponent's piece, the opponent's piece is sent back to where it began. The first person to bear off all their pieces wins. 
(game "Ludus Lombardorum" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {6 0 1 2 3 4 5 18 17 16 15 14 13 12} P1 directed:True) (track "Track2" {19 12 13 14 15 16 17 18 5 4 3 2 1 0} P2 directed:True)} use:Vertex) (dice num:3) (map {(pair 1 19) (pair 2 6)}) (piece "Disc" Each) (regions P1 {0 1 2 3 4 5}) (regions P2 {13 14 15 16 17 18})}) (rules (start {(place Stack "Disc1" 0 count:15) (place Stack "Disc2" 13 count:15)}) (play (do (if (not (is Prev Mover)) (roll)) next:(forEach Die if:(!= (pips) 0) (forEach Site (sites Occupied by:Mover) (if (= (trackSite Move from:(site) steps:(pips)) -1) (move Remove (site)) (move (from (site)) (to (trackSite Move from:(site) steps:(pips)) if:(or (and (is Enemy (who at:(to))) (= 1 (size Stack at:(to)))) (and (if (not (is In (to) (sites Mover))) True (is Empty (to))) (not (is Enemy (who at:(to)))))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (mover))))))))) (then (if (not (all DiceUsed)) (moveAgain)))))) (end (if (no Pieces Mover) (result Mover Win))))) 
The game is played on a board with twelve points on either side. The points form a continuous track in a horseshoe shape; each player progresses in opposite directions (one from their bottom right to the top right, the other from their bottom left to their top left. Each player has 15 pieces. Each player's fifteen pieces begin on the first point of their track. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. If doubles are rolled, the player must play the number on each die twice. When a piece lands on a space occupied by one of the opponent's piece, the opponent's piece may not move from that spot until the player's piece is moved from that spot. Two or more of the opponent's pieces may land on this space, but another of the player's pieces may not. When all of the player's pieces are on the final six points, they may be borne off the board. The player who bears off all of their pieces wins. The winning player's score equals the number of the opponent's pieces which are left on the board. Play continues until one player's score reaches 31. 
(match "Mahbouseh" (players 2) (games (subgame "MahbousehSubgame" result:(score Mover))) (end {(if (>= (matchScore P1) 31) (result P1 Win)) (if (>= (matchScore P2) 31) (result P2 Win))})) 
2x12 board, divided in half. Spaces on each side take the form of semi-circular sockets, into which the pieces fit. Fifteen pieces per player. Two or three six-sided dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. One player begins with all of their pieces on the space furthest to the left on their side, the other with their pieces on the point directly opposite it. Pieces move in opposite directions around the board, only on the half of the board where the pieces begin, toward the point where the opponent's pieces begin, and bearing off the board from there. When a piece lands on the same space as an opponent's piece, the opponent's piece is sent back to where it began. The first person to bear off all their pieces wins. If players move their pieces such that they fill up all the points in a quadrant, and the other fills up all of the points in an adjacent quadrant such that neither player can move, the game is a draw.  The game involves 2 dice
(game "Medio Emperador" (players 2) (equipment {(board (merge {(rectangle 1 6) (shift 7 0 (rectangle 1 6)) (shift 0 6 (rectangle 1 6)) (shift 7 6 (rectangle 1 6))}) {(track "Track1" {24 0 1 2 3 4 5 6 7 8 9 10 11 23 22 21 20 19 18 17 16 15 14 13 12} P1 directed:True) (track "Track2" {25 12 13 14 15 16 17 18 19 20 21 22 23 11 10 9 8 7 6 5 4 3 2 1 0} P2 directed:True)} use:Vertex) (dice d:6 num:2) (hand Each) (piece "Disc" Each (forEach Die if:(!= (pips) 0) (if (= (trackSite Move steps:(pips)) -1) (move Remove (from)) (if (or (not (is Enemy (who at:(trackSite Move steps:(pips))))) (= 1 (size Stack at:(trackSite Move steps:(pips))))) (move (from) (to (trackSite Move steps:(pips)) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next))))))))))}) (rules (start {(place Stack "Disc1" 0 count:15) (place Stack "Disc2" 12 count:15)}) (play (do (if (not (is Prev Mover)) (roll)) next:(or (forEach Piece top:True) (forEach Piece container:(mover) top:True) (then (if (not (all DiceUsed)) (moveAgain)))))) (end {(if (no Pieces Mover) (result Mover Win)) (if (and (no Moves P1) (no Moves P2)) (result Mover Draw))}))) 
The game is played on a board with twelve points on either side. The points form a continuous track in a horseshoe shape; each player progresses in opposite directions (one from their bottom right to the top right, the other from their bottom left to their top left. Each player has 15 pieces. Each player's fifteen pieces begin on the first point of their track. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. If doubles are rolled, the player must play the number on each die twice. A piece cannot land on a space occupied by one of the opponent's pieces. A player must first move a single one of their pieces around the board and onto one of the final six points of their track before moving any of the other pieces. When all of the player's pieces are on the final six points, they may be borne off the board. The player who bears off all of their pieces wins. The winning player's score equals the number of the opponent's pieces which are left on the board. Play continues until one player's score reaches 31.
(match "Mughrabieh" (players 2) (games (subgame "MughrabiehSubgame" result:(score Mover))) (end {(if (>= (matchScore P1) 31) (result P1 Win)) (if (>= (matchScore P2) 31) (result P2 Win))})) 
2x12 board, divided in half, where the spaces are rendered as points. Fifteen pieces per player. Two six-sided dice. Both players begin on the same side of the board, one player (who plays first) with five pieces on the rightmost point of the starting row, four on the fifth and sixth points and two in the eleventh point in the opposite row. The other player has three pieces each on the right five points in the second row. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. On each throw the player also plays a throw of 6 in addition to the throw presented by the dice. Pieces move in an anti-clockwise direction around the board. A piece cannot move to a point that is occupied by more than one of the opponent's pieces. If a piece lands on a point occupied by a single piece belonging to the opponent, the opponent's piece is removed from the board and must enter again from the leftmost point in the row where the pieces began. A piece may be borne off the board when a throw is greater than the number of points left on the board. The first player to bear all of their pieces off the board wins.
(game "Myles" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {6 0 1 2 3 4 5 7 8 9 10 11 12 25 24 23 22 21 20 18 17 16 15 14 13} P1 directed:True) (track "Track2" {19 0 1 2 3 4 5 7 8 9 10 11 12 25 24 23 22 21 20 18 17 16 15 14 13} P2 directed:True)} use:Vertex) (dice num:2) (map {(pair 1 19) (pair 2 6)}) (piece "Disc" Each)}) (rules (start {(place Stack "Disc1" 12 count:5) (place Stack "Disc1" 20 count:4) (place Stack "Disc1" 21 count:4) (place Stack "Disc1" 14 count:2) (place Stack "Disc2" 25 count:3) (place Stack "Disc2" 24 count:3) (place Stack "Disc2" 23 count:3) (place Stack "Disc2" 22 count:3) (place Stack "Disc2" 21 count:3)}) (play (do (if (not (is Prev Mover)) (roll)) next:(if (all DiceUsed) (forEach Site (sites Occupied by:Mover) (if (= (trackSite Move from:(site) steps:6) -1) (move Remove (site)) (move (from (site)) (to (trackSite Move from:(site) steps:6) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (mover))))))))) (forEach Die if:(!= (pips) 0) (forEach Site (sites Occupied by:Mover) (if (= (trackSite Move from:(site) steps:(pips)) -1) (move Remove (site)) (move (from (site)) (to (trackSite Move from:(site) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (mover))))))))) (then (moveAgain)))))) (end (if (no Pieces Mover) (result Mover Win))))) 
The board is a track of any number of spaces, made in the sand. Any number of players, playing with one piece. One piece is the hyena. Four nut shells are used as dice, with the following throws: four of all the same side = 20; two of the same side = 2; any other throw = 0. The first player to reach the end of the track then plays as the hyena. The hyena moves twice the value of the throw. When the hyena overtakes a player's piece, it is removed from the board and the player loses.  The game involves 8 players. The track is composed of 100 spaces
(game "Nama" (players 8) (equipment {(board (rectangle 100 1) (track "Track" {0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99} directed:True)) (hand Each) (hand Shared) (piece "Marker" Each (if (= (if (= (from) (handSite Mover)) (trackSite Move from:0 steps:(- (mapEntry "Throw" (count Pips)) 1)) (trackSite Move from:(from) steps:(mapEntry "Throw" (count Pips)))) -1) (move Remove (from) level:(level) (then (if (= (where "Hyena" Shared) -1) (and (add (piece "Hyena") (to 0) stack:True) (set Var (id Mover)))))) (move (from (from) level:(level)) (to (if (= (from) (handSite Mover)) (trackSite Move from:0 steps:(- (mapEntry "Throw" (count Pips)) 1)) (trackSite Move from:(from) steps:(mapEntry "Throw" (count Pips))))) stack:True))) (piece "Hyena" Shared) (dice d:2 from:0 num:4) (map "Throw" {(pair 0 0) (pair 1 0) (pair 2 2) (pair 3 0) (pair 4 20)})}) (rules (start (place "Marker" "Hand")) (play (do (roll) next:(if (< 0 (mapEntry "Throw" (count Pips))) (if (= (var) (id Mover)) (if (= (trackSite Move from:(where "Hyena" Shared) steps:(* 2 (mapEntry "Throw" (count Pips)))) -1) (move Remove (where "Hyena" Shared) (then (forEach Site (sites Board) (if (is Occupied (site)) (remove (site) count:(size Stack at:(site))))))) (move (from (where "Hyena" Shared)) (to (trackSite Move from:(where "Hyena" Shared) steps:(* 2 (mapEntry "Throw" (count Pips))))) (then (forEach Value min:1 max:(- (* 2 (mapEntry "Throw" (count Pips))) 1) (if (is Occupied (trackSite Move from:(last From) steps:(value))) (remove (trackSite Move from:(last From) steps:(value)) count:(size Stack at:(trackSite Move from:(last From) steps:(value))))))))) (or (forEach Piece) (forEach Piece container:(mover))))))) (end {(forEach Player if:(and {(> (var) 0) (!= (player) (var)) (= (where "Hyena" Shared) -1)}) (result Player Loss)) (if (and (= (id Mover) (var)) (= (where "Hyena" Shared) -1)) (result Mover Win)) (forEach Player if:(and (!= (player) (var)) (no Pieces of:(player))) (result Player Loss))}))) 
The game is played on a board with twelve points on either side. The points form a continuous track in a horseshoe shape; each player progresses in opposite directions (one from their bottom right to the top right, the other from their bottom left to their top left). Each player has 15 pieces. The starting position is as such, numbering the points from the origin of each player's track: Point six: five pieces. Point 8: three pieces. Point 13: five pieces. Point 24: two pieces. Players move according to the number on each die by moving one piece the number on one die and another the number on the other die, or by moving one piece twice (once for each die). Players cannot end their move on a point with multiple opposing pieces. If a player ends the turn on a point with one opposing piece, that piece is placed in the middle of the board (not on a point) and must reenter the board according to the next die roll, counting the origin point as a move of one. They cannot reenter on a point with two or more pieces. No other pieces can move until all of the pieces belonging to that player are removed from the center. When all of a player's pieces are on their final 6 points, they may start removing pieces from the board. They can do so by rolling a 6 to move from the 6th point, and so on down to 1. Players must use all available moves presented by the dice. The first player to remove all of their pieces wins. The winner gains one point, or two points if the opponent has pieces in their starting quadrant. 
(game "Nard" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {6 12 11 10 9 8 7 5 4 3 2 1 0 13 14 15 16 17 18 20 21 22 23 24 25 -2} P1 directed:True) (track "Track2" {19 25 24 23 22 21 20 18 17 16 15 14 13 0 1 2 3 4 5 7 8 9 10 11 12 -2} P2 directed:True)} use:Vertex) (dice d:6 num:2) (map "Bar" {(pair P1 6) (pair P2 19)}) (regions "FinalQuadrant" P1 (sites {20 21 22 23 24 25})) (regions "FinalQuadrant" P2 (sites {7 8 9 10 11 12})) (piece "Disc" Each (forEach Die if:(!= (pips) 0) (if (= (trackSite Move from:(from) steps:(pips)) -2) (if (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover "FinalQuadrant"))) (move Remove (from))) (move (from (from)) (to (trackSite Move from:(from) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry "Bar" Next))))))) (then (if (not (all DiceUsed)) (moveAgain)))))}) (rules (start {(place Stack "Disc1" 7 count:5) (place Stack "Disc1" 4 count:3) (place Stack "Disc1" 13 count:5) (place Stack "Disc1" 25 count:2) (place Stack "Disc2" 20 count:5) (place Stack "Disc2" 17 count:3) (place Stack "Disc2" 0 count:5) (place Stack "Disc2" 12 count:2)}) (play (do (if (not (is Prev Mover)) (roll)) next:(priority {(if (is Occupied (mapEntry "Bar" Mover)) (forEach Die if:(!= (pips) 0) (move (from (mapEntry "Bar" Mover)) (to (trackSite Move from:(mapEntry "Bar" Mover) steps:(pips)) if:(< (size Stack at:(to)) 2) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry "Bar" Next)))))) (then (if (not (all DiceUsed)) (moveAgain))))) (if (is Empty (mapEntry "Bar" Mover)) (max Distance (forEach Piece top:True)))}) (then (if (no Pieces Mover) (if (no Pieces Enemy in:(sites Mover "FinalQuadrant")) (addScore Mover 1) (addScore Mover 2)))))) (end (if (no Pieces Mover) (result Mover Win))))) 
Twenty small circles arranged in a large circle, with a cross of nine more circles in the center of the large circle. The central circle and the circles where the crosses meet the larger circle are larger than the others. Two players play with either one or four pieces each. Four stick dice with a white and a black side, with the following values for the throws: four white sides up = 4; four black sides up = 5; three white sides up = 3, two white sides up = 2, one white side up = 1. Throws of 4 and 5 allow the player another throw, pieces being moved after all of the player's throws. Pieces enter the board on the spot to the left of the topmost position of the circle, and proceed around the circle in an anti-clockwise direction. If a piece lands on one of the spaces where the central cross meets the circle, the piece may proceed along the cross to the opposite side on the next turn. A piece may not turn and move along a cross if it does not land on the end of the cross at the end of a throw. Pieces proceed to the topmost space, and move off the board by throwing one or more than required to land on this space. When a player lands on the same spot as one of their own pieces, these may be moved together as one piece. When a player lands on an opponent's piece, the opponent's piece is sent back to the start. The first player to remove all of their pieces from the board wins. 2 players involved with four pieces per player.
(game "Nyout" (players 2) (equipment {(board (concentric {1 -4 -4 20}) {(track "Track1" {29 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28} P1 directed:True) (track "Track2" {30 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28} P2 directed:True) (track "HorizontalTrack" {13 5 1 0 3 7 23 24 25 26 27 28} directed:True) (track "VerticalTrack" {18 6 2 0 4 8 28} directed:True)} use:Vertex) (piece "Counter" Each (or {(if (is In (from) (sites Track Mover "Track")) (forEach Value (values Remembered "Throws") (or (if (= (trackSite Move from:(from) "Track" steps:(value)) -1) (do (forget Value "Throws" (value)) next:(move Remove (from) level:(level)))) (move (from (from) level:(level)) (to (trackSite Move from:(from) "Track" steps:(value)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply (and (if (is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite (who at:(to)))))) (forget Value "Throws" (value))))) (then (if (and (!= (last From) (handSite Mover)) (is Occupied (last From))) (forEach Level (last From) FromTop (fromTo (from (last From) level:(level)) (to (last To))))))) (then (if (!= 0 (size Array (values Remembered "Throws"))) (moveAgain)))))) (if (is In (from) (sites Track "HorizontalTrack")) (forEach Value (values Remembered "Throws") (or (if (= (trackSite Move from:(from) "HorizontalTrack" steps:(value)) -1) (do (forget Value "Throws" (value)) next:(move Remove (from) level:(level)))) (move (from (from) level:(level)) (to (trackSite Move from:(from) "HorizontalTrack" steps:(value)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply (and (if (is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite (who at:(to)))))) (forget Value "Throws" (value))))) (then (if (and (!= (last From) (handSite Mover)) (is Occupied (last From))) (forEach Level (last From) FromTop (fromTo (from (last From) level:(level)) (to (last To))))))) (then (if (!= 0 (size Array (values Remembered "Throws"))) (moveAgain)))))) (if (is In (from) (sites Track "VerticalTrack")) (forEach Value (values Remembered "Throws") (or (if (= (trackSite Move from:(from) "VerticalTrack" steps:(value)) -1) (do (forget Value "Throws" (value)) next:(move Remove (from) level:(level)))) (move (from (from) level:(level)) (to (trackSite Move from:(from) "VerticalTrack" steps:(value)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply (and (if (is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite (who at:(to)))))) (forget Value "Throws" (value))))) (then (if (and (!= (last From) (handSite Mover)) (is Occupied (last From))) (forEach Level (last From) FromTop (fromTo (from (last From) level:(level)) (to (last To))))))) (then (if (!= 0 (size Array (values Remembered "Throws"))) (moveAgain))))))})) (dice d:2 from:0 num:4) (hand Each) (map "Throw" {(pair 0 4) (pair 1 3) (pair 2 2) (pair 3 1) (pair 4 5)})}) (rules (start {(set Team 1 {P1}) (set Team 2 {P2}) (place Stack "Counter1" (handSite P1) count:4) (place Stack "Counter2" (handSite P2) count:4)}) phases:{(phase "Throwing" (play (do (roll) next:(move Pass (then (remember Value "Throws" (mapEntry "Throw" (count Pips))))) (then (moveAgain)))) (nextPhase Mover (not (is In (mapEntry "Throw" (count Pips)) (sites {4 5}))) "Moving")) (phase "Moving" (play (if (can Move (or (forEach Piece top:True) (forEach Piece container:(mover) top:True))) (or (forEach Piece top:True) (forEach Piece container:(mover) top:True)) (move Pass (then (forget Value "Throws" All))))) (nextPhase Mover (= 0 (size Array (values Remembered "Throws"))) "Throwing"))} (end (if (no Pieces TeamMover) (result TeamMover Win))))) 
2x12 board, with spaces as points, divided in two. Twelve pieces per player, which start stacked, two per point in the quadrant to the player's right. Two six-sided dice. Players unstack the pieces by moving pieces off of the stack, but remaining on the same point, according to the throws of the dice. The value of the throw indicates the number of the point which can be unstacked. For example, a throw of 1 and 4 allows the player to unstack the pieces on points 1 and 4. Doubles allow players to only move one piece, but grant the player another throw. When all of a player's pieces are unstacked, they must be restacked, in the same way. When they have been successfully restacked, the player then bears off the pieces from this quadrant of the board. When bearing off, players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. The first player to bear off all their pieces wins. 
(game "Ofanfelling" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {7 8 9 10 11 12} P1 directed:True) (track "Track2" {18 17 16 15 14 13} P2 directed:True)} use:Vertex) (dice d:6 num:2) (piece "Disc" Each (forEach Die if:(!= (pips) 0) (if (= (trackSite Move steps:(pips)) -1) (move Remove (from)) (move (from) (to (trackSite Move steps:(pips))))))) (map "StartTrack" {(pair P1 7) (pair P2 18)})}) (rules (start {(place Stack "Disc1" (sites {7 8 9 10 11 12}) count:2) (place Stack "Disc2" (sites {13 14 15 16 17 18}) count:2)}) phases:{(phase "UnStacking" (play (do (if (or (is Pending) (not (is Prev Mover))) (roll)) next:(forEach Die if:(!= (pips) 0) (if (= (state at:(trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) 0) (move Select (from (trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) (then (and (forEach Level (last To) (set State at:(last To) level:(level) 1)) (if (not (all DiceUsed)) (moveAgain))))))) (then (if (all DiceEqual) (and (set Pending) (moveAgain)))))) (nextPhase Mover (all Sites (sites Occupied by:Mover) if:(not (= (state at:(site)) 0))) "Stacking")) (phase "Stacking" (play (do (if (or (is Pending) (not (is Prev Mover))) (roll)) next:(forEach Die if:(!= (pips) 0) (if (= (state at:(trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) 1) (move Select (from (trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) (then (and (forEach Level (last To) (set State at:(last To) level:(level) 0)) (if (not (all DiceUsed)) (moveAgain))))))) (then (if (all DiceEqual) (and (set Pending) (moveAgain)))))) (nextPhase Mover (all Sites (sites Occupied by:Mover) if:(not (= (state at:(site)) 1))) "BearingOff")) (phase "BearingOff" (play (do (if (or (all DiceEqual) (not (is Prev Mover))) (roll)) next:(forEach Piece top:True) (then (if (or (not (all DiceUsed)) (all DiceEqual)) (moveAgain))))) (end (if (no Pieces Mover) (result Mover Win))))})) 
Four 3x8 rectangles, arranged in a cross. The couting from the bottom of each arm, the spaces marked are the fourth square in the outer rows and the first in the central row. Four pieces per player. Seven cowrie shells, used as dice. The throws are as follows: one mouth up = 10; two mouths up = 2; three mouth up = 3; four mouths up = 4; five mouths up. = 25; six mouths up = 30, seven mouths up = 12, zero mouths up = 7. Pieces begin in the large central space of the board, and then proceed down the central row of their arm, then clockwise around the board, back to the central row, and then to the central space again. Pieces may enter the board on throws of 10, 25, or 30. When a player's piece lands on a space that is occupied by an opponent's piece, the opponent's piece is sent back to start. Pieces are safe from being sent to start when they rest on a marked space. To move off the board, a player must make an exact throw to arrive in the central square. When resting on the final square before the central one, a throw of 10, 25, or 30 is required. The first player to place all of their pieces in the central square wins. 
(game "Pachesi" (players 4) (equipment {(board (add (hole (merge (shift 0 (/ (- 19 3) 2) (rectangle 3 19)) (shift (/ (- 19 3) 2) 0 (rectangle 19 3))) (poly {{8 8} {8 11} {11 11} {11 8}})) cells:{{8 28 48 68 69 70 71 51 31 11 10 9}}) {(track "Track1" "96,9,S,W,N,7,W,N,E,51,N,E,S,43,E,S,W,10,S,W1,N7,End" P1 directed:True) (track "Track2" "96,26,W,N,E,51,N,E,S,43,E,S,W,10,S,W,N,7,W,N1,W7,End" P2 directed:True) (track "Track3" "96,52,N,E,S,43,E,S,W,10,S,W,N,7,W,N,E,51,N,E1,S7,End" P3 directed:True) (track "Track4" "96,27,E,S,W,10,S,W,N,7,W,N,E,51,N,E,S,43,E,S1,W7,End" P4 directed:True)}) (dice d:2 from:0 num:7) (piece "Pawn" Each (if (= (trackSite Move from:(from) steps:(mapEntry "Throw" (count Pips))) -2) (move Remove (from) level:(level)) (if (and (= (trackSite Move from:(from) steps:1) -2) (is In (mapEntry "Throw" (count Pips)) (sites {10 25 30}))) (move Remove (from) level:(level)) (move (from (from) level:(level)) (to (trackSite Move from:(from) steps:(mapEntry "Throw" (count Pips))) if:(not (and (is In (to) (sites "SafeSites")) (is Enemy (who at:(to))))) (apply (if (is Enemy (who at:(to))) (forEach Level (to) FromTop (fromTo (from (to) level:(level)) (to (centrePoint))))))))))) (hand Each) (regions "SafeSites" (sites {55 63 65 34 15 47 94 84 86 19 38 3})) (map "Throw" {(pair 0 7) (pair 1 10) (pair 2 2) (pair 3 3) (pair 4 4) (pair 5 25) (pair 6 30) (pair 7 12)})}) (rules (start {(place Stack "Pawn1" (handSite P1) count:4) (place Stack "Pawn2" (handSite P2) count:4) (place Stack "Pawn3" (handSite P3) count:4) (place Stack "Pawn4" (handSite P4) count:4)}) (play (do (roll) next:(or (if (and (is Occupied (handSite Mover)) (is In (mapEntry "Throw" (count Pips)) (sites {10 25 30}))) (move (from (handSite Mover)) (to (centrePoint)))) (forEach Piece)))) (end (if (no Pieces Mover) (result Mover Win))))) 
Four 3x8 rectangles, arranged in a cross shape around a large central square. The third space, counting from the outer corner, in the two outer rows of each arm of the board are marked with an "X." Four pieces per player. Seven cowrie shells used as dice, the throws as follows: Zero mouths up = 7; one = 10; two = 2; three = 3; four = 4; five = 25; six =30; seven = 14. Throws of 7, 25, 30, and 14 receive an extra throw. Three total throws is the maximum allowed. Pieces begin the game on the top square of the central row of the player's arm of the board. Pieces progress down the central row, then anti-clockwise around the circumference of the board, then up the central row again, to the central space. When a player's piece lands on a spot occupied by an opponent's piece, the opponent's piece is sent back to the starting space. Pieces resting on a marked space cannot be sent back to start; in this case the player's piece as well as the opponent's piece may occupy this space. The first player to bring all four of their pieces to the central space wins. 
(game "Pachih" (players 4) (equipment {(board (add (hole (merge (shift 0 (/ (- 19 3) 2) (rectangle 3 19)) (shift (/ (- 19 3) 2) 0 (rectangle 19 3))) (poly {{8 8} {8 11} {11 11} {11 8}})) cells:{{8 28 48 68 69 70 71 51 31 11 10 9}}) {(track "Track1" "96,9,S,E,N,11,E,N,W,53,N,W,S,42,W,S,E,8,S,E1,N7,End" P1 directed:True) (track "Track2" "96,26,W,S,E,8,S,E,N,11,E,N,W,53,N,W,S,42,W,S1,E7,End" P2 directed:True) (track "Track3" "96,52,N,W,S,42,W,S,E,8,S,E,N,11,E,N,W,53,N,W1,S7,End" P3 directed:True) (track "Track4" "96,27,E,N,W,53,N,W,S,42,W,S,E,8,S,E,N,11,E,N1,W7,End" P4 directed:True)}) (dice d:2 from:0 num:7) (piece "Pawn" Each (if (= (trackSite Move from:(from) steps:(mapEntry "Throw" (count Pips))) -2) (move Remove (from) level:(level)) (move (from (from) level:(level)) (to (trackSite Move from:(from) steps:(mapEntry "Throw" (count Pips))) if:True (apply (if (and (not (is In (to) (sites "SafeSites"))) (is Enemy (who at:(to)))) (forEach Level (to) FromTop (fromTo (from (to) level:(level)) (to (centrePoint)))))))))) (regions "SafeSites" (sites {60 62 2 37 87 89 16 48})) (map "Throw" {(pair 0 7) (pair 1 10) (pair 2 2) (pair 3 3) (pair 4 4) (pair 5 25) (pair 6 30) (pair 7 14)})}) (rules (start {(place Stack "Pawn1" 9 count:4) (place Stack "Pawn2" 26 count:4) (place Stack "Pawn3" 52 count:4) (place Stack "Pawn4" 27 count:4)}) (play (do (roll) next:(forEach Piece) (then (if (and (< (value Player Mover) 2) (is In (mapEntry "Throw" (count Pips)) (sites {7 25 30 14}))) (and (moveAgain) (set Value Mover (+ 1 (value Player Mover)))) (set Value Mover -1))))) (end (if (no Pieces Mover) (result Mover Win))))) 
The game is played either by two teams of two players, or by two players playing with two sets of pieces. The pieces move along the outer track of the board according to dice throws. If a piece lands on a space occupied by an opponent, the opponent's piece is sent back to the starting position. Certain marked squares indicate spaces where pieces are safe from being sent back. After completing a circuit of the board, the pieces then move into the central row of squares in the arm where the player began. The player must then move off all of their pieces by an exact roll. The player or team to remove all of their pieces from the board first wins. 
(game "Pachisi" (players 4) (equipment {(board (add (hole (merge (shift 0 (/ (- 19 3) 2) (rectangle 3 19)) (shift (/ (- 19 3) 2) 0 (rectangle 19 3))) (poly {{8 8} {8 11} {11 11} {11 8}})) cells:{{8 28 48 68 69 70 71 51 31 11 10 9}}) {(track "Track1" "97,68,N,11,E,N,W,53,N,W,S,42,W,S,E,8,S,55,N8" P1 directed:True) (track "Track2" "98,46,W,53,N,W,S,42,W,S,E,8,S,E,N,11,E,34,W8" P2 directed:True) (track "Track3" "99,81,S,42,W,S,E,8,S,E,N,11,E,N,W,53,N,94,S8" P3 directed:True) (track "Track4" "100,4,E,8,S,E,N,11,E,N,W,53,N,W,S,42,W,19,E8" P4 directed:True)}) (hand Each) (dice d:2 from:0 num:6) (map "Die" {(pair 0 25) (pair 1 10) (pair 2 2) (pair 3 3) (pair 4 4) (pair 5 5) (pair 6 6)}) (map "Entry" {(pair 1 68) (pair 2 46) (pair 3 81) (pair 4 4)}) (map "PreviousGoal" {(pair 1 9) (pair 2 27) (pair 3 52) (pair 4 26)}) (regions "Castle" {61 63 65 32 47 15 80 84 86 21 38 3}) (regions "Grace" {0 1 6}) (piece "Pawn" Each (if (or (= (trackSite Move steps:(count Pips)) 96) (and (is In (count Pips) (sites "Grace")) (= (from) (mapEntry "PreviousGoal" (mover))))) (move Select (from) (to 96) (then (remove (last From)))) (if (and (not (= (trackSite Move steps:(mapEntry "Die" (count Pips))) 96)) (not (= (trackSite Move steps:(mapEntry "Die" (count Pips))) -1))) (move (from (from) level:(level)) (to (trackSite Move steps:(mapEntry "Die" (count Pips))) (apply if:(or (not (is In (trackSite Move steps:(mapEntry "Die" (count Pips))) (sites "castle"))) (and (is In (trackSite Move steps:(mapEntry "Die" (count Pips))) (sites "Castle")) (is Friend (who at:(trackSite Move steps:(mapEntry "Die" (count Pips))))))) (if (is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite (who at:(to))))))))))))}) (rules (start {(place Stack "Pawn1" (handSite P1) count:4) (place Stack "Pawn2" (handSite P2) count:4) (place Stack "Pawn3" (handSite P3) count:4) (place Stack "Pawn4" (handSite P4) count:4) (set Team 1 {P1 P3}) (set Team 2 {P2 P4})}) phases:{(phase "firstTurn" (play (do (roll) next:(move (from (handSite (mover))) (to (trackSite Move from:(handSite (mover)) steps:(mapEntry "Die" (count Pips))))))) (nextPhase (> (count Moves) 3) "Movement")) (phase "Movement" (play (do (roll) next:(or {(forEach Piece) (if (and (is Occupied (handSite (mover))) (is In (count Pips) (sites "Grace"))) (move (from (handSite Mover) level:(topLevel at:(handSite (mover)))) (to (mapEntry "Entry" (mover))))) (move Pass)} (then (if (is In (count Pips) (sites "Grace")) (moveAgain)))))))} (end (if (no Pieces TeamMover) (result TeamMover Win))))) 
Sixteen 3x8 rectangles are arranged in a circle, each rectangle touching the corner of another on its left and right. The second, fifth, and eighth squares (counting from the top) in the outer rows, and the third and sixth squares in the central row of each rectangle are marked. Can be played with sixteen, eight, or four players. It can be played individually, or on two teams. Each rectangle has one set of four pieces. They enter the board from the center, proceeding down the central row or their respective rectangles, proceeding in the outer rows of the rectangles in an anti-clockwise direction. When a complete circuit of the board has been made, the pieces must travel down the central row again and exit the board with an exact throw. The game is played with two eight-sided die, containing the following values: 1, 3, 4, 6, 8, 10, 12, 16 on one, 2, 5, 7, 9, 11, 13, 15, 16 on the other. It may also be played with four rectangular dice each with the values 1, 3, 4, 6. Pieces are entered on the throw of nine. Doubles allow a second roll.Spaces moved may be broken up between two pieces but each piece must move a number equal to that displayed on one of the dice. A player can pass, but only before the die is thrown. When two pieces of the same color occupy a space, no other pieces may pass them. These pieces may then move as a single pawn. If a piece lands on the same spot occupied by an opponent's piece, the opponent's piece is sent back to the start. Two pieces moving as a single pawn can only be sent to start by two other pieces moving as a single pawn. Pieces on a marked space cannot be sent to start. A play which sends an opponent's piece to start allows another roll. A player may bypass the central row and circuit the board another time if they wish (i.e., in order to send another player back to start to prevent them from winning). The first player to remove all their pieces from the board wins, and the other platers continue playing until all but one player have moved their pieces into the center. The game involves 16 players.
(game "Pagade Kayi Ata (Sixteen-handed)" (players 16) (equipment {(board (add (merge {(rectangle 3 8) (shift 0.88 -4.45 (rotate 22.5 (rectangle 3 8))) (shift 3.39 -8.21 (rotate 45 (rectangle 3 8))) (shift 7.15 -10.71 (rotate 67.5 (rectangle 3 8))) (shift 11.58 -11.59 (rotate 90 (rectangle 3 8))) (shift 16.02 -10.71 (rotate 112.5 (rectangle 3 8))) (shift 19.8 -8.21 (rotate 135 (rectangle 3 8))) (shift 22.33 -4.45 (rotate 157.5 (rectangle 3 8))) (shift 23.21 0 (rotate 180 (rectangle 3 8))) (shift 22.33 4.45 (rotate 202.5 (rectangle 3 8))) (shift 19.8 8.21 (rotate 225 (rectangle 3 8))) (shift 16.02 10.71 (rotate 247.5 (rectangle 3 8))) (shift 11.58 11.59 (rotate 270 (rectangle 3 8))) (shift 7.15 10.71 (rotate 292.5 (rectangle 3 8))) (shift 3.39 8.21 (rotate 315 (rectangle 3 8))) (shift 0.88 4.45 (rotate 337.5 (rectangle 3 8)))}) edges:{{8 71} {44 107} {80 143} {116 179} {152 215} {188 251} {224 287} {260 323} {296 359} {332 395} {368 431} {404 467} {440 503} {476 539} {512 575} {548 35}} cells:{{35 26 17 8 71 62 53 44 107 98 89 80 143 134 125 116 179 170 161 152 215 206 197 188 251 242 233 224 287 278 269 260 323 314 305 296 359 350 341 332 395 386 377 368 431 422 413 404 467 458 449 440 503 494 485 476 539 530 521 512 575 566 557 548}}) {(track "Track1" "384,15,W,S,E7,47,WSW,SSE,ENE7,71,SW,SE,NE7,95,SSW,ESE,NNE7,119,S,E,N7,143,SSE,ENE,NNW7,167,SE,NE,NW7,191,ESE,NNE,WNW7,215,E,N,W7,239,ENE,NNW,WSW7,263,NE,NW,SW7,287,NNE,WNW,SSW7,311,N,W,S7,335,NNW,WSW,SSE7,359,NW,SW,SE7,383,WNW,SSW,ESE7,23,W,S1,End" P1 directed:True) (track "Track2" "384,39,WSW,SSE,ENE7,71,SW,SE,NE7,95,SSW,ESE,NNE7,119,S,E,N7,143,SSE,ENE,NNW7,167,SE,NE,NW7,191,ESE,NNE,WNW7,215,E,N,W7,239,ENE,NNW,WSW7,263,NE,NW,SW7,287,NNE,WNW,SSW7,311,N,W,S7,335,NNW,WSW,SSE7,359,NW,SW,SE7,383,WNW,SSW,ESE7,23,W,S,E7,47,WSW,SSE1,End" P2 directed:True) (track "Track3" "384,63,SW,SE,NE7,95,SSW,ESE,NNE7,119,S,E,N7,143,SSE,ENE,NNW7,167,SE,NE,NW7,191,ESE,NNE,WNW7,215,E,N,W7,239,ENE,NNW,WSW7,263,NE,NW,SW7,287,NNE,WNW,SSW7,311,N,W,S7,335,NNW,WSW,SSE7,359,NW,SW,SE7,383,WNW,SSW,ESE7,23,W,S,E7,47,WSW,SSE,ENE7,71,SW,SE1,End" P3 directed:True) (track "Track4" "384,87,SSW,ESE,NNE7,119,S,E,N7,143,SSE,ENE,NNW7,167,SE,NE,NW7,191,ESE,NNE,WNW7,215,E,N,W7,239,ENE,NNW,WSW7,263,NE,NW,SW7,287,NNE,WNW,SSW7,311,N,W,S7,335,NNW,WSW,SSE7,359,NW,SW,SE7,383,WNW,SSW,ESE7,23,W,S,E7,47,WSW,SSE,ENE7,71,SW,SE,NE7,95,SSW,ESE1,End" P4 directed:True) (track "Track5" "384,111,S,E,N7,143,SSE,ENE,NNW7,167,SE,NE,NW7,191,ESE,NNE,WNW7,215,E,N,W7,239,ENE,NNW,WSW7,263,NE,NW,SW7,287,NNE,WNW,SSW7,311,N,W,S7,335,NNW,WSW,SSE7,359,NW,SW,SE7,383,WNW,SSW,ESE7,23,W,S,E7,47,WSW,SSE,ENE7,71,SW,SE,NE7,95,SSW,ESE,NNE7,119,S,E1,End" P5 directed:True) (track "Track6" "384,135,SSE,ENE,NNW7,167,SE,NE,NW7,191,ESE,NNE,WNW7,215,E,N,W7,239,ENE,NNW,WSW7,263,NE,NW,SW7,287,NNE,WNW,SSW7,311,N,W,S7,335,NNW,WSW,SSE7,359,NW,SW,SE7,383,WNW,SSW,ESE7,23,W,S,E7,47,WSW,SSE,ENE7,71,SW,SE,NE7,95,SSW,ESE,NNE7,119,S,E,N7,143,SSE,ENE1,End" P6 directed:True) (track "Track7" "384,159,SE,NE,NW7,191,ESE,NNE,WNW7,215,E,N,W7,239,ENE,NNW,WSW7,263,NE,NW,SW7,287,NNE,WNW,SSW7,311,N,W,S7,335,NNW,WSW,SSE7,359,NW,SW,SE7,383,WNW,SSW,ESE7,23,W,S,E7,47,WSW,SSE,ENE7,71,SW,SE,NE7,95,SSW,ESE,NNE7,119,S,E,N7,143,SSE,ENE,NNW7,167,SE,NE1,End," P7 directed:True) (track "Track8" "384,183,ESE,NNE,WNW7,215,E,N,W7,239,ENE,NNW,WSW7,263,NE,NW,SW7,287,NNE,WNW,SSW7,311,N,W,S7,335,NNW,WSW,SSE7,359,NW,SW,SE7,383,WNW,SSW,ESE7,23,W,S,E7,47,WSW,SSE,ENE7,71,SW,SE,NE7,95,SSW,ESE,NNE7,119,S,E,N7,143,SSE,ENE,NNW7,167,SE,NE,NW7,191,ESE,NNE1,End," P8 directed:True) (track "Track9" "384,207,E,N,W7,239,ENE,NNW,WSW7,263,NE,NW,SW7,287,NNE,WNW,SSW7,311,N,W,S7,335,NNW,WSW,SSE7,359,NW,SW,SE7,383,WNW,SSW,ESE7,23,W,S,E7,47,WSW,SSE,ENE7,71,SW,SE,NE7,95,SSW,ESE,NNE7,119,S,E,N7,143,SSE,ENE,NNW7,167,SE,NE,NW7,191,ESE,NNE,WNW7,215,E,N1,End" P9 directed:True) (track "Track10" "384,231,ENE,NNW,WSW7,263,NE,NW,SW7,287,NNE,WNW,SSW7,311,N,W,S7,335,NNW,WSW,SSE7,359,NW,SW,SE7,383,WNW,SSW,ESE7,23,W,S,E7,47,WSW,SSE,ENE7,71,SW,SE,NE7,95,SSW,ESE,NNE7,119,S,E,N7,143,SSE,ENE,NNW7,167,SE,NE,NW7,191,ESE,NNE,WNW7,215,E,N,W7,239,ENE,NNW1,End" P10 directed:True) (track "Track11" "384,255,NE,NW,SW7,287,NNE,WNW,SSW7,311,N,W,S7,335,NNW,WSW,SSE7,359,NW,SW,SE7,383,WNW,SSW,ESE7,23,W,S,E7,47,WSW,SSE,ENE7,71,SW,SE,NE7,95,SSW,ESE,NNE7,119,S,E,N7,143,SSE,ENE,NNW7,167,SE,NE,NW7,191,ESE,NNE,WNW7,215,E,N,W7,239,ENE,NNW,WSW7,263,NE,NW1,End" P11 directed:True) (track "Track12" "384,279,NNE,WNW,SSW7,311,N,W,S7,335,NNW,WSW,SSE7,359,NW,SW,SE7,383,WNW,SSW,ESE7,23,W,S,E7,47,WSW,SSE,ENE7,71,SW,SE,NE7,95,SSW,ESE,NNE7,119,S,E,N7,143,SSE,ENE,NNW7,167,SE,NE,NW7,191,ESE,NNE,WNW7,215,E,N,W7,239,ENE,NNW,WSW7,263,NE,NW,SW7,287,NNE,WNW1,End" P12 directed:True) (track "Track13" "384,303,N,W,S7,335,NNW,WSW,SSE7,359,NW,SW,SE7,383,WNW,SSW,ESE7,23,W,S,E7,47,WSW,SSE,ENE7,71,SW,SE,NE7,95,SSW,ESE,NNE7,119,S,E,N7,143,SSE,ENE,NNW7,167,SE,NE,NW7,191,ESE,NNE,WNW7,215,E,N,W7,239,ENE,NNW,WSW7,263,NE,NW,SW7,287,NNE,WNW,SSW7,311,N,W1,End" P13 directed:True) (track "Track14" "384,327,NNW,WSW,SSE7,359,NW,SW,SE7,383,WNW,SSW,ESE7,23,W,S,E7,47,WSW,SSE,ENE7,71,SW,SE,NE7,95,SSW,ESE,NNE7,119,S,E,N7,143,SSE,ENE,NNW7,167,SE,NE,NW7,191,ESE,NNE,WNW7,215,E,N,W7,239,ENE,NNW,WSW7,263,NE,NW,SW7,287,NNE,WNW,SSW7,311,N,W,S7,335,NNW,WSW1,End" P14 directed:True) (track "Track15" "384,351,NW,SW,SE7,383,WNW,SSW,ESE7,23,W,S,E7,47,WSW,SSE,ENE7,71,SW,SE,NE7,95,SSW,ESE,NNE7,119,S,E,N7,143,SSE,ENE,NNW7,167,SE,NE,NW7,191,ESE,NNE,WNW7,215,E,N,W7,239,ENE,NNW,WSW7,263,NE,NW,SW7,287,NNE,WNW,SSW7,311,N,W,S7,335,NNW,WSW,SSE7,359,NW,SW1,End" P15 directed:True) (track "Track16" "384,375,WNW,SSW,ESE7,23,W,S,E7,47,WSW,SSE,ENE7,71,SW,SE,NE7,95,SSW,ESE,NNE7,119,S,E,N7,143,SSE,ENE,NNW7,167,SE,NE,NW7,191,ESE,NNE,WNW7,215,E,N,W7,239,ENE,NNW,WSW7,263,NE,NW,SW7,287,NNE,WNW,SSW7,311,N,W,S7,335,NNW,WSW,SSE7,359,NW,SW,SE7,383,WNW,SSW1,End" P16 directed:True)}) (map "Start" {(pair 1 15) (pair 2 39) (pair 3 63) (pair 4 87) (pair 5 111) (pair 6 135) (pair 7 159) (pair 8 183) (pair 9 207) (pair 10 231) (pair 11 255) (pair 12 279) (pair 13 303) (pair 14 327) (pair 15 351) (pair 16 375)}) (piece "Disc" Each (if (and (!= (pips) 0) (!= (trackSite Move from:(from) steps:(pips)) -1)) (if (= (trackSite Move from:(from) steps:(pips)) -2) (move Remove (from)) (move (from (from) level:(level)) (to (trackSite Move from:(from) steps:(pips)) if:(and (or (not (is In (to) (sites "Castle"))) (and (is In (to) (sites "Castle")) (not (is Enemy (who at:(to)))))) (not (and (is Enemy (who at:(to))) (> (count at:(to)) 1)))) (apply if:(and (is Enemy (who at:(to))) (= (count at:(to)) 1)) (and (fromTo (from (to)) (to 384)) (set Pending)))))))) (hand Each) (dice d:8 faces:{1 3 4 6 8 10 12 16} num:2) (regions "Castle" {22 19 16 0 3 6 13 10 46 43 40 34 37 24 27 30 70 54 61 67 51 58 64 48 94 78 118 102 142 126 85 109 133 91 75 115 99 139 123 82 106 130 112 88 72 96 136 120 166 150 190 174 214 198 238 222 157 181 205 229 163 147 187 171 211 195 235 219 154 178 202 226 160 144 232 184 168 232 216 208 192 262 246 253 286 270 277 310 294 301 334 318 325 358 342 349 366 382 373 331 315 322 312 328 363 379 370 259 243 250 256 240 376 283 267 274 280 264 307 291 298 304 288 355 339 346 352 360 336}) (regions "DiceHand" {401 402})}) (rules (start {(place Stack "Disc1" (handSite P1) count:4) (place Stack "Disc2" (handSite P2) count:4) (place Stack "Disc3" (handSite P3) count:4) (place Stack "Disc4" (handSite P4) count:4) (place Stack "Disc5" (handSite P5) count:4) (place Stack "Disc6" (handSite P6) count:4) (place Stack "Disc7" (handSite P7) count:4) (place Stack "Disc8" (handSite P8) count:4) (place Stack "Disc9" (handSite P9) count:4) (place Stack "Disc10" (handSite P10) count:4) (place Stack "Disc11" (handSite P11) count:4) (place Stack "Disc12" (handSite P12) count:4) (place Stack "Disc13" (handSite P13) count:4) (place Stack "Disc14" (handSite P14) count:4) (place Stack "Disc15" (handSite P15) count:4) (place Stack "Disc16" (handSite P16) count:4)}) (play (if (is Pending) (move Select (from (sites "DiceHand")) (then (and (roll) (moveAgain)))) (do (if (not (is Prev Mover)) (roll)) next:(forEach Die combined:True replayDouble:True (or (if (and (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site))))) (= (pips) 9)) (move (from (handSite Mover)) (to (mapEntry "Start" (mover))))) (or (forEach Piece) (forEach Piece container:(mover)))) (then (if (can Move (forEach Die combined:True (or (if (and (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site))))) (= (pips) 9)) (fromTo (from (handSite Mover)) (to (mapEntry "Start" (mover))))) (or (forEach Piece) (forEach Piece container:(mover)))))) (moveAgain))))))) (end (if (no Pieces Mover) (result Mover Win))))) 
Four 3x8 rectangles, arranged in a cross shape with a large square space in the center. The outer corners of each square are marked with a cross, as are the third and sixth space from the same corner. Four players, playing on two teams. Four pieces per player. The pieces are red, green, yellow, and black. Players start with one piece on the sixth and seventh space of the central row in their arm, and two pieces on the third space in the outer row of their arm, to the right. Two rectangular four-sided dice, with the following throws: 1, 3, 4, 6. Players use the throw of a die to move a piece; they may therefore may move two pieces each the value of one of the dice, or one piece twice, using the value of each dice. Play moves down the central track of the player's arm, around the outer perimeter of the board in an anti-clockwise direction, and back up the central row of the player's arm, proceeding into the large central square. When a player's piece moves into a space occupied by an opponent's piece, the opponent's piece is sent to the central square, from which it must begin again. A player cannot move into their central row, approaching the end of the track, unless two of their team member's pieces have moved past the player's own pieces. If two or more of the team member's pieces remain behind the player's own pieces, the player's pieces may not advance past the final three spaces in the left hand track of their home arm of the board. Neither they, nor any of the team's pieces, can proceed until two of the team member's pieces are placed, by exact throws, on the left inner corner of the arm of the player wishing to advance. These two pieces must then proceed together; i.e., only on double throws of the dice, with the exception that a double they cannot be used if it would cause them to land on a space occupied by a team member waiting to move. Once a double throw is successfully made and both pieces moved, the waiting pieces may proceed up the central row. When players cannot move the throws, they pass their turn. Players must move into the central square with an exact throw. The first team to place all of their pieces in the central square wins.
(game "Pahada Keliya" (players 4) (equipment {(board (add (hole (merge (shift 0 (/ (- 19 3) 2) (rectangle 3 19)) (shift (/ (- 19 3) 2) 0 (rectangle 19 3))) (poly {{8 8} {8 11} {11 11} {11 8}})) cells:{{8 28 48 68 69 70 71 51 31 11 10 9}}) {(track "Track1" "96,9,S,E,N,11,E,N,W,53,N,W,S,42,W,S,E,8,S,E1,N7,End" P1 directed:True) (track "Track2" "96,26,W,S,E,8,S,E,N,11,E,N,W,53,N,W,S,42,W,S1,E7,End" P2 directed:True) (track "Track3" "96,52,N,W,S,42,W,S,E,8,S,E,N,11,E,N,W,53,N,W1,S7,End" P3 directed:True) (track "Track4" "96,27,E,N,W,53,N,W,S,42,W,S,E,8,S,E,N,11,E,N1,W7,End" P4 directed:True)}) (dice d:4 faces:{1 3 4 6} num:2) (piece "Pawn" Each (forEach Die if:(!= (pips) 0) (if (= (trackSite Move from:(from) steps:(pips)) -2) (move Remove (from) level:(level)) (move (from (from) level:(level)) (to (trackSite Move from:(from) steps:(pips)) if:(if (not (is In (to) (sites Mover "CentralRow"))) True (if (or (is In (from) (sites Mover "CentralRow")) (= (from) 96)) True (<= 1 (value Player Mover)))) (apply (if (is Enemy (who at:(to))) (forEach Level (to) FromTop (and {(if (= 1 (state at:(to) level:(level))) (if (is Mover P1) (set Value P3 (- (if (is Mover P1) (value Player P3) (if (is Mover P3) (value Player P1) (if (is Mover P2) (value Player P4) (value Player P2)))) 1)) (if (is Mover P3) (set Value P1 (- (if (is Mover P1) (value Player P3) (if (is Mover P3) (value Player P1) (if (is Mover P2) (value Player P4) (value Player P2)))) 1)) (if (is Mover P2) (set Value P4 (- (if (is Mover P1) (value Player P3) (if (is Mover P3) (value Player P1) (if (is Mover P2) (value Player P4) (value Player P2)))) 1)) (set Value P2 (- (if (is Mover P1) (value Player P3) (if (is Mover P3) (value Player P1) (if (is Mover P2) (value Player P4) (value Player P2)))) 1)))))) (remove (to) level:(level)) (add (piece (if (= (who at:(to) level:(level)) 1) (id "Pawn" P1) (if (= (who at:(to) level:(level)) 2) (id "Pawn" P2) (if (= (who at:(to) level:(level)) 3) (id "Pawn" P3) (id "Pawn" P4))))) (to (centrePoint)))}))))) (then (if (and (= 0 (state at:(last To) level:(last LevelTo))) (is In (last To) (if (is Mover P1) (sites P3 "RightCentral") (if (is Mover P3) (sites P1 "RightCentral") (if (is Mover P2) (sites P4 "RightCentral") (sites P2 "RightCentral")))))) (and (set State at:(last To) 1) (if (is Mover P1) (set Value P3 (+ 1 (if (is Mover P1) (value Player P3) (if (is Mover P3) (value Player P1) (if (is Mover P2) (value Player P4) (value Player P2)))))) (if (is Mover P3) (set Value P1 (+ 1 (if (is Mover P1) (value Player P3) (if (is Mover P3) (value Player P1) (if (is Mover P2) (value Player P4) (value Player P2)))))) (if (is Mover P2) (set Value P4 (+ 1 (if (is Mover P1) (value Player P3) (if (is Mover P3) (value Player P1) (if (is Mover P2) (value Player P4) (value Player P2)))))) (set Value P2 (+ 1 (if (is Mover P1) (value Player P3) (if (is Mover P3) (value Player P1) (if (is Mover P2) (value Player P4) (value Player P2)))))))))))))) (then (if (not (all DiceUsed)) (moveAgain))))) (regions "CentralRow" P1 (sites Direction from:55 N included:True distance:7)) (regions "CentralRow" P2 (sites Direction from:19 E included:True distance:7)) (regions "CentralRow" P3 (sites Direction from:94 S included:True distance:7)) (regions "CentralRow" P4 (sites Direction from:34 W included:True distance:7)) (regions "RightCentral" P1 (sites Direction from:56 N included:True distance:7)) (regions "RightCentral" P2 (sites Direction from:0 E included:True distance:7)) (regions "RightCentral" P3 (sites Direction from:93 S included:True distance:7)) (regions "RightCentral" P4 (sites Direction from:50 W included:True distance:7))}) (rules (start {(set Team 1 {P1 P3}) (set Team 2 {P2 P4}) (place Stack "Pawn1" 61) (place Stack "Pawn1" 58) (place Stack "Pawn1" 62 count:2) (place Stack "Pawn2" 21) (place Stack "Pawn2" 20) (place Stack "Pawn2" 2 count:2) (place Stack "Pawn3" 88) (place Stack "Pawn3" 91) (place Stack "Pawn3" 87 count:2) (place Stack "Pawn4" 32) (place Stack "Pawn4" 33) (place Stack "Pawn4" 48 count:2)}) (play (do (if (not (is Prev Mover)) (roll)) next:(forEach Piece))) (end (if (no Pieces TeamMover) (result TeamMover Win))))) 
The board is a single track: nine squares along the bottom row. From the central space, a track of 25 spaces, which makes turns every five spaces. It begins vertically, then to the right, then vertical, then diagonallyup and to the left, then diagonallydown and to the left. The squares just before the track turns are marked with an "X." Three pieces per player. Moves are determined with six cowrie shells, the number of mouths which are face up determine the length of the move. 6, 5, and 1 give the player an additional throw. A player must throw a 6, 5, or 1 to enter a piece on the board. The players begin on opposite sides of the bottom row of squares. The score of each throw must be used in its entirety by one piece; it cannot be subdivided. When a player's piece lands on the same square as an opponent's piece, the opponent's piece is sent back to the start. A piece resting on a marked square cannot be sent to start. To move off the board, a player must throw exactly one more than the number of spaces remaining in the track. The first player to remove all of their pieces from the board wins.
(game "Pancha Keliya" (players 2) (equipment {(board (rotate 90 (merge {(shift 2.79 10.44 (rotate 135 (rectangle 5 1))) (shift 6.32 11.15 (rotate 45 (rectangle 5 1))) (shift 9 11 (graph vertices:{{0 0} {-0.75 0.55} {-0.04 1.24} {1 0}} edges:{{0 1} {1 2} {2 3} {3 0}})) (shift 9 5 (rectangle 6 1)) (shift 5 5 (rectangle 1 5)) (rectangle 1 9) (shift 4 0 (rectangle 6 1))})) {(track "Track1" "23,N4,W,N,W,11,7,SW,SE,End" P1 directed:True) (track "Track2" "31,S4,W,N,W,11,7,SW,SE,End" P2 directed:True)}) (piece "Marker" Each (if (= (trackSite Move steps:(count Pips)) -2) (move Remove (from)) (if (!= (trackSite Move steps:(count Pips)) -1) (if (or (is Empty (trackSite Move steps:(count Pips))) (and (not (is Friend (who at:(trackSite Move steps:(count Pips))))) (not (is In (trackSite Move steps:(count Pips)) (sites "Protect"))))) (move (from) (to (trackSite Move steps:(count Pips)) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry "Entry" Next)))))))))) (dice d:2 from:0 num:6) (hand Each) (regions "Protect" (sites {27 19 12 10 1})) (regions "SpecialDiceValues" (sites {1 5 6})) (map "Entry" {(pair P1 23) (pair P2 31)})}) (rules (start (place "Marker" "Hand" count:3)) (play (do (roll) next:(if (and (is In (count Pips) (sites "SpecialDiceValues")) (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))))) (or (move (from (handSite Mover)) (to (mapEntry "Entry" Mover) if:(not (is Enemy (who at:(to)))))) (forEach Piece) (then (moveAgain))) (forEach Piece)))) (end (if (no Pieces Mover) (result Mover Win))))) 
A track of eleven squares, with marks in the two outer and central squares. Ten further squares extending from the central square, with markings in the fifth and final squares. Including this fifth square, a square track with eleven squares per side, with a marked square in each corner and middle square of each side. Five pieces per player. Seven cowries used as dice. The number of mouths up equals the value of the throw; when no mouths are up the player loses their turn. Players begin from opposite ends of the bottom track, and proceed up the vertical track, around the square, and then up the remainder of the vertical track. A player must throw a 1, 5, or 7 to enter the board. Throws of 1, 5, or 7 grant the player another throw. If a piece lands on a space occupied by a piece belonging to the opponent, the opponent's piece is removed from the board and must enter again. Pieces resting on a marked square are safe from being sent back. The player who moves all five of their pieces beyond the final space in the vertical row with an exact throw wins. 
(game "Panchi" (players 2) (equipment {(board (merge {(rectangle 1 11) (shift 0 5 (rotate 90 (rectangle 1 11))) (shift 0 5 (rectangle 1 11)) (shift -5 10 (rotate 90 (rectangle 1 11))) (shift 5 10 (rotate 90 (rectangle 1 11))) (shift 0 15 (rectangle 1 11))}) {(track "Track1" "0,E5,N5,W,N,E,S,W5,N,End" P1 directed:True) (track "Track2" "10,W5,N5,E,N,W,S,E5,N,End" P2 directed:True)}) (piece "Pawn" Each (if (= (trackSite Move steps:(count Pips)) -2) (move Remove (from)) (if (!= (trackSite Move steps:(count Pips)) -1) (if (if (not (is Enemy (who at:(trackSite Move steps:(count Pips))))) True (not (is In (trackSite Move steps:(count Pips)) (sites "Protect")))) (move (from (from) level:(level)) (to (trackSite Move steps:(count Pips)) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite (who at:(to)))) count:(count at:(to)))))))))) (dice d:2 from:0 num:7) (hand Each) (regions "Protect" (sites {0 10 5 16 21 23 30 36 46 56 51 42})) (map {(pair P1 0) (pair P2 10)})}) (rules (start {(place Stack "Pawn1" (handSite P1) count:5) (place Stack "Pawn2" (handSite P2) count:5)}) (play (do (roll) next:(if (can Move (or {(forEach Piece) (forEach Piece container:(mover)) (if (and {(or {(= (count Pips) 1) (= (count Pips) 5) (= (count Pips) 7)}) (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site))))) (or (is Empty (mapEntry (mover))) (is Friend (who at:(mapEntry (mover)))))}) (move (from (handSite (mover))) (to (mapEntry (mover)))))} (then (if (or {(= (count Pips) 1) (= (count Pips) 5) (= (count Pips) 7)}) (moveAgain))))) (or {(forEach Piece) (forEach Piece container:(mover)) (if (and {(or {(= (count Pips) 1) (= (count Pips) 5) (= (count Pips) 7)}) (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site))))) (or (is Empty (mapEntry (mover))) (is Friend (who at:(mapEntry (mover)))))}) (move (from (handSite (mover))) (to (mapEntry (mover)))))} (then (if (or {(= (count Pips) 1) (= (count Pips) 5) (= (count Pips) 7)}) (moveAgain)))) (move Pass (then (if (or {(= (count Pips) 1) (= (count Pips) 5) (= (count Pips) 7)}) (moveAgain))))))) (end (if (no Pieces Mover) (result Mover Win))))) 
2x12 board, divided in half. Spaces on each side take the form of semi-circular sockets, into which the pieces fit. Fifteen pieces per player. Two or three dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. Both players enter their pieces into the same quadrant of the board, and move pieces along a horseshoe-shaped track around the board toward the quadrant on the opposite side of the board. When a piece lands on a space occupied by a single piece of the opponent, the opponent's piece is removed from the board and must enter again as before. When all of the dice present the same number, the player receives another turn. The player to bear off all of their pieces first wins.  The game involves 3 dice
(game "Pareia de Entrada" (players 2) (equipment {(board (merge {(rectangle 1 6) (shift 7 0 (rectangle 1 6)) (shift 0 6 (rectangle 1 6)) (shift 7 6 (rectangle 1 6))}) {(track "Track1" {24 0 1 2 3 4 5 6 7 8 9 10 11 23 22 21 20 19 18 17 16 15 14 13 12} P1 directed:True) (track "Track2" {25 0 1 2 3 4 5 6 7 8 9 10 11 23 22 21 20 19 18 17 16 15 14 13 12} P2 directed:True)} use:Vertex) (dice d:6 num:3) (hand Each) (piece "Disc" Each (forEach Die if:(!= (pips) 0) (if (= (trackSite Move steps:(pips)) -1) (move Remove (from)) (if (or (not (is Enemy (who at:(trackSite Move steps:(pips))))) (= 1 (size Stack at:(trackSite Move steps:(pips))))) (move (from) (to (trackSite Move steps:(pips)) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next))))))))))}) (rules (start {(place Stack "Disc1" (handSite P1) count:15) (place Stack "Disc2" (handSite P2) count:15)}) (play (do (if (or (is Pending) (not (is Prev Mover))) (roll)) next:(or (forEach Piece top:True) (forEach Piece container:(mover) top:True) (then (and (if (not (all DiceUsed)) (moveAgain)) (if (and (all DiceUsed) (all DiceEqual)) (and (set Pending) (moveAgain)))))))) (end (if (no Pieces Mover) (result Mover Win))))) 
Played on a board with 12 points per side, divided in half. Play occurs only in the top right quadrant of the board. Fifteen pieces per player. Two six-sided dice. A double throw grants the player another throw. Players enter their pieces according to the throws of the dice, and they must use the entire value of a die to place or to move a piece. When all of a player's pieces are on the board, they may bear off their pieces with throws equal to the number of remaining spaces, plus one. If a piece lands on a point with a single piece belonging to the opponent, the opponent's piece is removed from the board and must re-enter. The player who bears off all their pieces first wins.
(game "Paumecary" (players 2) (equipment {(board (merge {(rectangle 1 6) (shift 7 0 (rectangle 1 6)) (shift 0 6 (rectangle 1 6)) (shift 7 6 (rectangle 1 6))}) {(track "Track1" {24 23 22 21 20 19 18 -2} P1 directed:True) (track "Track2" {25 23 22 21 20 19 18 -2} P2 directed:True)} use:Vertex) (dice d:6 num:2) (piece "Disc" Each (or (forEach Die replayDouble:True if:(!= (pips) 0) (move (from (from)) (to (trackSite Move from:(from) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next)))))) (then (if (not (all DiceUsed)) (moveAgain)))) (if (is Empty (handSite Mover)) (forEach Die replayDouble:True if:(and (!= (pips) 0) (= (trackSite Move from:(from) steps:(pips)) -2)) (move Remove (from)) (then (if (not (all DiceUsed)) (moveAgain))))))) (hand Each)}) (rules (start {(place Stack "Disc1" (handSite P1) count:15) (place Stack "Disc2" (handSite P2) count:15)}) (play (do (if (not (is Prev Mover)) (roll)) next:(or (forEach Piece) (forEach Piece container:(mover))))) (end (if (no Pieces Mover) (result Mover Win))))) 
Cross-shaped board, with two opposite arms bent at a right angle. Line cross each arm, creating 55 intersections where the pieces are placed. Two teams of one, two, or three people play, with each player controlling one piece. Four longitudinally split reed are used as dice, two are unmarked on the concave side which count as 1, and the other two are marked, and count as 15 and 20. The throws are as follows: All convex faces up = 10; all concave sides up = 5; one concave side up = the value of that side; two concave sides up = 2, three concave sides up =3, A player must throw 10 or more to enter the board. Once a piece is entered, the player throws three times consecutively. Each player owns one of the bent arms of the board, and the piece move anti-clockwise from the right hand end of the arm, to the exit at the left hand end of the arm, but not entering the opponent's arm. When a player lands on a space occupied by an opponent's piece, the opponent's piece is sent back to start. Pieces on the central spot (spot 25) are safe from being sent back. When a piece enters the player's arm again as they approach the goal, throws of 10, 15, and 20 count as 1. On the penultimate space, a throw of 2, 3, or 5 allows a piece to exit, but on the final space a throw of 1, 10, 15, or 20 is required. If playing on teams, a player who has reached the goal continues to throw and use those throws to move their teammates' pieces. The first team to remove all their pieces from the board wins.  The game is played with 6 players.
(game "Petol" (players 6) (equipment {(board (remove (merge {(shift 0 7 (scale 2 1 (rectangle 3 2))) (scale 2 1 (rectangle 8 2)) (shift 0 9 (scale 2 1 (rectangle 8 2))) (shift 4.5 1 (scale 2 1 (rectangle 6 2))) (shift -4.5 10 (scale 2 1 (rectangle 6 2))) (shift 4.5 6 (graph vertices:{{0 0} {0 1} {2 3} {2 0}} edges:{{0 1} {1 2} {2 3} {3 0}})) (shift 2 7 (graph vertices:{{0 0} {0 2} {4.5 2} {2.5 0}} edges:{{0 1} {1 2} {2 3} {3 0}})) (shift 0 7 (graph vertices:{{0 0} {0 2} {-2.5 2} {-4.5 0}} edges:{{0 1} {1 2} {2 3} {3 0}})) (shift -2.5 10 (graph vertices:{{0 0} {0 -1} {-2 -3} {-2 0}} edges:{{0 1} {1 2} {2 3} {3 0}}))}) edges:{{2 3}}) {(track "Track1" "56,S,E1,S,E,N,W,S7,W1,N,End" P1 directed:True) (track "Track2" "35,N,W1,N,W,S,E,N7,E1,S,End" P2 directed:True) (track "Track3" "56,S,E1,S,E,N,W,S7,W1,N,End" P3 directed:True) (track "Track4" "35,N,W1,N,W,S,E,N7,E1,S,End" P4 directed:True) (track "Track5" "56,S,E1,S,E,N,W,S7,W1,N,End" P5 directed:True) (track "Track6" "35,N,W1,N,W,S,E,N7,E1,S,End" P6 directed:True)} use:Vertex) (dice d:2 facesByDie:{{0 1} {0 1} {0 15} {0 20}} num:4) (piece "Marker" Each (if (= (trackSite Move from:(from) steps:1) -2) (if (or {(= 1 (mapEntry "Throw" (count Pips))) (= 10 (mapEntry "Throw" (count Pips))) (= 15 (mapEntry "Throw" (count Pips))) (= 20 (mapEntry "Throw" (count Pips)))}) (move Remove (from) level:(level))) (if (= (trackSite Move from:(from) steps:2) -2) (or (if (or {(= 2 (mapEntry "Throw" (count Pips))) (= 3 (mapEntry "Throw" (count Pips))) (= 5 (mapEntry "Throw" (count Pips)))}) (move Remove (from) level:(level))) (if (is In (mapEntry "Throw" (count Pips)) (sites {1 10 15 20})) (move (from (from) level:(level)) (to (trackSite Move from:(from) steps:1))))) (if (is In (from) (sites Mover "EndTrack")) (move (from (from) level:(level)) (to (trackSite Move from:(from) steps:(if (is In (mapEntry "Throw" (count Pips)) (sites {1 10 15 20})) 1 (mapEntry "Throw" (count Pips)))) if:True)) (move (from (from) level:(level)) (to (trackSite Move from:(from) steps:(mapEntry "Throw" (count Pips))) if:(not (and (is In (to) (sites "SafeSites")) (is Enemy (who at:(to))))) (apply (if (is Enemy (who at:(to))) (forEach Level (to) FromTop (fromTo (from (to) level:(level)) (to (handSite (who at:(to) level:(level)))))))))))))) (hand Each) (map "Throw" {(pair 0 10) (pair 37 5) (pair 1 1) (pair 15 15) (pair 20 20) (pair 2 2) (pair 16 2) (pair 21 2) (pair 35 2) (pair 17 3) (pair 22 3) (pair 36 3)}) (map "Entry" {(pair P1 56) (pair P2 35) (pair P3 56) (pair P4 35) (pair P5 56) (pair P6 35)}) (regions "SafeSites" (sites {2 3})) (regions "EndTrack" P1 (sites {60 47 49 51 53 55 57})) (regions "EndTrack" P2 (sites {58 44 42 40 38 36 34})) (regions "EndTrack" P3 (sites {60 47 49 51 53 55 57})) (regions "EndTrack" P4 (sites {58 44 42 40 38 36 34})) (regions "EndTrack" P5 (sites {60 47 49 51 53 55 57})) (regions "EndTrack" P6 (sites {58 44 42 40 38 36 34}))}) (rules (start {(set Team 1 {P1 P3 P5}) (set Team 2 {P2 P4 P6}) (place "Marker1" (handSite P1)) (place "Marker2" (handSite P2)) (place "Marker3" (handSite P3)) (place "Marker4" (handSite P4)) (place "Marker5" (handSite P5)) (place "Marker6" (handSite P6))}) (play (do (roll) next:(or {(if (and (is Occupied (handSite Mover)) (<= 10 (mapEntry "Throw" (count Pips)))) (move (from (handSite Mover)) (to (mapEntry "Entry" Mover)) (then (and (moveAgain) (set Value Mover 0))))) (forEach Piece (then (if (and (< -1 (value Player Mover)) (> 3 (value Player Mover))) (if (> 2 (value Player Mover)) (and (moveAgain) (set Value Mover (+ 1 (value Player Mover)))) (set Value Mover (+ 1 (value Player Mover))))))) (if (no Pieces Mover) (if (or {(is Mover P1) (is Mover P3) (is Mover P5)}) (or {(forEach Piece P1) (forEach Piece P3) (forEach Piece P5)}) (or {(forEach Piece P2) (forEach Piece P4) (forEach Piece P6)})))}))) (end (if (no Pieces TeamMover) (result TeamMover Win))))) 
2x12 board, with the spaces rendered as points, divided into half. Fifteen pieces per player, which begin on the rightmost point, with respect to the player, on the opposite side of the board from which they sit. Two six-sided dice. Pieces move according to the throws of the dice, the value of a die being used to move a piece the entire value of the die. A throw of double sixes makes the player play six twice, then five twice, then four twice, and so on down to one. A throw of double fives forces the player to play five twice and then six twice. A throw of double four, three, or two forces the player to play two of that number, down to one. A play of double ones forces the player to play one twice, then two twice, up to six. More than two pieces of the same player may not occupy a point on the starting side of the board. The player cannot move past the penultimate point on the opposite side of the board until five pieces have been moved from the starting point. A single opponent's piece may be removed from the board when a player's piece lands on it, and the opponent's piece must reenter the board. Pieces cannot move to a point occupied by two opponent's piece. A piece cannot reenter the board on a point occupied by another piece, whether belonging to the player or the opponent. When all of a player's pieces have reached the final quadrant of the board, the player may begin to remove them from the table. The player who bears off their pieces scores two points.
(game "Piprjall" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {25 24 23 22 21 20 18 17 16 15 14 13 0 1 2 3 4 5 7 8 9 10 11 12 -2} P1 directed:True) (track "Track2" {0 1 2 3 4 5 7 8 9 10 11 12 25 24 23 22 21 20 18 17 16 15 14 13 -2} P2 directed:True)} use:Vertex) (dice d:6 num:2) (piece "Disc" Each (forEach Die replayDouble:True if:(!= (pips) 0) (if (= (trackSite Move from:(from) steps:(pips)) -2) (if (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover "FinalQuadrant"))) (move Remove (from))) (move (from (from)) (to (trackSite Move from:(from) steps:(pips)) if:(and {(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (if (not (is In (to) (sites Mover "StartingSide"))) True (> 2 (size Stack at:(to)))) (if (not (is In (to) (sites Mover "AfterPenultimate"))) True (>= 10 (count Pieces in:(sites {(handSite Mover) (mapEntry "Entry" Mover)}))))}) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next))))))) (then (if (not (all DiceUsed)) (moveAgain))))) (hand Each) (regions "FinalQuadrant" P1 (sites {7 8 9 10 11 12})) (regions "FinalQuadrant" P2 (sites {13 14 15 16 17 18})) (regions "StartingSide" P1 (sites {25 24 23 22 21 20 18 17 16 15 14 13})) (regions "StartingSide" P2 (sites {0 1 2 3 4 5 7 8 9 10 11 12})) (regions "AfterPenultimate" P1 (sites {12})) (regions "AfterPenultimate" P2 (sites {13})) (map "Entry" {(pair P1 25) (pair P2 0)})}) (rules (start {(place Stack "Disc1" 25 count:15) (place Stack "Disc2" 0 count:15)}) (play (if (can Move (if (>= 0 (value Player Mover)) (do (if (not (is Prev Mover)) (roll)) next:(if (all DiceEqual) (or (if (is Occupied (handSite Mover)) (move (from (handSite Mover)) (to (trackSite Move from:(mapEntry "Entry" Mover) steps:(- (face 28) 1)) if:(is Empty (to))))) (forEach Piece (if (= (trackSite Move from:(from) steps:(face 28)) -2) (if (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover "FinalQuadrant"))) (move Remove (from))) (move (from (from)) (to (trackSite Move from:(from) steps:(face 28)) if:(and {(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (if (not (is In (to) (sites Mover "StartingSide"))) True (> 2 (size Stack at:(to)))) (if (not (is In (to) (sites Mover "AfterPenultimate"))) True (>= 10 (count Pieces in:(sites {(handSite Mover) (mapEntry "Entry" Mover)}))))}) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next))))))) top:True) (then (and {(moveAgain) (set Var "FirstPlay" 1) (set Value Mover (face 28)) (set Var "DoubleToPlay" (face 28))}))) (or (if (is Occupied (handSite Mover)) (forEach Die replayDouble:True if:(!= (pips) 0) (move (from (handSite Mover)) (to (trackSite Move from:(mapEntry "Entry" Mover) steps:(- (pips) 1)) if:(is Empty (to)))) (then (if (not (all DiceUsed)) (moveAgain))))) (forEach Piece top:True)))) (or (if (is Occupied (handSite Mover)) (move (from (handSite Mover)) (to (trackSite Move from:(mapEntry "Entry" Mover) steps:(- (var "DoubleToPlay") 1)) if:(is Empty (to))))) (forEach Piece (if (= (trackSite Move from:(from) steps:(var "DoubleToPlay")) -2) (if (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover "FinalQuadrant"))) (move Remove (from))) (move (from (from)) (to (trackSite Move from:(from) steps:(var "DoubleToPlay")) if:(and {(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (if (not (is In (to) (sites Mover "StartingSide"))) True (> 2 (size Stack at:(to)))) (if (not (is In (to) (sites Mover "AfterPenultimate"))) True (>= 10 (count Pieces in:(sites {(handSite Mover) (mapEntry "Entry" Mover)}))))}) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next))))))) top:True) (then (and {(if (or (= (value Player Mover) 1) (= (value Player Mover) 5)) (if (!= (var "FirstPlay") 1) (and (set Var "DoubleToPlay" (var "DoubleToPlay")) (moveAgain)) (if (!= 6 (var "DoubleToPlay")) (and (set Var "DoubleToPlay" (+ (var "DoubleToPlay") 1)) (moveAgain)) (and (set Var "DoubleToPlay" 0) (set Value Mover 0)))) (if (!= (var "FirstPlay") 1) (and (set Var "DoubleToPlay" (var "DoubleToPlay")) (moveAgain)) (if (!= 1 (var "DoubleToPlay")) (and (set Var "DoubleToPlay" (- (var "DoubleToPlay") 1)) (moveAgain)) (and (set Var "DoubleToPlay" 0) (set Value Mover 0))))) (if (!= (var "FirstPlay") 1) (set Var "FirstPlay" 1) (set Var "FirstPlay" 0))}))) (then (if (no Pieces Mover) (set Score Mover 2))))) (if (>= 0 (value Player Mover)) (do (if (not (is Prev Mover)) (roll)) next:(if (all DiceEqual) (or (if (is Occupied (handSite Mover)) (move (from (handSite Mover)) (to (trackSite Move from:(mapEntry "Entry" Mover) steps:(- (face 28) 1)) if:(is Empty (to))))) (forEach Piece (if (= (trackSite Move from:(from) steps:(face 28)) -2) (if (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover "FinalQuadrant"))) (move Remove (from))) (move (from (from)) (to (trackSite Move from:(from) steps:(face 28)) if:(and {(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (if (not (is In (to) (sites Mover "StartingSide"))) True (> 2 (size Stack at:(to)))) (if (not (is In (to) (sites Mover "AfterPenultimate"))) True (>= 10 (count Pieces in:(sites {(handSite Mover) (mapEntry "Entry" Mover)}))))}) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next))))))) top:True) (then (and {(moveAgain) (set Var "FirstPlay" 1) (set Value Mover (face 28)) (set Var "DoubleToPlay" (face 28))}))) (or (if (is Occupied (handSite Mover)) (forEach Die replayDouble:True if:(!= (pips) 0) (move (from (handSite Mover)) (to (trackSite Move from:(mapEntry "Entry" Mover) steps:(- (pips) 1)) if:(is Empty (to)))) (then (if (not (all DiceUsed)) (moveAgain))))) (forEach Piece top:True)))) (or (if (is Occupied (handSite Mover)) (move (from (handSite Mover)) (to (trackSite Move from:(mapEntry "Entry" Mover) steps:(- (var "DoubleToPlay") 1)) if:(is Empty (to))))) (forEach Piece (if (= (trackSite Move from:(from) steps:(var "DoubleToPlay")) -2) (if (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover "FinalQuadrant"))) (move Remove (from))) (move (from (from)) (to (trackSite Move from:(from) steps:(var "DoubleToPlay")) if:(and {(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (if (not (is In (to) (sites Mover "StartingSide"))) True (> 2 (size Stack at:(to)))) (if (not (is In (to) (sites Mover "AfterPenultimate"))) True (>= 10 (count Pieces in:(sites {(handSite Mover) (mapEntry "Entry" Mover)}))))}) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next))))))) top:True) (then (and {(if (or (= (value Player Mover) 1) (= (value Player Mover) 5)) (if (!= (var "FirstPlay") 1) (and (set Var "DoubleToPlay" (var "DoubleToPlay")) (moveAgain)) (if (!= 6 (var "DoubleToPlay")) (and (set Var "DoubleToPlay" (+ (var "DoubleToPlay") 1)) (moveAgain)) (and (set Var "DoubleToPlay" 0) (set Value Mover 0)))) (if (!= (var "FirstPlay") 1) (and (set Var "DoubleToPlay" (var "DoubleToPlay")) (moveAgain)) (if (!= 1 (var "DoubleToPlay")) (and (set Var "DoubleToPlay" (- (var "DoubleToPlay") 1)) (moveAgain)) (and (set Var "DoubleToPlay" 0) (set Value Mover 0))))) (if (!= (var "FirstPlay") 1) (set Var "FirstPlay" 1) (set Var "FirstPlay" 0))}))) (then (if (no Pieces Mover) (set Score Mover 2)))) (move Pass (then (and {(set Value Mover 0) (set Var "FirstPlay" 0) (set Var "DoubleToPlay" 0)}))))) (end (if (no Pieces Mover) (result Mover Win))))) 
Played on a standard Backgammon board. Each player starts with fifteen pieces on the starting point of their track. Two six-sided dice. The pieces move around the board in opposite directions in a horseshoe-shaped track. Each player rolls one die. The player who rolls highest goes first. The player then rolls two die to begin play. The numbers on the two dice constitute separate moves; i.e. a piece must move the full value of an individual die. One piece may move the combined total of the two die. Doubles are played twice. A player must use both numbers of a roll if possible, or all four numbers in the case of doubles. If a player lands on a point occupied by a single opposing piece, the opponent’s piece is trapped until the trapping player removes their piece. A piece may not be moved to a point occupied by two or more of the opponent's pieces. The player cannot move a piece to a point where the opponent has trapped another of the player's pieces. Once a player has moved all fifteen of their pieces into the their home section of the board (that is, the six points at the end of the player's track), the player may begin bearing off. A player cannot bear off when the player has one or more pieces trapped inside the their home section. A player bears off by rolling a number equal to the number of points left in the track of a piece, plus one. If there is no piece on the point indicated by the roll, then the player must make a legal move using a piece that will not remove it from the board. If there are no pieces available to fulfill this condition, the player must remove a piece that is furthest from the goal. The first player to bear off all fifteen pieces wins the game. If the last piece belonging to player remains in the starting position is trapped by the opponent before it has left the starting position, the player loses. The only exception is if the opponent still has pieces on their starting position. A game in which both players' respective pieces in the starting position are trapped is a draw. In Tavli, in subsequent rounds, the winner of the previous round plays first. The game is also typically played with a point system, where points are lost based on the winning conditions. Players lose two points by losing if they haven't yet borne off any of their pieces, or one point if they have borne off at least one piece. A player who loses because their final piece in the starting position was trapped loses two points.
(game "Plakoto" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {12 11 10 9 8 7 5 4 3 2 1 0 13 14 15 16 17 18 20 21 22 23 24 25} P1 directed:True) (track "Track2" {25 24 23 22 21 20 18 17 16 15 14 13 0 1 2 3 4 5 7 8 9 10 11 12} P2 directed:True)} use:Vertex) (dice num:2) (regions P1 {20 21 22 23 24 25}) (regions P2 {7 8 9 10 11 12}) (piece "Disc" Each (forEach Die replayDouble:True if:(and {(!= (pips) 0) (!= (trackSite Move from:(from) steps:(pips)) -1) (!= (trackSite Move from:(from) steps:(pips)) -2)}) (move (from (from)) (to (trackSite Move from:(from) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to))))))))}) (rules (start {(place Stack "Disc1" 12 count:15) (place Stack "Disc2" 25 count:15)}) (play (do (if (not (is Prev Mover)) (roll)) next:(if (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover))) (forEach Die replayDouble:True if:(!= (pips) 0) (forEach Site (sites Occupied by:Mover) (if (and (is Occupied (site)) (!= (trackSite Move from:(site) steps:(pips)) -1)) (if (= (trackSite Move from:(site) steps:(pips)) -2) (move Remove (from)) (move (from (site)) (to (trackSite Move from:(site) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))))))) noMoveYet:(firstMoveOnTrack "Track" Mover (if (and (is Friend (who at:(site))) (< (trackSite Move from:(site) steps:(pips)) 0)) (move Remove (from)))) (then (if (not (all DiceUsed)) (moveAgain))))) (max Distance "Track" Mover (forEach Piece top:True (then (if (not (all DiceUsed)) (moveAgain)))))))) (end {(if (no Pieces Mover) (byScore {(score P1 (if (is Mover P1) (if (= (size Stack in:(sites Occupied by:P2)) 15) 2 1) 0)) (score P2 (if (is Mover P2) (if (= (size Stack in:(sites Occupied by:P1)) 15) 2 1) 0))})) (if (and (= (what at:12 level:0) (id "Disc1" P1)) (= (what at:12 level:1) (id "Disc2" P2))) (byScore {(score P1 0) (score P2 2)})) (if (and (= (what at:25 level:0) (id "Disc2" P2)) (= (what at:25 level:1) (id "Disc1" P1))) (byScore {(score P1 2) (score P2 0)}))}))) 
The game is played on a board with twelve points on either side. The points form a continuous track in a horseshoe shape; each player progresses in opposite directions (one from their bottom right to the top right, the other from their bottom left to their top left. Each player has 15 pieces. The starting position is as such, numbering the points from the origin of each player's track: Point six: five pieces. Point 8: three pieces. Point 13: five pieces. Point 24: two pieces. Play begins by each player rolling one die; the player who rolls the highest plays first, and then rolls again to begin play. Players move according to the number on each die by moving one piece the number on one die and another the number on the other die, or by moving one piece twice (once for each die). If doubles are rolled, the player must play the number on each die twice. Players cannot end their move on a point with multiple opposing pieces. If a player ends the turn on a point with one opposing piece, that piece is placed in the middle of the board (not on a point) and must reenter the board according the the next die roll, counting the origin point as a move of one. They cannot reenter on a point with two or more pieces. No other pieces can move until all of the pieces belonging to that player are removed from the center. When all of a player's pieces are on their final 6 points, they may start removing pieces from the board. They can do so by rolling a 6 to move from the 6th point, and so on down to 1. Players must use all available moves presented by the dice. The first player to remove all of their pieces wins. The winner gains one point, or two points if the opponent has pieces in their starting quadrant. 
(game "Portes" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {6 12 11 10 9 8 7 5 4 3 2 1 0 13 14 15 16 17 18 20 21 22 23 24 25 -2} P1 directed:True) (track "Track2" {19 25 24 23 22 21 20 18 17 16 15 14 13 0 1 2 3 4 5 7 8 9 10 11 12 -2} P2 directed:True)} use:Vertex) (dice num:2) (regions P1 {20 21 22 23 24 25}) (regions P2 {7 8 9 10 11 12}) (map {(pair 1 6) (pair 2 19)}) (piece "Disc" Each (forEach Die replayDouble:True if:(and {(!= (pips) 0) (!= (trackSite Move from:(from) steps:(pips)) -1) (!= (trackSite Move from:(from) steps:(pips)) -2)}) (move (from (from)) (to (trackSite Move from:(from) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry Next))))))))}) (rules (start {(place Stack "Disc1" 0 count:5) (place Stack "Disc1" 12 count:2) (place Stack "Disc1" 17 count:3) (place Stack "Disc1" 20 count:5) (place Stack "Disc2" 4 count:3) (place Stack "Disc2" 7 count:5) (place Stack "Disc2" 13 count:5) (place Stack "Disc2" 25 count:2)}) (play (do (if (not (is Prev Mover)) (roll)) next:(if (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover))) (forEach Die replayDouble:True if:(!= (pips) 0) (forEach Site (sites Occupied by:Mover) (if (and (is Occupied (site)) (!= (trackSite Move from:(site) steps:(pips)) -1)) (if (= (trackSite Move from:(site) steps:(pips)) -2) (move Remove (site)) (move (from (site)) (to (trackSite Move from:(site) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry Next)))))))) noMoveYet:(firstMoveOnTrack "Track" Mover (if (and (is Friend (who at:(site))) (< (trackSite Move from:(site) steps:(pips)) 0)) (move Remove (site)))) (then (if (not (all DiceUsed)) (moveAgain))))) (max Distance "Track" Mover (if (is Empty (mapEntry (mover))) (forEach Piece top:True) (forEach Die replayDouble:True if:(!= (pips) 0) (move (from (mapEntry (mover))) (to (trackSite Move from:(mapEntry (mover)) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry Next))))))) (then (if (not (all DiceUsed)) (if (can Move (if (is Empty (mapEntry (mover))) (forEach Piece top:True) (forEach Die replayDouble:True if:(!= (pips) 0) (move (from (mapEntry (mover))) (to (trackSite Move from:(mapEntry (mover)) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry Next))))))))) (moveAgain))))))))) (end (if (no Pieces Mover) (byScore {(score P1 (if (is Mover P1) (if (= (size Stack in:(sites Occupied by:P2)) 15) 2 1) 0)) (score P2 (if (is Mover P2) (if (= (size Stack in:(sites Occupied by:P1)) 15) 2 1) 0))}))))) 
2x12 board, divided in half, where the spaces are rendered as points. Fifteen pieces per player. Three six-sided dice. The points form a continuous track in a horseshoe shape; each player progresses in opposite directions, one from their bottom right to the top right, the other from their bottom left to their top left. Pieces begin on the board, each player with eight pieces on the sixth and seven on the seventh point of their track. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. A piece cannot move to a point that is occupied by more than one of the opponent's pieces. If a piece lands on a point occupied by a single piece belonging to the opponent, the opponent's piece is removed from the board and must enter again from the beginning of the player's track. A piece may be borne off the board when a throw is greater than the number of points left on the board. The first player to bear all of their pieces off the board wins. 
(game "Provincial" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {6 12 11 10 9 8 7 5 4 3 2 1 0 13 14 15 16 17 18 20 21 22 23 24 25} P1 directed:True) (track "Track2" {19 25 24 23 22 21 20 18 17 16 15 14 13 0 1 2 3 4 5 7 8 9 10 11 12} P2 directed:True)} use:Vertex) (dice num:3) (map {(pair 1 19) (pair 2 6)}) (piece "Disc" Each)}) (rules (start {(place Stack "Disc1" 7 count:8) (place Stack "Disc1" 5 count:7) (place Stack "Disc2" 20 count:8) (place Stack "Disc2" 18 count:7)}) (play (do (if (not (is Prev Mover)) (roll)) next:(forEach Die if:(!= (pips) 0) (forEach Site (sites Occupied by:Mover) (if (= (trackSite Move from:(site) steps:(pips)) -1) (move Remove (site)) (move (from (site)) (to (trackSite Move from:(site) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (mover))))))))) (then (if (not (all DiceUsed)) (moveAgain)))))) (end (if (no Pieces Mover) (result Mover Win))))) 
2x12 board, divided in half. Spaces on each side take the form of semi-circular sockets, into which the pieces fit. Fifteen pieces per player. Pieces begin on one half of a player's side of the board (the half to the left of one player, and to the right of the other player), two per space, then two on the next space and one on the space following that one. Three six-sided dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. Pieces move in a track the long way around the board toward the portion where the opponent begins. No more than two pieces can occupy a space at a time. When a piece lands on a space occupied by a single piece of the opponent, the opponent's piece is removed from the board. The opponent must then reenter this piece on the board onto an open point according to the throw of the dice, from the original starting quadrant on the board. Players attempt to bear off their pieces by rolling the exact number of spaces left on the board, plus one. The first player to bear off all their pieces wins.
(game "Quinze Tablas" (players 2) (equipment {(board (merge {(rectangle 1 6) (shift 7 0 (rectangle 1 6)) (shift 0 6 (rectangle 1 6)) (shift 7 6 (rectangle 1 6))}) {(track "Track1" {24 0 1 2 3 4 5 6 7 8 9 10 11 23 22 21 20 19 18 17 16 15 14 13 12 -2} P1 directed:True) (track "Track2" {25 12 13 14 15 16 17 18 19 20 21 22 23 11 10 9 8 7 6 5 4 3 2 1 0 -2} P2 directed:True)} use:Vertex) (dice d:6 num:3) (hand Each) (piece "Disc" Each (forEach Die if:(!= (pips) 0) (if (= (trackSite Move steps:(pips)) -2) (move Remove (from)) (if (!= (trackSite Move steps:(pips)) -1) (if (= (topLevel at:(trackSite Move steps:(pips))) 0) (move (from) (to (trackSite Move steps:(pips)) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next)))))))))))}) (rules (start {(place Stack "Disc1" (sites {0 1 2 3 4 5 6}) count:2) (place Stack "Disc1" 7 count:1) (place Stack "Disc2" (sites {12 13 14 15 16 17 18}) count:2) (place Stack "Disc2" 19 count:1)}) (play (do (if (not (is Prev Mover)) (roll)) next:(if (is Empty (handSite Mover)) (forEach Piece top:True) (forEach Die replayDouble:True if:(!= (pips) 0) (move (from (handSite Mover)) (to (trackSite Move from:(handSite Mover) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next))))))) (then (if (not (all DiceUsed)) (moveAgain)))))) (end {(if (no Pieces P1) (result P1 Win)) (if (no Pieces P2) (result P2 Win))}))) 
Played on a board with 36 holes arranged in a square, with a gap in the center of each side. There are two semi circles of five holes on the outside of two opposite corners of the board. Two pieces per player. Four stick dice are used, each with one marked side. Each die is marked differently for a different value: 4, 6, 14, 15. The throws are as follows: All marked sides up = 5; three marked sides up = 3; two marked sides up = 2, one marked side up = the value of the marked side; zero marked sides up = 10. Throws of 14 may instead be played as a throw of 1, whenever the player chooses. Players’ pieces enter on the branching arcs. Players move in opposite directions around the board, and then back down the arc in which they started, moving their pieces off the board. If a player lands on the same spot as the opponent, the opponent’s piece is removed from the board and must re-enter. A player's piece is allowed to occupy the same space as that player's other piece. On the last side of the rectangle before completing a circuit of the board, only throws of 1, 2, or 3 are used. Players must make an exact throw to get a piece off the board. The first player to remove their pieces from the board wins. 
(game "Romavoa" (players 2) (equipment {(board (add (merge {(shift -1.25 -0.34 (rotate 30 (rectangle 6 1))) (rectangle 1 5) (rectangle 5 1) (shift 0 6 (rectangle 5 1)) (shift 0 10 (rectangle 1 5)) (shift 7 0 (rectangle 1 5)) (shift 7 10 (rectangle 1 5)) (shift 11 0 (rectangle 5 1)) (shift 11 6 (rectangle 5 1)) (shift 12.25 5.33 (rotate 30 (rectangle 6 1)))}) edges:{{13 14} {22 28} {37 36} {9 23}}) {(track "Track1" "46,5,SSE,N,E,S,W,NNW2,End" P1 directed:True) (track "Track2" "47,41,NNW,W,S,E,N,SSE2,End" P2 directed:True)} use:Vertex) (regions "AllSites" (sites Board)) (regions "LastSide" P1 (sites {6 7 8 9 23 24 25 26 27})) (regions "LastSide" P2 (sites {27 33 34 35 36 37 38 39 40})) (dice d:2 facesByDie:{{0 4} {0 6} {0 14} {0 15}} num:4) (piece "Marker" Each (if (if (not (is In (from) (sites Mover "LastSide"))) True (or {(= (mapEntry "Throw" (count Pips)) 1) (= (mapEntry "Throw" (count Pips)) 2) (= (mapEntry "Throw" (count Pips)) 3)})) (or (if (= 14 (mapEntry "Throw" (count Pips))) (if (= (trackSite Move steps:1) -2) (move Remove (from) level:(level)) (move (from (from) level:(level)) (to (trackSite Move steps:1) (apply (if (is Enemy (who at:(to))) (forEach Level (to) FromTop (fromTo (from (to) level:(level)) (to (handSite (who at:(to) level:(level)))))))))))) (if (= (trackSite Move steps:(mapEntry "Throw" (count Pips))) -2) (move Remove (from) level:(level)) (move (from (from) level:(level)) (to (trackSite Move steps:(mapEntry "Throw" (count Pips))) (apply (if (is Enemy (who at:(to))) (forEach Level (to) FromTop (fromTo (from (to) level:(level)) (to (handSite (who at:(to) level:(level)))))))))))))) (hand Each) (map "Throw" {(pair 0 10) (pair 39 5) (pair 24 3) (pair 25 3) (pair 35 3) (pair 33 3) (pair 10 2) (pair 18 2) (pair 19 2) (pair 20 2) (pair 21 2) (pair 29 2)})}) (rules (start {(place Stack "Marker1" (handSite P1) count:2) (place Stack "Marker2" (handSite P2) count:2)}) (play (do (roll) next:(or (forEach Piece) (forEach Piece container:(mover))))) (end (if (no Pieces Mover) (result Mover Win))))) 
Each player starts play on one of the top corners of the 3x4 grid, proceeding down that row to the opposite corner, and then up the central track, which both players use, and then turning back toward the original side of the track when reaching the top of the central track in the 2x3 grid. If a player lands on an opponent's spot, they are removed from the board and may reenter on a subsequent turn. A rosette in the center of the central track marks the spot where a player is safe from capture. Rosettes in the four corners allow a player to roll again. A player wins when they remove all seven of their pieces from the board by rolling the exact number of spaces left in the track, plus one. The pieces follow the track described by Finkel. The rosettes are protecting the pieces and allow them to replay.
(game "Royal Game of Ur" (players 2) (equipment {(board (hole (hole (rectangle 3 8) (poly {{4 0} {4 1} {6 1} {6 0}})) (poly {{4 2} {4 3} {6 3} {6 2}})) {(track "Track1" "20,3,W,N1,E,S1,W,End" P1 directed:True) (track "Track2" "21,17,W,S1,E,N1,W,End" P2 directed:True)}) (dice d:2 from:0 num:4) (hand Each) (regions "Replay" (sites {"A1" "A3" "D2" "G1" "G3"})) (piece "UrPiece" Each (if (= (trackSite Move steps:(count Pips)) -2) (move Remove (from)) (if (!= (trackSite Move steps:(count Pips)) -1) (if (or (is Empty (trackSite Move steps:(count Pips))) (and (not (is Friend (who at:(trackSite Move steps:(count Pips))))) (not (is In (trackSite Move steps:(count Pips)) (sites "Replay"))))) (move (from) (to (trackSite Move steps:(count Pips)) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next))))) (then (if (is In (last To) (sites "Replay")) (moveAgain))))))))}) (rules (start {(place "UrPiece1" (handSite P1) count:7) (place "UrPiece2" (handSite P2) count:7)}) (play (do (roll) next:(if (!= (count Pips) 0) (or (forEach Piece) (forEach Piece container:(mover)))))) (end (if (no Pieces Mover) (result Mover Win))))) 
Played on a board with twelve points on either side. The points form a continuous track in a horseshoe shape; each player progresses in opposite directions (one from their bottom right to the top right, the other from their bottom left to their top left. Each player has 15 pieces. Each player's pieces begin in three stacks of five on the first point of their track. Two six-sided dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. If a player places all of their pieces on all of the points on the final six points of their side of the board, with three on each of the final three points, they win two points. Otherwise, they move into the opposite side of the board. When an opponent's piece lands on a point occupied by one of the player's pieces on the opponent's side of the board, the piece is removed from the board and must enter again. A player's pieces cannot be hit on their own side of the board. Once a player has brought all of their pieces into the final six points of the board, they may begin to bear off. They can do so by rolling a 6 to move from the 6th point, and so on down to 1. Players must use all available moves presented by the dice. The first player to remove all of their pieces wins. 
(game "Schuster" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {6 12 11 10 9 8 7 5 4 3 2 1 0 13 14 15 16 17 18 20 21 22 23 24 25 -2} P1 directed:True) (track "Track2" {19 25 24 23 22 21 20 18 17 16 15 14 13 0 1 2 3 4 5 7 8 9 10 11 12 -2} P2 directed:True)} use:Vertex) (dice d:6 num:2) (piece "Disc" Each (forEach Die if:(!= (pips) 0) (if (= (trackSite Move from:(from) steps:(pips)) -2) (if (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover "FinalQuadrant"))) (move Remove (from))) (move (from (from)) (to (trackSite Move from:(from) steps:(pips)) if:(or (and {(is Enemy (who at:(to))) (not (is In (to) (sites Mover "OppositeSide"))) (= (topLevel at:(to)) 0)}) (not (is Enemy (who at:(to))))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry "Bar" Next))))))) (then (and (if (not (all DiceUsed)) (moveAgain)) (if (if (is Mover P1) (and {(= 15 (count Pieces Mover in:(sites {0 1 2 3 4 5}))) (is Friend (who at:3)) (is Friend (who at:4)) (is Friend (who at:5)) (= 3 (size Stack at:0)) (= 3 (size Stack at:1)) (= 3 (size Stack at:2))}) (and {(= 15 (count Pieces Mover in:(sites {13 14 15 16 17 18}))) (is Friend (who at:16)) (is Friend (who at:17)) (is Friend (who at:18)) (= 3 (size Stack at:13)) (= 3 (size Stack at:14)) (= 3 (size Stack at:15))})) (addScore Mover 2)))))) (regions "FinalQuadrant" P1 (sites {20 21 22 23 24 25})) (regions "FinalQuadrant" P2 (sites {7 8 9 10 11 12})) (regions "OppositeSide" P1 (sites {25 24 23 22 21 20 18 17 16 15 14 13})) (regions "OppositeSide" P2 (sites {0 1 2 3 4 5 7 8 9 10 11 12})) (map "Bar" {(pair P1 6) (pair P2 19)})}) (rules (start {(place Stack "Disc1" 12 count:15) (place Stack "Disc2" 25 count:15)}) (play (do (if (not (is Prev Mover)) (roll)) next:(forEach Piece top:True))) (end {(if (if (is Mover P1) (and {(= 15 (count Pieces Mover in:(sites {0 1 2 3 4 5}))) (is Friend (who at:3)) (is Friend (who at:4)) (is Friend (who at:5)) (= 3 (size Stack at:0)) (= 3 (size Stack at:1)) (= 3 (size Stack at:2))}) (and {(= 15 (count Pieces Mover in:(sites {13 14 15 16 17 18}))) (is Friend (who at:16)) (is Friend (who at:17)) (is Friend (who at:18)) (= 3 (size Stack at:13)) (= 3 (size Stack at:14)) (= 3 (size Stack at:15))})) (result Mover Win)) (if (no Pieces Mover) (result Mover Win))}))) 
Seven pieces per player, which begin on the board, alternating spaces from white to black along the track. Four throwing sticks, marked on one side and blank on the other, used as dice. The values of the throws are equal to the number of blank sides up, when no blank sides are up the throw = 5. Throws of 1, 4, and 5 grant the player another throw. All throws are made before moving, and a piece must move the full value of one throw at a time. Players alternate turns throwing the sticks, and the first one to throw 1 plays as white and moves the white piece in front. When a piece lands on a space occupied by the opponent's piece, the opponent's piece is sent back to the space where the piece that captured it moved from. When a player has two or more pieces in consecutive spaces, these pieces cannot be sent backward in this way. If a player cannot use a throw to move a piece forward, it must be used to move a piece backward. If a backward move makes a player's piece land on a space occupied by a piece belonging to the opponent, the opponent's piece is sent to the place where the player's move began. If a player cannot move, the turn ends. Spaces 26-30 provide special rules allowing the player to bear off. To move beyond square 26, the player must first land on it with an exact throw. From there, the player may: bear off with a throw of 5; move to square 30 with a throw of 4 and bear off on any subsequent throw; move to square 29 with a throw of 3, but it must stay there until borne off with a throw of 2; move to square 28 with a throw of 2, but it must stay there until borne off with a throw of 3. Pieces in squares 28 and 29 are never required to move backward and bearing off is not required from any space. When a player lands on squares 28-30 and an opponent's piece is already there, the opponent's piece is sent to square 27 instead of 26. When a piece is in square 27, whether by being sent there as described above or by being forced to use a throw of 1 to move into square 27, the player may either move the piece back to square 15 and lose one turn, or may leave the piece in square 27 until a 4 is thrown, bearing the piece off. A player cannot move any other piece on the board when one remains in square 27 or 15 after being sent back to it, and pieces which normally would be protected from bring sent back because they are next to each other may now be sent back. Pieces in squares 28-30 are safe as long as a piece is in square 27. The player in square 27 may decide to give up trying to throw a 4 on any turn and move this piece back to square 15 and lose their next turn. The first player to successfully bear off all their pieces wins. The track is a boustrophedon track with backward track. Four D2. The value of the throw is equal to the sum except when the sum is 0 the throw = 5. The rules of Kendall.
(game "Senet" (players 2) (equipment {(board (rectangle 3 10) {(track "Track1" "20,E,S1,W,S1,E,End" P1 directed:True) (track "Track2" "20,E,S1,W,S1,E,End" P2 directed:True) (track "TrackOpposite1" "9,W,N1,E,N1,W" P1 directed:True) (track "TrackOpposite2" "9,W,N1,E,N1,W" P2 directed:True)}) (dice d:2 from:0 num:4) (map {(pair 0 5) (pair 1 1) (pair 2 2) (pair 3 3) (pair 4 4)}) (regions "Symbols" (sites {"F2" "F1" "G1" "H1" "I1"})) (regions "Ankh Waset" (sites {"F2"})) (regions "Neferu" (sites {"F1"})) (regions "Water" (sites {"G1"})) (regions "Baw" (sites {"H1"})) (regions "Two Men" (sites {"I1"})) (regions "Horus" (sites {"J1"})) (regions "TopRow" (sites Top)) (regions "MiddleRow" (difference (expand (sites Top)) (sites Top))) (regions "BottomRow" (sites Bottom)) (piece "SenetPiece" Each) (hand Each)}) (rules (start {(place "SenetPiece1" (sites {"B3" "D3" "F3" "H3" "J3" "I2" "G2"})) (place "SenetPiece2" (sites {"A3" "C3" "E3" "G3" "I3" "J2" "H2"}))}) phases:{(phase "Opening" (play (do (roll) next:(move Pass (then (if (= 1 (mapEntry (count Pips))) (and {(fromTo (from (coord "G2")) (to (coord "F2"))) (if (is Mover P2) (swap Players P1 P2)) (set NextPlayer (player 1))})))))) (nextPhase (= 1 (count Pips)) "Playing")) (phase "Playing" (play (do (roll) next:(if (can Move (if (and (= (state at:(coord "F2")) 1) (= 1 (count Sites in:(intersection (sites Occupied by:Mover) (sites "Ankh Waset"))))) (priority {(if (is Empty (trackSite Move from:(coord "F2") steps:(mapEntry (count Pips)))) (move (from (coord "F2")) (to (trackSite Move from:(coord "F2") steps:(mapEntry (count Pips))))) (if (and (not (if (= (trackSite Move from:(coord "F2") steps:(mapEntry (count Pips))) 19) (or (is Line 2 W through:(trackSite Move from:(coord "F2") steps:(mapEntry (count Pips)))) (is Line 2 N through:(trackSite Move from:(coord "F2") steps:(mapEntry (count Pips))))) (if (= (trackSite Move from:(coord "F2") steps:(mapEntry (count Pips))) 29) (or (is Line 2 W through:(trackSite Move from:(coord "F2") steps:(mapEntry (count Pips)))) (is Line 2 S through:(trackSite Move from:(coord "F2") steps:(mapEntry (count Pips))))) (if (= (trackSite Move from:(coord "F2") steps:(mapEntry (count Pips))) 10) (or (is Line 2 E through:(trackSite Move from:(coord "F2") steps:(mapEntry (count Pips)))) (is Line 2 S through:(trackSite Move from:(coord "F2") steps:(mapEntry (count Pips))))) (if (= (trackSite Move from:(coord "F2") steps:(mapEntry (count Pips))) 0) (or (is Line 2 E through:(trackSite Move from:(coord "F2") steps:(mapEntry (count Pips)))) (is Line 2 N through:(trackSite Move from:(coord "F2") steps:(mapEntry (count Pips))))) (or (is Line 2 W through:(trackSite Move from:(coord "F2") steps:(mapEntry (count Pips)))) (is Line 2 E through:(trackSite Move from:(coord "F2") steps:(mapEntry (count Pips)))))))))) (is Enemy (who at:(trackSite Move from:(coord "F2") steps:(mapEntry (count Pips)))))) (move Swap Pieces (coord "F2") (trackSite Move from:(coord "F2") steps:(mapEntry (count Pips))))) (then (set State at:(last To) 0))) (if (is Empty (trackSite Move from:(coord "F2") "TrackOpposite" steps:(mapEntry (count Pips)))) (move (from (coord "F2")) (to (trackSite Move from:(coord "F2") "TrackOpposite" steps:(mapEntry (count Pips))))) (if (and (not (if (= (trackSite Move from:(coord "F2") "TrackOpposite" steps:(mapEntry (count Pips))) 19) (or (is Line 2 W through:(trackSite Move from:(coord "F2") "TrackOpposite" steps:(mapEntry (count Pips)))) (is Line 2 N through:(trackSite Move from:(coord "F2") "TrackOpposite" steps:(mapEntry (count Pips))))) (if (= (trackSite Move from:(coord "F2") "TrackOpposite" steps:(mapEntry (count Pips))) 29) (or (is Line 2 W through:(trackSite Move from:(coord "F2") "TrackOpposite" steps:(mapEntry (count Pips)))) (is Line 2 S through:(trackSite Move from:(coord "F2") "TrackOpposite" steps:(mapEntry (count Pips))))) (if (= (trackSite Move from:(coord "F2") "TrackOpposite" steps:(mapEntry (count Pips))) 10) (or (is Line 2 E through:(trackSite Move from:(coord "F2") "TrackOpposite" steps:(mapEntry (count Pips)))) (is Line 2 S through:(trackSite Move from:(coord "F2") "TrackOpposite" steps:(mapEntry (count Pips))))) (if (= (trackSite Move from:(coord "F2") "TrackOpposite" steps:(mapEntry (count Pips))) 0) (or (is Line 2 E through:(trackSite Move from:(coord "F2") "TrackOpposite" steps:(mapEntry (count Pips)))) (is Line 2 N through:(trackSite Move from:(coord "F2") "TrackOpposite" steps:(mapEntry (count Pips))))) (or (is Line 2 W through:(trackSite Move from:(coord "F2") "TrackOpposite" steps:(mapEntry (count Pips)))) (is Line 2 E through:(trackSite Move from:(coord "F2") "TrackOpposite" steps:(mapEntry (count Pips)))))))))) (is Enemy (who at:(trackSite Move from:(coord "F2") "TrackOpposite" steps:(mapEntry (count Pips)))))) (move Swap Pieces (coord "F2") (trackSite Move from:(coord "F2") "TrackOpposite" steps:(mapEntry (count Pips))))) (then (set State at:(last To) 0)))}) (if (= 1 (count Sites in:(intersection (sites Occupied by:Mover) (sites "Water")))) (if (= (mapEntry (count Pips)) 4) (move Remove (sites "Water")) (or (if (= 1 (count Sites in:(intersection (sites Empty) (sites "Ankh Waset")))) (move (from (sites "Water")) (to (sites "Ankh Waset")) (then (set State at:(last To) 1)))) (move Pass))) (if True (priority {(forEach Piece (or {(if (is In (from) (sites "Neferu")) (if (!= (trackSite Move steps:(mapEntry (count Pips))) -1) (if (= (trackSite Move steps:(mapEntry (count Pips))) -2) (move Remove (from)) (if (is Empty (trackSite Move steps:(mapEntry (count Pips)))) (move (from) (to (trackSite Move steps:(mapEntry (count Pips))))) (if (and (not (if (= (trackSite Move steps:(mapEntry (count Pips))) 19) (or (is Line 2 W through:(trackSite Move steps:(mapEntry (count Pips)))) (is Line 2 N through:(trackSite Move steps:(mapEntry (count Pips))))) (if (= (trackSite Move steps:(mapEntry (count Pips))) 29) (or (is Line 2 W through:(trackSite Move steps:(mapEntry (count Pips)))) (is Line 2 S through:(trackSite Move steps:(mapEntry (count Pips))))) (if (= (trackSite Move steps:(mapEntry (count Pips))) 10) (or (is Line 2 E through:(trackSite Move steps:(mapEntry (count Pips)))) (is Line 2 S through:(trackSite Move steps:(mapEntry (count Pips))))) (if (= (trackSite Move steps:(mapEntry (count Pips))) 0) (or (is Line 2 E through:(trackSite Move steps:(mapEntry (count Pips)))) (is Line 2 N through:(trackSite Move steps:(mapEntry (count Pips))))) (or (is Line 2 W through:(trackSite Move steps:(mapEntry (count Pips)))) (is Line 2 E through:(trackSite Move steps:(mapEntry (count Pips)))))))))) (is Enemy (who at:(trackSite Move steps:(mapEntry (count Pips)))))) (if (and (= 1 (count in:(intersection (sites Empty) (sites "Water")))) (is In (trackSite Move steps:(mapEntry (count Pips))) (union {(sites "Baw") (sites "Two Men") (sites "Horus")}))) (move Swap Pieces (from) (trackSite Move steps:(mapEntry (count Pips))) (then (fromTo (from (last From)) (to (trackSite Move from:(last From) steps:1))))))))))) (if (is In (from) (union {(sites "Two Men") (sites "Baw")})) (if (!= (trackSite Move steps:(mapEntry (count Pips))) -1) (if (= (trackSite Move steps:(mapEntry (count Pips))) -2) (move Remove (from))))) (if (is In (from) (sites "Horus")) (if (or (= (trackSite Move steps:(mapEntry (count Pips))) -2) (= (trackSite Move steps:(mapEntry (count Pips))) -1)) (move Remove (from)))) (if (not (is In (from) (union {(sites "Neferu") (sites "Water") (sites "Baw") (sites "Two Men") (sites "Horus")}))) (or {(if (not (or {(= (trackSite Move steps:(mapEntry (count Pips))) -2) (= (trackSite Move steps:(mapEntry (count Pips))) -1) (is In (trackSite Move steps:(mapEntry (count Pips))) (union {(sites "Water") (sites "Baw") (sites "Two Men") (sites "Horus")}))})) (if (is Empty (trackSite Move steps:(mapEntry (count Pips)))) (move (from) (to (trackSite Move steps:(mapEntry (count Pips))))) (if (and (not (if (= (trackSite Move steps:(mapEntry (count Pips))) 19) (or (is Line 2 W through:(trackSite Move steps:(mapEntry (count Pips)))) (is Line 2 N through:(trackSite Move steps:(mapEntry (count Pips))))) (if (= (trackSite Move steps:(mapEntry (count Pips))) 29) (or (is Line 2 W through:(trackSite Move steps:(mapEntry (count Pips)))) (is Line 2 S through:(trackSite Move steps:(mapEntry (count Pips))))) (if (= (trackSite Move steps:(mapEntry (count Pips))) 10) (or (is Line 2 E through:(trackSite Move steps:(mapEntry (count Pips)))) (is Line 2 S through:(trackSite Move steps:(mapEntry (count Pips))))) (if (= (trackSite Move steps:(mapEntry (count Pips))) 0) (or (is Line 2 E through:(trackSite Move steps:(mapEntry (count Pips)))) (is Line 2 N through:(trackSite Move steps:(mapEntry (count Pips))))) (or (is Line 2 W through:(trackSite Move steps:(mapEntry (count Pips)))) (is Line 2 E through:(trackSite Move steps:(mapEntry (count Pips)))))))))) (is Enemy (who at:(trackSite Move steps:(mapEntry (count Pips)))))) (move Swap Pieces (from) (trackSite Move steps:(mapEntry (count Pips)))))))}))})) (forEach Piece (or {(if (is In (from) (sites "Neferu")) (if (!= (trackSite Move "TrackOpposite" steps:(mapEntry (count Pips))) -1) (if (is Empty (trackSite Move "TrackOpposite" steps:(mapEntry (count Pips)))) (move (from) (to (trackSite Move "TrackOpposite" steps:(mapEntry (count Pips))))) (if (and (not (if (= (trackSite Move "TrackOpposite" steps:(mapEntry (count Pips))) 19) (or (is Line 2 W through:(trackSite Move "TrackOpposite" steps:(mapEntry (count Pips)))) (is Line 2 N through:(trackSite Move "TrackOpposite" steps:(mapEntry (count Pips))))) (if (= (trackSite Move "TrackOpposite" steps:(mapEntry (count Pips))) 29) (or (is Line 2 W through:(trackSite Move "TrackOpposite" steps:(mapEntry (count Pips)))) (is Line 2 S through:(trackSite Move "TrackOpposite" steps:(mapEntry (count Pips))))) (if (= (trackSite Move "TrackOpposite" steps:(mapEntry (count Pips))) 10) (or (is Line 2 E through:(trackSite Move "TrackOpposite" steps:(mapEntry (count Pips)))) (is Line 2 S through:(trackSite Move "TrackOpposite" steps:(mapEntry (count Pips))))) (if (= (trackSite Move "TrackOpposite" steps:(mapEntry (count Pips))) 0) (or (is Line 2 E through:(trackSite Move "TrackOpposite" steps:(mapEntry (count Pips)))) (is Line 2 N through:(trackSite Move "TrackOpposite" steps:(mapEntry (count Pips))))) (or (is Line 2 W through:(trackSite Move "TrackOpposite" steps:(mapEntry (count Pips)))) (is Line 2 E through:(trackSite Move "TrackOpposite" steps:(mapEntry (count Pips)))))))))) (is Enemy (who at:(trackSite Move "TrackOpposite" steps:(mapEntry (count Pips)))))) (move Swap Pieces (from) (trackSite Move "TrackOpposite" steps:(mapEntry (count Pips)))))))) (if (not (is In (from) (union {(sites "Neferu") (sites "Water") (sites "Baw") (sites "Two Men") (sites "Horus")}))) (if (!= (trackSite Move "TrackOpposite" steps:(mapEntry (count Pips))) -1) (if (is Empty (trackSite Move "TrackOpposite" steps:(mapEntry (count Pips)))) (move (from) (to (trackSite Move "TrackOpposite" steps:(mapEntry (count Pips))))) (if (and (not (if (= (trackSite Move "TrackOpposite" steps:(mapEntry (count Pips))) 19) (or (is Line 2 W through:(trackSite Move "TrackOpposite" steps:(mapEntry (count Pips)))) (is Line 2 N through:(trackSite Move "TrackOpposite" steps:(mapEntry (count Pips))))) (if (= (trackSite Move "TrackOpposite" steps:(mapEntry (count Pips))) 29) (or (is Line 2 W through:(trackSite Move "TrackOpposite" steps:(mapEntry (count Pips)))) (is Line 2 S through:(trackSite Move "TrackOpposite" steps:(mapEntry (count Pips))))) (if (= (trackSite Move "TrackOpposite" steps:(mapEntry (count Pips))) 10) (or (is Line 2 E through:(trackSite Move "TrackOpposite" steps:(mapEntry (count Pips)))) (is Line 2 S through:(trackSite Move "TrackOpposite" steps:(mapEntry (count Pips))))) (if (= (trackSite Move "TrackOpposite" steps:(mapEntry (count Pips))) 0) (or (is Line 2 E through:(trackSite Move "TrackOpposite" steps:(mapEntry (count Pips)))) (is Line 2 N through:(trackSite Move "TrackOpposite" steps:(mapEntry (count Pips))))) (or (is Line 2 W through:(trackSite Move "TrackOpposite" steps:(mapEntry (count Pips)))) (is Line 2 E through:(trackSite Move "TrackOpposite" steps:(mapEntry (count Pips)))))))))) (is Enemy (who at:(trackSite Move "TrackOpposite" steps:(mapEntry (count Pips)))))) (move Swap Pieces (from) (trackSite Move "TrackOpposite" steps:(mapEntry (count Pips))))))))}))} (then (if (is In (mapEntry (count Pips)) (sites {1 4 5})) (moveAgain)))))))) (if (and (= (state at:(coord "F2")) 1) (= 1 (count Sites in:(intersection (sites Occupied by:Mover) (sites "Ankh Waset"))))) (priority {(if (is Empty (trackSite Move from:(coord "F2") steps:(mapEntry (count Pips)))) (move (from (coord "F2")) (to (trackSite Move from:(coord "F2") steps:(mapEntry (count Pips))))) (if (and (not (if (= (trackSite Move from:(coord "F2") steps:(mapEntry (count Pips))) 19) (or (is Line 2 W through:(trackSite Move from:(coord "F2") steps:(mapEntry (count Pips)))) (is Line 2 N through:(trackSite Move from:(coord "F2") steps:(mapEntry (count Pips))))) (if (= (trackSite Move from:(coord "F2") steps:(mapEntry (count Pips))) 29) (or (is Line 2 W through:(trackSite Move from:(coord "F2") steps:(mapEntry (count Pips)))) (is Line 2 S through:(trackSite Move from:(coord "F2") steps:(mapEntry (count Pips))))) (if (= (trackSite Move from:(coord "F2") steps:(mapEntry (count Pips))) 10) (or (is Line 2 E through:(trackSite Move from:(coord "F2") steps:(mapEntry (count Pips)))) (is Line 2 S through:(trackSite Move from:(coord "F2") steps:(mapEntry (count Pips))))) (if (= (trackSite Move from:(coord "F2") steps:(mapEntry (count Pips))) 0) (or (is Line 2 E through:(trackSite Move from:(coord "F2") steps:(mapEntry (count Pips)))) (is Line 2 N through:(trackSite Move from:(coord "F2") steps:(mapEntry (count Pips))))) (or (is Line 2 W through:(trackSite Move from:(coord "F2") steps:(mapEntry (count Pips)))) (is Line 2 E through:(trackSite Move from:(coord "F2") steps:(mapEntry (count Pips)))))))))) (is Enemy (who at:(trackSite Move from:(coord "F2") steps:(mapEntry (count Pips)))))) (move Swap Pieces (coord "F2") (trackSite Move from:(coord "F2") steps:(mapEntry (count Pips))))) (then (set State at:(last To) 0))) (if (is Empty (trackSite Move from:(coord "F2") "TrackOpposite" steps:(mapEntry (count Pips)))) (move (from (coord "F2")) (to (trackSite Move from:(coord "F2") "TrackOpposite" steps:(mapEntry (count Pips))))) (if (and (not (if (= (trackSite Move from:(coord "F2") "TrackOpposite" steps:(mapEntry (count Pips))) 19) (or (is Line 2 W through:(trackSite Move from:(coord "F2") "TrackOpposite" steps:(mapEntry (count Pips)))) (is Line 2 N through:(trackSite Move from:(coord "F2") "TrackOpposite" steps:(mapEntry (count Pips))))) (if (= (trackSite Move from:(coord "F2") "TrackOpposite" steps:(mapEntry (count Pips))) 29) (or (is Line 2 W through:(trackSite Move from:(coord "F2") "TrackOpposite" steps:(mapEntry (count Pips)))) (is Line 2 S through:(trackSite Move from:(coord "F2") "TrackOpposite" steps:(mapEntry (count Pips))))) (if (= (trackSite Move from:(coord "F2") "TrackOpposite" steps:(mapEntry (count Pips))) 10) (or (is Line 2 E through:(trackSite Move from:(coord "F2") "TrackOpposite" steps:(mapEntry (count Pips)))) (is Line 2 S through:(trackSite Move from:(coord "F2") "TrackOpposite" steps:(mapEntry (count Pips))))) (if (= (trackSite Move from:(coord "F2") "TrackOpposite" steps:(mapEntry (count Pips))) 0) (or (is Line 2 E through:(trackSite Move from:(coord "F2") "TrackOpposite" steps:(mapEntry (count Pips)))) (is Line 2 N through:(trackSite Move from:(coord "F2") "TrackOpposite" steps:(mapEntry (count Pips))))) (or (is Line 2 W through:(trackSite Move from:(coord "F2") "TrackOpposite" steps:(mapEntry (count Pips)))) (is Line 2 E through:(trackSite Move from:(coord "F2") "TrackOpposite" steps:(mapEntry (count Pips)))))))))) (is Enemy (who at:(trackSite Move from:(coord "F2") "TrackOpposite" steps:(mapEntry (count Pips)))))) (move Swap Pieces (coord "F2") (trackSite Move from:(coord "F2") "TrackOpposite" steps:(mapEntry (count Pips))))) (then (set State at:(last To) 0)))}) (if (= 1 (count Sites in:(intersection (sites Occupied by:Mover) (sites "Water")))) (if (= (mapEntry (count Pips)) 4) (move Remove (sites "Water")) (or (if (= 1 (count Sites in:(intersection (sites Empty) (sites "Ankh Waset")))) (move (from (sites "Water")) (to (sites "Ankh Waset")) (then (set State at:(last To) 1)))) (move Pass))) (if True (priority {(forEach Piece (or {(if (is In (from) (sites "Neferu")) (if (!= (trackSite Move steps:(mapEntry (count Pips))) -1) (if (= (trackSite Move steps:(mapEntry (count Pips))) -2) (move Remove (from)) (if (is Empty (trackSite Move steps:(mapEntry (count Pips)))) (move (from) (to (trackSite Move steps:(mapEntry (count Pips))))) (if (and (not (if (= (trackSite Move steps:(mapEntry (count Pips))) 19) (or (is Line 2 W through:(trackSite Move steps:(mapEntry (count Pips)))) (is Line 2 N through:(trackSite Move steps:(mapEntry (count Pips))))) (if (= (trackSite Move steps:(mapEntry (count Pips))) 29) (or (is Line 2 W through:(trackSite Move steps:(mapEntry (count Pips)))) (is Line 2 S through:(trackSite Move steps:(mapEntry (count Pips))))) (if (= (trackSite Move steps:(mapEntry (count Pips))) 10) (or (is Line 2 E through:(trackSite Move steps:(mapEntry (count Pips)))) (is Line 2 S through:(trackSite Move steps:(mapEntry (count Pips))))) (if (= (trackSite Move steps:(mapEntry (count Pips))) 0) (or (is Line 2 E through:(trackSite Move steps:(mapEntry (count Pips)))) (is Line 2 N through:(trackSite Move steps:(mapEntry (count Pips))))) (or (is Line 2 W through:(trackSite Move steps:(mapEntry (count Pips)))) (is Line 2 E through:(trackSite Move steps:(mapEntry (count Pips)))))))))) (is Enemy (who at:(trackSite Move steps:(mapEntry (count Pips)))))) (if (and (= 1 (count in:(intersection (sites Empty) (sites "Water")))) (is In (trackSite Move steps:(mapEntry (count Pips))) (union {(sites "Baw") (sites "Two Men") (sites "Horus")}))) (move Swap Pieces (from) (trackSite Move steps:(mapEntry (count Pips))) (then (fromTo (from (last From)) (to (trackSite Move from:(last From) steps:1))))))))))) (if (is In (from) (union {(sites "Two Men") (sites "Baw")})) (if (!= (trackSite Move steps:(mapEntry (count Pips))) -1) (if (= (trackSite Move steps:(mapEntry (count Pips))) -2) (move Remove (from))))) (if (is In (from) (sites "Horus")) (if (or (= (trackSite Move steps:(mapEntry (count Pips))) -2) (= (trackSite Move steps:(mapEntry (count Pips))) -1)) (move Remove (from)))) (if (not (is In (from) (union {(sites "Neferu") (sites "Water") (sites "Baw") (sites "Two Men") (sites "Horus")}))) (or {(if (not (or {(= (trackSite Move steps:(mapEntry (count Pips))) -2) (= (trackSite Move steps:(mapEntry (count Pips))) -1) (is In (trackSite Move steps:(mapEntry (count Pips))) (union {(sites "Water") (sites "Baw") (sites "Two Men") (sites "Horus")}))})) (if (is Empty (trackSite Move steps:(mapEntry (count Pips)))) (move (from) (to (trackSite Move steps:(mapEntry (count Pips))))) (if (and (not (if (= (trackSite Move steps:(mapEntry (count Pips))) 19) (or (is Line 2 W through:(trackSite Move steps:(mapEntry (count Pips)))) (is Line 2 N through:(trackSite Move steps:(mapEntry (count Pips))))) (if (= (trackSite Move steps:(mapEntry (count Pips))) 29) (or (is Line 2 W through:(trackSite Move steps:(mapEntry (count Pips)))) (is Line 2 S through:(trackSite Move steps:(mapEntry (count Pips))))) (if (= (trackSite Move steps:(mapEntry (count Pips))) 10) (or (is Line 2 E through:(trackSite Move steps:(mapEntry (count Pips)))) (is Line 2 S through:(trackSite Move steps:(mapEntry (count Pips))))) (if (= (trackSite Move steps:(mapEntry (count Pips))) 0) (or (is Line 2 E through:(trackSite Move steps:(mapEntry (count Pips)))) (is Line 2 N through:(trackSite Move steps:(mapEntry (count Pips))))) (or (is Line 2 W through:(trackSite Move steps:(mapEntry (count Pips)))) (is Line 2 E through:(trackSite Move steps:(mapEntry (count Pips)))))))))) (is Enemy (who at:(trackSite Move steps:(mapEntry (count Pips)))))) (move Swap Pieces (from) (trackSite Move steps:(mapEntry (count Pips)))))))}))})) (forEach Piece (or {(if (is In (from) (sites "Neferu")) (if (!= (trackSite Move "TrackOpposite" steps:(mapEntry (count Pips))) -1) (if (is Empty (trackSite Move "TrackOpposite" steps:(mapEntry (count Pips)))) (move (from) (to (trackSite Move "TrackOpposite" steps:(mapEntry (count Pips))))) (if (and (not (if (= (trackSite Move "TrackOpposite" steps:(mapEntry (count Pips))) 19) (or (is Line 2 W through:(trackSite Move "TrackOpposite" steps:(mapEntry (count Pips)))) (is Line 2 N through:(trackSite Move "TrackOpposite" steps:(mapEntry (count Pips))))) (if (= (trackSite Move "TrackOpposite" steps:(mapEntry (count Pips))) 29) (or (is Line 2 W through:(trackSite Move "TrackOpposite" steps:(mapEntry (count Pips)))) (is Line 2 S through:(trackSite Move "TrackOpposite" steps:(mapEntry (count Pips))))) (if (= (trackSite Move "TrackOpposite" steps:(mapEntry (count Pips))) 10) (or (is Line 2 E through:(trackSite Move "TrackOpposite" steps:(mapEntry (count Pips)))) (is Line 2 S through:(trackSite Move "TrackOpposite" steps:(mapEntry (count Pips))))) (if (= (trackSite Move "TrackOpposite" steps:(mapEntry (count Pips))) 0) (or (is Line 2 E through:(trackSite Move "TrackOpposite" steps:(mapEntry (count Pips)))) (is Line 2 N through:(trackSite Move "TrackOpposite" steps:(mapEntry (count Pips))))) (or (is Line 2 W through:(trackSite Move "TrackOpposite" steps:(mapEntry (count Pips)))) (is Line 2 E through:(trackSite Move "TrackOpposite" steps:(mapEntry (count Pips)))))))))) (is Enemy (who at:(trackSite Move "TrackOpposite" steps:(mapEntry (count Pips)))))) (move Swap Pieces (from) (trackSite Move "TrackOpposite" steps:(mapEntry (count Pips)))))))) (if (not (is In (from) (union {(sites "Neferu") (sites "Water") (sites "Baw") (sites "Two Men") (sites "Horus")}))) (if (!= (trackSite Move "TrackOpposite" steps:(mapEntry (count Pips))) -1) (if (is Empty (trackSite Move "TrackOpposite" steps:(mapEntry (count Pips)))) (move (from) (to (trackSite Move "TrackOpposite" steps:(mapEntry (count Pips))))) (if (and (not (if (= (trackSite Move "TrackOpposite" steps:(mapEntry (count Pips))) 19) (or (is Line 2 W through:(trackSite Move "TrackOpposite" steps:(mapEntry (count Pips)))) (is Line 2 N through:(trackSite Move "TrackOpposite" steps:(mapEntry (count Pips))))) (if (= (trackSite Move "TrackOpposite" steps:(mapEntry (count Pips))) 29) (or (is Line 2 W through:(trackSite Move "TrackOpposite" steps:(mapEntry (count Pips)))) (is Line 2 S through:(trackSite Move "TrackOpposite" steps:(mapEntry (count Pips))))) (if (= (trackSite Move "TrackOpposite" steps:(mapEntry (count Pips))) 10) (or (is Line 2 E through:(trackSite Move "TrackOpposite" steps:(mapEntry (count Pips)))) (is Line 2 S through:(trackSite Move "TrackOpposite" steps:(mapEntry (count Pips))))) (if (= (trackSite Move "TrackOpposite" steps:(mapEntry (count Pips))) 0) (or (is Line 2 E through:(trackSite Move "TrackOpposite" steps:(mapEntry (count Pips)))) (is Line 2 N through:(trackSite Move "TrackOpposite" steps:(mapEntry (count Pips))))) (or (is Line 2 W through:(trackSite Move "TrackOpposite" steps:(mapEntry (count Pips)))) (is Line 2 E through:(trackSite Move "TrackOpposite" steps:(mapEntry (count Pips)))))))))) (is Enemy (who at:(trackSite Move "TrackOpposite" steps:(mapEntry (count Pips)))))) (move Swap Pieces (from) (trackSite Move "TrackOpposite" steps:(mapEntry (count Pips))))))))}))} (then (if (is In (mapEntry (count Pips)) (sites {1 4 5})) (moveAgain))))))) (move Pass (then (if (is In (mapEntry (count Pips)) (sites {1 4 5})) (moveAgain))))))))} (end (if (no Pieces Mover) (result Mover Win))))) 
2x12 board, divided in half. Spaces on each side take the form of semi-circular sockets, into which the pieces fit. Fifteen pieces per player. Three six-sided dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. Both players begin in the same quadrant of the board. One player's pieces are arranged as follows: Eight on the first point of the quadrant to their left, four on the fifth, and three on the sixth. The other player places five on the second, third, and fourth space of the same quadrant. The track proceeds in a clockwise direction around the board. When a player's piece lands on a space occupied by a single piece of the opponent, it is sent back to the beginning of the quadrant to the right of the starting quadrant. Pieces bear off from the quadrant diagonal from the starting quadrant. The first player to bear off all their pieces wins.
(game "Seys Dos y As" (players 2) (equipment {(board (merge {(rectangle 1 6) (shift 7 0 (rectangle 1 6)) (shift 0 6 (rectangle 1 6)) (shift 7 6 (rectangle 1 6))}) {(track "Track1" {24 11 10 9 8 7 6 5 4 3 2 1 0 12 13 14 15 16 17} P1 directed:True) (track "Track2" {25 11 10 9 8 7 6 5 4 3 2 1 0 12 13 14 15 16 17} P2 directed:True)} use:Vertex) (dice d:6 num:3) (piece "Disc" Each (forEach Die if:(!= (pips) 0) (if (= (trackSite Move from:(from) steps:(pips)) -1) (move Remove (from)) (move (from (from)) (to (trackSite Move from:(from) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next))))))) (then (if (not (all DiceUsed)) (moveAgain))))) (hand Each)}) (rules (start {(place Stack "Disc1" 11 count:8) (place Stack "Disc1" 6 count:3) (place Stack "Disc1" 7 count:4) (place Stack "Disc2" (sites {10 9 8}) count:5)}) (play (do (if (not (is Prev Mover)) (roll)) next:(or (forEach Piece top:True) (forEach Piece container:(mover) top:True)))) (end (if (no Pieces Mover) (result Mover Win))))) 
The game is played on a board with twelve points on either side. The points form a continuous track in a horseshoe shape; each player progresses in opposite directions (one from their bottom right to the top right, the other from their bottom left to their top left). Each player has 15 pieces. The starting position is as such, number the points from the origin of each player's track: Point six: five pieces Point 8: three pieces Point 13: five pieces Point 24: two pieces. Players move according to the number on each die by moving one piece the number on one die and other the number on the other die, or by moving one piece the total number of both die. Players cannot end their move on a point with multiple opposing pieces. If a player ends the turn on a point with one opposing piece, that piece is placed in the middle of the board (not on a point) and must reenter the board according the the next die roll, counting the origin point as a move of 1. They cannot reenter on a point with two or more pieces. No other pieces can move until all of the pieces belonging to that player are removed from the center. When all of a player's pieces are on their final 6 points, they may start removing pieces from the board. They can do so by rolling a 6 to move from the 6th point, and so on down to 1. Players must use all available moves presented by the dice. The first player to remove all of their pieces wins. 
(game "Shuanglu" (players 2) (equipment {(board (merge {(rectangle 1 6) (shift 7 0 (rectangle 1 6)) (shift 0 6 (rectangle 1 6)) (shift 7 6 (rectangle 1 6))}) {(track "Track1" {24 11 10 9 8 7 6 5 4 3 2 1 0 12 13 14 15 16 17 18 19 20 21 22 23 -2} P1 directed:True) (track "Track2" {25 23 22 21 20 19 18 17 16 15 14 13 12 0 1 2 3 4 5 6 7 8 9 10 11 -2} P2 directed:True)} use:Vertex) (dice d:6 num:2) (piece "Disc" Each (forEach Die if:(!= (pips) 0) (if (= (trackSite Move from:(from) steps:(pips)) -2) (if (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover "FinalQuadrant"))) (move Remove (from))) (move (from (from)) (to (trackSite Move from:(from) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next))))))) (then (if (not (all DiceUsed)) (moveAgain))))) (hand Each) (regions "FinalQuadrant" P1 (sites {18 19 20 21 22 23})) (regions "FinalQuadrant" P2 (sites {6 7 8 9 10 11}))}) (rules (start {(place Stack "Disc1" 6 count:5) (place Stack "Disc1" 4 count:3) (place Stack "Disc1" 12 count:5) (place Stack "Disc1" 23 count:2) (place Stack "Disc2" 18 count:5) (place Stack "Disc2" 16 count:3) (place Stack "Disc2" 0 count:5) (place Stack "Disc2" 11 count:2)}) (play (do (if (not (is Prev Mover)) (roll)) next:(priority {(if (is Occupied (handSite Mover)) (forEach Die if:(!= (pips) 0) (move (from (handSite Mover)) (to (trackSite Move from:(handSite Mover) steps:(pips)) if:(< (size Stack at:(to)) 2) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next)))))) (then (if (not (all DiceUsed)) (moveAgain))))) (if (is Empty (handSite Mover)) (max Distance (forEach Piece top:True)))}))) (end (if (no Pieces Mover) (result Mover Win))))) 
Four 3x8 rectangles, arranged in a cross shape around a large central square space. Squares marked with "X" (counting from top of each row): fifth in each outer row, fourth in central row. Four players playing on two teams. Three pieces per player. Play begins in the central row of each player's arm of the board. Six cowrie shells used as dice. Values of the cowries are: 0=6, 1=10, 2=2, 3=3, 4=4, 5=25, 6=12. A roll of 10 or 25 adds an extra move of 1. This extra move must be used to enter a new piece on the board if possible, if not possible then it can be assigned to any piece. Pieces on a space marked "x" are safe from being captured. Players play until they throw a 2, 3, or 4. The value of an individual roll can only move one piece, but multiple pieces can be moved in turns with multiple rolls. Pieces enter the board with a throw of 10 or 25. Pieces enter the board from the central square onto the central row of their arm of the cross, and then anti-clockwise around the board, then back up the central row of their arm, entering the central square only with an exact throw. The first team to move all of their pieces into the central square wins.
(game "Sokkattan" (players 4) (equipment {(board (add (hole (merge (shift 0 (/ (- 19 3) 2) (rectangle 3 19)) (shift (/ (- 19 3) 2) 0 (rectangle 19 3))) (poly {{8 8} {8 11} {11 11} {11 8}})) cells:{{8 28 48 68 69 70 71 51 31 11 10 9}}) {(track "Track1" "96,9,S,E,N,11,E,N,W,53,N,W,S,42,W,S,E,8,S,E1,N7,End" P1 directed:True) (track "Track2" "96,26,W,S,E,8,S,E,N,11,E,N,W,53,N,W,S,42,W,S1,E7,End" P2 directed:True) (track "Track3" "96,52,N,W,S,42,W,S,E,8,S,E,N,11,E,N,W,53,N,W1,S7,End" P3 directed:True) (track "Track4" "96,27,E,N,W,53,N,W,S,42,W,S,E,8,S,E,N,11,E,N1,W7,End" P4 directed:True)}) (hand Each) (dice d:2 from:0 num:6) (piece "Pawn" Each (if (= (trackSite Move from:(from) steps:(mapEntry "Throw" (count Pips))) -2) (move Remove (from) level:(level)) (move (from (from) level:(level)) (to (trackSite Move from:(from) steps:(mapEntry "Throw" (count Pips))) if:(not (and (is In (to) (sites "SafeSites")) (is Enemy (who at:(to))))) (apply (if (is Enemy (who at:(to))) (forEach Level (to) FromTop (fromTo (from (to) level:(level)) (to (handSite (who at:(to) level:(level)))))))))))) (regions "SafeSites" (sites {67 63 65 23 38 3 82 84 86 30 47 15})) (map "Throw" {(pair 0 6) (pair 1 10) (pair 2 2) (pair 3 3) (pair 4 4) (pair 5 25) (pair 6 12)}) (map "Entry" {(pair P1 67) (pair P2 23) (pair P3 82) (pair P4 30)})}) (rules (start {(set Team 1 {P1 P3}) (set Team 2 {P2 P4}) (place Stack "Pawn1" (handSite P1) count:3) (place Stack "Pawn2" (handSite P2) count:3) (place Stack "Pawn3" (handSite P3) count:3) (place Stack "Pawn4" (handSite P4) count:3)}) (play (do (roll) next:(if (= (var "ExtraOne") 1) (priority {(if (is Occupied (handSite Mover)) (move (from (handSite Mover)) (to (mapEntry "Entry" Mover)))) (forEach Piece (if (= (trackSite Move from:(from) steps:1) -2) (move Remove (from) level:(level)) (move (from (from) level:(level)) (to (trackSite Move from:(from) steps:1) if:(not (and (is In (to) (sites "SafeSites")) (is Enemy (who at:(to))))) (apply (if (is Enemy (who at:(to))) (forEach Level (to) FromTop (fromTo (from (to) level:(level)) (to (handSite (who at:(to) level:(level))))))))))))} (then (and (moveAgain) (set Var "ExtraOne" 0)))) (or (if (and (is Occupied (handSite Mover)) (is In (mapEntry "Throw" (count Pips)) (sites {10 25}))) (move (from (handSite Mover)) (to (mapEntry "Entry" Mover)))) (forEach Piece))) (then (if (not (is In (mapEntry "Throw" (count Pips)) (sites {2 3 4}))) (and (if (is In (mapEntry "Throw" (count Pips)) (sites {10 25})) (set Var "ExtraOne" 1)) (moveAgain)))))) (end (if (no Pieces TeamMover) (result TeamMover Win))))) 
The game is played on a board with twelve points on either side. The points form a continuous track in a horseshoe shape; each player progresses in opposite directions (one from their bottom right to the top right, the other from their bottom left to their top left). Each player has 15 pieces. The starting position is as such, numbering the points from the origin of each player's track: Point six: five pieces Point 8: three pieces Point 13: five pieces Point 24: two pieces. Players move according to the number on each die by moving one piece the number on one die and other the number on the other die, or by moving one piece the total number of both die. Players cannot end their move on a point with multiple opposing pieces. If a player ends the turn on a point with one opposing piece, that piece is placed in the middle of the board (not on a point) and must reenter the board according the the next die roll, counting the origin point as a move of 1. They cannot reenter on a point with two or more pieces. No other pieces can move until all of the pieces belonging to that player are removed from the center. When all of a player's pieces are on their final 6 points, they may start removing pieces from the board. They can do so by rolling a 6 to move from the 6th point, and so on down to 1. Players must use all available moves presented by the dice. The first player to remove all of their pieces wins. 
(game "Ssang-Ryouk" (players 2) (equipment {(board (merge {(rectangle 1 6) (shift 7 0 (rectangle 1 6)) (shift 0 6 (rectangle 1 6)) (shift 7 6 (rectangle 1 6))}) {(track "Track1" {24 11 10 9 8 7 6 5 4 3 2 1 0 12 13 14 15 16 17 18 19 20 21 22 23 -2} P1 directed:True) (track "Track2" {25 23 22 21 20 19 18 17 16 15 14 13 12 0 1 2 3 4 5 6 7 8 9 10 11 -2} P2 directed:True)} use:Vertex) (dice d:6 num:2) (piece "Disc" Each (forEach Die if:(!= (pips) 0) (if (= -2 (trackSite Move from:(from) steps:(pips))) (if (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover "FinalQuadrant"))) (move Remove (from))) (move (from (from)) (to (trackSite Move from:(from) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next))))))) (then (if (not (all DiceUsed)) (moveAgain))))) (hand Each) (regions "FinalQuadrant" P1 (sites {18 19 20 21 22 23})) (regions "FinalQuadrant" P2 (sites {6 7 8 9 10 11}))}) (rules (start {(place Stack "Disc1" 6 count:5) (place Stack "Disc1" 4 count:3) (place Stack "Disc1" 12 count:5) (place Stack "Disc1" 23 count:2) (place Stack "Disc2" 18 count:5) (place Stack "Disc2" 16 count:3) (place Stack "Disc2" 0 count:5) (place Stack "Disc2" 11 count:2)}) (play (do (if (not (is Prev Mover)) (roll)) next:(priority {(if (is Occupied (handSite Mover)) (forEach Die if:(!= (pips) 0) (move (from (handSite Mover)) (to (trackSite Move from:(handSite Mover) steps:(pips)) if:(< (size Stack at:(to)) 2) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite Next)))))) (then (if (not (all DiceUsed)) (moveAgain))))) (if (is Empty (handSite Mover)) (max Distance (forEach Piece top:True)))}))) (end (if (no Pieces Mover) (result Mover Win))))) 
2x12 board, with the spaces rendered as points, divided into half. Fifteen pieces per player. Two six-sided dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. A throw of doubles forces the player to play the throw twice. Each player's pieces begin in three stacks of five, on the leftmost point (with respect to the opponent) on the opponent's side of the board. Play proceeds (with respect to the player) from right to left on the opponent's side of the board, and then from left to right on the player's side of the board. A player cannot place two pieces on a single point on any of the first eleven points of the board, except for those pieces in the starting position, until one of the player's pieces has first landed on the twelfth point. However, a player may place two pieces on any point after the twelfth point, regardless of whether a piece has ever landed on the twelfth point. A player cannot move a piece onto a point containing two or more pieces belonging to the opponent. When a piece lands on a point occupied by a single piece belonging to the opponent, it is removed from the board and must be entered again, and can only do so using the value of one die, not both, with the starting point considered to be point 1, the next point 2, etc. Opponent's pieces can be removed from the board in this way when reentering the board. To win, a player must place their pieces in one of the following winning positions: five pieces on each of the final three points; three pieces on the final five points; seven on the final point, five on the penultimate point, and three on the antepenultimate point; fifteen on the final point. If none of these positions are possible, the player must bear off all of their pieces once all of their pieces have reached the final six points. The first player to reach a winning position or to bear off all of their pieces wins.
(game "Svensk Bradspel" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {6 25 24 23 22 21 20 18 17 16 15 14 13 0 1 2 3 4 5 7 8 9 10 11 12 -2} P1 directed:True) (track "Track2" {19 0 1 2 3 4 5 7 8 9 10 11 12 25 24 23 22 21 20 18 17 16 15 14 13 -2} P2 directed:True)} use:Vertex) (dice d:6 num:2) (piece "Disc" Each (forEach Die replayDouble:True if:(!= (pips) 0) (if (= (trackSite Move from:(from) steps:(pips)) -2) (if (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover "FinalQuadrant"))) (move Remove (from))) (move (from (from)) (to (trackSite Move from:(from) steps:(pips)) if:(and (or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (if (not (is In (to) (sites Mover "StartingSide"))) True (if (= (value Player Mover) 1) True (is Empty (to))))) (apply (if (is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry "Bar" Next)))))))) (then (and (if (not (all DiceUsed)) (moveAgain)) (if (and (= (last To) (mapEntry "12thPoint" Mover)) (!= 1 (value Player Mover))) (set Value Mover 1)))))) (regions "FinalQuadrant" P1 (sites {7 8 9 10 11 12})) (regions "FinalQuadrant" P2 (sites {13 14 15 16 17 18})) (regions "StartingSide" P1 (sites {25 24 23 22 21 20 18 17 16 15 14})) (regions "StartingSide" P2 (sites {0 1 2 3 4 5 7 8 9 10 11})) (map "12thPoint" {(pair P1 13) (pair P2 12)}) (map "Bar" {(pair P1 6) (pair P2 19)})}) (rules (start {(place Stack "Disc1" 25 count:15) (place Stack "Disc2" 0 count:15)}) (play (do (if (not (is Prev Mover)) (roll)) next:(forEach Piece top:True))) (end {(if (no Pieces Mover) (result Mover Win)) (if (if (is Mover P1) (and {(is Friend (who at:10)) (is Friend (who at:11)) (is Friend (who at:12)) (= 5 (size Stack at:10)) (= 5 (size Stack at:11)) (= 5 (size Stack at:12))}) (and {(is Friend (who at:13)) (is Friend (who at:14)) (is Friend (who at:15)) (= 5 (size Stack at:13)) (= 5 (size Stack at:14)) (= 5 (size Stack at:15))})) (result Mover Win)) (if (if (is Mover P1) (and {(is Friend (who at:8)) (is Friend (who at:9)) (is Friend (who at:10)) (is Friend (who at:11)) (is Friend (who at:12)) (= 3 (size Stack at:8)) (= 3 (size Stack at:9)) (= 3 (size Stack at:10)) (= 3 (size Stack at:11)) (= 3 (size Stack at:12))}) (and {(is Friend (who at:13)) (is Friend (who at:14)) (is Friend (who at:15)) (is Friend (who at:17)) (is Friend (who at:18)) (= 3 (size Stack at:13)) (= 3 (size Stack at:14)) (= 3 (size Stack at:15)) (= 3 (size Stack at:17)) (= 3 (size Stack at:18))})) (result Mover Win)) (if (if (is Mover P1) (and {(is Friend (who at:10)) (is Friend (who at:11)) (is Friend (who at:12)) (= 3 (size Stack at:10)) (= 5 (size Stack at:11)) (= 7 (size Stack at:12))}) (and {(is Friend (who at:13)) (is Friend (who at:14)) (is Friend (who at:15)) (= 7 (size Stack at:13)) (= 5 (size Stack at:14)) (= 3 (size Stack at:15))})) (result Mover Win)) (if (if (is Mover P1) (and (is Friend (who at:12)) (= 15 (size Stack at:12))) (and (is Friend (who at:13)) (= 15 (size Stack at:13)))) (result Mover Win))}))) 
2x12 board, divided in half, where the spaces are rendered as points. Fifteen pieces per player. Two six-sided dice. Play occurs only in two quadrants of the board, opposite one another, a player's pieces only leaving their quadrant to bear off. Two pieces are stacked each on the first three points, and three are stacked in the second three points. Players use throws to unstack pieces on their points, unstacking one piece per die which corresponds to that point. Doubles allow the player to unstack or bear off a number of pieces equal to the total number of the throw. When all of the pieces are unstacked, that player may begin bearing their pieces off. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. Once a player has borne off all of their pieces, they must re-enter them onto the points and replicate the starting position. The first player to bear off all their pieces and then place them in the starting position again wins. 
(game "Tables Rabbatuees" (players 2) (equipment {(board (merge {(rectangle 1 6) (shift 7 0 (rectangle 1 6)) (shift 0 6 (rectangle 1 6)) (shift 7 6 (rectangle 1 6))}) {(track "Track1" {0 1 2 3 4 5} P1 directed:True) (track "Track2" {12 13 14 15 16 17} P2 directed:True)} use:Vertex) (dice d:6 num:2) (piece "Disc" Each (forEach Die if:(!= (pips) 0) (if (= (trackSite Move steps:(pips)) -1) (move (from (from)) (to (handSite Mover))) (move (from) (to (trackSite Move steps:(pips))))))) (hand Each) (map "StartTrack" {(pair P1 0) (pair P2 12)})}) (rules (start {(place Stack "Disc1" (sites {0 1 2}) count:2) (place Stack "Disc1" (sites {3 4 5}) count:3) (place Stack "Disc2" (sites {12 13 14}) count:2) (place Stack "Disc2" (sites {15 16 17}) count:3)}) phases:{(phase "UnStacking" (play (do (if (not (is Prev Mover)) (roll)) next:(if (or (< 0 (var "Double")) (all DiceEqual)) (do (if (>= 0 (var "Double")) (set Var "Double" (count Pips))) next:(forEach Site (sites Occupied by:Mover) (if (= (state at:(site)) 0) (move Select (from (site)) (then (if (= 3 (size Stack at:(last To))) (forEach Level (last To) (set State at:(last To) level:(level) 1)) (forEach Level (last To) (set State at:(last To) level:(level) 2))))) (if (= (state at:(site)) 1) (move Select (from (site)) (then (forEach Level (last To) (set State at:(last To) level:(level) 2)))))) (then (and (if (< 1 (var "Double")) (moveAgain)) (set Var "Double" (- (var "Double") 1)))))) (forEach Die if:(!= (pips) 0) (or (if (= (state at:(trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) 0) (move Select (from (trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) (then (and (if (= 3 (size Stack at:(last To))) (forEach Level (last To) (set State at:(last To) level:(level) 1)) (forEach Level (last To) (set State at:(last To) level:(level) 2))) (if (not (all DiceUsed)) (moveAgain)))))) (if (= (state at:(trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) 1) (move Select (from (trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) (then (and (forEach Level (last To) (set State at:(last To) level:(level) 2)) (if (not (all DiceUsed)) (moveAgain))))))))))) (nextPhase Mover (all Sites (sites Occupied by:Mover) if:(not (or (= (state at:(site)) 0) (= (state at:(site)) 1)))) "BearingOff")) (phase "BearingOff" (play (do (if (not (is Prev Mover)) (roll)) next:(if (or (< 0 (var "Double")) (all DiceEqual)) (do (if (>= 0 (var "Double")) (set Var "Double" (count Pips))) next:(forEach Site (sites Occupied by:Mover) (move (from (site)) (to (handSite Mover))) (then (and (if (< 1 (var "Double")) (moveAgain)) (set Var "Double" (- (var "Double") 1)))))) (forEach Piece top:True)) (then (if (not (all DiceUsed)) (moveAgain))))) (nextPhase Mover (no Pieces Mover in:(sites Board)) "Placing")) (phase "Placing" (play (do (if (not (is Prev Mover)) (roll)) next:(if (is Occupied (handSite Mover)) (forEach Die if:(!= (pips) 0) (if (if (< (pips) 4) (< (size Stack at:(trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) 2) (< (size Stack at:(trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) 3)) (move (from (handSite Mover)) (to (trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))))) (then (and (if (not (all DiceUsed)) (moveAgain)) (if (!= 0 (state at:(last To))) (set State at:(last To) 0)))))))) (end (if (is Empty (handSite Mover)) (result Mover Win))))})) 
Portes, Plakoto, and Fevga are played in succession. One point is awarded to the winner of each game, two points if the opponent hasn't moved pieces out of their starting quadrant. It is typically played to five or seven points.
(match "Tavli" (players 2) (games {(subgame "Portes" next:1 result:(score Mover)) (subgame "Plakoto" next:2 result:(score Mover)) (subgame "Fevga" next:0 result:(score Mover))}) (end {(if (>= (matchScore P1) 5) (result P1 Win)) (if (>= (matchScore P2) 5) (result P2 Win))})) 
The game is played on a board with twelve points on either side. The points form a continuous track in a horseshoe shape; both players progress in an anti-clockwise direction. Fifteen pieces per player, two six-sided dice. Each player begins with two pieces on the rightmost point on the opposite side of the board. Players move according to the number on each die by moving one piece the number on one die and other the number on the other die, or by moving one piece the total number of both die. Further pieces are entered based on the roll of the dice, the point after the one with the two pieces on it at the beginning being counted as the first point. When entering captured pieces, however, the point where the two pieces start is counted as the first point. The two pieces which start on the board cannot be moved until all of the remaining pieces have been entered on the board. No more than one piece may rest on a point on the first half of the board, except for the two which start and also on the leftmost point on the opposite side of the board from where the player sits. When a piece lands on a point occupied by an opponent's piece, the opponent's piece is removed from the board and must be entered again. Players must enter captured pieces before continuing to move the other pieces on the board. When a piece is captured in the opponent's starting quadrant, a point must be left open or with only one piece, thus allowing the opponent to enter their piece. The player to move all of their pieces off the board wins. 
(game "Tawula" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {6 25 24 23 22 21 20 18 17 16 15 14 13 0 1 2 3 4 5 7 8 9 10 11 12} P1 directed:True) (track "Track2" {19 0 1 2 3 4 5 7 8 9 10 11 12 25 24 23 22 21 20 18 17 16 15 14 13} P2 directed:True)} use:Vertex) (dice d:6 num:2) (piece "Disc" Each (if (or (!= (from) (mapEntry "StartTrack" Mover)) (and (= (from) (mapEntry "StartTrack" Mover)) (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))))) (forEach Die if:(!= (pips) 0) (if (= (trackSite Move steps:(pips)) -1) (move Remove (from)) (move (from) (to (trackSite Move steps:(pips)) if:(or (or (and (is Empty (to)) (is In (to) (sites Mover "OnePieceMax"))) (and (not (is In (to) (sites Mover "OnePieceMax"))) (or (is Friend (who at:(to))) (is Empty (to))))) (and (= 1 (size Stack at:(to))) (is Enemy (who at:(to))))) (apply (if (is Enemy (who at:(to))) (move (from (to)) (to (mapEntry "Bar" Next))))))))))) (hand Each) (map "Bar" {(pair P1 6) (pair P2 19)}) (map "StartTrack" {(pair P1 25) (pair P2 0)}) (regions "OnePieceMax" P1 (sites {14 15 16 17 18 20 21 22 23 24})) (regions "OnePieceMax" P2 (sites {1 2 3 4 5 7 8 9 10 11}))}) (rules (start {(place Stack "Disc1" 25 count:2) (place Stack "Disc2" 0 count:2) (place Stack "Disc1" (handSite P1) count:13) (place Stack "Disc2" (handSite P2) count:13)}) (play (do (if (not (is Prev Mover)) (roll)) next:(or (if (is Empty (mapEntry "Bar" Mover)) (forEach Piece top:True) (forEach Die if:(!= (pips) 0) (move (from (mapEntry "Bar" Mover)) (to (trackSite Move from:(mapEntry "Bar" Mover) steps:(pips)) if:(or (or (and (is Empty (to)) (is In (to) (sites Mover "OnePieceMax"))) (and (not (is In (to) (sites Mover "OnePieceMax"))) (or (is Friend (who at:(to))) (is Empty (to))))) (and (= 1 (size Stack at:(to))) (is Enemy (who at:(to))))) (apply (if (is Enemy (who at:(to))) (move (from (to)) (to (mapEntry "Bar" Next))))))))) (if (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site))))) (forEach Die if:(!= (pips) 0) (move (from (handSite Mover)) (to (trackSite Move from:(mapEntry "StartTrack" Mover) steps:(pips)) if:(or (is Empty (to)) (and (= 1 (size Stack at:(to))) (is Enemy (who at:(to))))) (apply (if (is Enemy (who at:(to))) (move (from (to)) (to (mapEntry "Bar" Next))))))))) (then (if (not (all DiceUsed)) (moveAgain)))))) (end (if (no Pieces Mover) (result Mover Win))))) 
Four 3x8 rectangles, arranged in a cross shape around large central square. Four players. Four pieces per player. Two rectangular four-sided die, each marked as follows: 0, 1, 2, 4. When the throw is 0 and 1, the throw is called Tayam, when it is 0 and 4 it is called Sonal. Pieces enter the board from the central square onto the central row of their arm of the board, proceed down the central row, and then in an anti-clockwise direction around the circumference of the board, and back up the central row of their arm of the board, having to enter the central square with an exact throw. The first counter of each player must be entered with a throw of Tayam. After this, pieces may be entered with a throw of 1, 5, or Sonal, each of which enter the piece on the first square of the central row of their arm. These three throws also grant the player another throw. The throws made after entering a piece are made at once, and then the pieces moved afterward, the undivided value of each throw being used to move a piece. When a piece lands on a space occupied by an opponent's piece, the opponent's piece is sent back to start. If the opponent has two pieces on such a space, they both are sent back to start, but both may reenter the board with a single throw of 1, 5, or Sonal. The first player to place all of their pieces in the central square wins. 
(game "Tayam Sonalu" (players 4) (equipment {(board (add (hole (merge (shift 0 (/ (- 19 3) 2) (rectangle 3 19)) (shift (/ (- 19 3) 2) 0 (rectangle 19 3))) (poly {{8 8} {8 11} {11 11} {11 8}})) cells:{{8 28 48 68 69 70 71 51 31 11 10 9}}) {(track "Track1" "96,9,S,E,N,11,E,N,W,53,N,W,S,42,W,S,E,8,S,E1,N7,End" P1 directed:True) (track "Track2" "96,26,W,S,E,8,S,E,N,11,E,N,W,53,N,W,S,42,W,S1,E7,End" P2 directed:True) (track "Track3" "96,52,N,W,S,42,W,S,E,8,S,E,N,11,E,N,W,53,N,W1,S7,End" P3 directed:True) (track "Track4" "96,27,E,N,W,53,N,W,S,42,W,S,E,8,S,E,N,11,E,N1,W7,End" P4 directed:True)}) (hand Each) (dice d:4 faces:{0 1 2 4} num:2) (piece "Pawn" Each (if (= (trackSite Move from:(from) steps:(count Pips)) -2) (move Remove (from) level:(level)) (move (from (from) level:(level)) (to (trackSite Move from:(from) steps:(count Pips)) if:True (apply (if (is Enemy (who at:(to))) (if (= 1 (size Stack at:(to))) (forEach Level (to) FromTop (fromTo (from (to) level:(level)) (to (centrePoint)))) (forEach Level (to) FromTop (fromTo (from (to) level:(level)) (to (handSite (who at:(to) level:(level))))))))))))) (map "Start" {(pair P1 9) (pair P2 26) (pair P3 52) (pair P4 27)})}) (rules (start {(place Stack "Pawn1" (handSite P1) count:4) (place Stack "Pawn2" (handSite P2) count:4) (place Stack "Pawn3" (handSite P3) count:4) (place Stack "Pawn4" (handSite P4) count:4)}) (play (do (roll) next:(if (!= 0 (count Pips)) (or (if (and (is Occupied (handSite Mover)) (or (and (= -1 (value Player Mover)) (or (and (= 0 (face 101)) (= 1 (face 102))) (and (= 1 (face 101)) (= 0 (face 102))))) (and (= 1 (value Player Mover)) (or (is In (count Pips) (sites {1 5})) (or (and (= 0 (face 101)) (= 4 (face 102))) (and (= 4 (face 101)) (= 0 (face 102)))))))) (move (from (handSite Mover)) (to (mapEntry "Start" Mover)) (then (if (= -1 (value Player Mover)) (set Value Mover 1))))) (forEach Piece))) (then (if (and (not (no Pieces Mover)) (or (is In (count Pips) (sites {1 5})) (or (and (= 0 (face 101)) (= 4 (face 102))) (and (= 4 (face 101)) (= 0 (face 102)))))) (moveAgain))))) (end (if (no Pieces Mover) (result Mover Win))))) 
5x5 board, marked with an X in the central square and the midpoints of the outer circuit of spaces. Four players. Four pieces per player. Four seeds, with one white side and one dark side, used as dice. The values of the throws are equal to the number of white sides up, except when no white sides are up the throw equals 8. Throws of 1, 4, and 8 grant the player another throw. Players make all of the throws in their turn first, and then move the values of the throws individually. A player cannot subdivide the value of a single throw between pieces, but may move more than one piece in a turn if they have multiple throws, moving a piece the value of an entire throw. Pieces may only enter the board with a throw of 1. When a player has no pieces on the board, throws made before a throw of 1 do not count and cannot be played. Pieces enter on the marked square on the outer track of the square in front of the player. Pieces move anticlockwise around the outer squares of the board until they reach the square just before the square from which they started, then moving to the inner track and moving clockwise, and then onto the central square. Multiple pieces may occupy the same square. If a player's piece lands on a spot occupied by an opponent's piece, the opponent's piece is removed from the board and must be entered again. If the opponent has multiple pieces on this spot, they all are sent to the beginning. Sending an opponent's piece off the board grants the player another throw. Pieces on marked squares cannot be sent off the board. If a player has two pieces on the marked square on the opposite side of the board from the one in which they begin, the player may declare these as a twin which then play as one piece. Twins move half the value of a throw, rounding down. Twins may only be sent off the board by another twin. Twins may not send back to start a single piece belonging to an opponent. When sent off the board, the twins enter the board again as single pieces. When the twin reaches the central space, it becomes two single pieces again. When all of a player's pieces are in the central square, they may begin bearing them off. A throw of 1 is required to bear a piece off. The player who bears off all their pieces first wins.
(game "Thaayam" (players 4) (equipment {(board (square 5) {(track "Track1" "2,E,N,W,S,E1,N3,E2,S2,W1,N1" P1 directed:True) (track "Track2" "14,N,W,S,E,N1,W3,N2,E2,S1,W1" P2 directed:True) (track "Track3" "22,W,S,E,N,W1,S3,W2,N2,E1,S1" P3 directed:True) (track "Track4" "10,S,E,N,W,S1,E3,S2,W2,N1,E1" P4 directed:True)}) (hand Each) (regions "MarkedCells" (union {(sites Centre) (intersection (sites Outer) (sites Row (row of:(centrePoint)))) (intersection (sites Outer) (sites Column (column of:(centrePoint))))})) (piece "Counter" Each (or (if (!= (trackSite Move steps:(value)) -1) (move (from (from) level:(level)) (to (trackSite Move steps:(value)) (apply if:True (and (if (and {(is Enemy (who at:(to))) (= (value Piece at:(to)) 1) (not (is In (to) (sites "MarkedCells")))}) (fromTo (from (to)) (to (handSite (who at:(to))) (apply if:True (and (set Pending) (moveAgain)))) count:(size Stack at:(to)) stack:True)) (forget Value (value))))))) (if (and (= 1 (value)) (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Centre)))) (move (from (from) level:(level)) (to (handSite Mover) (apply if:True (forget Value (value)))) (then (remove (last To))))))) (piece "DoubleCounter" Each (if (and (> (/ (value) 2) 0) (!= (trackSite Move steps:(/ (value) 2)) -1)) (move (from (from) level:(level)) (to (trackSite Move steps:(/ (value) 2)) (apply if:True (and (if (and {(is Enemy (who at:(to))) (= (value Piece at:(to)) 2) (not (is In (to) (sites "MarkedCells")))}) (and {(remove (to)) (add (piece (if (= (who at:(to)) P1) (id "Counter" P1) (if (= (who at:(to)) P2) (id "Counter" P2) (if (= (who at:(to)) P3) (id "Counter" P3) (id "Counter" P4))))) (to (handSite (who at:(to)))) count:2 stack:True) (set Pending) (moveAgain)})) (forget Value (value))))) (then (if (= (centrePoint) (last To)) (and (remove (last To)) (add (piece (if (= (who at:(last To)) P1) (id "Counter" P1) (if (= (who at:(last To)) P2) (id "Counter" P2) (if (= (who at:(last To)) P3) (id "Counter" P3) (id "Counter" P4))))) (to (last To)) count:2 stack:True))))))) (dice d:2 from:0 num:4) (map "Start" {(pair P1 2) (pair P2 14) (pair P3 22) (pair P4 10)}) (map "OppositeStart" {(pair P1 22) (pair P2 10) (pair P3 2) (pair P4 14)})}) (rules (start {(place Stack "Counter1" (handSite P1) count:4 value:1) (place Stack "Counter2" (handSite P2) count:4 value:1) (place Stack "Counter3" (handSite P3) count:4 value:1) (place Stack "Counter4" (handSite P4) count:4 value:1)}) (play (if (can Move (if (or (not (is Prev Mover)) (is Pending)) (do (roll) next:(move Pass (then (and {(if (or {(= (if (= 0 (count Pips)) 8 (count Pips)) 1) (= (if (= 0 (count Pips)) 8 (count Pips)) 4) (= (if (= 0 (count Pips)) 8 (count Pips)) 8)}) (set Pending)) (if (not (all Sites (sites Occupied by:Mover) if:(not (is In (site) (sites Board))))) (remember Value (if (= 0 (count Pips)) 8 (count Pips))) (if (or (= (if (= 0 (count Pips)) 8 (count Pips)) 1) (is In 1 (values Remembered))) (remember Value (if (= 0 (count Pips)) 8 (count Pips))))) (moveAgain)})))) (or (forEach Value (values Remembered) (or (if (and (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site))))) (= 1 (value))) (move (from (handSite Mover)) (to (mapEntry "Start" (mover)) (apply if:True (forget Value (value)))))) (forEach Piece) (then (if (!= 0 (size Array (values Remembered))) (moveAgain))))) (if (and {(= (size Stack at:(mapEntry "OppositeStart" (mover))) 2) (= (who at:(mapEntry "OppositeStart" (mover)) level:0) Mover) (= (who at:(mapEntry "OppositeStart" (mover)) level:1) Mover)}) (move Select (from (mapEntry "OppositeStart" (mover))) (then (and {(remove (mapEntry "OppositeStart" (mover)) count:2) (add (piece (id "DoubleCounter" Mover)) (to (mapEntry "OppositeStart" (mover))) (then (set Value at:(mapEntry "OppositeStart" (mover)) 2))) (moveAgain)}))))))) (if (or (not (is Prev Mover)) (is Pending)) (do (roll) next:(move Pass (then (and {(if (or {(= (if (= 0 (count Pips)) 8 (count Pips)) 1) (= (if (= 0 (count Pips)) 8 (count Pips)) 4) (= (if (= 0 (count Pips)) 8 (count Pips)) 8)}) (set Pending)) (if (not (all Sites (sites Occupied by:Mover) if:(not (is In (site) (sites Board))))) (remember Value (if (= 0 (count Pips)) 8 (count Pips))) (if (or (= (if (= 0 (count Pips)) 8 (count Pips)) 1) (is In 1 (values Remembered))) (remember Value (if (= 0 (count Pips)) 8 (count Pips))))) (moveAgain)})))) (or (forEach Value (values Remembered) (or (if (and (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site))))) (= 1 (value))) (move (from (handSite Mover)) (to (mapEntry "Start" (mover)) (apply if:True (forget Value (value)))))) (forEach Piece) (then (if (!= 0 (size Array (values Remembered))) (moveAgain))))) (if (and {(= (size Stack at:(mapEntry "OppositeStart" (mover))) 2) (= (who at:(mapEntry "OppositeStart" (mover)) level:0) Mover) (= (who at:(mapEntry "OppositeStart" (mover)) level:1) Mover)}) (move Select (from (mapEntry "OppositeStart" (mover))) (then (and {(remove (mapEntry "OppositeStart" (mover)) count:2) (add (piece (id "DoubleCounter" Mover)) (to (mapEntry "OppositeStart" (mover))) (then (set Value at:(mapEntry "OppositeStart" (mover)) 2))) (moveAgain)})))))) (move Pass (then (forEach Value (values Remembered) (forget Value (value))))))) (end (if (no Pieces Mover) (result Mover Win))))) 
2x12 board, divided in half. Spaces on each side take the form of semi-circular sockets, into which the pieces fit. The points form a continuous track in a horseshoe shape; each player progresses in opposite directions (one from their bottom right to the top right, the other from their bottom left to their top left). Fifteen pieces per player. The starting position is as such, number the points from the origin of each player's track: point six: five pieces; point 8: three pieces; point 13: five pieces; point 24: two pieces. Two dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. When a player's piece lands on a spot occupied by a single piece belonging to the opponent, the opponent's piece is sent back to the quadrant in which that player started with two pieces. Players bear off their pieces at the end of their track. The first player to bear off all their pieces wins.
(game "Todas Tablas" (players 2) (equipment {(board (merge {(rectangle 1 6) (shift 7 0 (rectangle 1 6)) (shift 0 6 (rectangle 1 6)) (shift 7 6 (rectangle 1 6))}) {(track "Track1" {11 10 9 8 7 6 5 4 3 2 1 0 12 13 14 15 16 17 18 19 20 21 22 23} P1 directed:True) (track "Track2" {23 22 21 20 19 18 17 16 15 14 13 12 0 1 2 3 4 5 6 7 8 9 10 11} P2 directed:True)} use:Vertex) (dice d:6 num:2) (piece "Disc" Each (forEach Die if:(!= (pips) 0) (if (= (trackSite Move from:(from) steps:(pips)) -1) (move Remove (from)) (move (from (from)) (to (trackSite Move from:(from) steps:(pips)) if:(or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (if (and (!= (to) (regionSite (sites Next "StartQuadrant") index:0)) (not (is Friend (who at:(regionSite (sites Next "StartQuadrant") index:0))))) (regionSite (sites Next "StartQuadrant") index:0) (if (and (!= (to) (regionSite (sites Next "StartQuadrant") index:1)) (not (is Friend (who at:(regionSite (sites Next "StartQuadrant") index:1))))) (regionSite (sites Next "StartQuadrant") index:1) (if (and (!= (to) (regionSite (sites Next "StartQuadrant") index:2)) (not (is Friend (who at:(regionSite (sites Next "StartQuadrant") index:2))))) (regionSite (sites Next "StartQuadrant") index:2) (if (and (!= (to) (regionSite (sites Next "StartQuadrant") index:3)) (not (is Friend (who at:(regionSite (sites Next "StartQuadrant") index:3))))) (regionSite (sites Next "StartQuadrant") index:3) (if (and (!= (to) (regionSite (sites Next "StartQuadrant") index:4)) (not (is Friend (who at:(regionSite (sites Next "StartQuadrant") index:4))))) (regionSite (sites Next "StartQuadrant") index:4) (if (and (!= (to) (regionSite (sites Next "StartQuadrant") index:5)) (not (is Friend (who at:(regionSite (sites Next "StartQuadrant") index:5))))) (regionSite (sites Next "StartQuadrant") index:5) (if (and (!= (to) (regionSite (sites Next "StartQuadrant") index:6)) (not (is Friend (who at:(regionSite (sites Next "StartQuadrant") index:6))))) (regionSite (sites Next "StartQuadrant") index:6) -1))))))))))))) (then (if (not (all DiceUsed)) (moveAgain))))) (regions "StartQuadrant" P1 (sites {6 7 8 9 10 11})) (regions "StartQuadrant" P2 (sites {18 19 20 21 22 23}))}) (rules (start {(place Stack "Disc1" 6 count:5) (place Stack "Disc1" 4 count:3) (place Stack "Disc1" 12 count:5) (place Stack "Disc1" 23 count:2) (place Stack "Disc2" 18 count:5) (place Stack "Disc2" 16 count:3) (place Stack "Disc2" 0 count:5) (place Stack "Disc2" 11 count:2)}) (play (do (if (not (is Prev Mover)) (roll)) next:(forEach Piece))) (end (if (no Pieces Mover) (result Mover Win))))) 
2x12 board, with spaces as points, divided in two. Fifteen or sixteen pieces per player, which begin on one of the points, the furthest to the right of one player and the furthest to the left of the other (they will be opposite each other). The points form a continuous track in a horseshoe shape; each player progresses in opposite directions (one from their bottom right to the top right, the other from their bottom left to their top left). Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. Doubles are only played once. Pieces may not land on a space occupied by an opponent's piece. Pieces may only move into the twelfth point on their side of the board (Hucke) with a throw that allows two pieces to move there at once. A player cannot move into or hit pieces in the opponent's Hucke. Players may move beyond their Hucke only on a throw that allows them, to move two pieces from the Hucke onto the opposite side of the board. Each player has another piece, placed at the tip of their point. The player moves this piece to mark the score they earn. Points are awarded as follows: When it is possible for a player to land on a space occupied by a single piece belonging to the opponent (a hit), a player gains one point. Hitting the opponent's Hucke is only possible by throwing two 1s with at least four pieces on the player's own Hucke. For a given throw, all possible hits made by any legal move are counted. Players move their pieces after the possible hits are calculated. A player gains two points by bringing all of their pieces into the final section of the board and bearing all of their pieces off by throwing more than the number of remaining spaces. The player who obtains twelve points wins.  Each player has 15 pieces.
(game "Tokkadille" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {12 11 10 9 8 7 5 4 3 2 1 0 13 14 15 16 17 18 20 21 22 23 24 25} P1 directed:True) (track "Track2" {25 24 23 22 21 20 18 17 16 15 14 13 0 1 2 3 4 5 7 8 9 10 11 12} P2 directed:True) (track "ReverseHuckeTrack1" {0 1 2 3 4 5 7} P1 directed:True) (track "ReverseHuckeTrack2" {13 14 15 16 17 18 20} P2 directed:True)} use:Vertex) (dice d:6 num:2) (piece "Disc" Each (if (is In (from) (sites Mover "BeforeHucke")) (forEach Die if:(!= (pips) 0) (move (from (from)) (to (trackSite Move from:(from) "Track" steps:(pips)) if:(and (is In (to) (sites Mover "BeforeHucke")) (not (is Enemy (who at:(to))))))) (then (if (not (all DiceUsed)) (moveAgain)))) (if (!= (from) (mapEntry "Hucke" (mover))) (forEach Die if:(!= (pips) 0) (if (= (trackSite Move from:(from) "Track" steps:(pips)) -1) (move Remove (from)) (move (from (from)) (to (trackSite Move from:(from) "Track" steps:(pips)) if:(not (is Enemy (who at:(to))))))) (then (if (not (all DiceUsed)) (moveAgain))))))) (regions "BeforeHucke" P1 (sites {12 11 10 9 8 7 5 4 3 2 1})) (regions "BeforeHucke" P2 (sites {25 24 23 22 21 20 18 17 16 15 14})) (map "Hucke" {(pair P1 0) (pair P2 13)})}) (rules (start {(place Stack "Disc1" 12 count:15) (place Stack "Disc2" 25 count:15)}) (play (do (if (not (is Prev Mover)) (roll)) next:(do (if (not (is Prev Mover)) (forEach Site (sites Occupied by:Mover) (if (is In (site) (sites Mover "BeforeHucke")) (and (if (and {(is In (trackSite Move from:(site) "Track" steps:(face 26)) (sites Mover "BeforeHucke")) (is Enemy (who at:(trackSite Move from:(site) "Track" steps:(face 26)))) (= 1 (size Stack at:(trackSite Move from:(site) "Track" steps:(face 26))))}) (addScore Mover 1)) (if (and {(is In (trackSite Move from:(site) "Track" steps:(face 27)) (sites Mover "BeforeHucke")) (is Enemy (who at:(trackSite Move from:(site) "Track" steps:(face 27)))) (= 1 (size Stack at:(trackSite Move from:(site) "Track" steps:(face 27))))}) (addScore Mover 1))) (if (!= (site) (mapEntry "Hucke" (mover))) (and (if (and (is Enemy (who at:(trackSite Move from:(site) "Track" steps:(face 26)))) (= 1 (size Stack at:(trackSite Move from:(site) "Track" steps:(face 26))))) (addScore Mover 1)) (if (and (is Enemy (who at:(trackSite Move from:(site) "Track" steps:(face 27)))) (= 1 (size Stack at:(trackSite Move from:(site) "Track" steps:(face 27))))) (addScore Mover 1))) (if (and {(= 1 (face 26)) (= 1 (face 27)) (<= 4 (size Stack at:(mapEntry "Hucke" (mover)))) (= 1 (size Stack at:(trackSite Move from:(site) "Track" steps:(face 26))))}) (addScore Mover 1)))))) next:(or {(if (and (>= 0 (var "MovingFromHucke")) (>= 0 (var "MovingToHucke"))) (forEach Piece)) (if (>= 0 (var "MovingFromHucke")) (if (or (< 0 (var "MovingToHucke")) (if (= (face 26) (face 27)) (<= 2 (count Pieces Mover in:(sites {(trackSite Move from:(mapEntry "Hucke" (mover)) "ReverseHuckeTrack" steps:(face 27))}))) (and (<= 1 (count Pieces Mover in:(sites {(trackSite Move from:(mapEntry "Hucke" (mover)) "ReverseHuckeTrack" steps:(face 26))}))) (<= 1 (count Pieces Mover in:(sites {(trackSite Move from:(mapEntry "Hucke" (mover)) "ReverseHuckeTrack" steps:(face 27))})))))) (or (if (and (!= 26 (var "MovingToHucke")) (is Friend (who at:(trackSite Move from:(mapEntry "Hucke" (mover)) "ReverseHuckeTrack" steps:(face 26))))) (move (from (trackSite Move from:(mapEntry "Hucke" (mover)) "ReverseHuckeTrack" steps:(face 26))) (to (mapEntry "Hucke" (mover))) (then (if (= 0 (count MovesThisTurn)) (and (moveAgain) (set Var "MovingToHucke" 26)) (set Var "MovingToHucke" 0))))) (if (and (!= 27 (var "MovingToHucke")) (is Friend (who at:(trackSite Move from:(mapEntry "Hucke" (mover)) "ReverseHuckeTrack" steps:(face 27))))) (move (from (trackSite Move from:(mapEntry "Hucke" (mover)) "ReverseHuckeTrack" steps:(face 27))) (to (mapEntry "Hucke" (mover))) (then (if (= 0 (count MovesThisTurn)) (and (moveAgain) (set Var "MovingToHucke" 27)) (set Var "MovingToHucke" 0)))))))) (if (>= 0 (var "MovingToHucke")) (if (or (< 0 (var "MovingFromHucke")) (if (and (and (!= (face 26) 1) (!= (face 27) 1)) (<= 2 (count Pieces Mover in:(sites {(mapEntry "Hucke" (mover))})))) (if (= (face 26) (face 27)) (not (is Enemy (who at:(trackSite Move from:(mapEntry "Hucke" (mover)) "Track" steps:(face 27))))) (and (not (is Enemy (who at:(trackSite Move from:(mapEntry "Hucke" (mover)) "Track" steps:(face 26))))) (not (is Enemy (who at:(trackSite Move from:(mapEntry "Hucke" (mover)) "Track" steps:(face 27))))))))) (or (if (and (!= 26 (var "MovingFromHucke")) (not (is Enemy (who at:(trackSite Move from:(mapEntry "Hucke" (mover)) "Track" steps:(face 26)))))) (move (from (mapEntry "Hucke" (mover))) (to (trackSite Move from:(mapEntry "Hucke" (mover)) "Track" steps:(face 26))) (then (if (= 0 (count MovesThisTurn)) (and (moveAgain) (set Var "MovingFromHucke" 26)) (set Var "MovingFromHucke" 0))))) (if (and (!= 27 (var "MovingFromHucke")) (not (is Enemy (who at:(trackSite Move from:(mapEntry "Hucke" (mover)) "Track" steps:(face 27)))))) (move (from (mapEntry "Hucke" (mover))) (to (trackSite Move from:(mapEntry "Hucke" (mover)) "Track" steps:(face 27))) (then (if (= 0 (count MovesThisTurn)) (and (moveAgain) (set Var "MovingFromHucke" 27)) (set Var "MovingFromHucke" 0))))))))})) (then (if (no Pieces Mover) (addScore Mover 2))))) (end (if (<= 12 (score Mover)) (result Mover Win))))) 
2x8 board, with rectangular spaces. Sixteen pieces per player, eight each placed on the two rectangles to each player's left. Each player moves their pieces in an anti-clockwise direction. Two six-sided dice. When a player rolls two 1s, they lose a piece. When a player rolls doubles of another number, the player may move two pieces the full total of the roll, or one piece only moves half the total roll. When consecutive numbers are rolled, the player may move one piece the total of the two dice and the second piece the value of the lower die, or may move one piece the total of the die and another piece the total of the dice minus 1. When the roll is two non-consecutive numbers, the player moves the values of the individual dice. The first player to move their pieces around the board and back to the starting position wins. 
(game "Tsun K'i" (players 2) (equipment {(board (scale 10 2 (rectangle 8 2)) {(track "Track1" "1,N,W,S,N,E1,S" P1 directed:True) (track "Track2" "14,S,E,N,S,W1,N" P2 directed:True)}) (piece "Stick" Each) (dice d:6 num:2) (regions "Exit" P1 (sites {"B1" "B2"})) (regions "Exit" P2 (sites {"A7" "A8"}))}) (rules (start {(place Stack "Stick1" (sites {"B1" "B2"}) count:8) (place Stack "Stick2" (sites {"A7" "A8"}) count:8)}) (play (do (if (<= (var) 0) (roll)) next:(if (can Move (if (and (= 2 (count Pips)) (is AnyDie 1)) (forEach Site (sites Occupied by:Mover top:False) (forEach Level (site) (if (is Friend (who at:(site) level:(level))) (move Remove (site) level:(level))))) (if (= (face 16) (face 17)) (forEach Site (sites Occupied by:Mover top:False) (forEach Level (site) (or (if (<= (var) 0) (move (from (site) level:(level)) (to (trackSite Move from:(site) "Track" steps:(face 16))))) (move (from (site) level:(level)) (to (trackSite Move from:(site) "Track" steps:(count Pips))) (then (if (<= (var) 0) (and (moveAgain) (set Var 1)) (set Var 0))))))) (if (or (= (face 16) (- (face 17) 1)) (= (face 16) (+ (face 17) 1))) (forEach Site (sites Occupied by:Mover top:False) (forEach Level (site) (or (if (!= (var) (- (count Pips) 1)) (or (move (from (site) level:(level)) (to (trackSite Move from:(site) "Track" steps:(if (< (face 16) (face 17)) (face 16) (face 17))))) (move (from (site) level:(level)) (to (trackSite Move from:(site) "Track" steps:(- (count Pips) 1)))) (then (if (<= (var) 0) (and (moveAgain) (set Var (- (count Pips) 1))) (set Var 0))))) (if (!= (var) (count Pips)) (move (from (site) level:(level)) (to (trackSite Move from:(site) "Track" steps:(count Pips))) (then (if (<= (var) 0) (and (moveAgain) (set Var (count Pips))) (set Var 0)))))))) (forEach Site (sites Occupied by:Mover top:False) (forEach Level (site) (or (if (!= (var) (face 16)) (move (from (site) level:(level)) (to (trackSite Move from:(site) "Track" steps:(face 16))) (then (if (<= (var) 0) (and (moveAgain) (set Var (face 16))) (set Var 0))))) (if (!= (var) (face 17)) (move (from (site) level:(level)) (to (trackSite Move from:(site) "Track" steps:(face 17))) (then (if (<= (var) 0) (and (moveAgain) (set Var (face 17))) (set Var 0)))))))))))) (if (and (= 2 (count Pips)) (is AnyDie 1)) (forEach Site (sites Occupied by:Mover top:False) (forEach Level (site) (if (is Friend (who at:(site) level:(level))) (move Remove (site) level:(level))))) (if (= (face 16) (face 17)) (forEach Site (sites Occupied by:Mover top:False) (forEach Level (site) (or (if (<= (var) 0) (move (from (site) level:(level)) (to (trackSite Move from:(site) "Track" steps:(face 16))))) (move (from (site) level:(level)) (to (trackSite Move from:(site) "Track" steps:(count Pips))) (then (if (<= (var) 0) (and (moveAgain) (set Var 1)) (set Var 0))))))) (if (or (= (face 16) (- (face 17) 1)) (= (face 16) (+ (face 17) 1))) (forEach Site (sites Occupied by:Mover top:False) (forEach Level (site) (or (if (!= (var) (- (count Pips) 1)) (or (move (from (site) level:(level)) (to (trackSite Move from:(site) "Track" steps:(if (< (face 16) (face 17)) (face 16) (face 17))))) (move (from (site) level:(level)) (to (trackSite Move from:(site) "Track" steps:(- (count Pips) 1)))) (then (if (<= (var) 0) (and (moveAgain) (set Var (- (count Pips) 1))) (set Var 0))))) (if (!= (var) (count Pips)) (move (from (site) level:(level)) (to (trackSite Move from:(site) "Track" steps:(count Pips))) (then (if (<= (var) 0) (and (moveAgain) (set Var (count Pips))) (set Var 0)))))))) (forEach Site (sites Occupied by:Mover top:False) (forEach Level (site) (or (if (!= (var) (face 16)) (move (from (site) level:(level)) (to (trackSite Move from:(site) "Track" steps:(face 16))) (then (if (<= (var) 0) (and (moveAgain) (set Var (face 16))) (set Var 0))))) (if (!= (var) (face 17)) (move (from (site) level:(level)) (to (trackSite Move from:(site) "Track" steps:(face 17))) (then (if (<= (var) 0) (and (moveAgain) (set Var (face 17))) (set Var 0))))))))))) (move Pass (then (set Var 0)))) (then (if (and (is In (last To) (sites Mover "Exit")) (not (is In (last From) (sites Mover "Exit")))) (remove (last To) level:(last LevelTo)))))) (end (if (no Pieces Mover) (result Mover Win))))) 
Stones are placed on the ground to make a square with ten spaces per side, the spaces between the stones being the place where the pieces are played. One piece per player. Three sticks used as dice, one side flat, the other round. One of the sticks is notched on the round side. Throws are as follows: All flat sides up = 5; all round sides up = 10; one flat and two round, with no notches up = 1, two flat and one round, with no notches up = 3, two flat or two round, with notches up = 15. Pieces begin in one corner of the board. Players may move in opposite directions around the board, or in the same direction. When players move in the same direction, they may send the opponent's piece back to the beginning if they land on their spot. When the opponent is sent back to the beginning, they may then choose their direction of play. When players are moving in opposite directions, the opponent's piece may not be sent to start. The first player to travel around the board and land in the starting space wins. The game has 2 players.
(game "Tugi-Epfe" (players 2) (equipment {(board (merge {(rectangle 1 11) (rectangle 11 1) (shift 0 10 (rectangle 1 11)) (shift 10 0 (rectangle 11 1))}) {(track "TrackCW" {0 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 39 38 37 36 35 34 33 32 31 30 9 8 7 6 5 4 3 2 1 0} directed:True) (track "TrackCCW" {0 1 2 3 4 5 6 7 8 9 30 31 32 33 34 35 36 37 38 39 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 0} directed:True)} use:Edge) (dice d:2 facesByDie:{{0 10} {0 1} {0 1}} num:3) (map "ThrowDiceValue" {(pair 0 5) (pair 12 5) (pair 2 1) (pair 1 3) (pair 10 15) (pair 11 15)}) (piece "Horse" Each (if (= (value Player Mover) -1) (or (if (!= (trackSite Move "TrackCW" steps:(mapEntry "ThrowDiceValue" (count Pips))) -1) (if (or (is Empty (trackSite Move "TrackCW" steps:(mapEntry "ThrowDiceValue" (count Pips)))) (and (is Enemy (who at:(trackSite Move "TrackCW" steps:(mapEntry "ThrowDiceValue" (count Pips))))) (or (= (value Player Mover) (value Player (who at:(trackSite Move "TrackCW" steps:(mapEntry "ThrowDiceValue" (count Pips)))))) (= (value Player Mover) -1)))) (move (from (from) level:(level)) (to (trackSite Move "TrackCW" steps:(mapEntry "ThrowDiceValue" (count Pips))) (apply if:(is Enemy (who at:(to))) (and (fromTo (from (to)) (to 0)) (set Value (player (who at:(to))) -1)))))) (then (if (= (value Player Mover) -1) (set Value Mover 1)))) (if (!= (trackSite Move "TrackCCW" steps:(mapEntry "ThrowDiceValue" (count Pips))) -1) (if (or (is Empty (trackSite Move "TrackCCW" steps:(mapEntry "ThrowDiceValue" (count Pips)))) (and (is Enemy (who at:(trackSite Move "TrackCCW" steps:(mapEntry "ThrowDiceValue" (count Pips))))) (or (= (value Player Mover) (value Player (who at:(trackSite Move "TrackCCW" steps:(mapEntry "ThrowDiceValue" (count Pips)))))) (= (value Player Mover) -1)))) (move (from (from) level:(level)) (to (trackSite Move "TrackCCW" steps:(mapEntry "ThrowDiceValue" (count Pips))) (apply if:(is Enemy (who at:(to))) (and (fromTo (from (to)) (to 0)) (set Value (player (who at:(to))) -1)))))) (then (if (= (value Player Mover) -1) (set Value Mover 2))))) (if (!= (if (= (value Player Mover) 2) (trackSite Move "TrackCCW" steps:(mapEntry "ThrowDiceValue" (count Pips))) (trackSite Move "TrackCW" steps:(mapEntry "ThrowDiceValue" (count Pips)))) -1) (if (or (is Empty (if (= (value Player Mover) 2) (trackSite Move "TrackCCW" steps:(mapEntry "ThrowDiceValue" (count Pips))) (trackSite Move "TrackCW" steps:(mapEntry "ThrowDiceValue" (count Pips))))) (and (is Enemy (who at:(if (= (value Player Mover) 2) (trackSite Move "TrackCCW" steps:(mapEntry "ThrowDiceValue" (count Pips))) (trackSite Move "TrackCW" steps:(mapEntry "ThrowDiceValue" (count Pips)))))) (or (= (value Player Mover) (value Player (who at:(if (= (value Player Mover) 2) (trackSite Move "TrackCCW" steps:(mapEntry "ThrowDiceValue" (count Pips))) (trackSite Move "TrackCW" steps:(mapEntry "ThrowDiceValue" (count Pips))))))) (= (value Player Mover) -1)))) (move (from (from) level:(level)) (to (if (= (value Player Mover) 2) (trackSite Move "TrackCCW" steps:(mapEntry "ThrowDiceValue" (count Pips))) (trackSite Move "TrackCW" steps:(mapEntry "ThrowDiceValue" (count Pips)))) (apply if:(is Enemy (who at:(to))) (and (fromTo (from (to)) (to 0)) (set Value (player (who at:(to))) -1))))))))) (regions "AllSites" (sites Board))}) (rules (start (place Stack items:{"Horse2" "Horse1"} 0)) (play (do (roll) next:(forEach Piece) (then (if (= (last To) 0) (remove (last To)))))) (end (if (no Pieces Mover) (result Mover Win))))) 
The board is a rectilinear track with two rows, of any number. Six or seven players, seven are preferred. One piece per player. Two seashells, used as dice. The throws are as follows: two backs = 20; two hollow sides = 10, one of each = 0. The player to reach the end of the track wins. The game involves 7 players. Each row has 50 holes.
(game "Uturu Uturu Kaida" (players 7) (equipment {(board (rectangle 2 50) (track "Track" {0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 99 98 97 96 95 94 93 92 91 90 89 88 87 86 85 84 83 82 81 80 79 78 77 76 75 74 73 72 71 70 69 68 67 66 65 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50} directed:True) use:Vertex) (hand Each) (piece "Horse" Each (if (= (if (= (from) (handSite Mover)) (trackSite Move from:0 steps:(- (mapEntry (count Pips)) 1)) (trackSite Move from:(from) steps:(mapEntry (count Pips)))) -1) (move Remove (from) level:(level)) (move (from (from) level:(level)) (to (if (= (from) (handSite Mover)) (trackSite Move from:0 steps:(- (mapEntry (count Pips)) 1)) (trackSite Move from:(from) steps:(mapEntry (count Pips))))) stack:True))) (dice d:2 from:0 num:2) (map {(pair 0 10) (pair 1 0) (pair 2 20)})}) (rules (start (place "Horse" "Hand")) (play (do (roll) next:(if (< 0 (mapEntry (count Pips))) (or (forEach Piece) (forEach Piece container:(mover)))))) (end (if (no Pieces Mover) (result Mover Win))))) 
2x12 board, with the spaces rendered as points, divided into half. Fifteen pieces per player. Two six-sided dice. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. A throw of doubles forces the player to play the throw twice. Each player's pieces begin in three stacks of five, on the leftmost point (with respect to the opponent) on the opponent's side of the board. Play proceeds (with respect to the player) from right to left on the opponent's side of the board, and then from left to right on the player's side of the board. A player cannot place two pieces on a single point on any of the first twelve points of the board, except for those pieces in the starting position. A player cannot move a piece onto a point containing two or more pieces belonging to the opponent. When a piece lands on a point occupied by a single piece belonging to the opponent, it is removed from the board and must be entered again, and can only do so using the value of one die, not both, with the starting point considered to be point 1, the next point 2, etc. Opponent's pieces can be removed from the board in this way when reentering the board. If a player cannot reenter pieces on the board they lose their turn. When all of a player's pieces are on their final 6 points, they may start removing pieces from the board. They can do so by rolling a 6 to move from the 6th point, and so on down to 1. Players must use all available moves presented by the dice. The first player to remove all of their pieces wins.
(game "Verquere" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {6 25 24 23 22 21 20 18 17 16 15 14 13 0 1 2 3 4 5 7 8 9 10 11 12 -2} P1 directed:True) (track "Track2" {19 0 1 2 3 4 5 7 8 9 10 11 12 25 24 23 22 21 20 18 17 16 15 14 13 -2} P2 directed:True)} use:Vertex) (dice d:6 num:2) (piece "Disc" Each (forEach Die replayDouble:True if:(!= (pips) 0) (if (= (trackSite Move from:(from) steps:(pips)) -2) (if (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover "FinalQuadrant"))) (move Remove (from))) (move (from (from)) (to (trackSite Move from:(from) steps:(pips)) if:(and (or (not (is Enemy (who at:(to)))) (= 1 (size Stack at:(to)))) (if (not (is In (to) (sites Mover "StartingSide"))) True (is Empty (to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry "Bar" Next))))))) (then (if (not (all DiceUsed)) (moveAgain))))) (regions "FinalQuadrant" P1 (sites {7 8 9 10 11 12})) (regions "FinalQuadrant" P2 (sites {13 14 15 16 17 18})) (regions "StartingSide" P1 (sites {25 24 23 22 21 20 18 17 16 15 14 13})) (regions "StartingSide" P2 (sites {0 1 2 3 4 5 7 8 9 10 11 12})) (map "Bar" {(pair P1 6) (pair P2 19)})}) (rules (start {(place Stack "Disc1" 25 count:15) (place Stack "Disc2" 0 count:15)}) (play (do (if (not (is Prev Mover)) (roll)) next:(forEach Piece top:True))) (end (if (no Pieces Mover) (result Mover Win))))) 
Play begins in the central row and continues from left to right, then down the furthest row from right to left, then on the closest row from left to right. Played using three dice; throws can be used singly or combined but could not be divided. No second throw with doubles or triples. More than one piece of the same player can occupy one point, Single pieces can be removed from the board when the opponent lands on it; it must then be re-entered to the board before the player can move their other pieces. The goal is to bear off all of the player's pieces, which can be done one they are all in the closest row. The rules are describing with the Murray ruleset.
(game "XII Scripta" (players 2) (equipment {(board (add (merge (rectangle 3 6) (shift 7 0 (rectangle 3 6))) edges:{{5 18} {11 24} {17 30}}) {(track "Track1" "36,6,E,N1,W,0,E,End" P1 directed:True) (track "Track2" "38,6,E,S1,W,12,E,End" P2 directed:True)} use:Vertex) (dice num:3) (hand Each size:2) (piece "Disc" Each (forEach Die combined:True if:(and (!= (pips) 0) (!= (trackSite Move from:(from) steps:(pips)) -1)) (if (= (trackSite Move from:(from) steps:(pips)) -2) (move Select (from (from)) (then (if (= (count at:(last To)) 1) (remove (last To)) (set Count at:(last To) (- (count at:(last To)) 1))))) (move (from (from)) (to (trackSite Move from:(from) steps:(pips)) if:(not (and (is Enemy (who at:(to))) (> (count at:(to)) 1))) (apply if:(and (is Enemy (who at:(to))) (= (count at:(to)) 1)) (fromTo (from (to)) (to (handSite Next 1)))))))))}) (rules (start {(place "Disc1" (handSite P1) count:15) (place "Disc2" (handSite P2) count:15)}) (play (do (if (not (is Prev Mover)) (roll)) next:(if (!= (what at:(handSite Mover 1)) 0) (forEach Die combined:True if:(and (!= (pips) 0) (!= (trackSite Move from:(handSite Mover) steps:(pips)) -1)) (if (= (trackSite Move from:(handSite Mover) steps:(pips)) -2) (move Select (from (handSite Mover 1)) (then (if (= (count at:(last To)) 1) (remove (last To)) (set Count at:(last To) (- (count at:(last To)) 1))))) (move (from (handSite Mover 1)) (to (trackSite Move from:(handSite Mover) steps:(pips)) if:(not (and (is Enemy (who at:(to))) (> (count at:(to)) 1))) (apply if:(and (is Enemy (who at:(to))) (= (count at:(to)) 1)) (fromTo (from (to)) (to (handSite Next 1)))))))) (or (forEach Piece) (forEach Piece container:(mover))) (then (if (can Move (if (!= (what at:(handSite Mover 1)) 0) (forEach Die combined:True if:(and (!= (pips) 0) (!= (trackSite Move from:(handSite Mover) steps:(pips)) -1)) (if (= (trackSite Move from:(handSite Mover) steps:(pips)) -2) (move Select (from (handSite Mover 1)) (then (if (= (count at:(last To)) 1) (remove (last To)) (set Count at:(last To) (- (count at:(last To)) 1))))) (move (from (handSite Mover 1)) (to (trackSite Move from:(handSite Mover) steps:(pips)) if:(not (and (is Enemy (who at:(to))) (> (count at:(to)) 1))) (apply if:(and (is Enemy (who at:(to))) (= (count at:(to)) 1)) (fromTo (from (to)) (to (handSite Next 1)))))))) (or (forEach Piece) (forEach Piece container:(mover))))) (moveAgain)))))) (end (if (no Pieces Mover) (result Mover Win))))) 
2x12 board, with spaces as points, divided in two. Fifteen pieces per player, which start stacked, two on the players' first three points and three in the next three points. Two six-sided dice. Players unstack the pieces by moving pieces off of the stack, but remaining on the same point, according to the throws of the dice. The value of the throw indicates the number of the point which can be unstacked. For example, a throw of 1 and 4 allows the player to unstack the pieces on points 1 and 4. When all of a player's pieces are unstacked, they must be restacked, in the same way. When they have been successfully restacked, the player then bears off the pieces from this quadrant of the board. When bearing off, players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. The first player to bear off all their pieces wins. 
(game "Yahoudieh" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {7 8 9 10 11 12} P1 directed:True) (track "Track2" {18 17 16 15 14 13} P2 directed:True)} use:Vertex) (dice d:6 num:2) (piece "Disc" Each (forEach Die if:(!= (pips) 0) (if (= (trackSite Move steps:(pips)) -1) (move Remove (from)) (move (from) (to (trackSite Move steps:(pips))))))) (map "StartTrack" {(pair P1 7) (pair P2 18)})}) (rules (start {(place Stack "Disc1" (sites {7 8 9}) count:2) (place Stack "Disc1" (sites {10 11 12}) count:3) (place Stack "Disc2" (sites {13 14 15}) count:3) (place Stack "Disc2" (sites {16 17 18}) count:2)}) phases:{(phase "UnStacking" (play (do (if (not (is Prev Mover)) (roll)) next:(forEach Die if:(!= (pips) 0) (or (if (= (state at:(trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) 0) (move Select (from (trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) (then (and (if (= 3 (size Stack at:(last To))) (forEach Level (last To) (set State at:(last To) level:(level) 1)) (forEach Level (last To) (set State at:(last To) level:(level) 2))) (if (not (all DiceUsed)) (moveAgain)))))) (if (= (state at:(trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) 1) (move Select (from (trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) (then (and (forEach Level (last To) (set State at:(last To) level:(level) 2)) (if (not (all DiceUsed)) (moveAgain)))))))))) (nextPhase Mover (all Sites (sites Occupied by:Mover) if:(not (or (= (state at:(site)) 0) (= (state at:(site)) 1)))) "Stacking")) (phase "Stacking" (play (do (if (not (is Prev Mover)) (roll)) next:(forEach Die if:(!= (pips) 0) (or (if (= (state at:(trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) 2) (move Select (from (trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) (then (and {(if (= 3 (size Stack at:(last To))) (forEach Level (last To) (set State at:(last To) level:(level) 1)) (forEach Level (last To) (set State at:(last To) level:(level) 0))) (if (not (all DiceUsed)) (moveAgain))})))) (if (= (state at:(trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) 1) (move Select (from (trackSite Move from:(mapEntry "StartTrack" (mover)) steps:(- (pips) 1))) (then (and (forEach Level (last To) (set State at:(last To) level:(level) 0)) (if (not (all DiceUsed)) (moveAgain)))))))))) (nextPhase Mover (all Sites (sites Occupied by:Mover) if:(not (= (state at:(site)) 2))) "BearingOff")) (phase "BearingOff" (play (do (if (or (all DiceEqual) (not (is Prev Mover))) (roll)) next:(forEach Piece top:True) (then (if (not (all DiceUsed)) (moveAgain))))) (end (if (no Pieces Mover) (result Mover Win))))})) 
1. Agon is played on a hexagonal board made of 91 hexagonal playing spaces. Each concentric layer for hexagons is so coloured that it is easy to see a playing space's distance from the centre of the board. 2. The players each start with a queen and six guards. They are placed in a set configuration at the edge of the board, as shown again in the diagram. 3. In his turn a player moves a piece one space in any direction, except for any direction that leads away from the centre. 5. A piece may not land on or jump over another. 6. A piece may not move adjacent to two enemy pieces such that it is directly between them. 7. Only a queen may move to the central space. 8. If a piece becomes sandwiched between two enemies, it is captured. 9. If the queen is captured, then its owner must, on his next turn, remove the queen from her predicament and place her on any other space on the board. 10. Otherwise if one of his guards is captured, the player must remove the guard from his predicament, but the guard must be placed on a space at the edge of the board. 11. Only one captured piece may be so removed each turn; so a player may arrest his opponent's strategy for a number of turns if he makes multiple captures at once or in quick succession. 12. A player has won the game when his queen rests on the central space, and her six guards are on the six spaces adjacent to her. 13. A player has lost the game if his six guards are adjacent to the central space but his queen is not between them, as this configuration prevents either player from ever winning the game.
(game "Agon" (players 2) (equipment {(board (hex 6)) (piece "Pawn" Each (move Step (to if:(and {(is Empty (to)) (>= (count Steps Orthogonal (from) (centrePoint)) (count Steps Orthogonal (to) (centrePoint))) (!= (to) (centrePoint))})) (then (custodial (from (last To)) Orthogonal (between (max 1) if:(is Enemy (who at:(between))) (apply (set State at:(between) 1))) (to if:(is Friend (who at:(to)))))))) (piece "Queen" Each (move Step (to if:(and (is Empty (to)) (>= (count Steps Orthogonal (from) (centrePoint)) (count Steps Orthogonal (to) (centrePoint))))) (then (custodial (from (last To)) Orthogonal (between (max 1) if:(is Enemy (who at:(between))) (apply (set State at:(between) 1))) (to if:(is Friend (who at:(to))))))))}) (rules (start {(place "Pawn1" (sites {89 60 20 3 6 51})) (place "Pawn2" (sites {87 84 39 1 30 70})) (place "Queen1" 85) (place "Queen2" 5)}) (play (priority {(forEach Site (forEach (sites Occupied by:Mover component:"Queen") if:(!= 0 (state at:(site)))) (move (from (site)) (to (sites Board) if:(is Empty (to))) (then (set State at:(last To) 0)))) (forEach Site (forEach (sites Occupied by:Mover component:"Pawn") if:(!= 0 (state at:(site)))) (move (from (site)) (to (sites Outer) if:(is Empty (to))) (then (set State at:(last To) 0)))) (do (forEach Piece) ifAfterwards:(not (can Move (intervene (from (last To)) Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to))))))))})) (end (if (all Sites (difference (sites Around (sites Centre)) (sites Centre)) if:(= (what at:(site)) (id "Pawn" Mover))) {(if (= (what at:(centrePoint)) (id "Queen" Mover)) (result Mover Win)) (if (not (= (what at:(centrePoint)) (id "Queen" Mover))) (result Mover Loss))})))) 
3x3 board. Each player plays with three Horse-shaped pieces, which begin on the row of squares closest to the player. Pieces move one space forward and one space diagonally, jumping over any intervening pieces. The first player to place their pieces in the squares where the opponent started wins.
(game "Aralzaa" (players 2) (equipment {(board (square 3)) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(is Empty (to))))) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Knight1" (sites P1)) (place "Knight2" (sites P2))}) (play (forEach Piece)) (end (if (= (sites Occupied by:Mover) (sites Next)) (result Mover Win))))) 
6x6 board. Two or four players. Three pieces per player, which begin in opposite corners of the board. Players alternate turns moving one piece to an empty adjacent space, orthogonally or diagonally. The first player to place their pieces in the squares in the opposite corner where the opponent's pieces started wins.  The board is a square 6x6 The game involves two players.
(game "Bajr" (players 2) (equipment {(board (square 6)) (piece "Counter" Each (move Step (to if:(is Empty (to))))) (regions "Home" P1 (expand (intersection (sites Bottom) (sites Left)) steps:1 Orthogonal)) (regions "Home" P2 (expand (intersection (sites Top) (sites Right)) steps:1 Orthogonal)) (map {(pair P1 P2) (pair P2 P1)})}) (rules (start {(place "Counter1" (sites P1)) (place "Counter2" (sites P2))}) (play (forEach Piece)) (end (if (= (sites Occupied by:Mover) (sites (player (mapEntry (mover))))) (result Mover Win))))) 
The game is played on a 10x10 board. Four of the squares are marked and are considered to contain a watering hole. Each player has two elephants, two lions and two mice. Pieces do not take other pieces. Their movement is as follows: mice move like rooks, lions move like bishops, and elephants move like queens. Like their chess counterparts, the pieces cannot jump over other pieces. A mouse is afraid of a lion of the opponent; a lion is afraid of an elephant of the opponent, and an elephant is afraid of a mouse of the opponent. An animal may not move to a square that is adjacent (horizontally, vertically or diagonally) to an animal it is afraid of. In addition, if an animal is adjacent to an animal that it is afraid of, then it must be moved by its owner, i.e., the owner may not move another animal. In the special case that more than one animal is adjacent to an animal it is afraid of, the owner may choose which animal to move. One wins the game by occupying three of the watering holes with own pieces.
(game "Barca" (players 2) (equipment {(board (square 10)) (piece "Mouse" Each (move Slide Orthogonal (to (apply if:(all Sites (sites Around (to)) if:(!= (what at:(site)) (id "Lion" Next))))))) (piece "Elephant" Each (move Slide All (to (apply if:(all Sites (sites Around (to)) if:(!= (what at:(site)) (id "Mouse" Next))))))) (piece "Lion" Each (move Slide Diagonal (to (apply if:(all Sites (sites Around (to)) if:(!= (what at:(site)) (id "Elephant" Next))))))) (regions "Water" (sites {"D4" "D7" "G4" "G7"}))}) (rules (start {(place "Elephant1" (sites {"E1" "F1"})) (place "Lion1" (sites {"D2" "G2"})) (place "Mouse1" (sites {"E2" "F2"})) (place "Elephant2" (sites {"E10" "F10"})) (place "Lion2" (sites {"D9" "G9"})) (place "Mouse2" (sites {"E9" "F9"}))}) (play (priority {(and {(forEach Piece "Mouse" (if (is In (from) (sites Around (sites Occupied by:Next component:"Lion"))) (move Slide Orthogonal (to (apply if:(all Sites (sites Around (to)) if:(!= (what at:(site)) (id "Lion" Next)))))))) (forEach Piece "Elephant" (if (is In (from) (sites Around (sites Occupied by:Next component:"Mouse"))) (move Slide All (to (apply if:(all Sites (sites Around (to)) if:(!= (what at:(site)) (id "Mouse" Next)))))))) (forEach Piece "Lion" (if (is In (from) (sites Around (sites Occupied by:Next component:"Elephant"))) (move Slide Diagonal (to (apply if:(all Sites (sites Around (to)) if:(!= (what at:(site)) (id "Elephant" Next))))))))}) (forEach Piece)})) (end (if (= 3 (count Sites in:(intersection (sites Occupied by:Mover) (sites "Water")))) (result Mover Win))))) 
The object of the game is to be the first player to occupy the opponent's castle with two of your own pieces, or, to capture all of your opponent's pieces while retaining two or more of your own pieces. Both knights and pawns can move either horizontally, vertically, or diagonally in three ways, as follows: One space in any direction (like a king in chess). This is called a plain move. A leaping move (called cantering) over an adjacent friendly piece to a vacant space immediately beyond. Multiple leaps over a player's own pieces are permitted. Cantering is always optional (never obligatory). A jumping move over an adjacent enemy piece to a vacant space immediately beyond. The enemy piece is captured and removed from the board. As in checkers, multiple jumps are allowed, and capturing is obligatory whenever it is possible. Pawns may make any of the three moves, but only one type of move per turn. Knights have a fourth option: a combination move consisting of a canter immediately followed by a jump (capture). This is called the knight's charge. The knight may, in this single move, perform multiple canters (or just one), followed by multiple jumps (or just one); but the canter(s) must precede the jump(s). A knight may not combine a plain move with a canter or a jump.
(game "Camelot" (players 2) (equipment {(board (keep (rectangle 12 16) (poly {{0 7} {1 10} {4 13} {12 13} {15 10} {16 7} {16 5} {15 2} {13 0} {3 0} {1 2} {0 5}}))) (piece "Pawn" Each (or (if (not (is In (from) (sites Next))) (move Hop (from (from)) (between if:(is Friend (who at:(between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to))))) (then (if (and (not (is In (last To) (sites Next))) (can Move (move Hop (from (last To)) (between if:(is Friend (who at:(between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to)))))))) (and (moveAgain) (set Pending)))))) (move Step (to if:(if (is In (from) (sites Next)) (and (is Empty (to)) (is In (to) (sites Next))) (is In (to) (difference (sites Empty) (sites Mover)))))))) (piece "Knight" Each (or (if (not (is In (from) (sites Next))) (move Hop (from (from)) (between if:(is Friend (who at:(between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to))))) (then (if (and (not (is In (last To) (sites Next))) (can Move (move Hop (from (last To)) (between if:(is Friend (who at:(between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to)))))))) (and (moveAgain) (set Pending)))))) (move Step (to if:(if (is In (from) (sites Next)) (and (is Empty (to)) (is In (to) (sites Next))) (is In (to) (difference (sites Empty) (sites Mover)))))))) (regions P1 (sites {"A6" "A7"})) (regions P2 (sites {"P6" "P7"}))}) (rules (start {(place "Pawn1" {"F4" "F5" "F6" "F7" "F8" "F9" "G5" "G6" "G7" "G8"}) (place "Knight1" {"F3" "G4" "G9" "F10"}) (place "Pawn2" {"K4" "K5" "K6" "K7" "K8" "K9" "J5" "J6" "J7" "J8"}) (place "Knight2" {"K3" "J4" "J9" "K10"})}) (play (if (is Prev Mover) (if (is Pending) (if (= (what at:(last To)) (id "Knight" Mover)) (priority {(move Hop (from (last To)) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to))))) (then (if (and (not (is In (last To) (sites Next))) (can Move (move Hop (from (last To)) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to)))))))) (moveAgain)))) (or (move Hop (from (last To)) (between if:(is Friend (who at:(between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to))))) (then (if (and (not (is In (last To) (sites Next))) (can Move (move Hop (from (last To)) (between if:(is Friend (who at:(between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to)))))))) (and (moveAgain) (set Pending))))) (move Pass))}) (or (move Hop (from (last To)) (between if:(is Friend (who at:(between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to))))) (then (if (and (not (is In (last To) (sites Next))) (can Move (move Hop (from (last To)) (between if:(is Friend (who at:(between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to)))))))) (and (moveAgain) (set Pending))))) (move Pass))) (move Hop (from (last To)) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to))))) (then (if (and (not (is In (last To) (sites Next))) (can Move (move Hop (from (last To)) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to)))))))) (moveAgain))))) (priority {(forEach Site (sites Mover) (if (= (who at:(site)) (mover)) (priority {(move Hop (from (site)) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to))))) (then (if (and (not (is In (last To) (sites Next))) (can Move (move Hop (from (last To)) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to)))))))) (moveAgain)))) (or (move Hop (from (site)) (between if:(is Friend (who at:(between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to))))) (then (if (and (not (is In (last To) (sites Next))) (can Move (move Hop (from (last To)) (between if:(is Friend (who at:(between)))) (to if:(and (is In (to) (difference (sites Empty) (sites Mover))) (not (is Visited (to)))))))) (and (moveAgain) (set Pending))))) (move Step (to if:(if (is In (from) (sites Next)) (and (is Empty (to)) (is In (to) (sites Next))) (is In (to) (difference (sites Empty) (sites Mover)))))))}))) (forEach Piece (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(if (is In (from) (sites Next)) (and (is Empty (to)) (is In (to) (sites Next))) (is In (to) (difference (sites Empty) (sites Mover))))) (then (if (and (not (is In (last To) (sites Next))) (can Move (hop (from (last To)) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))))) (moveAgain))))) (forEach Piece)}))) (end {(if (= (sites P2) (sites Occupied by:P1)) (result P1 Win)) (if (= (sites P1) (sites Occupied by:P2)) (result P2 Win)) (if (and (>= (count Pieces Mover) 2) (= (count Pieces Next) 0)) (result Mover Win)) (if (and (< (count Pieces Mover) 2) (< (count Pieces Next) 2)) (result Mover Draw))}))) 
DROP - Each stone is dropped on an empty cell, next to and below a stone of the same color MOVE - First player drops one stone at the first turn, then each player drops up to two stones (he may pass). GOAL - Wins the player with more stones on the bottom row.
(game "Cascades" (players 2) (equipment {(board (remove (hex Triangle 15) cells:{92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119} vertices:{223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285})) (piece "Ball" Each) (hand Each)}) (rules (start {(place "Ball1" (forEach (sites Top) if:(is Even (site)))) (place "Ball2" (forEach (sites Top) if:(is Odd (site))))}) phases:{(phase "FirstMove" (play (move Add (to (union (sites Around (sites Occupied by:Mover) SSW) (sites Around (sites Occupied by:Mover) SSE)) if:(is Empty (to))))) (nextPhase "Main")) (phase "Main" (play (or (move Add (to (union (sites Around (sites Occupied by:Mover) SSW) (sites Around (sites Occupied by:Mover) SSE)) if:(is Empty (to))) (then (if (not (is Prev Mover)) (moveAgain)))) (if (is Prev Mover) (move Pass)))))} (end (if (and (no Moves P1) (no Moves P2)) (byScore {(score P1 (count Sites in:(forEach (sites Bottom) if:(= (who at:(site)) P1)))) (score P2 (count Sites in:(forEach (sites Bottom) if:(= (who at:(site)) P2))))}))))) 
The game can be played by two, three, four, or six people. It is played on a board that is shaped like a six-pointed star with 121 holes for the pieces. Each point of the star has ten colored spheres and the goal of the game is to move all of one's pieces into the opposite point of the star. Players can move a piece to one adjacent hole, or can jump either their own or opponent's pieces. This does not result in capturing, and jumping is not mandatory. When fewer than six people play, players can play with only one color of pieces, but if two or three people play they can use more than one color, but each player must use an equal number of pieces. Six players occupy home regions (standard game). The game is played on a board of size 4.
(game "Chinese Checkers" (players 6) (equipment {(board (hex Star 4)) (piece "Marker" Each) (regions "Home" P1 (expand origin:(coord row:0 column:4) steps:(- 4 1))) (regions "Home" P2 (expand origin:(coord row:4 column:(* 4 3)) steps:(- 4 1))) (regions "Home" P3 (expand origin:(coord row:(* 4 3) column:(* 4 4)) steps:(- 4 1))) (regions "Home" P4 (expand origin:(coord row:(* 4 4) column:(* 4 3)) steps:(- 4 1))) (regions "Home" P5 (expand origin:(coord row:(* 4 3) column:4) steps:(- 4 1))) (regions "Home" P6 (expand origin:(coord row:4 column:0) steps:(- 4 1))) (map {(pair 1 4) (pair 2 5) (pair 3 6) (pair 4 1) (pair 5 2) (pair 6 3)})}) (rules (start {(place "Marker1" (sites P1)) (place "Marker2" (sites P2)) (place "Marker3" (sites P3)) (place "Marker4" (sites P4)) (place "Marker5" (sites P5)) (place "Marker6" (sites P6))}) phases:{(phase "Movement" (play (forEach Piece (or (move Hop (from (from)) (between if:(is Occupied (between))) (to if:(and (and (is Empty (to)) (not (is Visited (to)))) (or (not (is In (from) (sites (player (mapEntry (mover)))))) (is In (to) (sites (player (mapEntry (mover)))))))) (then (if (can Move (move Hop (from (last To)) (between if:(is Occupied (between))) (to if:(and (and (is Empty (to)) (not (is Visited (to)))) (or (not (is In (last To) (sites (player (mapEntry (mover)))))) (is In (to) (sites (player (mapEntry (mover)))))))))) (moveAgain)))) (move Step (to if:(and (is Empty (to)) (or (not (is In (from) (sites (player (mapEntry (mover)))))) (is In (to) (sites (player (mapEntry (mover)))))))))))) (nextPhase (is Mover (next)) "MultiJump")) (phase "MultiJump" (play (or (move Hop (from (last To)) (between if:(is Occupied (between))) (to if:(and (and (is Empty (to)) (not (is Visited (to)))) (or (not (is In (last To) (sites (player (mapEntry (mover)))))) (is In (to) (sites (player (mapEntry (mover)))))))) (then (if (can Move (move Hop (from (last To)) (between if:(is Occupied (between))) (to if:(and (and (is Empty (to)) (not (is Visited (to)))) (or (not (is In (last To) (sites (player (mapEntry (mover)))))) (is In (to) (sites (player (mapEntry (mover)))))))))) (moveAgain)))) (move Pass))) (nextPhase (not (is Mover (next))) "Movement"))} (end (if (= (sites Occupied by:Mover) (sites (player (mapEntry (mover))))) (result Mover Win))))) 
Play begins with an empty board. Black goes first. Players alternate turns. The game proceeds in two phases: Drop phase: Players place one cone per turn on any vacant cell on the special 9×5 centre area of the board. Players may not move a cone until all their cones have been placed. After the drop phase is completed, the conspirateurs scatter to hide in sanctuaries. A sanctuary may hold at most one man. The first to bring all his conspirateurs to sanctuary wins the game. Move phase: If a conspirateur starts the turn already on a sanctuary then it can’t move. Players move one man per turn to a vacant point one step in any direction orthogonally or diagonally, or players may leap over an adjacent man (friend or foe; and whether the jumpee is on a sanctuary or not) and land on the vacant point immediately beyond. Multiple leaps are allowed in a single turn: a man may continue to leap in any direction as long as there are jumps to be made, and may stop jumping at any point (leaps are not compulsory). A jumped man is not captured (there is no capturing in Conspirateurs). GAME END The game ends when a player brings all her conspirateurs to shelter holes (sanctuaries), thus winning the game
(game "Conspirateurs" (players 2) (equipment {(board (square 17)) (piece "Pawn" Each) (hand Each) (regions "Secret Meeting Place" (sites {106 107 108 109 110 111 112 113 114 123 124 125 126 127 128 129 130 131 140 141 142 143 144 145 146 147 148 157 158 159 160 161 162 163 164 165 174 175 176 177 178 179 180 181 182})) (regions "Sanctuaries" (sites {"A1" "B1" "D1" "F1" "H1" "J1" "L1" "N1" "P1" "Q1" "A2" "Q2" "A4" "Q4" "A6" "Q6" "A8" "Q8" "A9" "Q9" "A10" "Q10" "A12" "Q12" "A14" "Q14" "A16" "Q16" "A17" "B17" "D17" "F17" "H17" "I17" "J17" "L17" "L17" "N17" "P17" "Q17"}))}) (rules (start {(place "Pawn1" (handSite P1) count:21) (place "Pawn2" (handSite P2) count:21)}) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (forEach (sites "Secret Meeting Place") if:(is Empty (site)))))) (nextPhase (and (all Sites (sites Hand P1) if:(= 0 (count Cell at:(site)))) (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site))))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (or (move Hop (from (last To)) (between if:(is Occupied (between))) (to if:(and (is Empty (to)) (not (is Visited (to))))) (then (if (and (not (is In (last To) (sites "Sanctuaries"))) (can Move (move Hop (from (last To)) (between if:(is Occupied (between))) (to if:(and (is Empty (to)) (not (is Visited (to)))))))) (moveAgain)))) (move Pass)) (forEach Piece (if (not (is In (from) (sites "Sanctuaries"))) (or (move Hop (from (from)) (between if:(is Occupied (between))) (to if:(and (is Empty (to)) (not (is Visited (to))))) (then (if (and (not (is In (last To) (sites "Sanctuaries"))) (can Move (move Hop (from (last To)) (between if:(is Occupied (between))) (to if:(and (is Empty (to)) (not (is Visited (to)))))))) (moveAgain)))) (move Step (to if:(is Empty (to))))))))) (end (if (all Sites (sites Occupied by:Mover) if:(is In (site) (sites "Sanctuaries"))) (result Mover Win))))})) 
Initially, all pawns are placed on their starting positions in the outer sites of the circle. All pawns can move to an empty or enemy site adjacent to its position. Capture is mandatory. A pawn can never move to one of the starting positions of its owner. If a pawn is moving from a ring of the circle to another (except the outer ring), after moving, the player has to rotate the ring where moved the pawn. The game ends, when a player has no moves at its turn. The player with the most pieces on the starting positions of the opponent is winning.
(game "Gadis" (players 2) (equipment {(board (remove (concentric {0 0 12 12 12 24}) cells:{1})) (piece "Pawn" Each) (regions P1 {45 46 47 48 49 50 51 52 53 54 55 56}) (regions P2 {57 58 59 36 37 38 39 40 41 42 43 44}) (regions "FirstCircle" {24 25 26 27 28 29 30 31 32 33 34 35}) (regions "SecondCircle" {12 13 14 15 16 17 18 19 20 21 22 23}) (regions "ThirdCircle" {1 2 3 4 5 6 7 8 9 10 11})}) (rules (start {(place "Pawn1" (sites P1)) (place "Pawn2" (sites P2))}) (play (if (is Prev Mover) (if (is In (last To) (sites "FirstCircle")) (or (move Select (from 34) (to 33) (then (do (set Var (what at:34)) next:(and {(remove 34) (if (is Occupied 35) (move (from 35) (to 34))) (if (is Occupied 25) (move (from 25) (to 35))) (if (is Occupied 24) (move (from 24) (to 25))) (if (is Occupied 26) (move (from 26) (to 24))) (if (is Occupied 27) (move (from 27) (to 26))) (if (is Occupied 28) (move (from 28) (to 27))) (if (is Occupied 29) (move (from 29) (to 28))) (if (is Occupied 30) (move (from 30) (to 29))) (if (is Occupied 31) (move (from 31) (to 30))) (if (is Occupied 32) (move (from 32) (to 31))) (if (is Occupied 33) (move (from 33) (to 32))) (if (!= 0 (var)) (add (piece (var)) (to 33)))})))) (move Select (from 34) (to 35) (then (do (set Var (what at:34)) next:(and {(remove 34) (if (is Occupied 33) (move (from 33) (to 34))) (if (is Occupied 32) (move (from 32) (to 33))) (if (is Occupied 31) (move (from 31) (to 32))) (if (is Occupied 30) (move (from 30) (to 31))) (if (is Occupied 29) (move (from 29) (to 30))) (if (is Occupied 28) (move (from 28) (to 29))) (if (is Occupied 27) (move (from 27) (to 28))) (if (is Occupied 26) (move (from 26) (to 27))) (if (is Occupied 24) (move (from 24) (to 26))) (if (is Occupied 25) (move (from 25) (to 24))) (if (is Occupied 35) (move (from 35) (to 25))) (if (!= 0 (var)) (add (piece (var)) (to 35)))}))))) (if (is In (last To) (sites "SecondCircle")) (or (move Select (from 22) (to 21) (then (do (set Var (what at:22)) next:(and {(remove 22) (if (is Occupied 23) (move (from 23) (to 22))) (if (is Occupied 13) (move (from 13) (to 23))) (if (is Occupied 12) (move (from 12) (to 13))) (if (is Occupied 14) (move (from 14) (to 12))) (if (is Occupied 15) (move (from 15) (to 14))) (if (is Occupied 16) (move (from 16) (to 15))) (if (is Occupied 17) (move (from 17) (to 16))) (if (is Occupied 18) (move (from 18) (to 17))) (if (is Occupied 19) (move (from 19) (to 18))) (if (is Occupied 20) (move (from 20) (to 19))) (if (is Occupied 21) (move (from 21) (to 20))) (if (!= 0 (var)) (add (piece (var)) (to 21)))})))) (move Select (from 22) (to 23) (then (do (set Var (what at:22)) next:(and {(remove 22) (if (is Occupied 21) (move (from 21) (to 22))) (if (is Occupied 20) (move (from 20) (to 21))) (if (is Occupied 19) (move (from 19) (to 20))) (if (is Occupied 18) (move (from 18) (to 19))) (if (is Occupied 17) (move (from 17) (to 18))) (if (is Occupied 16) (move (from 16) (to 17))) (if (is Occupied 15) (move (from 15) (to 16))) (if (is Occupied 14) (move (from 14) (to 15))) (if (is Occupied 12) (move (from 12) (to 14))) (if (is Occupied 13) (move (from 13) (to 12))) (if (is Occupied 23) (move (from 23) (to 13))) (if (!= 0 (var)) (add (piece (var)) (to 23)))}))))) (if (is In (last To) (sites "ThirdCircle")) (or (move Select (from 10) (to 9) (then (do (set Var (what at:10)) next:(and {(remove 10) (if (is Occupied 11) (move (from 11) (to 10))) (if (is Occupied 1) (move (from 1) (to 11))) (if (is Occupied 0) (move (from 0) (to 1))) (if (is Occupied 2) (move (from 2) (to 0))) (if (is Occupied 3) (move (from 3) (to 2))) (if (is Occupied 4) (move (from 4) (to 3))) (if (is Occupied 5) (move (from 5) (to 4))) (if (is Occupied 6) (move (from 6) (to 5))) (if (is Occupied 7) (move (from 7) (to 6))) (if (is Occupied 8) (move (from 8) (to 7))) (if (is Occupied 9) (move (from 9) (to 8))) (if (!= 0 (var)) (add (piece (var)) (to 9)))})))) (move Select (from 10) (to 11) (then (do (set Var (what at:10)) next:(and {(remove 10) (if (is Occupied 9) (move (from 9) (to 10))) (if (is Occupied 8) (move (from 8) (to 9))) (if (is Occupied 7) (move (from 7) (to 8))) (if (is Occupied 6) (move (from 6) (to 7))) (if (is Occupied 5) (move (from 5) (to 6))) (if (is Occupied 4) (move (from 4) (to 5))) (if (is Occupied 3) (move (from 3) (to 4))) (if (is Occupied 2) (move (from 2) (to 3))) (if (is Occupied 0) (move (from 0) (to 2))) (if (is Occupied 1) (move (from 1) (to 0))) (if (is Occupied 11) (move (from 11) (to 1))) (if (!= 0 (var)) (add (piece (var)) (to 11)))})))))))) (priority {(forEach Piece (move Step (from if:(not (is In (from) (sites Next)))) Orthogonal (to if:(and (is Enemy (who at:(to))) (not (is In (to) (sites Outer)))) (apply (remove (to)))))) (forEach Piece (move Step (from if:(not (is In (from) (sites Next)))) Orthogonal (to if:(and (is Empty (to)) (not (is In (to) (sites Mover)))))))} (then (if (or {(and (is In (last From) (union (sites "SecondCircle") (sites Outer))) (is In (last To) (sites "FirstCircle"))) (and (is In (last From) (union (sites "FirstCircle") (sites "ThirdCircle"))) (is In (last To) (sites "SecondCircle"))) (and (is In (last From) (sites "SecondCircle")) (is In (last To) (sites "ThirdCircle")))}) (moveAgain)))))) (end {(if (no Moves Next) (byScore {(score P1 (count Sites in:(intersection (sites Occupied by:P1) (if (= (id P1) 1) (sites P2) (sites P1))))) (score P2 (count Sites in:(intersection (sites Occupied by:P2) (if (= (id P2) 1) (sites P2) (sites P1)))))}))}))) 
The rules are the same as for Halma. Pieces move one space orthogonally or diagonally. They may jump over a piece of any color. Multiple jumps in one turn are possible. Jumps do not capture. The player who first places all of their pieces in the opponent's starting position wins. The game is played on a board 8x8.
(game "Grasshopper" (players 2) (equipment {(board (square 8)) (piece "Counter" Each) (regions "Home" P1 (expand origin:(coord "A1") steps:3 Orthogonal)) (regions "Home" P2 (expand origin:(coord "H8") steps:3 Orthogonal)) (map {(pair P1 P2) (pair P2 P1)})}) (rules (start {(place "Counter1" (sites P1)) (place "Counter2" (sites P2))}) phases:{(phase "Movement" (play (forEach Piece (or (move Hop (from (from)) (between if:(is Occupied (between))) (to if:(and (and (is Empty (to)) (not (is Visited (to)))) (or (not (is In (from) (sites (player (mapEntry (mover)))))) (is In (to) (sites (player (mapEntry (mover)))))))) (then (if (can Move (move Hop (from (last To)) (between if:(is Occupied (between))) (to if:(and (and (is Empty (to)) (not (is Visited (to)))) (or (not (is In (last To) (sites (player (mapEntry (mover)))))) (is In (to) (sites (player (mapEntry (mover)))))))))) (moveAgain)))) (move Step (to if:(and (is Empty (to)) (or (not (is In (from) (sites Next))) (is In (to) (sites Next))))))))) (nextPhase (is Mover (next)) "MultiJump")) (phase "MultiJump" (play (or (move Hop (from (last To)) (between if:(is Occupied (between))) (to if:(and (and (is Empty (to)) (not (is Visited (to)))) (or (not (is In (last To) (sites (player (mapEntry (mover)))))) (is In (to) (sites (player (mapEntry (mover)))))))) (then (if (can Move (move Hop (from (last To)) (between if:(is Occupied (between))) (to if:(and (and (is Empty (to)) (not (is Visited (to)))) (or (not (is In (last To) (sites (player (mapEntry (mover)))))) (is In (to) (sites (player (mapEntry (mover)))))))))) (moveAgain)))) (move Pass))) (nextPhase (not (is Mover (next))) "Movement"))} (end (if (= (sites Occupied by:Mover) (sites (player (mapEntry (mover))))) (result Mover Win))))) 
Played on a 16x16 checkered board. Can be played with two or four players. It is played with nineteen pieces for a two-player game, thirteen for a four-player game. The pieces begin play in opposing corners of the board, called the "camp." Pieces can move in any direction to an adjacent square. Players can also jump any adjacent piece, including the player's own. Jumping does not capture. Multiple jumps in one turn by the same piece are allowed. The goal is to move all of one's pieces into the opposing player's camp. Once a piece has moved into the camp, it cannot leave. The version of the game played with 2 players. The game is played on a 16x16 board.
(game "Halma" (players 2) (equipment {(board (square 16)) (piece "Counter" Each) (regions "Home" P1 (difference (expand (intersection (sites Bottom) (sites Right)) steps:(+ 1 (/ 16 4)) Orthogonal) (sites {(ahead (coord row:0 column:(- 16 1)) steps:(+ 1 (/ 16 4)) N) (ahead (coord row:0 column:(- 16 1)) steps:(+ 1 (/ 16 4)) W)}))) (regions "Home" P2 (difference (expand (intersection (sites Top) (sites Left)) steps:(+ 1 (/ 16 4)) Orthogonal) (sites {(ahead (coord row:(- 16 1) column:0) steps:(+ 1 (/ 16 4)) E) (ahead (coord row:(- 16 1) column:0) steps:(+ 1 (/ 16 4)) S)}))) (map {(pair P1 P2) (pair P2 P1)})}) (rules (start {(place "Counter1" (sites P1)) (place "Counter2" (sites P2))}) phases:{(phase "Movement" (play (forEach Piece (or (move Hop (from (from)) (between if:(is Occupied (between))) (to if:(and (and (is Empty (to)) (not (is Visited (to)))) (or (not (is In (from) (sites (player (mapEntry (mover)))))) (is In (to) (sites (player (mapEntry (mover)))))))) (then (if (can Move (move Hop (from (last To)) (between if:(is Occupied (between))) (to if:(and (and (is Empty (to)) (not (is Visited (to)))) (or (not (is In (last To) (sites (player (mapEntry (mover)))))) (is In (to) (sites (player (mapEntry (mover)))))))))) (moveAgain)))) (move Step (to if:(and (is Empty (to)) (or (not (is In (from) (sites (player (mapEntry (mover)))))) (is In (to) (sites (player (mapEntry (mover)))))))))))) (nextPhase (is Mover (next)) "MultiJump")) (phase "MultiJump" (play (or (move Hop (from (last To)) (between if:(is Occupied (between))) (to if:(and (and (is Empty (to)) (not (is Visited (to)))) (or (not (is In (last To) (sites (player (mapEntry (mover)))))) (is In (to) (sites (player (mapEntry (mover)))))))) (then (if (can Move (move Hop (from (last To)) (between if:(is Occupied (between))) (to if:(and (and (is Empty (to)) (not (is Visited (to)))) (or (not (is In (last To) (sites (player (mapEntry (mover)))))) (is In (to) (sites (player (mapEntry (mover)))))))))) (moveAgain)))) (move Pass))) (nextPhase (not (is Mover (next))) "Movement"))} (end (if (= (sites Occupied by:Mover) (sites (player (mapEntry (mover))))) (result Mover Win))))) 
The game is played on a board with ten round pits arranged in a circle. Each player owns the semicircle closest to him. The game requires ten seeds and one standard six-faced die. At the start of the game, each pit contains one seed. During their turn, a player rolls a die. He then chooses one of his nonempty pits to sow. They take one seed from the sown pit, and move it counterclockwise according to the die value rolled. Then, they must roll to move each remaining seed from the sown pit. The turn only ends once the sown pit is empty. So, for example, if a player chooses to sow a pit with 4 seeds after his initial roll, 3 additional rolls will be needed. A player wins when all ten seeds are on their part of the board at the end of their turn.
(game "Lelac" (players 2) (equipment {(board (concentric {0 10}) (track "Track" {0 1 2 3 4 5 6 7 8 9} loop:True) use:Vertex) (piece "Square" Shared) (dice d:6 num:1) (regions P1 (expand (sites Bottom) steps:2)) (regions P2 (expand (sites Top) steps:2))}) (rules (start (set Count 1 to:(sites Board))) (play (do (roll) next:(move (from (if (is Prev Mover) (sites {(last From)}) (forEach (sites Mover) if:(is Occupied (site))))) (to (trackSite Move from:(from) steps:(count Pips))) (then (if (is Occupied (last From)) (moveAgain)))))) (end (forEach Player if:(all Sites (sites Player) if:(and (is Next Player) (is Empty (site)))) (result Player Loss))))) 
Played on a 4x4 grid. Each player has seven pieces, placed on the intersections of the lines, five on the back row and one on each outer intersection of the second line. Pieces are moved diagonally across the squares. The object is to place one's pieces in the opponent's starting position. The first player to do so wins.
(game "O-Pat-Kono" (players 2) (equipment {(board (rectangle 5 5) use:Vertex) (piece "Marker" Each (move Step Diagonal (to if:(is Empty (to))))) (regions "Home" P1 (union (sites Bottom) (sites {"A2" "E2"}))) (regions "Home" P2 (union (sites Top) (sites {"A4" "E4"})))}) (rules (start {(place "Marker1" (sites P1)) (place "Marker2" (sites P2))}) (play (forEach Piece)) (end (if (= (sites Occupied by:Mover) (sites Next)) (result Mover Win))))) 
Players alternate moving their pieces forward or backward diagonally. A piece may also jump over one adjacent piece of the opponent diagonally forward. This does not capture the opponent's piece. Jumps are compulsory. A player cannot block the other player's pieces such that he or she cannot perform a legal move. The player that can first bring each of their pieces seven rows forward is the winner. The pieces must retain their original order in each row.
(game "Salta" (players 2) (equipment {(board (square 10)) (piece "Salta1Dot" Each) (piece "Salta2Dot" Each) (piece "Salta3Dot" Each) (piece "Salta4Dot" Each) (piece "Salta5Dot" Each) (piece "Salta1Moon" Each) (piece "Salta2Moon" Each) (piece "Salta3Moon" Each) (piece "Salta4Moon" Each) (piece "Salta5Moon" Each) (piece "Salta1Star" Each) (piece "Salta2Star" Each) (piece "Salta3Star" Each) (piece "Salta4Star" Each) (piece "Salta5Star" Each)}) (rules (start {(place "Salta1Star1" coord:"A1") (place "Salta2Star1" coord:"C1") (place "Salta3Star1" coord:"E1") (place "Salta4Star1" coord:"G1") (place "Salta5Star1" coord:"I1") (place "Salta1Moon1" coord:"B2") (place "Salta2Moon1" coord:"D2") (place "Salta3Moon1" coord:"F2") (place "Salta4Moon1" coord:"H2") (place "Salta5Moon1" coord:"J2") (place "Salta1Dot1" coord:"A3") (place "Salta2Dot1" coord:"C3") (place "Salta3Dot1" coord:"E3") (place "Salta4Dot1" coord:"G3") (place "Salta5Dot1" coord:"I3") (place "Salta1Star2" coord:"J10") (place "Salta2Star2" coord:"H10") (place "Salta3Star2" coord:"F10") (place "Salta4Star2" coord:"D10") (place "Salta5Star2" coord:"B10") (place "Salta1Moon2" coord:"I9") (place "Salta2Moon2" coord:"G9") (place "Salta3Moon2" coord:"E9") (place "Salta4Moon2" coord:"C9") (place "Salta5Moon2" coord:"A9") (place "Salta1Dot2" coord:"J8") (place "Salta2Dot2" coord:"H8") (place "Salta3Dot2" coord:"F8") (place "Salta4Dot2" coord:"D8") (place "Salta5Dot2" coord:"B8")}) (play (if (is Prev Mover) (move Hop (from (last To)) Diagonal (between if:(is Enemy (who at:(between)))) (to if:(and (is Empty (to)) (not (is Visited (to))))) (then (if (can Move (move Hop (from (last To)) Diagonal (between if:(is Enemy (who at:(between)))) (to if:(and (is Empty (to)) (not (is Visited (to))))))) (moveAgain)))) (priority {(forEach Piece (move Hop (from (from)) Diagonal (between if:(is Enemy (who at:(between)))) (to if:(and (is Empty (to)) (not (is Visited (to))))) (then (if (can Move (move Hop (from (last To)) Diagonal (between if:(is Enemy (who at:(between)))) (to if:(and (is Empty (to)) (not (is Visited (to))))))) (moveAgain))))) (forEach Piece (move Step Diagonal (to if:(is Empty (to)))))}))) (end {(if (and {(= (what at:(coord "J10")) (id "Salta1Star" P1)) (= (what at:(coord "H10")) (id "Salta2Star" P1)) (= (what at:(coord "F10")) (id "Salta3Star" P1)) (= (what at:(coord "D10")) (id "Salta4Star" P1)) (= (what at:(coord "B10")) (id "Salta5Star" P1)) (= (what at:(coord "I9")) (id "Salta1Moon" P1)) (= (what at:(coord "G9")) (id "Salta2Moon" P1)) (= (what at:(coord "E9")) (id "Salta3Moon" P1)) (= (what at:(coord "C9")) (id "Salta4Moon" P1)) (= (what at:(coord "A9")) (id "Salta5Moon" P1)) (= (what at:(coord "J8")) (id "Salta1Dot" P1)) (= (what at:(coord "H8")) (id "Salta2Dot" P1)) (= (what at:(coord "F8")) (id "Salta3Dot" P1)) (= (what at:(coord "D8")) (id "Salta4Dot" P1)) (= (what at:(coord "B8")) (id "Salta5Dot" P1))}) (result P1 Win)) (if (and {(= (what at:(coord "A1")) (id "Salta1Star" P2)) (= (what at:(coord "C1")) (id "Salta2Star" P2)) (= (what at:(coord "E1")) (id "Salta3Star" P2)) (= (what at:(coord "G1")) (id "Salta4Star" P2)) (= (what at:(coord "I1")) (id "Salta5Star" P2)) (= (what at:(coord "B2")) (id "Salta1Moon" P2)) (= (what at:(coord "D2")) (id "Salta2Moon" P2)) (= (what at:(coord "F2")) (id "Salta3Moon" P2)) (= (what at:(coord "H2")) (id "Salta4Moon" P2)) (= (what at:(coord "J2")) (id "Salta5Moon" P2)) (= (what at:(coord "A3")) (id "Salta1Dot" P2)) (= (what at:(coord "C3")) (id "Salta2Dot" P2)) (= (what at:(coord "E3")) (id "Salta3Dot" P2)) (= (what at:(coord "G3")) (id "Salta4Dot" P2)) (= (what at:(coord "I3")) (id "Salta5Dot" P2))}) (result P2 Win))}))) 
5x5 intersecting lines. Two triangles on opposite sides of the square, with the apex intersecting with the midpoint of opposite sides. A line is drawn from the apex , bisecting the base, and another line bisecting this one and the opposite two sides of the triangle. Lines are drawn through the apex, extending the sides of the triangle to the midpoint of the adjacent side. Sixteen pieces per player, which begin on the points of the board closes to the player. Players alternate turns moving a piece to an empty adjacent spot orthogonally or diagonally, even when there are not lines connecting the adjacent points. A player's piece may hop over an opponent's piece to an empty space immediately on the opposite side of it to capture it. The player who occupies all of the points in the opponent's triangle wins. 
(game "Shanzak Kammar" (players 2) (equipment {(board (add (merge {(square 5 diagonals:Alternating) (shift 0 4 (rotate 180 (wedge 3))) (shift 0 -2 (wedge 3))}) edges:{{5 1} {1 7} {7 3} {3 9} {13 9} {7 13} {11 5} {15 11} {11 17} {7 11} {17 13} {13 19} {23 19} {23 17} {17 21} {15 21}}) use:Vertex) (piece "Marker" Each (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))))) (regions "Goal" P1 (expand (sites Top))) (regions "Goal" P2 (expand (sites Bottom)))}) (rules (start {(place "Marker1" (expand (sites Bottom) steps:3)) (place "Marker2" (expand (sites Top) steps:3))}) (play (forEach Piece)) (end (if (= 6 (count Pieces Mover in:(sites Mover "Goal"))) (result Mover Win))))) 
The game is for two players, each of who has 21 pieces — 5 large pieces [pawns] and 16 small pieces [discs], representing the Suffragettes and the Police. The Suffragettes are colored green, and the large pieces are distinguished as Leaders of the Suffragette Party. The Police Forceis colored dark blue, and the large pieces are distinguished as Inspectors of Police. The Suffragettes are placed on the squares marked ‘S’ near ‘Albert Hall.’ The leaders ofthe party are positioned as follows: One leader is placed in the middle of the front row, and the other four Leaders are placed at the ends of the front and second rows. The Police Force is placed upon the squares marked ‘P’ near the House of Commons. One Inspector is placed in the middle of the front row, and the remaining four Inspectors at the ends of the front and second rows. Each player alternatively moves or hops one of his or her own pieces. Moving can result in moving to one space into a single adjacent square, hopping over your own pieces to move farther along the board, or hopping over an opponent’s piece to 'arrest' or 'disable' your opponent’s piece. A piece may move horizontally or diagonally one square a turn into any of the 8 adjoining squares, but that square must be unoccupied. Pieces may freely move over any part of the board except: a.) No piece can be moved (except when arrested or disabled) onto the spaces marked Prison, Prison Yard [PY], Hospital, or Hospital Grounds [HG]. b.) A Suffragette cannot move onto the spaces marked Albert Hall [AH]. c.) A Policeman cannot move onto the spaces marked House of Commons [HC]. On a player’s turn, they may hop a piece rather than move it a single square. Hopping means jumping over one of your own pieces into the unoccupied squareon the other side of the hopped over piece (as in Checkers). A player may string together hops into multiple jumps, provided that each jump lands in a permitted zone (as listed above) and there is a space in between each piece hopped over. If the square behind a piece is occupied, the hop cannot be completed. Any piece having gained entrance into their opponent’s House of Commons or Albert Hall may move about freely on the squares representing the building, but must not move or hop away from those squares. Moving within either the House of Commons or Albert Hall spends a player’s turn. Properly hopping over your opponent’s pieces results in arresting or disabling your opponent’s piece(s). Police may arrest Suffragettes and Suffragettes may disable Police through jiu jitsu. Disable is a term used in jiu jitsu when an opponent is neutralized. Any piece standing on one of the squares in The Arena (squares marked pink) is liable to be arrested or disabled by their opponent. Any of your pieces may arrest or disable your opponent’spieces. A Suffragette disables the Police by hopping over him in a diagonal direction. A Leader of the Suffragette Partycan disable any member of the Police Force by hopping over him in any direction. A Policeman arrests a Suffragette by hopping over her in a diagonal direction. An Inspector of Police arrests any Suffragette member by hopping over her in any direction. A piece can only arrest or disable its opponents when it is hopping, not when simply moving. Thus, one of the smaller pieces may hop over a Leader or Inspector simply to move about the board. A single piece may arrest or disable multiple pieces during one series of jumps. Suffragettes who are arrested are moved to the Prison. Police who are disabled are moved to the Hospital. No piece can be arrested or disabled on yellow squares outside the Arena, but may move or hop freely on these squares. If at any point, the Prison andthe Hospital each contain 12 or more inmates, either player may propose a release. The other player accept or reject this. If accepted the proposer moves one of their disabled pieces to the Prison Yard [PY] or Hospital Grounds [HG] as appropriate. Then the other player does the same but the piece chosen must be of the same value as the one the proposer released. The proposer cannot release a major piece if the other player does not have any disabled major pieces. This is repeated until either the Prison Yard and Hospital Grounds are full or the proposer passes. No exchange can be proposed while any piece remains on the Prison Yard or the Hospital Grounds.
(game "Suffragetto" (players 2) (equipment {(board (square 17)) (regions "House of Commons" Shared (sites {"H14" "I14" "J14" "H13" "I13" "J13"})) (regions "Albert Hall" Shared (sites {"H4" "I4" "J4" "H5" "I5" "J5"})) (regions "The Arena" Shared (difference (expand (expand (sites {"E17"}) steps:8 E) steps:16 S) (union (sites "House of Commons") (sites "Albert Hall")))) (regions "The Free Zone" Shared (union {(expand (sites {"P5"}) steps:6 N) (expand (sites {"B13"}) steps:6 S) (expand (sites {"C17" "D17" "N17" "O17"}) steps:16 S)})) (regions "Hospital Grounds" Shared (expand (sites {"P17"}) steps:5 S)) (regions "Prison Yard" Shared (expand (sites {"B1"}) steps:5 N)) (regions "Prison" Shared (union (expand (sites {"A1"}) steps:16 N) (expand (sites {"B17"}) steps:3 S))) (regions "Hospital" Shared (union (expand (sites {"Q1"}) steps:16 N) (expand (sites {"P1"}) steps:3 N))) (piece "Suffragette" P1 (or {(move (from (from) if:(is In (from) (union {(sites "The Arena") (sites "The Free Zone") (sites "Prison Yard")}))) (to (intersection {(sites Around (from)) (sites Empty) (union {(sites "The Arena") (sites "The Free Zone") (sites "House of Commons")})}))) (move (from (from) if:(is In (from) (sites "House of Commons"))) (to (intersection {(sites Around (from)) (sites Empty) (sites "House of Commons")}))) (move Hop (from if:(is In (from) (union {(sites "The Arena") (sites "The Free Zone") (sites "Prison Yard")}))) (between if:(is Occupied (between)) (apply (if (if (= 0 (state at:(from))) (and (and (is Enemy (who at:(between))) (is In (between) (sites "The Arena"))) (is In (between) (sites Around (from) Diagonal))) (and (is Enemy (who at:(between))) (is In (between) (sites "The Arena")))) (fromTo (from (between)) (to (sites Random (intersection (sites Empty) (sites "Hospital")))))))) (to if:(and (is Empty (to)) (is In (to) (union {(sites "The Arena") (sites "The Free Zone") (sites "House of Commons")})))) (then (moveAgain))) (move Hop (from if:(is In (from) (sites "House of Commons"))) (between if:(is Occupied (between)) (apply (if (if (= 0 (state at:(from))) (and (and (is Enemy (who at:(between))) (is In (between) (sites "The Arena"))) (is In (between) (sites Around (from) Diagonal))) (and (is Enemy (who at:(between))) (is In (between) (sites "The Arena")))) (fromTo (from (between)) (to (sites Random (intersection (sites Empty) (sites "Hospital")))))))) (to if:(and (is Empty (to)) (is In (to) (sites "House of Commons")))))})) (piece "Policeman" P2 (or {(move (from (from) if:(is In (from) (union {(sites "The Arena") (sites "The Free Zone") (sites "Hospital Grounds")}))) (to (intersection {(sites Around (from)) (sites Empty) (union {(sites "The Arena") (sites "The Free Zone") (sites "Albert Hall")})}))) (move (from (from) if:(is In (from) (sites "Albert Hall"))) (to (intersection {(sites Around (from)) (sites Empty) (sites "Albert Hall")}))) (move Hop (from if:(is In (from) (union {(sites "The Arena") (sites "The Free Zone") (sites "Hospital Grounds")}))) (between if:(is Occupied (between)) (apply (if (if (= 0 (state at:(from))) (and (and (is Enemy (who at:(between))) (is In (between) (sites "The Arena"))) (is In (between) (sites Around (from) Diagonal))) (and (is Enemy (who at:(between))) (is In (between) (sites "The Arena")))) (fromTo (from (between)) (to (sites Random (intersection (sites Empty) (sites "Prison")))))))) (to if:(and (is Empty (to)) (is In (to) (union {(sites "The Arena") (sites "The Free Zone") (sites "Albert Hall")})))) (then (moveAgain))) (move Hop (from if:(is In (from) (sites "Albert Hall"))) (between if:(is Occupied (between)) (apply (if (if (= 0 (state at:(from))) (and (and (is Enemy (who at:(between))) (is In (between) (sites "The Arena"))) (is In (between) (sites Around (from) Diagonal))) (and (is Enemy (who at:(between))) (is In (between) (sites "The Arena")))) (fromTo (from (between)) (to (sites Random (intersection (sites Empty) (sites "Prison")))))))) (to if:(and (is Empty (to)) (is In (to) (sites "Albert Hall")))))})) (piece "Leader" P1 (or {(move (from (from) if:(is In (from) (union {(sites "The Arena") (sites "The Free Zone") (sites "Prison Yard")}))) (to (intersection {(sites Around (from)) (sites Empty) (union {(sites "The Arena") (sites "The Free Zone") (sites "House of Commons")})}))) (move (from (from) if:(is In (from) (sites "House of Commons"))) (to (intersection {(sites Around (from)) (sites Empty) (sites "House of Commons")}))) (move Hop (from if:(is In (from) (union {(sites "The Arena") (sites "The Free Zone") (sites "Prison Yard")}))) (between if:(is Occupied (between)) (apply (if (if (= 0 (state at:(from))) (and (and (is Enemy (who at:(between))) (is In (between) (sites "The Arena"))) (is In (between) (sites Around (from) Diagonal))) (and (is Enemy (who at:(between))) (is In (between) (sites "The Arena")))) (fromTo (from (between)) (to (sites Random (intersection (sites Empty) (sites "Hospital")))))))) (to if:(and (is Empty (to)) (is In (to) (union {(sites "The Arena") (sites "The Free Zone") (sites "House of Commons")})))) (then (moveAgain))) (move Hop (from if:(is In (from) (sites "House of Commons"))) (between if:(is Occupied (between)) (apply (if (if (= 0 (state at:(from))) (and (and (is Enemy (who at:(between))) (is In (between) (sites "The Arena"))) (is In (between) (sites Around (from) Diagonal))) (and (is Enemy (who at:(between))) (is In (between) (sites "The Arena")))) (fromTo (from (between)) (to (sites Random (intersection (sites Empty) (sites "Hospital")))))))) (to if:(and (is Empty (to)) (is In (to) (sites "House of Commons")))))})) (piece "Inspector" P2 (or {(move (from (from) if:(is In (from) (union {(sites "The Arena") (sites "The Free Zone") (sites "Hospital Grounds")}))) (to (intersection {(sites Around (from)) (sites Empty) (union {(sites "The Arena") (sites "The Free Zone") (sites "Albert Hall")})}))) (move (from (from) if:(is In (from) (sites "Albert Hall"))) (to (intersection {(sites Around (from)) (sites Empty) (sites "Albert Hall")}))) (move Hop (from if:(is In (from) (union {(sites "The Arena") (sites "The Free Zone") (sites "Hospital Grounds")}))) (between if:(is Occupied (between)) (apply (if (if (= 0 (state at:(from))) (and (and (is Enemy (who at:(between))) (is In (between) (sites "The Arena"))) (is In (between) (sites Around (from) Diagonal))) (and (is Enemy (who at:(between))) (is In (between) (sites "The Arena")))) (fromTo (from (between)) (to (sites Random (intersection (sites Empty) (sites "Prison")))))))) (to if:(and (is Empty (to)) (is In (to) (union {(sites "The Arena") (sites "The Free Zone") (sites "Albert Hall")})))) (then (moveAgain))) (move Hop (from if:(is In (from) (sites "Albert Hall"))) (between if:(is Occupied (between)) (apply (if (if (= 0 (state at:(from))) (and (and (is Enemy (who at:(between))) (is In (between) (sites "The Arena"))) (is In (between) (sites Around (from) Diagonal))) (and (is Enemy (who at:(between))) (is In (between) (sites "The Arena")))) (fromTo (from (between)) (to (sites Random (intersection (sites Empty) (sites "Prison")))))))) (to if:(and (is Empty (to)) (is In (to) (sites "Albert Hall")))))}))}) (rules (start {(place "Suffragette1" {57 61 73 74 78 79 88 89 90 91 92 94 95 96 97 98} state:0) (place "Policeman2" {227 231 209 210 214 215 196 197 198 199 200 194 193 192 191 190} state:0) (place "Leader1" {87 93 99 72 80} state:1) (place "Inspector2" {189 195 201 208 216} state:1)}) (play (priority {(if (< 0 (var "ReleaseCountdown")) (if (is Odd (var "ReleaseCountdown")) (move (from (if (= (id P1) (id Mover)) (if (and (<= 1 (count Sites in:(forEach (intersection (sites "Prison") (sites Occupied by:All)) if:(= (var "LastState") (state at:(site)))))) (<= 1 (count Sites in:(forEach (intersection (sites "Hospital") (sites Occupied by:All)) if:(= (var "LastState") (state at:(site))))))) (forEach (intersection (sites "Prison") (sites Occupied by:All)) if:(= (var "LastState") (state at:(site))))) (if (and (<= 1 (count Sites in:(forEach (intersection (sites "Prison") (sites Occupied by:All)) if:(= (var "LastState") (state at:(site)))))) (<= 1 (count Sites in:(forEach (intersection (sites "Hospital") (sites Occupied by:All)) if:(= (var "LastState") (state at:(site))))))) (forEach (intersection (sites "Hospital") (sites Occupied by:All)) if:(= (var "LastState") (state at:(site))))))) (to (intersection (sites Empty) (if (= (id P1) (id Mover)) (sites "Prison Yard") (sites "Hospital Grounds")))) (then (and (set Var "LastState" -2) (set Var "ReleaseCountdown" (- (var "ReleaseCountdown") 1))))) (or (move (from (if (= (id P1) (id Mover)) (if (and (<= 1 (count Sites in:(forEach (intersection (sites "Prison") (sites Occupied by:All)) if:(= 0 (state at:(site)))))) (<= 1 (count Sites in:(forEach (intersection (sites "Hospital") (sites Occupied by:All)) if:(= 0 (state at:(site))))))) (if (and (<= 1 (count Sites in:(forEach (intersection (sites "Prison") (sites Occupied by:All)) if:(= 1 (state at:(site)))))) (<= 1 (count Sites in:(forEach (intersection (sites "Hospital") (sites Occupied by:All)) if:(= 1 (state at:(site))))))) (intersection (sites "Prison") (sites Occupied by:All)) (forEach (intersection (sites "Prison") (sites Occupied by:All)) if:(= 0 (state at:(site))))) (if (and (<= 1 (count Sites in:(forEach (intersection (sites "Prison") (sites Occupied by:All)) if:(= 1 (state at:(site)))))) (<= 1 (count Sites in:(forEach (intersection (sites "Hospital") (sites Occupied by:All)) if:(= 1 (state at:(site))))))) (forEach (intersection (sites "Prison") (sites Occupied by:All)) if:(= 1 (state at:(site)))))) (if (and (<= 1 (count Sites in:(forEach (intersection (sites "Prison") (sites Occupied by:All)) if:(= 0 (state at:(site)))))) (<= 1 (count Sites in:(forEach (intersection (sites "Hospital") (sites Occupied by:All)) if:(= 0 (state at:(site))))))) (if (and (<= 1 (count Sites in:(forEach (intersection (sites "Prison") (sites Occupied by:All)) if:(= 1 (state at:(site)))))) (<= 1 (count Sites in:(forEach (intersection (sites "Hospital") (sites Occupied by:All)) if:(= 1 (state at:(site))))))) (intersection (sites "Hospital") (sites Occupied by:All)) (forEach (intersection (sites "Hospital") (sites Occupied by:All)) if:(= 0 (state at:(site))))) (if (and (<= 1 (count Sites in:(forEach (intersection (sites "Prison") (sites Occupied by:All)) if:(= 1 (state at:(site)))))) (<= 1 (count Sites in:(forEach (intersection (sites "Hospital") (sites Occupied by:All)) if:(= 1 (state at:(site))))))) (forEach (intersection (sites "Hospital") (sites Occupied by:All)) if:(= 1 (state at:(site)))))))) (to (intersection (sites Empty) (if (= (id P1) (id Mover)) (sites "Prison Yard") (sites "Hospital Grounds")))) (then (and (set Var "LastState" (state at:(last To))) (set Var "ReleaseCountdown" (- (var "ReleaseCountdown") 1))))) (move Pass (then (and (set Var "LastState" -2) (set Var "ReleaseCountdown" 0))))))) (if (is Decided "Release") (move (from (if (= (id P1) (id Mover)) (if (and (<= 1 (count Sites in:(forEach (intersection (sites "Prison") (sites Occupied by:All)) if:(= 0 (state at:(site)))))) (<= 1 (count Sites in:(forEach (intersection (sites "Hospital") (sites Occupied by:All)) if:(= 0 (state at:(site))))))) (if (and (<= 1 (count Sites in:(forEach (intersection (sites "Prison") (sites Occupied by:All)) if:(= 1 (state at:(site)))))) (<= 1 (count Sites in:(forEach (intersection (sites "Hospital") (sites Occupied by:All)) if:(= 1 (state at:(site))))))) (intersection (sites "Prison") (sites Occupied by:All)) (forEach (intersection (sites "Prison") (sites Occupied by:All)) if:(= 0 (state at:(site))))) (if (and (<= 1 (count Sites in:(forEach (intersection (sites "Prison") (sites Occupied by:All)) if:(= 1 (state at:(site)))))) (<= 1 (count Sites in:(forEach (intersection (sites "Hospital") (sites Occupied by:All)) if:(= 1 (state at:(site))))))) (forEach (intersection (sites "Prison") (sites Occupied by:All)) if:(= 1 (state at:(site)))))) (if (and (<= 1 (count Sites in:(forEach (intersection (sites "Prison") (sites Occupied by:All)) if:(= 0 (state at:(site)))))) (<= 1 (count Sites in:(forEach (intersection (sites "Hospital") (sites Occupied by:All)) if:(= 0 (state at:(site))))))) (if (and (<= 1 (count Sites in:(forEach (intersection (sites "Prison") (sites Occupied by:All)) if:(= 1 (state at:(site)))))) (<= 1 (count Sites in:(forEach (intersection (sites "Hospital") (sites Occupied by:All)) if:(= 1 (state at:(site))))))) (intersection (sites "Hospital") (sites Occupied by:All)) (forEach (intersection (sites "Hospital") (sites Occupied by:All)) if:(= 0 (state at:(site))))) (if (and (<= 1 (count Sites in:(forEach (intersection (sites "Prison") (sites Occupied by:All)) if:(= 1 (state at:(site)))))) (<= 1 (count Sites in:(forEach (intersection (sites "Hospital") (sites Occupied by:All)) if:(= 1 (state at:(site))))))) (forEach (intersection (sites "Hospital") (sites Occupied by:All)) if:(= 1 (state at:(site)))))))) (to (intersection (sites Empty) (if (= (id P1) (id Mover)) (sites "Prison Yard") (sites "Hospital Grounds")))) (then (and (set Var "LastState" (state at:(last To))) (set Var "ReleaseCountdown" 11))))) (if (is Proposed "Release") (or (move Vote "Release") (move Vote "No"))) (if (is Prev Mover) (or (if (= (id P1) (id Mover)) (move Hop (from (last To) if:(is In (from) (union {(sites "The Arena") (sites "The Free Zone") (sites "Prison Yard")}))) (between if:(is Occupied (between)) (apply (if (if (= 0 (state at:(from))) (and (and (is Enemy (who at:(between))) (is In (between) (sites "The Arena"))) (is In (between) (sites Around (from) Diagonal))) (and (is Enemy (who at:(between))) (is In (between) (sites "The Arena")))) (fromTo (from (between)) (to (sites Random (intersection (sites Empty) (sites "Hospital")))))))) (to if:(and (is Empty (to)) (is In (to) (union {(sites "The Arena") (sites "The Free Zone") (sites "House of Commons")})))) (then (moveAgain))) (move Hop (from (last To) if:(is In (from) (union {(sites "The Arena") (sites "The Free Zone") (sites "Hospital Grounds")}))) (between if:(is Occupied (between)) (apply (if (if (= 0 (state at:(from))) (and (and (is Enemy (who at:(between))) (is In (between) (sites "The Arena"))) (is In (between) (sites Around (from) Diagonal))) (and (is Enemy (who at:(between))) (is In (between) (sites "The Arena")))) (fromTo (from (between)) (to (sites Random (intersection (sites Empty) (sites "Prison")))))))) (to if:(and (is Empty (to)) (is In (to) (union {(sites "The Arena") (sites "The Free Zone") (sites "Albert Hall")})))) (then (moveAgain)))) (move Pass)) (or (if (and {(= 0 (count Sites in:(intersection (sites "Prison Yard") (sites Occupied by:All)))) (= 0 (count Sites in:(intersection (sites "Hospital Grounds") (sites Occupied by:All)))) (<= 12 (count Sites in:(intersection (sites "Prison") (sites Occupied by:All)))) (<= 12 (count Sites in:(intersection (sites "Hospital") (sites Occupied by:All))))}) (move Propose "Release" (then (do (note "Release prisoners?" to:Next) next:(vote "Release"))))) (forEach Piece)))})) (end {(if (= 6 (count Pieces P1 in:(sites "House of Commons"))) (result P1 Win)) (if (= 6 (count Pieces P2 in:(sites "Albert Hall"))) (result P2 Win))}))) 
4x12 board. Twelve pieces per player. Pieces begin in the outer rows of the board. Four sticks serve as dice, painted on one side and blank on the other. The throws are as follows: one blank side up = 2; two blank sides up = 0; three blank sides up = 0; four blank sides up = 8; four painted sides up = 12. Throws of 2, 8, and 12 give the player another throw. Players must use each throw to move a piece. They may only subdivide a throw in half to move two pieces, otherwise they must use one full throw to move a piece. The first move for each piece must be a throw of 2. This can be divided into two throws of 1 to move two pieces. Play moves from left to right in the player's home row, from right to left in the second row, left to right in the third row, and right to left in the opponent's home row. When a piece enters the opponent's home row, it can no longer move. When a player's piece lands on a space occupied by an opponent's piece, the opponent's piece is captured. A player may not land on the same space as another of the player's pieces. The player which fills up the most of the opponent's home row wins.
(game "Tablan" (players 2) (equipment {(board (rectangle 4 12) {(track "Track1" "0,E,N1,W,N1,E,N1,W" P1 directed:True) (track "Track2" "47,W,S1,E,S1,W,S1,E" P2 directed:True)} use:Vertex) (piece "Stick" Each (if (and (not (is In (from) (sites Next "Home"))) (!= 0 (mapEntry "Throw" (count Pips)))) (or (if (not (= 1 (var))) (move (from (from) if:(if (= (state at:(from)) 1) True (= 2 (mapEntry "Throw" (count Pips))))) (to (trackSite Move steps:(mapEntry "Throw" (count Pips))) if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (if (not (= (state at:(last To)) 1)) (set State at:(last To) 1))))) (move (from (from) if:(if (= (state at:(from)) 1) True (= 2 (mapEntry "Throw" (count Pips))))) (to (trackSite Move steps:(/ (mapEntry "Throw" (count Pips)) 2)) if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (and (if (not (= (state at:(last To)) 1)) (set State at:(last To) 1)) (if (not (= 1 (var))) (and (set Var 1) (moveAgain)) (set Var 0)))))))) (regions "Home" P1 (sites Bottom)) (regions "Home" P2 (sites Top)) (map "Throw" {(pair 0 8) (pair 1 0) (pair 2 0) (pair 3 2) (pair 4 12)}) (dice d:2 from:0 num:4)}) (rules (start {(place "Stick1" (sites Bottom)) (place "Stick2" (sites Top))}) (play (do (if (not (= 1 (var))) (roll)) next:(if (can Move (forEach Piece)) (forEach Piece) (move Pass (then (set Var 0)))) (then (if (is In (mapEntry "Throw" (count Pips)) (sites {2 8 12})) (moveAgain))))) (end (if (and (= 0 (count Sites in:(forEach (sites Occupied by:P1) if:(not (is In (site) (sites P2 "Home")))))) (= 0 (count Sites in:(forEach (sites Occupied by:P2) if:(not (is In (site) (sites P1 "Home"))))))) (byScore {(score P1 (count Sites in:(forEach (sites P2 "Home") if:(= (who at:(site)) P1)))) (score P2 (count Sites in:(forEach (sites P1 "Home") if:(= (who at:(site)) P2))))}))))) 
On each turn, each player must move two friendly stones to adjacent (diagonal or orthogonal) empty cells, both in the same direction. Stones cannot move into the restricted points on the game board. The player that first moves 5 stones to the last row wins the game.
(game "Tandems" (players 2) (equipment {(board (square 5)) (piece "Pawn" Each (move Step (to if:(and {(is Empty (to)) (not (is In (to) (sites "RedDots"))) (can Move (do (set Var (to)) next:(forEach Site (difference (sites Occupied by:Mover) (from)) (step (from (site)) (directions Cell from:(from) to:(var)) (to if:(and (is Empty (to)) (not (is In (to) (sites "RedDots")))))))))})) (then (moveAgain)))) (regions "RedDots" (sites {"B2" "B4" "D2" "D4"}))}) (rules (start {(place "Pawn1" (sites Bottom)) (place "Pawn2" (sites Top))}) (play (if (is Prev Mover) (forEach Site (difference (sites Occupied by:Mover) (last To)) (move Step (from (site)) (directions Cell from:(last From) to:(last To)) (to if:(and (is Empty (to)) (not (is In (to) (sites "RedDots"))))))) (forEach Piece))) (end {(if (and (is Mover P1) (all Sites (sites Occupied by:P1) if:(is In (site) (sites Top)))) (result P1 Win)) (if (and (is Mover P2) (all Sites (sites Occupied by:P2) if:(is In (site) (sites Bottom)))) (result P2 Win))}))) 
Seven concentric circles. Three points outside the circles. The center contains a circle, the market. There are three balls, placed near the board. Each player plays with one piece, which begins in the outermost point. The first player holds something in their hand, and asks the second player to guess which hand it is in. If the guessing player guesses correctly, they move their piece to the next point, or to the next ring of the spiral toward the market. If the guessing player guesses incorrectly, the player holding the object moves one space forward. The guessing player now takes the object, and asks the next player to guess which hand the object is in, and so on. When a player reaches the market, they take one of the three balls next to the board. The player who fails to collect a ball loses.
(game "Aime" (players 4) (equipment {(board (merge {(concentric {4 4 4 4 4 4 4 4}) (shift -7 7 (square 1)) (shift -6 7 (square 1)) (shift -7 6 (square 1))}) {(track "Track1" {28 24 20 16 12 8 4 0} P1 directed:True) (track "Track2" {29 25 21 17 13 9 5 1} P2 directed:True) (track "Track3" {30 26 22 18 14 10 6 2} P3 directed:True) (track "Track4" {31 27 23 19 15 11 7 3} P4 directed:True)} use:Vertex) (piece "Marker" Each) (piece "Stick" Shared) (piece "Ball" Each) (piece "Ball" Shared) (hand Each size:2)}) (rules (start {(place "Marker1" 28) (place "Marker2" 29) (place "Marker3" 30) (place "Marker4" 31) (place "Ball" (sites {32 33 34}))}) phases:{(phase "Hiding" (play (move Add (piece (id "Stick" Shared)) (to Cell (sites Hand Mover)) (then (set Hidden Cell at:(last To) to:Next)))) (nextPhase "Guessing")) (phase "Guessing" (play (move Select (from Cell (sites Hand Prev)) (then (and (if (is Empty (last To)) (and (fromTo (from (where "Marker" Prev)) (to (if (is Prev P1) (trackSite Move from:(where "Marker" Prev) "Track1" steps:1) (if (is Prev P2) (trackSite Move from:(where "Marker" Prev) "Track2" steps:1) (if (is Prev P3) (trackSite Move from:(where "Marker" Prev) "Track3" steps:1) (trackSite Move from:(where "Marker" Prev) "Track4" steps:1)))))) (if (not (is In (if (is Prev P1) (trackSite Move from:(where "Marker" Prev) "Track1" steps:1) (if (is Prev P2) (trackSite Move from:(where "Marker" Prev) "Track2" steps:1) (if (is Prev P3) (trackSite Move from:(where "Marker" Prev) "Track3" steps:1) (trackSite Move from:(where "Marker" Prev) "Track4" steps:1)))) (sites {0 1 2 3}))) (set NextPlayer (player (prev))) (if (= (what at:32) (id "Ball" Shared)) (and (remove 32) (add (piece (id "Ball" Prev)) (to 32))) (if (= (what at:33) (id "Ball" Shared)) (and (remove 33) (add (piece (id "Ball" Prev)) (to 33))) (and (remove 34) (add (piece (id "Ball" Prev)) (to 34))))))) (and {(moveAgain) (fromTo (from (where "Marker" Mover)) (to (trackSite Move from:(where "Marker" Mover) steps:1))) (if (is In (trackSite Move from:(where "Marker" Mover) steps:1) (sites {0 1 2 3})) (if (= (what at:32) (id "Ball" Shared)) (and (remove 32) (add (piece (id "Ball" Mover)) (to 32))) (if (= (what at:33) (id "Ball" Shared)) (and (remove 33) (add (piece (id "Ball" Mover)) (to 33))) (and (remove 34) (add (piece (id "Ball" Mover)) (to 34))))))})) (remove Cell (sites Hand Prev)))))) (nextPhase "Hiding"))} (end (if (!= (- (count Players) (count Active)) (count Sites in:(difference (sites {0 1 2 3}) (sites Empty)))) {(if (and (is Active P1) (is In (where "Marker" P1) (sites {0 1 2 3}))) (result P1 Win)) (if (and (is Active P2) (is In (where "Marker" P2) (sites {0 1 2 3}))) (result P2 Win)) (if (and (is Active P3) (is In (where "Marker" P3) (sites {0 1 2 3}))) (result P3 Win)) (if (and (is Active P4) (is In (where "Marker" P4) (sites {0 1 2 3}))) (result P4 Win))})))) 
MOVING Each player moves one ship each turn. A ship moves any number of empty squares in a straight line, either vertically, horizontally, or diagonally (that is, like a chess queen). However, a ship may never end its turn in its home port. DESTROYING SHIPS Two opposing ships "attack" each other if they face each other along a straight line with no other ships between them (so that each could move to the other's square). A ship that is under attack from three or more enemy ships is "vulnerable." At the end of your move, you must destroy all vulnerable enemy ships by removing them from the board. In the example below, the white ship on b3 is under attack from black ships on a2, b1, and d3, and can be destroyed. You can only destroy enemy ships after your move. Sometimes, if an enemy ship is vulnerable at the beginning of your turn, your move in that turn will make it no longer vulnerable. When this happens, you cannot destroy the ship. If the destruction of one ship makes another ship vulnerable that wasn't vulnerable before, both ships must be destroyed. In the example below, destroying the white ship on f8 makes the ship on g8 vulnerable. Both are destroyed. REBUILDING SHIPS At the beginning of your turn, you may rebuild one of your destroyed ships. The ship is placed in your home port, and since ships may not end a turn in their own port, you must use your turn to move the ship out of port. Therefore, you cannot rebuild a ship until you have a vacant square to move the ship to. WINNING You win the game by moving one of your ships into the enemy port, provided that your opponent cannot destroy it on his or her next turn. (If your opponent can destroy it, the game continues.)
(game "Archimedes" (players 2) (equipment {(board (square 8)) (piece "Ball" Each (move Slide (between if:(and (is Empty (between)) (!= (between) (mapEntry "Port" Mover)))))) (map "Port" {(pair P1 "H8") (pair P2 "A1")}) (hand Each)}) (rules (start {(place "Ball1" (difference (expand origin:(mapEntry "Port" P1) steps:4 Orthogonal) (sites {"D8" "H4" "H8"}))) (place "Ball2" (difference (expand origin:(mapEntry "Port" P2) steps:4 Orthogonal) (sites {"A5" "A1" "E1"})))}) (play (if (is Prev Mover) (move Slide (from (mapEntry "Port" Mover))) (or (forEach Piece (then (forEach Site (sites Occupied by:Next) (if (<= 3 (count Sites in:(forEach (sites LineOfSight at:(site)) if:(= (who at:(site)) Mover)))) (fromTo (from (site)) (to (handSite Next))))))) (if (and {(is Occupied (handSite Mover)) (is Empty (mapEntry "Port" Mover)) (not (all Sites (difference (expand origin:(mapEntry "Port" P1)) (mapEntry "Port" Mover)) if:(is Occupied (site))))}) (move (from (handSite Mover)) (to (mapEntry "Port" Mover)) (then (moveAgain))))))) (end (if (and (is Friend (who at:(if (is Mover P1) (mapEntry "Port" P2) (mapEntry "Port" P1)))) (> 3 (count Sites in:(forEach (sites LineOfSight at:(if (is Mover P1) (mapEntry "Port" P2) (mapEntry "Port" P1))) if:(if (is Mover P1) (= (who at:(site)) P1) (= (who at:(site)) P2)))))) (result Mover Win))))) 
Played on an 8x8 board with "trap" squares at C6, F6, C3 and F3. Each player has 16 pieces, in order from strongest to weakest: Elephant (1) Camel (1) Horse (2) Dog (2) Cat(2) Rabbit (8) Each player places their pieces in any configuration on their side of the board. Pieces can move one space orthogonally, except rabbits cannot move backward. The goal is for one of a player's rabbits to reach the opposing player's edge of the board. Players can capture an opponent's pieces by pulling or pushing them into one of the trap squares as long as there is no piece friendly to the piece being pulled or pushed adjacent to the trap square. Pieces can only push and pull adjacent opponent's pieces of a lower rank than the piece making the move. Pushing and pulling cannot happen simultaneously. Pieces can be frozen, or prevented from moving, when they are adjacent to an opposing stronger piece.
(game "Arimaa" (players {(player N) (player S)}) (equipment {(board (square 8)) (hand Each size:6) (piece "Rabbit" Each (move Step (directions {Forward Rightward Leftward}) (to if:(and (or (= (count Sites in:(sites Around (from) Orthogonal if:(and (is Enemy (who at:(to))) (> (value Piece at:(to)) (value Piece at:(from)))))) 0) (and (not (= (count Sites in:(sites Around (from) Orthogonal if:(and (is Enemy (who at:(to))) (> (value Piece at:(to)) (value Piece at:(from)))))) 0)) (not (= (count Sites in:(sites Around (from) Orthogonal if:(= (who at:(to)) Mover))) 0)))) (or (is Empty (to)) (and {(< (count MovesThisTurn) 3) (not (= (count Sites in:(sites Around (to) Orthogonal if:(is Empty (to)))) 0)) (is Enemy (who at:(to))) (< (value Piece at:(to)) (value Piece at:(from)))}))) (apply (fromTo (from (to)) (to (handSite Mover))))))) (piece "Cat" Each (move Step Orthogonal (to if:(and (or (= (count Sites in:(sites Around (from) Orthogonal if:(and (is Enemy (who at:(to))) (> (value Piece at:(to)) (value Piece at:(from)))))) 0) (and (not (= (count Sites in:(sites Around (from) Orthogonal if:(and (is Enemy (who at:(to))) (> (value Piece at:(to)) (value Piece at:(from)))))) 0)) (not (= (count Sites in:(sites Around (from) Orthogonal if:(= (who at:(to)) Mover))) 0)))) (or (is Empty (to)) (and {(< (count MovesThisTurn) 3) (not (= (count Sites in:(sites Around (to) Orthogonal if:(is Empty (to)))) 0)) (is Enemy (who at:(to))) (< (value Piece at:(to)) (value Piece at:(from)))}))) (apply (fromTo (from (to)) (to (handSite Mover))))))) (piece "Dog" Each (move Step Orthogonal (to if:(and (or (= (count Sites in:(sites Around (from) Orthogonal if:(and (is Enemy (who at:(to))) (> (value Piece at:(to)) (value Piece at:(from)))))) 0) (and (not (= (count Sites in:(sites Around (from) Orthogonal if:(and (is Enemy (who at:(to))) (> (value Piece at:(to)) (value Piece at:(from)))))) 0)) (not (= (count Sites in:(sites Around (from) Orthogonal if:(= (who at:(to)) Mover))) 0)))) (or (is Empty (to)) (and {(< (count MovesThisTurn) 3) (not (= (count Sites in:(sites Around (to) Orthogonal if:(is Empty (to)))) 0)) (is Enemy (who at:(to))) (< (value Piece at:(to)) (value Piece at:(from)))}))) (apply (fromTo (from (to)) (to (handSite Mover))))))) (piece "Horse" Each (move Step Orthogonal (to if:(and (or (= (count Sites in:(sites Around (from) Orthogonal if:(and (is Enemy (who at:(to))) (> (value Piece at:(to)) (value Piece at:(from)))))) 0) (and (not (= (count Sites in:(sites Around (from) Orthogonal if:(and (is Enemy (who at:(to))) (> (value Piece at:(to)) (value Piece at:(from)))))) 0)) (not (= (count Sites in:(sites Around (from) Orthogonal if:(= (who at:(to)) Mover))) 0)))) (or (is Empty (to)) (and {(< (count MovesThisTurn) 3) (not (= (count Sites in:(sites Around (to) Orthogonal if:(is Empty (to)))) 0)) (is Enemy (who at:(to))) (< (value Piece at:(to)) (value Piece at:(from)))}))) (apply (fromTo (from (to)) (to (handSite Mover))))))) (piece "Camel" Each (move Step Orthogonal (to if:(and (or (= (count Sites in:(sites Around (from) Orthogonal if:(and (is Enemy (who at:(to))) (> (value Piece at:(to)) (value Piece at:(from)))))) 0) (and (not (= (count Sites in:(sites Around (from) Orthogonal if:(and (is Enemy (who at:(to))) (> (value Piece at:(to)) (value Piece at:(from)))))) 0)) (not (= (count Sites in:(sites Around (from) Orthogonal if:(= (who at:(to)) Mover))) 0)))) (or (is Empty (to)) (and {(< (count MovesThisTurn) 3) (not (= (count Sites in:(sites Around (to) Orthogonal if:(is Empty (to)))) 0)) (is Enemy (who at:(to))) (< (value Piece at:(to)) (value Piece at:(from)))}))) (apply (fromTo (from (to)) (to (handSite Mover))))))) (piece "Elephant" Each (move Step Orthogonal (to if:(and (or (= (count Sites in:(sites Around (from) Orthogonal if:(and (is Enemy (who at:(to))) (> (value Piece at:(to)) (value Piece at:(from)))))) 0) (and (not (= (count Sites in:(sites Around (from) Orthogonal if:(and (is Enemy (who at:(to))) (> (value Piece at:(to)) (value Piece at:(from)))))) 0)) (not (= (count Sites in:(sites Around (from) Orthogonal if:(= (who at:(to)) Mover))) 0)))) (or (is Empty (to)) (and {(< (count MovesThisTurn) 3) (not (= (count Sites in:(sites Around (to) Orthogonal if:(is Empty (to)))) 0)) (is Enemy (who at:(to))) (< (value Piece at:(to)) (value Piece at:(from)))}))) (apply (fromTo (from (to)) (to (handSite Mover))))))) (regions "Traps" (sites {"C3" "C6" "F3" "F6"})) (regions "Home" P1 (expand (sites Bottom))) (regions "Home" P2 (expand (sites Top))) (regions "Goal" P1 (sites Top)) (regions "Goal" P2 (sites Bottom))}) (rules (start {(place "Rabbit" "Hand" count:8 value:1) (place "Cat" "Hand" count:2 value:2) (place "Dog" "Hand" count:2 value:3) (place "Horse" "Hand" count:2 value:4) (place "Camel" "Hand" count:1 value:5) (place "Elephant" "Hand" count:1 value:6)}) phases:{(phase "PlacementP1" (play (move (from (sites Occupied by:Mover container:(mover))) (to (forEach (sites Mover "Home") if:(is Empty (site)))) (then (if (not (all Sites (sites Hand P1) if:(= 0 (count Cell at:(site))))) (moveAgain))))) (nextPhase (all Sites (sites Hand P1) if:(= 0 (count Cell at:(site)))) "PlacementP2")) (phase "PlacementP2" (play (move (from (sites Occupied by:Mover container:(mover))) (to (forEach (sites Mover "Home") if:(is Empty (site)))) (then (if (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) (remember State) (moveAgain))))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (avoidStoredState (if (is Occupied (handSite Mover)) (move (from (handSite Mover)) (to (sites Around (last To) Orthogonal if:(and (!= (last From) (to)) (is Empty (to))))) (then (and (forEach Site (sites "Traps") (if (or (and (= (who at:(to)) P1) (= (count Sites in:(sites Around (site) Orthogonal if:(= (who at:(to)) P1))) 0)) (and (= (who at:(to)) P2) (= (count Sites in:(sites Around (site) Orthogonal if:(= (who at:(to)) P2))) 0))) (do (set Pending (value Piece at:(to))) next:(remove (to))))) (if (< (count MovesThisTurn) 3) (moveAgain) (remember State))))) (or (or (if (and (is Prev Mover) (is In (last From) (sites Board))) (move (from (sites Around (last From) Orthogonal if:(and (is Enemy (who at:(to))) (if (and (is In (last To) (sites "Traps")) (is Pending)) (< (value Piece at:(to)) (value Pending)) (< (value Piece at:(to)) (value Piece at:(last To))))))) (to (last From)))) (forEach Piece) (then (and (forEach Site (sites "Traps") (if (or (and (= (who at:(to)) P1) (= (count Sites in:(sites Around (site) Orthogonal if:(= (who at:(to)) P1))) 0)) (and (= (who at:(to)) P2) (= (count Sites in:(sites Around (site) Orthogonal if:(= (who at:(to)) P2))) 0))) (do (set Pending (value Piece at:(to))) next:(remove (to))))) (if (< (count MovesThisTurn) 3) (moveAgain) (remember State))))) (move Pass (then (remember State))))))) (end (if (not (is Next Mover)) {(if (!= 0 (count Sites in:(forEach (sites Occupied by:P1 component:"Rabbit") if:(is In (site) (sites P1 "Goal"))))) (result P1 Win)) (if (!= 0 (count Sites in:(forEach (sites Occupied by:P2 component:"Rabbit") if:(is In (site) (sites P2 "Goal"))))) (result P2 Win)) (if (and (not (= (what at:(handSite P2)) (id "Rabbit" P1))) (= (count Sites in:(sites Occupied by:P1 component:"Rabbit")) 0)) (result P2 Win)) (if (and (not (= (what at:(handSite P1)) (id "Rabbit" P2))) (= (count Sites in:(sites Occupied by:P2 component:"Rabbit")) 0)) (result P1 Win)) (if (no Moves Next) (result Next Loss))})))})) 
Seven concentric circles or squares. Four players. One piece per player. One player has a stick, which is hidden in their fist. The next player attempts to guess which hand holds the stick. If the player guessing guesses correctly, they enter their piece in the first circle or advances it to the next circle, and the stick is passed to them. If the guessing player guesses incorrectly, the player holding the stick moves their piece into the first circle or advances it to the next circle. The player with the stick keeps it until the next player guesses the hand holding the stick. The first player to reach the central circle wins. 
(game "Ashere" (players 4) (equipment {(board (concentric {4 4 4 4 4 4 4 4}) {(track "Track1" {28 24 20 16 12 8 4 0} P1 directed:True) (track "Track2" {29 25 21 17 13 9 5 1} P2 directed:True) (track "Track3" {30 26 22 18 14 10 6 2} P3 directed:True) (track "Track4" {31 27 23 19 15 11 7 3} P4 directed:True)} use:Vertex) (piece "Marker" Each) (piece "Stick" Shared) (hand Each size:2)}) (rules (start {(place "Marker1" 28) (place "Marker2" 29) (place "Marker3" 30) (place "Marker4" 31)}) phases:{(phase "Hiding" (play (move Add (piece (id "Stick" Shared)) (to Cell (sites Hand Mover)) (then (set Hidden Cell at:(last To) to:Next)))) (nextPhase "Guessing")) (phase "Guessing" (play (move Select (from Cell (sites Hand Prev)) (then (and (if (is Empty (last To)) (and (fromTo (from (where "Marker" Prev)) (to (if (is Prev P1) (trackSite Move from:(where "Marker" Prev) "Track1" steps:1) (if (is Prev P2) (trackSite Move from:(where "Marker" Prev) "Track2" steps:1) (if (is Prev P3) (trackSite Move from:(where "Marker" Prev) "Track3" steps:1) (trackSite Move from:(where "Marker" Prev) "Track4" steps:1)))))) (if (not (is In (if (is Prev P1) (trackSite Move from:(where "Marker" Prev) "Track1" steps:1) (if (is Prev P2) (trackSite Move from:(where "Marker" Prev) "Track2" steps:1) (if (is Prev P3) (trackSite Move from:(where "Marker" Prev) "Track3" steps:1) (trackSite Move from:(where "Marker" Prev) "Track4" steps:1)))) (sites Centre))) (set NextPlayer (player (prev))))) (and {(moveAgain) (fromTo (from (where "Marker" Mover)) (to (trackSite Move from:(where "Marker" Mover) steps:1)))})) (remove Cell (sites Hand Prev)))))) (nextPhase "Hiding"))} (end (if (!= (- (count Players) (count Active)) (count Sites in:(forEach (sites Centre) if:(is Occupied (site))))) {(if (and (is Active P1) (is In (where "Marker" P1) (sites Centre))) (result P1 Win)) (if (and (is Active P2) (is In (where "Marker" P2) (sites Centre))) (result P2 Win)) (if (and (is Active P3) (is In (where "Marker" P3) (sites Centre))) (result P3 Win)) (if (and (is Active P4) (is In (where "Marker" P4) (sites Centre))) (result P4 Win))})))) 
Buffalos move one step forward to a free space. Dogs move like a chess queen but cannot capture. The villager moves like a chess king, and can capture buffalos. Dogs and the villager cannot enter the top or bottom rows of the board. Buffalos start, and win by reaching the top row. They lose if they cannot move anymore.
(game "Bison" (players 2) (equipment {(board (rectangle 7 11)) (piece "Bull" P1 (move Step Forward (to if:(is Empty (to))))) (piece "Colonel" P2 (move Step Adjacent (to if:(and (and (not (is In (to) (sites Top))) (not (is In (to) (sites Bottom)))) (not (is Friend (who at:(to))))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Dog" P2 (move Slide (between if:(and (and (not (is In (to) (sites Top))) (not (is In (to) (sites Bottom)))) (is Empty (to))))))}) (rules (start {(place "Bull1" (sites Bottom)) (place "Colonel2" {"F6"}) (place "Dog2" {"D6" "E6" "G6" "H6"})}) (play (forEach Piece)) (end {(if (is In (last To) (sites Top)) (result P1 Win)) (if (no Moves Next) (result Mover Win))}))) 
MOVE - On each turn, each player must do one of the following actions: - Move one friendly stone (the missiles) one cell forward (orthogonally or diagonally) - Explode one friendly stone, i.e., capture all stones of either color orthogonally and diagonally adjacent including itself. GOAL - Wins the player that move a stone into the last row, or is the only with stones in the board.
(game "Bombardment" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "NuclearBomb" Each (or (move Step Forwards (to if:(is Empty (to)))) (move Select (from (from)) (then (forEach Site (sites Around (last To) includeSelf:True) (if (is Occupied (site)) (remove (site)))))))) (regions P1 (sites Top)) (regions P2 (sites Bottom))}) (rules (start {(place "NuclearBomb1" (expand (sites Bottom))) (place "NuclearBomb2" (expand (sites Top)))}) (play (forEach Piece)) (end (if (or (is In (last To) (sites Mover)) (no Pieces Next)) (result Mover Win))))) 
Played on an 8x8 board with a double contingent of chess pawns. Pieces move forward one orthogonally or diagonally. Pieces can capture by moving diagonally. The first player to reach the opponent's edge of the board wins. A player also can win if they capture all of the opponent's pieces. The board is tiling by square. The game is played on a 8x8 board.
(game "Breakthrough" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(or (is Empty (to)) (is Enemy (who at:(to)))) (apply (remove (to)))))})) (regions P1 (sites Top)) (regions P2 (sites Bottom))}) (rules (start {(place "Pawn1" (expand (sites Bottom))) (place "Pawn2" (expand (sites Top)))}) (play (forEach Piece)) (end (if (is In (last To) (sites Mover)) (result Mover Win))))) 
Take turns placing stones on a hexhex board of size 4, or a square board of an odd size not larger than 9. The winner is the player who places a stone on the center cell. A placement N steps away from the perimeter must have at least N friendly pieces in sight. On the square board, pieces see in all 8 directions. A square board of size 9 is currently selected The pie rule is currenty not in force.
(game "Center" (players 2) (equipment {(board (square 9) use:Vertex) (piece "Marker" Each)}) (rules (play (move Add (to (sites Empty) if:(<= (count Steps All (to) (sites Perimeter)) (count Sites in:(intersection (sites LineOfSight at:(to) All) (sites Occupied by:Mover))))))) (end (if (is Occupied (centrePoint)) (result Next Loss))))) 
3x12-28 board. Players begin with soldiers, equal in number to the number of spaces in one row for each player, which begin in the spaces in the row closes to the player. Each player has one king piece, which begins in the rightmost space in the central row with respect to the player. Four six-sided dice with values from 1-6. A throw of 1 is called Chong. Pieces move in a boustrophedon path along the board, from left to right in their home row, right to left in the center row, and then left to right in their opponent's row. A player must first throw a Chong to play. On this turn, when a player throws one Chong, the King exchanges places with the soldier behind it. If more than one Chong is thrown, the King exchanges places with the soldier that many spaces behind it. Any remaining values in the throw are moved by the soldier which took the king's space. Once this move has taken place, pieces move according to the throws of the dice, which can be subdivided between the pieces as the player sees fit. The King only moves with a Chong, and it exchanges the place of a piece that number of occupied squares away, i.e., only spaces occupied by the player's pieces are counted when moving the King. When the player has only one soldier and the King, the King may move normally (like a soldier does), but on throws of Chong. When only the King is left, the first Chong in a throw is ignored and only the second, third, or fourth Chongs are moved. When a player's piece lands on a space occupied by an opponent's piece, the opponent's piece is captured. An opponent's King cannot be taken by a soldier until it has first moved backwards, and then it can only be taken by a Chong. The game continues after the players' Kings have been taken. When a player reaches the end of the opponent's home line, the player wins. The game is played on a 3x12 board.
(game "Chong (Sakhalin)" (players 2) (equipment {(board (rectangle 3 12) {(track "Track1" "0,E,N1,W,N1,E" P1 directed:True) (track "Track2" "35,W,S1,E,S1,W" P2 directed:True)}) (dice d:6 num:4) (piece "Marker" Each (move (from) (to (trackSite Move from:(from) steps:(pips)) if:(or {(is Empty (to)) (and (is Enemy (who at:(to))) (if (not (= (what at:(to)) (id "King" Next))) True (= 1 (abs (- (to) (from))))))}) (apply if:(is Enemy (who at:(to))) (remove (to)))))) (piece "King" Each (if (= 1 (pips)) (if (<= 2 (count Pieces Mover)) (if (and (!= 1 (value Player Mover)) (= 1 (count Pieces Mover))) (move (from (from)) (to (from)) (then (set Value Mover 1))) (move (from) (to (trackSite Move from:(from) steps:(pips)) if:(or {(is Empty (to)) (and (is Enemy (who at:(to))) (if (not (= (what at:(to)) (id "King" Next))) True (= 1 (abs (- (to) (from))))))}) (apply if:(is Enemy (who at:(to))) (remove (to)))))) (firstMoveOnTrack "Track" Mover (if (and (> (site) (from)) (is Mover (who at:(site)))) (move Swap Pieces (from) (site)))))))}) (rules (start {(place "Marker1" (difference (sites Bottom) (sites Right))) (place "King1" (intersection (sites Bottom) (sites Right))) (place "Marker2" (difference (sites Top) (sites Left))) (place "King2" (intersection (sites Top) (sites Left)))}) phases:{(phase "Opening" (play (do (roll) next:(if (!= 0 (+ {(if (= 1 (face (+ 0 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 1 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 2 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 3 (count Sites in:(sites Board))))) 1 0)})) (if (is Mover P1) (if (is Mover (who at:(- (where "King" Mover) (+ {(if (= 1 (face (+ 0 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 1 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 2 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 3 (count Sites in:(sites Board))))) 1 0)})))) (move Swap Pieces (where "King" Mover) (- (where "King" Mover) (+ {(if (= 1 (face (+ 0 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 1 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 2 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 3 (count Sites in:(sites Board))))) 1 0)})))) (if (is Mover (who at:(+ (where "King" Mover) (+ {(if (= 1 (face (+ 0 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 1 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 2 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 3 (count Sites in:(sites Board))))) 1 0)})))) (move Swap Pieces (where "King" Mover) (+ (where "King" Mover) (+ {(if (= 1 (face (+ 0 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 1 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 2 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 3 (count Sites in:(sites Board))))) 1 0)})))) (then (fromTo (from (last From)) (to (trackSite Move from:(last From) steps:(- (count Pips) (+ {(if (= 1 (face (+ 0 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 1 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 2 (count Sites in:(sites Board))))) 1 0) (if (= 1 (face (+ 3 (count Sites in:(sites Board))))) 1 0)}))) (apply if:(is Enemy (who at:(to))) (remove (to)))))))))) (nextPhase Mover (not (was Pass)) "Playing")) (phase "Playing" (play (do (if (not (is Prev Mover)) (roll)) next:(forEach Die if:(!= (pips) 0) (forEach Piece) (then (if (not (all DiceUsed)) (moveAgain)))))))} (end {(if (= (who at:0) P2) (result P2 Win)) (if (= (who at:(- (count Sites in:(sites Board)) 1)) P1) (result P1 Win))}))) 
Four 3x8 rectangles, arranged in a cross. No marked squares. Four players, each with four pieces, which are black, yellow, green, and red. Yellow seated at the bottom, red to their right, black to the right of red, green to the right of black. Green and red play on a team against black and yellow. Three four-sided rectangular dice, each marked 1, 2, 5, and 6. Pieces begin on the board, with one each in the sixth and seventh space of the central row of the player's arm, (counting from the top of the row), and in the seventh and eighth spaces of the left row of the arm belonging to the player to the right. The latter two pieces must move as a pair, I.e., they must always be moved together, and can only do so when doubles are thrown. The other two pieces belonging to a player may move singly. Throws may be split up as a player sees fit, but the value of one die must be used it its entirety by a piece. Pieces move around the board in an anti-clockwise direction until they reach their central row, at which point they move up the central row to the central spot. They must enter the central space by an exact throw. When a player moves all of their pieces to the center, they continue to throw the dice, and use these throws to move their partner's pieces. When all of the team's pieces reach the center, that team wins.
(game "Chonpa" (players 4) (equipment {(board (add (hole (merge (shift 0 (/ (- 19 3) 2) (rectangle 3 19)) (shift (/ (- 19 3) 2) 0 (rectangle 19 3))) (poly {{8 8} {8 11} {11 11} {11 8}})) cells:{{8 28 48 68 69 70 71 51 31 11 10 9}}) {(track "TrackNormal1" "64,S,E,N,11,E,N,W,53,N,W,S,42,W,S,E,8,54,E1,N8" P1 directed:True) (track "TrackPaired1" "57,S,E,N,11,E,N,W,53,N,W,S,42,W,S,E,8,54,E1,N8" P1 directed:True) (track "TrackNormal2" "22,W,S,E,8,S,E,N,11,E,N,W,53,N,W,S,42,W,S1,E8" P2 directed:True) (track "TrackPaired2" "36,W,S,E,8,S,E,N,11,E,N,W,53,N,W,S,42,W,S1,E8" P2 directed:True) (track "TrackNormal3" "85,N,W,S,42,W,S,E,8,S,E,N,11,E,N,W,53,N,W1,S8" P3 directed:True) (track "TrackPaired3" "92,N,W,S,42,W,S,E,8,S,E,N,11,E,N,W,53,N,W1,S8" P3 directed:True) (track "TrackNormal4" "31,E,N,W,53,N,W,S,42,W,S,E,8,S,E,N,11,E,N1,W8" P4 directed:True) (track "TrackPaired4" "17,E,N,W,53,N,W,S,42,W,S,E,8,S,E,N,11,E,N1,W8" P4 directed:True)}) (dice d:4 faces:{1 2 5 6} num:3) (piece "Pawn" Each (forEach Die if:(!= (pips) 0) (move (from (from) level:(level) if:(!= 0 (what at:(from) level:(level)))) (to (if (= 0 (state at:(from) level:(level))) (trackSite Move from:(from) "TrackNormal" steps:(pips)) (trackSite Move from:(from) "TrackPaired" steps:(pips))) if:(if (= 0 (state at:(from) level:(level))) (if (not (= 1 (var "MovePair"))) True (or (all DiceEqual) (= (pips) (if (= (face 97) (face 98)) (face 99) (if (= (face 98) (face 99)) (face 97) (face 98)))))) (and {(not (= 1 (var "MovePair"))) (or {(= (face 97) (face 98)) (= (face 97) (face 99)) (= (face 98) (face 99))}) (= (pips) (if (= (face 97) (face 98)) (face 97) (if (= (face 98) (face 99)) (face 98) (face 99)))) (< (count MovesThisTurn) 2) (if (= (count MovesThisTurn) 0) True (or (all DiceEqual) (!= (var "Pips") (if (= (face 97) (face 98)) (face 97) (if (= (face 98) (face 99)) (face 98) (face 99))))))})) (apply (and (if (= 1 (state at:(from))) (forEach Site (sites Occupied by:Mover top:False) (forEach Level (site) (if (and {(= 1 (state at:(site) level:(level))) (!= (from) (site)) (= (mover) (who at:(site) level:(level)))}) (fromTo (from (site) level:(level)) (to (trackSite Move from:(site) "TrackPaired" steps:(pips)))))))) (set Var "Pips" (pips))))) (then (if (and (not (= 1 (var "MovePair"))) (if (= 1 (state at:(last To) level:(last LevelTo))) (< (count MovesThisTurn) 1) (< (count MovesThisTurn) 2))) (and (moveAgain) (if (= 1 (state at:(last To) level:(last LevelTo))) (set Var "MovePair" 1))) (and (set Var "MovePair" 0) (set Var "Pips" 0)))))))}) (rules (start {(set Team 1 {P1 P3}) (set Team 2 {P2 P4}) (place Stack "Pawn1" (sites {61 64})) (place Stack "Pawn2" (sites {21 22})) (place Stack "Pawn3" (sites {85 88})) (place Stack "Pawn4" (sites {31 32})) (place Stack "Pawn1" (sites {54 57}) state:1) (place Stack "Pawn2" (sites {35 36}) state:1) (place Stack "Pawn3" (sites {95 92}) state:1) (place Stack "Pawn4" (sites {17 18}) state:1)}) (play (do (if (not (is Prev Mover)) (roll)) next:(if (can Move (if (and (= 1 (count Sites in:(sites Occupied by:Mover top:False))) (is In (centrePoint) (sites Occupied by:Mover top:False))) (if (is Mover P1) (forEach Piece (forEach Die if:(!= (pips) 0) (move (from (from) level:(level) if:(!= 0 (what at:(from) level:(level)))) (to (if (= 0 (state at:(from) level:(level))) (trackSite Move from:(from) "TrackNormal3" steps:(pips)) (trackSite Move from:(from) "TrackPaired3" steps:(pips))) if:(if (= 0 (state at:(from) level:(level))) (if (not (= 1 (var "MovePair"))) True (or (all DiceEqual) (= (pips) (if (= (face 97) (face 98)) (face 99) (if (= (face 98) (face 99)) (face 97) (face 98)))))) (and {(not (= 1 (var "MovePair"))) (or {(= (face 97) (face 98)) (= (face 97) (face 99)) (= (face 98) (face 99))}) (= (pips) (if (= (face 97) (face 98)) (face 97) (if (= (face 98) (face 99)) (face 98) (face 99)))) (< (count MovesThisTurn) 2) (if (= (count MovesThisTurn) 0) True (or (all DiceEqual) (!= (var "Pips") (if (= (face 97) (face 98)) (face 97) (if (= (face 98) (face 99)) (face 98) (face 99))))))})) (apply (and (if (= 1 (state at:(from))) (forEach Site (sites Occupied by:Mover top:False) (forEach Level (site) (if (and {(= 1 (state at:(site) level:(level))) (!= (from) (site)) (= (mover) (who at:(site) level:(level)))}) (fromTo (from (site) level:(level)) (to (trackSite Move from:(site) "TrackPaired3" steps:(pips)))))))) (set Var "Pips" (pips))))) (then (if (and (not (= 1 (var "MovePair"))) (if (= 1 (state at:(last To) level:(last LevelTo))) (< (count MovesThisTurn) 1) (< (count MovesThisTurn) 2))) (and (moveAgain) (if (= 1 (state at:(last To) level:(last LevelTo))) (set Var "MovePair" 1))) (and (set Var "MovePair" 0) (set Var "Pips" 0)))))) P3) (if (is Mover P3) (forEach Piece (forEach Die if:(!= (pips) 0) (move (from (from) level:(level) if:(!= 0 (what at:(from) level:(level)))) (to (if (= 0 (state at:(from) level:(level))) (trackSite Move from:(from) "TrackNormal1" steps:(pips)) (trackSite Move from:(from) "TrackPaired1" steps:(pips))) if:(if (= 0 (state at:(from) level:(level))) (if (not (= 1 (var "MovePair"))) True (or (all DiceEqual) (= (pips) (if (= (face 97) (face 98)) (face 99) (if (= (face 98) (face 99)) (face 97) (face 98)))))) (and {(not (= 1 (var "MovePair"))) (or {(= (face 97) (face 98)) (= (face 97) (face 99)) (= (face 98) (face 99))}) (= (pips) (if (= (face 97) (face 98)) (face 97) (if (= (face 98) (face 99)) (face 98) (face 99)))) (< (count MovesThisTurn) 2) (if (= (count MovesThisTurn) 0) True (or (all DiceEqual) (!= (var "Pips") (if (= (face 97) (face 98)) (face 97) (if (= (face 98) (face 99)) (face 98) (face 99))))))})) (apply (and (if (= 1 (state at:(from))) (forEach Site (sites Occupied by:Mover top:False) (forEach Level (site) (if (and {(= 1 (state at:(site) level:(level))) (!= (from) (site)) (= (mover) (who at:(site) level:(level)))}) (fromTo (from (site) level:(level)) (to (trackSite Move from:(site) "TrackPaired1" steps:(pips)))))))) (set Var "Pips" (pips))))) (then (if (and (not (= 1 (var "MovePair"))) (if (= 1 (state at:(last To) level:(last LevelTo))) (< (count MovesThisTurn) 1) (< (count MovesThisTurn) 2))) (and (moveAgain) (if (= 1 (state at:(last To) level:(last LevelTo))) (set Var "MovePair" 1))) (and (set Var "MovePair" 0) (set Var "Pips" 0)))))) P1) (if (is Mover P4) (forEach Piece (forEach Die if:(!= (pips) 0) (move (from (from) level:(level) if:(!= 0 (what at:(from) level:(level)))) (to (if (= 0 (state at:(from) level:(level))) (trackSite Move from:(from) "TrackNormal2" steps:(pips)) (trackSite Move from:(from) "TrackPaired2" steps:(pips))) if:(if (= 0 (state at:(from) level:(level))) (if (not (= 1 (var "MovePair"))) True (or (all DiceEqual) (= (pips) (if (= (face 97) (face 98)) (face 99) (if (= (face 98) (face 99)) (face 97) (face 98)))))) (and {(not (= 1 (var "MovePair"))) (or {(= (face 97) (face 98)) (= (face 97) (face 99)) (= (face 98) (face 99))}) (= (pips) (if (= (face 97) (face 98)) (face 97) (if (= (face 98) (face 99)) (face 98) (face 99)))) (< (count MovesThisTurn) 2) (if (= (count MovesThisTurn) 0) True (or (all DiceEqual) (!= (var "Pips") (if (= (face 97) (face 98)) (face 97) (if (= (face 98) (face 99)) (face 98) (face 99))))))})) (apply (and (if (= 1 (state at:(from))) (forEach Site (sites Occupied by:Mover top:False) (forEach Level (site) (if (and {(= 1 (state at:(site) level:(level))) (!= (from) (site)) (= (mover) (who at:(site) level:(level)))}) (fromTo (from (site) level:(level)) (to (trackSite Move from:(site) "TrackPaired2" steps:(pips)))))))) (set Var "Pips" (pips))))) (then (if (and (not (= 1 (var "MovePair"))) (if (= 1 (state at:(last To) level:(last LevelTo))) (< (count MovesThisTurn) 1) (< (count MovesThisTurn) 2))) (and (moveAgain) (if (= 1 (state at:(last To) level:(last LevelTo))) (set Var "MovePair" 1))) (and (set Var "MovePair" 0) (set Var "Pips" 0)))))) P2) (forEach Piece (forEach Die if:(!= (pips) 0) (move (from (from) level:(level) if:(!= 0 (what at:(from) level:(level)))) (to (if (= 0 (state at:(from) level:(level))) (trackSite Move from:(from) "TrackNormal4" steps:(pips)) (trackSite Move from:(from) "TrackPaired4" steps:(pips))) if:(if (= 0 (state at:(from) level:(level))) (if (not (= 1 (var "MovePair"))) True (or (all DiceEqual) (= (pips) (if (= (face 97) (face 98)) (face 99) (if (= (face 98) (face 99)) (face 97) (face 98)))))) (and {(not (= 1 (var "MovePair"))) (or {(= (face 97) (face 98)) (= (face 97) (face 99)) (= (face 98) (face 99))}) (= (pips) (if (= (face 97) (face 98)) (face 97) (if (= (face 98) (face 99)) (face 98) (face 99)))) (< (count MovesThisTurn) 2) (if (= (count MovesThisTurn) 0) True (or (all DiceEqual) (!= (var "Pips") (if (= (face 97) (face 98)) (face 97) (if (= (face 98) (face 99)) (face 98) (face 99))))))})) (apply (and (if (= 1 (state at:(from))) (forEach Site (sites Occupied by:Mover top:False) (forEach Level (site) (if (and {(= 1 (state at:(site) level:(level))) (!= (from) (site)) (= (mover) (who at:(site) level:(level)))}) (fromTo (from (site) level:(level)) (to (trackSite Move from:(site) "TrackPaired4" steps:(pips)))))))) (set Var "Pips" (pips))))) (then (if (and (not (= 1 (var "MovePair"))) (if (= 1 (state at:(last To) level:(last LevelTo))) (< (count MovesThisTurn) 1) (< (count MovesThisTurn) 2))) (and (moveAgain) (if (= 1 (state at:(last To) level:(last LevelTo))) (set Var "MovePair" 1))) (and (set Var "MovePair" 0) (set Var "Pips" 0)))))) P4)))) (forEach Piece))) (if (and (= 1 (count Sites in:(sites Occupied by:Mover top:False))) (is In (centrePoint) (sites Occupied by:Mover top:False))) (if (is Mover P1) (forEach Piece (forEach Die if:(!= (pips) 0) (move (from (from) level:(level) if:(!= 0 (what at:(from) level:(level)))) (to (if (= 0 (state at:(from) level:(level))) (trackSite Move from:(from) "TrackNormal3" steps:(pips)) (trackSite Move from:(from) "TrackPaired3" steps:(pips))) if:(if (= 0 (state at:(from) level:(level))) (if (not (= 1 (var "MovePair"))) True (or (all DiceEqual) (= (pips) (if (= (face 97) (face 98)) (face 99) (if (= (face 98) (face 99)) (face 97) (face 98)))))) (and {(not (= 1 (var "MovePair"))) (or {(= (face 97) (face 98)) (= (face 97) (face 99)) (= (face 98) (face 99))}) (= (pips) (if (= (face 97) (face 98)) (face 97) (if (= (face 98) (face 99)) (face 98) (face 99)))) (< (count MovesThisTurn) 2) (if (= (count MovesThisTurn) 0) True (or (all DiceEqual) (!= (var "Pips") (if (= (face 97) (face 98)) (face 97) (if (= (face 98) (face 99)) (face 98) (face 99))))))})) (apply (and (if (= 1 (state at:(from))) (forEach Site (sites Occupied by:Mover top:False) (forEach Level (site) (if (and {(= 1 (state at:(site) level:(level))) (!= (from) (site)) (= (mover) (who at:(site) level:(level)))}) (fromTo (from (site) level:(level)) (to (trackSite Move from:(site) "TrackPaired3" steps:(pips)))))))) (set Var "Pips" (pips))))) (then (if (and (not (= 1 (var "MovePair"))) (if (= 1 (state at:(last To) level:(last LevelTo))) (< (count MovesThisTurn) 1) (< (count MovesThisTurn) 2))) (and (moveAgain) (if (= 1 (state at:(last To) level:(last LevelTo))) (set Var "MovePair" 1))) (and (set Var "MovePair" 0) (set Var "Pips" 0)))))) P3) (if (is Mover P3) (forEach Piece (forEach Die if:(!= (pips) 0) (move (from (from) level:(level) if:(!= 0 (what at:(from) level:(level)))) (to (if (= 0 (state at:(from) level:(level))) (trackSite Move from:(from) "TrackNormal1" steps:(pips)) (trackSite Move from:(from) "TrackPaired1" steps:(pips))) if:(if (= 0 (state at:(from) level:(level))) (if (not (= 1 (var "MovePair"))) True (or (all DiceEqual) (= (pips) (if (= (face 97) (face 98)) (face 99) (if (= (face 98) (face 99)) (face 97) (face 98)))))) (and {(not (= 1 (var "MovePair"))) (or {(= (face 97) (face 98)) (= (face 97) (face 99)) (= (face 98) (face 99))}) (= (pips) (if (= (face 97) (face 98)) (face 97) (if (= (face 98) (face 99)) (face 98) (face 99)))) (< (count MovesThisTurn) 2) (if (= (count MovesThisTurn) 0) True (or (all DiceEqual) (!= (var "Pips") (if (= (face 97) (face 98)) (face 97) (if (= (face 98) (face 99)) (face 98) (face 99))))))})) (apply (and (if (= 1 (state at:(from))) (forEach Site (sites Occupied by:Mover top:False) (forEach Level (site) (if (and {(= 1 (state at:(site) level:(level))) (!= (from) (site)) (= (mover) (who at:(site) level:(level)))}) (fromTo (from (site) level:(level)) (to (trackSite Move from:(site) "TrackPaired1" steps:(pips)))))))) (set Var "Pips" (pips))))) (then (if (and (not (= 1 (var "MovePair"))) (if (= 1 (state at:(last To) level:(last LevelTo))) (< (count MovesThisTurn) 1) (< (count MovesThisTurn) 2))) (and (moveAgain) (if (= 1 (state at:(last To) level:(last LevelTo))) (set Var "MovePair" 1))) (and (set Var "MovePair" 0) (set Var "Pips" 0)))))) P1) (if (is Mover P4) (forEach Piece (forEach Die if:(!= (pips) 0) (move (from (from) level:(level) if:(!= 0 (what at:(from) level:(level)))) (to (if (= 0 (state at:(from) level:(level))) (trackSite Move from:(from) "TrackNormal2" steps:(pips)) (trackSite Move from:(from) "TrackPaired2" steps:(pips))) if:(if (= 0 (state at:(from) level:(level))) (if (not (= 1 (var "MovePair"))) True (or (all DiceEqual) (= (pips) (if (= (face 97) (face 98)) (face 99) (if (= (face 98) (face 99)) (face 97) (face 98)))))) (and {(not (= 1 (var "MovePair"))) (or {(= (face 97) (face 98)) (= (face 97) (face 99)) (= (face 98) (face 99))}) (= (pips) (if (= (face 97) (face 98)) (face 97) (if (= (face 98) (face 99)) (face 98) (face 99)))) (< (count MovesThisTurn) 2) (if (= (count MovesThisTurn) 0) True (or (all DiceEqual) (!= (var "Pips") (if (= (face 97) (face 98)) (face 97) (if (= (face 98) (face 99)) (face 98) (face 99))))))})) (apply (and (if (= 1 (state at:(from))) (forEach Site (sites Occupied by:Mover top:False) (forEach Level (site) (if (and {(= 1 (state at:(site) level:(level))) (!= (from) (site)) (= (mover) (who at:(site) level:(level)))}) (fromTo (from (site) level:(level)) (to (trackSite Move from:(site) "TrackPaired2" steps:(pips)))))))) (set Var "Pips" (pips))))) (then (if (and (not (= 1 (var "MovePair"))) (if (= 1 (state at:(last To) level:(last LevelTo))) (< (count MovesThisTurn) 1) (< (count MovesThisTurn) 2))) (and (moveAgain) (if (= 1 (state at:(last To) level:(last LevelTo))) (set Var "MovePair" 1))) (and (set Var "MovePair" 0) (set Var "Pips" 0)))))) P2) (forEach Piece (forEach Die if:(!= (pips) 0) (move (from (from) level:(level) if:(!= 0 (what at:(from) level:(level)))) (to (if (= 0 (state at:(from) level:(level))) (trackSite Move from:(from) "TrackNormal4" steps:(pips)) (trackSite Move from:(from) "TrackPaired4" steps:(pips))) if:(if (= 0 (state at:(from) level:(level))) (if (not (= 1 (var "MovePair"))) True (or (all DiceEqual) (= (pips) (if (= (face 97) (face 98)) (face 99) (if (= (face 98) (face 99)) (face 97) (face 98)))))) (and {(not (= 1 (var "MovePair"))) (or {(= (face 97) (face 98)) (= (face 97) (face 99)) (= (face 98) (face 99))}) (= (pips) (if (= (face 97) (face 98)) (face 97) (if (= (face 98) (face 99)) (face 98) (face 99)))) (< (count MovesThisTurn) 2) (if (= (count MovesThisTurn) 0) True (or (all DiceEqual) (!= (var "Pips") (if (= (face 97) (face 98)) (face 97) (if (= (face 98) (face 99)) (face 98) (face 99))))))})) (apply (and (if (= 1 (state at:(from))) (forEach Site (sites Occupied by:Mover top:False) (forEach Level (site) (if (and {(= 1 (state at:(site) level:(level))) (!= (from) (site)) (= (mover) (who at:(site) level:(level)))}) (fromTo (from (site) level:(level)) (to (trackSite Move from:(site) "TrackPaired4" steps:(pips)))))))) (set Var "Pips" (pips))))) (then (if (and (not (= 1 (var "MovePair"))) (if (= 1 (state at:(last To) level:(last LevelTo))) (< (count MovesThisTurn) 1) (< (count MovesThisTurn) 2))) (and (moveAgain) (if (= 1 (state at:(last To) level:(last LevelTo))) (set Var "MovePair" 1))) (and (set Var "MovePair" 0) (set Var "Pips" 0)))))) P4)))) (forEach Piece)) (move Pass (then (and (set Var "MovePair" 0) (set Var "Pips" 0))))))) (end (if (and (= 1 (count Sites in:(sites Occupied by:TeamMover top:False))) (is In (centrePoint) (sites Occupied by:TeamMover top:False))) (result TeamMover Win))))) 
The game is played on a square board with a 5×5 grid. Each player has six cubes, numbered one to six. During setup, each player can arrange the cubes as he or she sees fit within the triangular area of their own color. The players take turns rolling a six-sided die and then moving the matching cube. If the matching cube is no longer on the board, the player moves a remaining cube whose number is next-higher or next-lower to the rolled number. The player starting in the top-left may move that cube one square to the right, down, or on the diagonal down and to the right; the player starting in the bottom-right may move that cube one square to the left, up, or on the diagonal up and to the left. Any cube which already lies in the target square is removed from the board. The objective of the game is for a player to either get one of their cubes to the far corner square in the grid (where their opponent started) or to remove all of their opponent's cubes from the board. The version of the game played on 5x5 board.
(game "EinStein Wurfelt Nicht" (players {(player SE) (player NW)}) (equipment {(board (square 5)) (piece "Square" Each) (hand Each size:6) (dice num:1) (regions "Home" P1 (expand (intersection (sites Top) (sites Left)) steps:2 Orthogonal)) (regions "Home" P2 (expand (intersection (sites Bottom) (sites Right)) steps:2 Orthogonal)) (regions "Goal" P1 (intersection (sites Bottom) (sites Right))) (regions "Goal" P2 (intersection (sites Top) (sites Left)))}) (rules (start {(place "Square1" (handSite P1) state:1) (place "Square1" (handSite P1 1) state:2) (place "Square1" (handSite P1 2) state:3) (place "Square1" (handSite P1 3) state:4) (place "Square1" (handSite P1 4) state:5) (place "Square1" (handSite P1 5) state:6) (place "Square2" (handSite P2) state:1) (place "Square2" (handSite P2 1) state:2) (place "Square2" (handSite P2 2) state:3) (place "Square2" (handSite P2 3) state:4) (place "Square2" (handSite P2 4) state:5) (place "Square2" (handSite P2 5) state:6)}) phases:{(phase "Placement" (play (move (from (sites Occupied by:Mover container:(mover))) (to (forEach (sites Mover "Home") if:(is Empty (site)))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (do (roll) next:(if (!= (where "Square" Mover state:(count Pips)) -1) (forEach Piece (if (= (state at:(from)) (count Pips)) (move Step Forwards (to if:True (apply (if (is Occupied (to)) (remove (to)))))))) (or (forEach Piece (if (if (!= (where "Square" Mover state:(+ (count Pips) 1)) -1) (= (state at:(from)) (+ (count Pips) 1)) (if (!= (where "Square" Mover state:(+ (count Pips) 2)) -1) (= (state at:(from)) (+ (count Pips) 2)) (if (!= (where "Square" Mover state:(+ (count Pips) 3)) -1) (= (state at:(from)) (+ (count Pips) 3)) (if (!= (where "Square" Mover state:(+ (count Pips) 4)) -1) (= (state at:(from)) (+ (count Pips) 4)) (= (state at:(from)) (+ (count Pips) 5)))))) (move Step Forwards (to if:True (apply (if (is Occupied (to)) (remove (to)))))))) (forEach Piece (if (if (!= (where "Square" Mover state:(- (count Pips) 1)) -1) (= (state at:(from)) (- (count Pips) 1)) (if (!= (where "Square" Mover state:(- (count Pips) 2)) -1) (= (state at:(from)) (- (count Pips) 2)) (if (!= (where "Square" Mover state:(- (count Pips) 3)) -1) (= (state at:(from)) (- (count Pips) 3)) (if (!= (where "Square" Mover state:(- (count Pips) 4)) -1) (= (state at:(from)) (- (count Pips) 4)) (= (state at:(from)) (- (count Pips) 5)))))) (move Step Forwards (to if:True (apply (if (is Occupied (to)) (remove (to)))))))))))))} (end (if (or (no Pieces Next) (all Sites (sites Mover "Goal") if:(is In (site) (sites Occupied by:Mover)))) (result Mover Win))))) 
7x7 board, with an extra square above the top left square of the grid. One piece per player. Four sticks, with one green side and one white side, used as dice. The throws are as follows: one white and three green = sîg, valued at 1; two white and two green = 0; three white and one green = 3; four white = 4; four green=6. Pieces begin off the board, moving onto the bottom right square, and proceed in a boustrophedon direction, moving upward in the rightmost column, then down the next to the left, until reaching the extra space in the top left of the board. A player must first throw sîg to begin moving. Players move according to the values of the throws. If a player lands on the top right square, they must throw sîg five times to escape it. If a player lands on the central square, they must throw sîg ten times to escape it. A player must also throw one sîg to escape each of the final three spaces. Once a player has escaped the final space, they control the Ghula. The Ghula has different values for the throws: one white = 2; two white = 5; three white = 0; four white = 4; four green =6. The ghula moves in the opposite direction of the pieces, and when it overcomes one of the opponent's pieces it drags them in the direction it moves, with the goal of dragging them to the start. The Ghula may move forward or backward on its turn along the track. The Ghula does not have to throw a sîg to escape any spaces. Play continues until all of the players escape the final space. The game has 4 players.
(game "Es-Sig" (players 4) (equipment {(board (merge {(rectangle 8 1) (square 7) (shift 8 0 (square 1))}) {(track "Track" "50,19,W,N1,E,N1,W,N1,E,N1,W,N1,E,N1,W4" directed:True) (track "ExtensionTrack" "45,W,N" directed:True) (track "GhoulaTrack" "19,W,N1,E,N1,W,N1,E,N1,W,N1,E,N1,W" directed:True) (track "ReverseGhoulaTrack" "50,12,E,S1,W,S1,E,S1,W,S1,E,S1,W,S1,E" directed:True)}) (piece "Ghoula" Neutral) (piece "Stick" Each (if (= (from) 49) (if (= (state at:(from) level:(level)) 6) (move (from (from) level:(level)) (to 48) (then (forEach Level (last To) (set State at:(last To) level:(level) 0)))) (if (= (mapEntry "Throw" (count Pips)) 1) (move Select (from (from) level:(level)) (then (set State at:(last To) level:(last LevelTo) (+ 1 (state at:(last To) level:(last LevelTo)))))))) (if (= (from) 31) (if (= (state at:(from) level:(level)) 11) (move (from (from) level:(level)) (to 32) (then (forEach Level (last To) (set State at:(last To) level:(level) 0)))) (if (= (mapEntry "Throw" (count Pips)) 1) (move Select (from (from) level:(level)) (then (set State at:(last To) level:(last LevelTo) (+ 1 (state at:(last To) level:(last LevelTo)))))))) (if (and (!= (from) 45) (is In (from) (sites Track "Track"))) (move (from (from) level:(level) if:(if (<= 1 (state at:(from) level:(level))) True (= (mapEntry "Throw" (count Pips)) 1))) (to (trackSite Move "Track" steps:(mapEntry "Throw" (count Pips))) if:True) (then (if (not (<= 1 (state at:(last To) level:(topLevel at:(last To))))) (set State at:(last To) level:(topLevel at:(last To)) 1)))) (if (is In (from) (sites Track "ExtensionTrack")) (or {(if (and (!= (from) 14) (= (mapEntry "Throw" (count Pips)) 1)) (move (from (from) level:(level)) (to (trackSite Move "ExtensionTrack" steps:1)))) (if (= (from) 14) (move Pass (then (if (!= 1 (count Pips)) (and (moveAgain) (set Var 1))))))})))) (then (if (and (= (last To) 14) (!= (last From) 14)) (if (!= -1 (var "ScoreToGet")) (and (set Score Mover (- (var "ScoreToGet") 1)) (set Var "ScoreToGet" (- (var "ScoreToGet") 1))) (and (set Score Mover (count Players)) (set Var "ScoreToGet" (count Players))))))) maxState:12) (dice d:2 from:0 num:4) (map "Throw" {(pair 0 4) (pair 1 3) (pair 2 0) (pair 3 1) (pair 4 6)}) (map "ThrowGhoula" {(pair 0 4) (pair 1 6) (pair 2 4) (pair 3 2) (pair 4 6)})}) (rules (start (place Stack items:{"Ghoula0" "Stick4" "Stick3" "Stick2" "Stick1"} 50)) (play (do (roll) next:(if (> (var) 0) (if (= 1 (size Stack at:(where "Ghoula" Neutral))) (or (move (from (where "Ghoula" Neutral) level:(where Level "Ghoula" Neutral at:(where "Ghoula" Neutral))) (to (trackSite Move from:(where "Ghoula" Neutral) "GhoulaTrack" steps:(mapEntry "ThrowGhoula" (count Pips))))) (move (from (where "Ghoula" Neutral) level:(where Level "Ghoula" Neutral at:(where "Ghoula" Neutral))) (to (trackSite Move from:(where "Ghoula" Neutral) "ReverseGhoulaTrack" steps:(mapEntry "ThrowGhoula" (count Pips)))))) (move (from (where "Ghoula" Neutral) level:(where Level "Ghoula" Neutral at:(where "Ghoula" Neutral))) (to (trackSite Move from:(where "Ghoula" Neutral) "ReverseGhoulaTrack" steps:(mapEntry "ThrowGhoula" (count Pips)))) (then (if (= (last From) 19) (forEach Level (last From) FromTop (remove (last From) level:(level))) (forEach Level (last From) FromTop (fromTo (from (last From) level:(level)) (to (last To))))))) (then (set Var 0))) (if (or (= (where "Stick" Mover) 14) (!= 0 (mapEntry "Throw" (count Pips)))) (forEach Piece))))) (end {(forEach Player if:(no Pieces Player) (result Player Loss)) (if (or (and (= 1 (size Stack at:(where "Ghoula" Neutral))) (= 12 (where "Ghoula" Neutral))) (and (all Sites (difference (sites Board) (sites {50 14})) if:(or (is Empty (site)) (and (= 1 (size Stack at:(site))) (= (site) (where "Ghoula" Neutral))))) (is Empty 50))) (byScore))}))) 
A move of a player consists of two parts: he first makes a normal move with one of his pieces (this is not obligatory), but no piece may move to a goal, i.e., to e1 or e9. (Pieces like rooks and queens however may move across it, e.g. from d1 to f1.) However, no captures are made, and check is disregarded. Then, after this move, the player may, if he can, have a piece kick the ball. A piece can kick the ball if the ball is adjacent to it (i.e., a kings move away.) The ball moves in the same way as the piece that kicks the ball, and the ball must be moved directly away from the piece. Also, the ball cannot be moved to or over occupied squares (except when a knight kicks the ball). For instance, a rook on a3 can kick a ball on a4 to squares a5, a6, a7, a8, a9, as long as the ball isn't moved to an occupied square; but a rook on a3 cannot kick a ball on b4. A knight can kick the ball to any square, a knight-move away from the square where the ball was before the kick, but not to a square, adjacent to the knight. When the ball is kicked to a square adjacent to another piece of the same player, the player may make another kick. This is called a `pass'. If after a second kick, a third kick is possible, the player may also make this third kick, and similar for successive kicks. Making an infinite number of passes, in order to draw the game, however is not allowed. Note that when kicking, only the ball moves but all normal pieces remain on the same places. The object of the game is to kick to ball to the goal at the opponents side of the board. However, it is not allowed to kick the ball into or across the goal from a square on the 1st or 9th row.
(game "Football Chess" (players 2) (equipment {(board (square 9)) (piece "Rook" Each (move Slide Orthogonal (to (apply if:(not (is In (to) (sites "Goals"))))))) (piece "King" Each (move Step (to if:(and (is Empty (to)) (not (is In (to) (sites "Goals"))))))) (piece "Bishop" Each (move Slide Diagonal (to (apply if:(not (is In (to) (sites "Goals"))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(and (is Empty (to)) (not (is In (to) (sites "Goals"))))))) (piece "Queen" Each (move Slide (to (apply if:(not (is In (to) (sites "Goals"))))))) (piece "Ball" Shared) (regions "Goals" (sites {"E1" "E9"})) (map "Goal" {(pair P1 "E9") (pair P2 "E1")})}) (rules (meta (no Repeat PositionalInTurn)) (start {(place "Rook1" {"A1" "I1"}) (place "Knight1" {"B1" "H1"}) (place "Bishop1" {"C1" "G1"}) (place "Queen1" coord:"D1") (place "King1" coord:"F1") (place "Rook2" {"A9" "I9"}) (place "Knight2" {"B9" "H9"}) (place "Bishop2" {"C9" "G9"}) (place "Queen2" coord:"D9") (place "King2" coord:"F9") (place "Ball" {"E5"})}) (play (if (is Prev Mover) (or (if (is Pending) (forEach Site (sites Around (where "Ball" Shared)) (if (and (= (what at:(site)) (id "Knight" Mover)) (is In (where "Ball" Shared) (sites Around (site)))) (move (from (where "Ball" Shared)) (to (sites To (leap (from (where "Ball" Shared)) {{F F R F} {F F L F}} (to if:(is Empty (to))))) if:(not (is In (to) (sites Around (site)))))) (if (and (= (what at:(site)) (id "King" Mover)) (is In (where "Ball" Shared) (sites Around (site)))) (move (from (where "Ball" Shared)) (to (sites To (step (from (where "Ball" Shared)) (directions Cell from:(site) to:(where "Ball" Shared)) (to if:(is Empty (to))))) if:(if (is In (site) (union (sites Bottom) (sites Top))) (not (is In (to) (sites "Goals"))) True))) (if (and (= (what at:(site)) (id "Queen" Mover)) (is In (where "Ball" Shared) (sites Around (site)))) (move (from (where "Ball" Shared)) (to (sites To (slide (from (where "Ball" Shared)) (directions Cell from:(site) to:(where "Ball" Shared)) (between if:(if (is In (site) (union (sites Bottom) (sites Top))) (and (is Empty (between)) (not (is In (between) (sites "Goals")))) (is Empty (between)))))))) (if (and (= (what at:(site)) (id "Rook" Mover)) (is In (where "Ball" Shared) (sites Around (site) Orthogonal))) (move (from (where "Ball" Shared)) (to (sites To (slide (from (where "Ball" Shared)) (directions Cell from:(site) to:(where "Ball" Shared)) (between if:(if (is In (site) (union (sites Bottom) (sites Top))) (and (is Empty (between)) (not (is In (between) (sites "Goals")))) (is Empty (between)))))))) (if (and (= (what at:(site)) (id "Bishop" Mover)) (is In (where "Ball" Shared) (sites Around (site) Diagonal))) (move (from (where "Ball" Shared)) (to (sites To (slide (from (where "Ball" Shared)) (directions Cell from:(site) to:(where "Ball" Shared)) (between if:(if (is In (site) (union (sites Bottom) (sites Top))) (and (is Empty (between)) (not (is In (between) (sites "Goals")))) (is Empty (between))))))))))))) (then (if (can Move (forEach Site (sites Around (where "Ball" Shared)) (if (and (= (what at:(site)) (id "Knight" Mover)) (is In (where "Ball" Shared) (sites Around (site)))) (move (from (where "Ball" Shared)) (to (sites To (leap (from (where "Ball" Shared)) {{F F R F} {F F L F}} (to if:(is Empty (to))))) if:(not (is In (to) (sites Around (site)))))) (if (and (= (what at:(site)) (id "King" Mover)) (is In (where "Ball" Shared) (sites Around (site)))) (move (from (where "Ball" Shared)) (to (sites To (step (from (where "Ball" Shared)) (directions Cell from:(site) to:(where "Ball" Shared)) (to if:(is Empty (to))))) if:(if (is In (site) (union (sites Bottom) (sites Top))) (not (is In (to) (sites "Goals"))) True))) (if (and (= (what at:(site)) (id "Queen" Mover)) (is In (where "Ball" Shared) (sites Around (site)))) (move (from (where "Ball" Shared)) (to (sites To (slide (from (where "Ball" Shared)) (directions Cell from:(site) to:(where "Ball" Shared)) (between if:(if (is In (site) (union (sites Bottom) (sites Top))) (and (is Empty (between)) (not (is In (between) (sites "Goals")))) (is Empty (between)))))))) (if (and (= (what at:(site)) (id "Rook" Mover)) (is In (where "Ball" Shared) (sites Around (site) Orthogonal))) (move (from (where "Ball" Shared)) (to (sites To (slide (from (where "Ball" Shared)) (directions Cell from:(site) to:(where "Ball" Shared)) (between if:(if (is In (site) (union (sites Bottom) (sites Top))) (and (is Empty (between)) (not (is In (between) (sites "Goals")))) (is Empty (between)))))))) (if (and (= (what at:(site)) (id "Bishop" Mover)) (is In (where "Ball" Shared) (sites Around (site) Diagonal))) (move (from (where "Ball" Shared)) (to (sites To (slide (from (where "Ball" Shared)) (directions Cell from:(site) to:(where "Ball" Shared)) (between if:(if (is In (site) (union (sites Bottom) (sites Top))) (and (is Empty (between)) (not (is In (between) (sites "Goals")))) (is Empty (between))))))))))))))) (and (set Pending) (moveAgain))))) (if (and (= (what at:(last To)) (id "Knight" Mover)) (is In (where "Ball" Shared) (sites Around (last To)))) (move (from (where "Ball" Shared)) (to (sites To (leap (from (where "Ball" Shared)) {{F F R F} {F F L F}} (to if:(is Empty (to))))) if:(not (is In (to) (sites Around (last To)))))) (if (and (= (what at:(last To)) (id "King" Mover)) (is In (where "Ball" Shared) (sites Around (last To)))) (move (from (where "Ball" Shared)) (to (sites To (step (from (where "Ball" Shared)) (directions Cell from:(last To) to:(where "Ball" Shared)) (to if:(is Empty (to))))) if:(if (is In (last To) (union (sites Bottom) (sites Top))) (not (is In (to) (sites "Goals"))) True))) (if (and (= (what at:(last To)) (id "Queen" Mover)) (is In (where "Ball" Shared) (sites Around (last To)))) (move (from (where "Ball" Shared)) (to (sites To (slide (from (where "Ball" Shared)) (directions Cell from:(last To) to:(where "Ball" Shared)) (between if:(if (is In (last To) (union (sites Bottom) (sites Top))) (and (is Empty (between)) (not (is In (between) (sites "Goals")))) (is Empty (between)))))))) (if (and (= (what at:(last To)) (id "Rook" Mover)) (is In (where "Ball" Shared) (sites Around (last To) Orthogonal))) (move (from (where "Ball" Shared)) (to (sites To (slide (from (where "Ball" Shared)) (directions Cell from:(last To) to:(where "Ball" Shared)) (between if:(if (is In (last To) (union (sites Bottom) (sites Top))) (and (is Empty (between)) (not (is In (between) (sites "Goals")))) (is Empty (between)))))))) (if (and (= (what at:(last To)) (id "Bishop" Mover)) (is In (where "Ball" Shared) (sites Around (last To) Diagonal))) (move (from (where "Ball" Shared)) (to (sites To (slide (from (where "Ball" Shared)) (directions Cell from:(last To) to:(where "Ball" Shared)) (between if:(if (is In (last To) (union (sites Bottom) (sites Top))) (and (is Empty (between)) (not (is In (between) (sites "Goals")))) (is Empty (between)))))))))))) (then (if (can Move (forEach Site (sites Around (where "Ball" Shared)) (if (and (= (what at:(site)) (id "Knight" Mover)) (is In (where "Ball" Shared) (sites Around (site)))) (move (from (where "Ball" Shared)) (to (sites To (leap (from (where "Ball" Shared)) {{F F R F} {F F L F}} (to if:(is Empty (to))))) if:(not (is In (to) (sites Around (site)))))) (if (and (= (what at:(site)) (id "King" Mover)) (is In (where "Ball" Shared) (sites Around (site)))) (move (from (where "Ball" Shared)) (to (sites To (step (from (where "Ball" Shared)) (directions Cell from:(site) to:(where "Ball" Shared)) (to if:(is Empty (to))))) if:(if (is In (site) (union (sites Bottom) (sites Top))) (not (is In (to) (sites "Goals"))) True))) (if (and (= (what at:(site)) (id "Queen" Mover)) (is In (where "Ball" Shared) (sites Around (site)))) (move (from (where "Ball" Shared)) (to (sites To (slide (from (where "Ball" Shared)) (directions Cell from:(site) to:(where "Ball" Shared)) (between if:(if (is In (site) (union (sites Bottom) (sites Top))) (and (is Empty (between)) (not (is In (between) (sites "Goals")))) (is Empty (between)))))))) (if (and (= (what at:(site)) (id "Rook" Mover)) (is In (where "Ball" Shared) (sites Around (site) Orthogonal))) (move (from (where "Ball" Shared)) (to (sites To (slide (from (where "Ball" Shared)) (directions Cell from:(site) to:(where "Ball" Shared)) (between if:(if (is In (site) (union (sites Bottom) (sites Top))) (and (is Empty (between)) (not (is In (between) (sites "Goals")))) (is Empty (between)))))))) (if (and (= (what at:(site)) (id "Bishop" Mover)) (is In (where "Ball" Shared) (sites Around (site) Diagonal))) (move (from (where "Ball" Shared)) (to (sites To (slide (from (where "Ball" Shared)) (directions Cell from:(site) to:(where "Ball" Shared)) (between if:(if (is In (site) (union (sites Bottom) (sites Top))) (and (is Empty (between)) (not (is In (between) (sites "Goals")))) (is Empty (between))))))))))))))) (and (set Pending) (moveAgain)))))) (move Pass)) (or (forEach Piece (then (if (can Move (if (and (= (what at:(last To)) (id "Knight" Mover)) (is In (where "Ball" Shared) (sites Around (last To)))) (move (from (where "Ball" Shared)) (to (sites To (leap (from (where "Ball" Shared)) {{F F R F} {F F L F}} (to if:(is Empty (to))))) if:(not (is In (to) (sites Around (last To)))))) (if (and (= (what at:(last To)) (id "King" Mover)) (is In (where "Ball" Shared) (sites Around (last To)))) (move (from (where "Ball" Shared)) (to (sites To (step (from (where "Ball" Shared)) (directions Cell from:(last To) to:(where "Ball" Shared)) (to if:(is Empty (to))))) if:(if (is In (last To) (union (sites Bottom) (sites Top))) (not (is In (to) (sites "Goals"))) True))) (if (and (= (what at:(last To)) (id "Queen" Mover)) (is In (where "Ball" Shared) (sites Around (last To)))) (move (from (where "Ball" Shared)) (to (sites To (slide (from (where "Ball" Shared)) (directions Cell from:(last To) to:(where "Ball" Shared)) (between if:(if (is In (last To) (union (sites Bottom) (sites Top))) (and (is Empty (between)) (not (is In (between) (sites "Goals")))) (is Empty (between)))))))) (if (and (= (what at:(last To)) (id "Rook" Mover)) (is In (where "Ball" Shared) (sites Around (last To) Orthogonal))) (move (from (where "Ball" Shared)) (to (sites To (slide (from (where "Ball" Shared)) (directions Cell from:(last To) to:(where "Ball" Shared)) (between if:(if (is In (last To) (union (sites Bottom) (sites Top))) (and (is Empty (between)) (not (is In (between) (sites "Goals")))) (is Empty (between)))))))) (if (and (= (what at:(last To)) (id "Bishop" Mover)) (is In (where "Ball" Shared) (sites Around (last To) Diagonal))) (move (from (where "Ball" Shared)) (to (sites To (slide (from (where "Ball" Shared)) (directions Cell from:(last To) to:(where "Ball" Shared)) (between if:(if (is In (last To) (union (sites Bottom) (sites Top))) (and (is Empty (between)) (not (is In (between) (sites "Goals")))) (is Empty (between)))))))))))))) (moveAgain)))) (forEach Site (sites Around (where "Ball" Shared)) (if (and (= (what at:(site)) (id "Knight" Mover)) (is In (where "Ball" Shared) (sites Around (site)))) (move (from (where "Ball" Shared)) (to (sites To (leap (from (where "Ball" Shared)) {{F F R F} {F F L F}} (to if:(is Empty (to))))) if:(not (is In (to) (sites Around (site)))))) (if (and (= (what at:(site)) (id "King" Mover)) (is In (where "Ball" Shared) (sites Around (site)))) (move (from (where "Ball" Shared)) (to (sites To (step (from (where "Ball" Shared)) (directions Cell from:(site) to:(where "Ball" Shared)) (to if:(is Empty (to))))) if:(if (is In (site) (union (sites Bottom) (sites Top))) (not (is In (to) (sites "Goals"))) True))) (if (and (= (what at:(site)) (id "Queen" Mover)) (is In (where "Ball" Shared) (sites Around (site)))) (move (from (where "Ball" Shared)) (to (sites To (slide (from (where "Ball" Shared)) (directions Cell from:(site) to:(where "Ball" Shared)) (between if:(if (is In (site) (union (sites Bottom) (sites Top))) (and (is Empty (between)) (not (is In (between) (sites "Goals")))) (is Empty (between)))))))) (if (and (= (what at:(site)) (id "Rook" Mover)) (is In (where "Ball" Shared) (sites Around (site) Orthogonal))) (move (from (where "Ball" Shared)) (to (sites To (slide (from (where "Ball" Shared)) (directions Cell from:(site) to:(where "Ball" Shared)) (between if:(if (is In (site) (union (sites Bottom) (sites Top))) (and (is Empty (between)) (not (is In (between) (sites "Goals")))) (is Empty (between)))))))) (if (and (= (what at:(site)) (id "Bishop" Mover)) (is In (where "Ball" Shared) (sites Around (site) Diagonal))) (move (from (where "Ball" Shared)) (to (sites To (slide (from (where "Ball" Shared)) (directions Cell from:(site) to:(where "Ball" Shared)) (between if:(if (is In (site) (union (sites Bottom) (sites Top))) (and (is Empty (between)) (not (is In (between) (sites "Goals")))) (is Empty (between))))))))))))) (then (if (can Move (forEach Site (sites Around (where "Ball" Shared)) (if (and (= (what at:(site)) (id "Knight" Mover)) (is In (where "Ball" Shared) (sites Around (site)))) (move (from (where "Ball" Shared)) (to (sites To (leap (from (where "Ball" Shared)) {{F F R F} {F F L F}} (to if:(is Empty (to))))) if:(not (is In (to) (sites Around (site)))))) (if (and (= (what at:(site)) (id "King" Mover)) (is In (where "Ball" Shared) (sites Around (site)))) (move (from (where "Ball" Shared)) (to (sites To (step (from (where "Ball" Shared)) (directions Cell from:(site) to:(where "Ball" Shared)) (to if:(is Empty (to))))) if:(if (is In (site) (union (sites Bottom) (sites Top))) (not (is In (to) (sites "Goals"))) True))) (if (and (= (what at:(site)) (id "Queen" Mover)) (is In (where "Ball" Shared) (sites Around (site)))) (move (from (where "Ball" Shared)) (to (sites To (slide (from (where "Ball" Shared)) (directions Cell from:(site) to:(where "Ball" Shared)) (between if:(if (is In (site) (union (sites Bottom) (sites Top))) (and (is Empty (between)) (not (is In (between) (sites "Goals")))) (is Empty (between)))))))) (if (and (= (what at:(site)) (id "Rook" Mover)) (is In (where "Ball" Shared) (sites Around (site) Orthogonal))) (move (from (where "Ball" Shared)) (to (sites To (slide (from (where "Ball" Shared)) (directions Cell from:(site) to:(where "Ball" Shared)) (between if:(if (is In (site) (union (sites Bottom) (sites Top))) (and (is Empty (between)) (not (is In (between) (sites "Goals")))) (is Empty (between)))))))) (if (and (= (what at:(site)) (id "Bishop" Mover)) (is In (where "Ball" Shared) (sites Around (site) Diagonal))) (move (from (where "Ball" Shared)) (to (sites To (slide (from (where "Ball" Shared)) (directions Cell from:(site) to:(where "Ball" Shared)) (between if:(if (is In (site) (union (sites Bottom) (sites Top))) (and (is Empty (between)) (not (is In (between) (sites "Goals")))) (is Empty (between))))))))))))))) (and (set Pending) (moveAgain)))))))) (end {(if (= (where "Ball" Shared) (mapEntry P1)) (result P1 Win)) (if (= (where "Ball" Shared) (mapEntry P2)) (result P2 Win))}))) 
Starting with the runner player, players alternate moving one of their checker tokens. Each token moves in one orthogonal direction only. Runner tokens move vertically from the first rank, either by moving into an adjacent empty space or by jumping over an adjacent opponent token into an empty space and capturing the jumped token. Blocker tokens move horizontally in a similar manner - the left tokens always move toward the right and the right tokens always move towards the left. In the standard/introductory game, played on an 8x8 board, captures are mandatory and multiple capture are possible with maximum capture sequences having priority. In tournament games, played on a 10 x 10 board, captures are optional. Blocker tokens may not jump over or capture other blocker tokens. The game ends when a runner token reaches the last rank or the runner player cannot move. Two games should be played, with players swapping roles. At the end of each game, the runner player scores the rank/row of each of his or her remaining tokens on the board. The player with the highest score after two games wins the match. 8 x 8 board Forced captures
(game "Gauntlet" (players {(player N) (player W)}) (equipment {(board (square 8)) (piece "Counter" Each) (piece "DoubleCounter" Each) (regions "RunnerGoal" P1 (difference (sites Top) (sites Corners))) (regions "RunnerGoalRed" Neutral (intersection (difference (sites Top) (sites Corners)) (sites Phase 0))) (regions "RunnerGoalPink" Neutral (intersection (difference (sites Top) (sites Corners)) (sites Phase 1)))}) (rules (start {(place "Counter1" (difference (sites Bottom) (sites Corners))) (place "DoubleCounter2" (difference (sites Left) (sites Corners))) (place "Counter2" (difference (sites Right) (sites Corners)))}) (play (priority {(max Moves (or (forEach Piece "Counter" (move Hop (from (from)) Forward (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) Forward (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))))) (moveAgain))))) (forEach Piece "DoubleCounter" (move Hop (from (from)) Backward (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) Backward (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))))) (moveAgain))))))) (or (forEach Piece "Counter" (move Step (directions Forward) (to if:(is Empty (to))))) (forEach Piece "DoubleCounter" (move Step (directions Backward) (to if:(is Empty (to))))))})) (end {(if (no Moves Next) (result Next Loss)) (if (is In (last To) (sites Mover)) (result Mover Win))}))) 
5x5 square. Nine squares are marked: the four central squares of each side, the central square of the board, and the squares which are diagonally between them. Two or four players; each player begins on one of the marked outer squares, beginning on opposite sides if two are playing. Players use one or two cowries as pieces. Four or five cowries are used as dice, with the value of the throw equalling the number of mouths which land face up. Players proceed in a clockwise direction around the board, until they reach the space before the one in which they began, moving to the marked square to the right of the direction of play, and proceeding around the inner square of spaces in an anti-clockwise direction, until arriving at the central space. When a player's piece lands on a space occupied by the opposing player, the opponent's piece is sent back to the starting point. The first player to bring all their pieces to the central square wins. The game involves 4 players. The game involves 2 pieces per player. The game involves 4 dice.
(game "Gavalata" (players 4) (equipment {(board (square 5) {(track "Track1" "2,W,N,E,S,W1,N3,W2,S2,E1,N1" P1 directed:True) (track "Track2" "22,E,S,W,N,E1,S3,E2,N2,W1,S1" P2 directed:True) (track "Track3" "14,S,W,N,E,S1,W3,S2,E2,N1,W1" P3 directed:True) (track "Track4" "10,N,E,S,W,N1,E3,N2,W2,S1,E1" P4 directed:True)}) (dice d:2 from:0 num:4) (piece "Paddle" Each (if (!= (trackSite Move steps:(count Pips)) -1) (move (from (from) level:(level)) (to (trackSite Move steps:(count Pips)) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry (who at:(to)))))))) (then (if (= 12 (last To)) (remove (last To)))))) (map {(pair 1 "C1") (pair 2 "C5") (pair 3 "E3") (pair 4 "A3")})}) (rules (start {(place Stack "Paddle1" (mapEntry 1) count:2) (place Stack "Paddle2" (mapEntry 2) count:2) (place Stack "Paddle3" (mapEntry 3) count:2) (place Stack "Paddle4" (mapEntry 4) count:2)}) (play (do (roll) next:(if (!= 0 (count Pips)) (forEach Piece) (move Pass)))) (end (if (no Pieces Mover) (result Mover Win))))) 
Geister is a two-player board game on a 6×6 game board. Each player has four good ghosts and four evil ghosts, whose type is not revealed to the opponent player. In each turn a player can move one of his ghosts one step vertically or horizontally. Moving into a square containing an opponent's ghost will capture the opponent's ghost and move it off from the board. Moving into a square containing an ally ghost is not allowed. A player can also move off one of his good ghosts from one of the opponent's corner squares. A player wins when one of the three conditions is satisfied: • All the player's evil ghosts are captured. • All the opponent's good ghosts are captured. • One of the player's good ghosts is moved off the board from one of the opponent's corner squares.
(game "Geister" (players 2) (equipment {(board (square 6)) (hand Each size:2) (piece "GhostGood" Each) (piece "GhostEvil" Each) (regions "HomeP1" P1 (difference (expand (sites Bottom) steps:1) (union (sites Side E) (sites Side W)))) (regions "HomeP2" P2 (difference (expand (sites Top) steps:1) (union (sites Side E) (sites Side W)))) (regions "EscapeP1" P1 {30 35}) (regions "EscapeP2" P2 {0 5}) (map "Where" {(pair (id "GhostGood" P1) (handSite P1)) (pair (id "GhostEvil" P1) (handSite P1 1)) (pair (id "GhostGood" P2) (handSite P2)) (pair (id "GhostEvil" P2) (handSite P2 1))})}) (rules (start {(place "GhostGood1" 36 count:4) (place "GhostEvil1" 37 count:4) (set Hidden (sites Hand P1) to:P2) (place "GhostGood2" 38 count:4) (place "GhostEvil2" 39 count:4) (set Hidden (sites Hand P2) to:P1)}) phases:{(phase "Placement" (play (move (from (sites Occupied by:Mover container:(mover))) (to (forEach (sites Mover "Home") if:(is Empty (site)))) (then (if (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) (and {(set Hidden (sites P2 "Home") False to:P1) (set Hidden (sites P1 "Home") False to:P2) (set Hidden What (sites P2 "Home") to:P1) (set Hidden What (sites P1 "Home") to:P2)}))))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece {"GhostGood" "GhostEvil"} (or (move Step Orthogonal (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (add (piece (what at:(to))) (to (mapEntry "Where" (what at:(to))))))))) (move Select (from (intersection (sites Occupied by:Mover component:"GhostGood") (sites Mover "Escape"))) (then (trigger "Escaped" (mover))))))) (end {(if (or {(no Pieces Mover "GhostEvil" in:(sites Board)) (no Pieces Next "GhostGood" in:(sites Board)) (is Triggered "Escaped" Mover)}) (result Mover Win)) (if (or (no Pieces Next "GhostEvil" in:(sites Board)) (no Pieces Mover "GhostGood" in:(sites Board))) (result Mover Loss))}))})) 
10x10 board. Each player has one piece and move according to the roll of one die. Representations of snakes and ladders are scattered throughout the board, connecting two spaces. If a player lands at the bottom of the ladder at the end of their move, they advance to the space at the top of the ladder. If a player ends their turn on a space with the head of a snake, they move down to the space with the tail of the snake. The first player to move off the last space of the board wins.
(game "Gyan Chaupar" (players 4) (equipment {(board (square 10) (track "Track" "0,E,N1,W,N1,E,N1,W,N1,E,N1,W,N1,E,N1,W,N1,E,N1,W" directed:True)) (piece "Pawn" Each (move (from (from) level:(level)) (to (mapEntry (trackSite Move steps:(count Pips)))))) (dice num:1) (map {(pair "B1" "C4") (pair "D1" "G2") (pair "H1" "J4") (pair "A3" "B5") (pair "E4" "D5") (pair "H3" "D9") (pair "J8" "J10") (pair "A8" "A10") (pair "J6" "G7") (pair "B7" "C2") (pair "G5" "F3") (pair "E2" "F1") (pair "D7" "A6") (pair "C10" "C8") (pair "H10" "H8") (pair "E10" "E8") (pair "G9" "D3") (pair "H6" "E6") (pair "I5" "J2")})}) (rules (start (place Stack items:{"Pawn4" "Pawn3" "Pawn2" "Pawn1"} coord:"A1")) (play (do (roll) next:(forEach Piece))) (end (if (is In (last To) (sites {(trackSite EndSite)})) (result Mover Win))))) 
The board is drawn in the sand, with any large number of holes in a spiral pattern. The starting point is before the first hole in the outer ring of the spiral, and is made as a mound of sand; the goal is another mound of sand at the center of the spiral. Each player has one piece, which they place on the starting mound. Another piece, the hyena, also begins on the starting mound. Four throwing sticks, with a black side and a white side, used as dice. The values of the throws are as follows: four white sides = 20; three white sides = 5; two white sides = 0; one white sides = 9; all black sides = 80. Players throw, move, and throw again until they throw a 0. When a player reaches the goal, they then play as the hyena on their turn. When the hyena catches up to another player's piece, it drags the piece with it, until throwing a 0. When a 0 is thrown, the player moves back to the place where they were before the hyena dragged them, and must overtake the hyena in this turn. If the player cannot, they are removed from the game. If the player is overtaken by the hyena a second time, they are removed from the game.  The game has 4 players.
(game "Ishighan" (players 4) (equipment {(board (spiral turns:5 sites:86) {(track "Track" {86 85 84 83 82 81 80 79 78 77 76 75 74 73 72 71 70 69 68 67 66 65 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0} directed:True)} use:Vertex) (dice d:2 from:0 num:4) (map "Throw" {(pair 0 20) (pair 1 5) (pair 2 0) (pair 3 9) (pair 4 80)}) (piece "Stick" Each (if (= (trackSite Move "Track" steps:(mapEntry "Throw" (count Pips))) -1) (move (from (from) level:(level)) (to 0) (then (if (= 1 (value Player Mover)) (forEach Site (sites Track "Track" from:(last From) to:(last To)) (forEach Level (site) FromTop (if (= (what at:(site) level:(level)) (id "Hyena" Neutral)) (set Value Mover 2))))))) (move (from (from) level:(level)) (to (trackSite Move "Track" steps:(mapEntry "Throw" (count Pips))) if:True) (then (if (= 1 (value Player Mover)) (forEach Site (sites Track "Track" from:(last From) to:(last To)) (forEach Level (site) FromTop (if (= (what at:(site) level:(level)) (id "Hyena" Neutral)) (set Value Mover 2)))))))) maxState:85) (piece "Hyena" Neutral) (hand P1)}) (rules (start {(place Stack items:{"Stick4" "Stick3" "Stick2" "Stick1"} (handSite P1)) (place Stack "Hyena0" (handSite P1))}) (play (do (roll) next:(if (= 0 (where "Stick" Mover)) (if (!= (mapEntry "Throw" (count Pips)) 0) (move (from (if (!= (where "Hyena" Neutral) -1) (where "Hyena" Neutral) (handSite P1)) level:(where Level "Hyena" Neutral at:(if (!= (where "Hyena" Neutral) -1) (where "Hyena" Neutral) (handSite P1)))) (to (trackSite Move from:(if (!= (where "Hyena" Neutral) -1) (where "Hyena" Neutral) (handSite P1)) "Track" steps:(mapEntry "Throw" (count Pips)))) (then (if (= (last To) 0) (forEach Site (sites Track "Track" from:(last From) to:(last To)) (if (!= (site) (last To)) (forEach Level (site) FromTop (remove (site) level:(level))))) (forEach Site (sites Track "Track" from:(last From) to:(last To)) (if (!= (site) (last To)) (forEach Level (site) FromTop (fromTo (from (site) level:(level)) (to (last To) (apply (if (and (= 0 (state at:(site) level:(level))) (!= 0 (who at:(site) level:(level)))) (if (<= (site) (- (count Vertices) 1)) (set State at:(site) level:(level) (site))))))))))))) (move Pass (then (forEach Site (sites Board) (forEach Level (site) FromTop (if (!= 0 (state at:(site) level:(level))) (if (< 0 (value Player (who at:(site) level:(level)))) (remove (site) level:(level)) (fromTo (from (site) level:(level)) (to (state at:(site) level:(level)) (apply (and (set State at:(site) level:(level) 0) (set Value (player (who at:(site) level:(level))) 1)))))))))))) (if (!= (mapEntry "Throw" (count Pips)) 0) (or (forEach Piece) (forEach Piece container:1)) (move Pass (then (if (= 1 (value Player Mover)) (remove (where "Stick" Mover) level:(where Level "Stick" Neutral at:(where "Stick" Mover)))))))) (then (if (!= (mapEntry "Throw" (count Pips)) 0) (moveAgain))))) (end {(forEach Player if:(no Pieces Player) (result Player Loss)) (forEach Player if:(or (= (if (!= (where "Hyena" Neutral) -1) (where "Hyena" Neutral) (handSite P1)) 0) (and {(is Occupied 0) (>= 1 (count Sites in:(difference (sites Occupied by:All) (if (!= (where "Hyena" Neutral) -1) (where "Hyena" Neutral) (handSite P1))))) (= 1 (size Stack at:(if (!= (where "Hyena" Neutral) -1) (where "Hyena" Neutral) (handSite P1))))})) (result Player Win))}))) 
9x9 board. Nine horse-shaped pieces per player. Pieces begin in the spaces along opposite sides of the board. Pieces move orthogonally one space and then diagonally another, jumping over any intervening pieces. A player may capture one of the opponent's pieces by moving onto a space occupied by the opponent's piece. The goal is to move to the central space on the board. To win a knight as to reach the central square.
(game "Jeson Mor" (players 2) (equipment {(board (square 9)) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))}) (rules (start {(place "Knight1" (sites Bottom)) (place "Knight2" (sites Top))}) (play (forEach Piece)) (end {(if (no Pieces Next) (result Mover Win)) (if (is In (last To) (sites Centre)) (result Mover Win))}))) 
Each turn consists of moving a piece one square orthogonally in any direction. An animal may eat any animal smaller than itself by moving on to its square. The only exception to this rule is that the rat can kill the elephant. If the same animals meet, the animal moving on to a square eats the animal already there. Three pieces have special powers. When the rat reaches the river it can enter it and move along those squares squares as if it were any other. If it is in the river no other animal can attack it. The rat is unable to attack the elephant from the river. If both rats meet in the river the moving piece eats the other one. When a lion or a tiger reaches a square on the edge of the river, at the next move it can jump over the river in any orthogonal direction, landing on the nearest land square. It captures any smaller animal on that square: if, however, there is a rat in the river in the line of the jump, it blocks this move. Each side has three trap-squares and the player's own pieces may move on and off them without restriction, but if an enemy animal occupies a trap-square, it loses all its power and becomes weaker than any defending piece. As soon as it moves out of the trap it regains its full strength. A player may not move any of his animals on to his own den. The player who moves any of their pieces into the enemy's den wins.
(game "Jungle" (players 2) (equipment {(board (rectangle 9 7)) (piece "Elephant" Each (move Step Orthogonal (to if:(and (is In (to) (difference (union (sites Occupied by:Next) (sites Empty)) (union (sites "Water") (sites Mover)))) (<= (state at:(to)) (state at:(from)))) (apply (remove (to)))))) (piece "Lion" Each (or {(move Step Orthogonal (to if:(and (is In (to) (difference (union (sites Occupied by:Next) (sites Empty)) (union (sites "Water") (sites Mover)))) (<= (state at:(to)) (state at:(from)))) (apply (remove (to))))) (move Hop (directions {W E}) (between (max 2) if:(is In (between) (forEach (sites "Water") if:(is Empty (site)))) (apply (remove (between)))) (to if:(and {(not (is In (to) (sites "Water"))) (not (is Friend (who at:(to)))) (<= (state at:(to)) (state at:(from)))}))) (move Hop (directions {N S}) (between (max 3) if:(is In (between) (forEach (sites "Water") if:(is Empty (site)))) (apply (remove (between)))) (to if:(and {(not (is In (to) (sites "Water"))) (not (is Friend (who at:(to)))) (<= (state at:(to)) (state at:(from)))})))})) (piece "Tiger" Each (or {(move Step Orthogonal (to if:(and (is In (to) (difference (union (sites Occupied by:Next) (sites Empty)) (union (sites "Water") (sites Mover)))) (<= (state at:(to)) (state at:(from)))) (apply (remove (to))))) (move Hop (directions {W E}) (between (max 2) if:(is In (between) (forEach (sites "Water") if:(is Empty (site)))) (apply (remove (between)))) (to if:(and {(not (is In (to) (sites "Water"))) (not (is Friend (who at:(to)))) (<= (state at:(to)) (state at:(from)))}))) (move Hop (directions {N S}) (between (max 3) if:(is In (between) (forEach (sites "Water") if:(is Empty (site)))) (apply (remove (between)))) (to if:(and {(not (is In (to) (sites "Water"))) (not (is Friend (who at:(to)))) (<= (state at:(to)) (state at:(from)))})))})) (piece "Leopard" Each (move Step Orthogonal (to if:(and (is In (to) (difference (union (sites Occupied by:Next) (sites Empty)) (union (sites "Water") (sites Mover)))) (<= (state at:(to)) (state at:(from)))) (apply (remove (to)))))) (piece "Dog" Each (move Step Orthogonal (to if:(and (is In (to) (difference (union (sites Occupied by:Next) (sites Empty)) (union (sites "Water") (sites Mover)))) (<= (state at:(to)) (state at:(from)))) (apply (remove (to)))))) (piece "Wolf" Each (move Step Orthogonal (to if:(and (is In (to) (difference (union (sites Occupied by:Next) (sites Empty)) (union (sites "Water") (sites Mover)))) (<= (state at:(to)) (state at:(from)))) (apply (remove (to)))))) (piece "Cat" Each (move Step Orthogonal (to if:(and (is In (to) (difference (union (sites Occupied by:Next) (sites Empty)) (union (sites "Water") (sites Mover)))) (<= (state at:(to)) (state at:(from)))) (apply (remove (to)))))) (piece "Rat" Each (move Step Orthogonal (to if:(and (is In (to) (difference (union (sites Occupied by:Next) (sites Empty)) (sites Mover))) (or (<= (state at:(to)) (state at:(from))) (and (not (is In (from) (sites "Water"))) (= (what at:(to)) (id "Elephant" Next))))) (apply (remove (to)))))) (regions "Water" (sites {"B4" "C4" "B5" "C5" "B6" "C6" "E4" "F4" "E5" "F5" "E6" "F6"})) (regions "Trap" (sites {"C1" "E1" "D2" "D8" "C9" "E9"})) (regions "Den" P1 (sites {"D1"})) (regions "Den" P2 (sites {"D9"})) (map {(pair 1 8) (pair 2 8) (pair 3 7) (pair 4 7) (pair 5 6) (pair 6 6) (pair 7 5) (pair 8 5) (pair 9 4) (pair 10 4) (pair 11 3) (pair 12 3) (pair 13 2) (pair 14 2) (pair 15 1) (pair 16 1)})}) (rules (start {(place "Rat1" coord:"G3" state:1) (place "Rat2" coord:"A7" state:1) (place "Cat1" coord:"B2" state:2) (place "Cat2" coord:"F8" state:2) (place "Wolf1" coord:"C3" state:3) (place "Wolf2" coord:"E7" state:3) (place "Dog1" coord:"F2" state:4) (place "Dog2" coord:"B8" state:4) (place "Leopard1" coord:"E3" state:5) (place "Leopard2" coord:"C7" state:5) (place "Tiger1" coord:"A1" state:6) (place "Tiger2" coord:"G9" state:6) (place "Lion1" coord:"G1" state:7) (place "Lion2" coord:"A9" state:7) (place "Elephant1" coord:"A3" state:8) (place "Elephant2" coord:"G7" state:8)}) (play (forEach Piece (then (and (if (is In (last From) (sites "Trap")) (set State at:(last To) (mapEntry (what at:(last To))))) (if (is In (last To) (sites "Trap")) (set State at:(last To) 0)))))) (end (if (is In (last To) (sites Next)) (result Mover Win))))) 
Forty stones, arranged in a circle, with larger gaps (doors) between the stones after every ten. The gaps between the stones are the playing spaces. Any number of players. One stick per player. Three sticks used as dice, one marked with two notches, one marked with three notches, the other marked with ten notches. The value of the throw is the number of notches which land face up. Players move their sticks around the board, beginning at one of the doors. Players may choose in which direction to proceed around the board. When a player lands on the same space as an opponent, the opponent's piece is sent back to the starting door. The first player to complete the circuit of the board wins. The game has 2 players.
(game "Kawasukuts" (players 2) (equipment {(board (add (remove (concentric {44}) vertices:{43 21 0 22}) edges:{{20 18} {0 1} {19 21} {38 39}}) {(track "TrackCW" {39 35 33 31 29 27 25 23 21 19 38 17 15 13 11 9 7 5 3 1 37 0 2 4 6 8 10 12 14 16 36 18 20 22 24 26 28 30 32 34} loop:True) (track "TrackCCW" {39 34 32 30 28 26 24 22 20 18 36 16 14 12 10 8 6 4 2 0 37 1 3 5 7 9 11 13 15 17 38 19 21 23 25 27 29 31 33 35} loop:True)} use:Edge) (regions "Gates" (sites {36 37 38 39})) (piece "Marker" Each (if (= (value Player Mover) -1) (or (if (!= (trackSite Move "TrackCW" steps:(count Pips)) -1) (if (or (is In (trackSite Move "TrackCW" steps:(count Pips)) (sites Empty)) (is Enemy (who at:(trackSite Move "TrackCW" steps:(count Pips))))) (move (from (from) level:(level)) (to (trackSite Move "TrackCW" steps:(count Pips)) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (value Piece at:(to)))))))) (then (if (= (value Player Mover) -1) (set Value Mover 1)))) (if (!= (trackSite Move "TrackCCW" steps:(count Pips)) -1) (if (or (is In (trackSite Move "TrackCCW" steps:(count Pips)) (sites Empty)) (is Enemy (who at:(trackSite Move "TrackCCW" steps:(count Pips))))) (move (from (from) level:(level)) (to (trackSite Move "TrackCCW" steps:(count Pips)) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (value Piece at:(to)))))))) (then (if (= (value Player Mover) -1) (set Value Mover 2))))) (if (!= (if (= (value Player Mover) 2) (trackSite Move "TrackCCW" steps:(count Pips)) (trackSite Move "TrackCW" steps:(count Pips))) -1) (if (or (is In (if (= (value Player Mover) 2) (trackSite Move "TrackCCW" steps:(count Pips)) (trackSite Move "TrackCW" steps:(count Pips))) (sites Empty)) (is Enemy (who at:(if (= (value Player Mover) 2) (trackSite Move "TrackCCW" steps:(count Pips)) (trackSite Move "TrackCW" steps:(count Pips)))))) (move (from (from) level:(level)) (to (if (= (value Player Mover) 2) (trackSite Move "TrackCCW" steps:(count Pips)) (trackSite Move "TrackCW" steps:(count Pips))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (value Piece at:(to))))))))))) (dice d:2 facesByDie:{{0 2} {0 3} {0 10}} num:3) (hand Each)}) (rules (start (place "Marker" "Hand")) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites "Gates")) (then (set Value at:(last To) (last To))))) (nextPhase Mover "Playing")) (phase "Playing" (play (do (roll) next:(forEach Piece))) (end (if (and (!= 0 (count Pips)) (if (= 1 (value Player Mover)) (is In (value Piece at:(where "Marker" Mover)) (sites Track "TrackCW" from:(trackSite Move from:(last From) "TrackCW" steps:1) to:(last To))) (is In (value Piece at:(where "Marker" Mover)) (sites Track "TrackCCW" from:(trackSite Move from:(last From) "TrackCCW" steps:1) to:(last To))))) (result Mover Win))))})) 
King's Valley is a very simple and easy game to play. This is because all the pieces move the same. Any piece can move straight horizontal, vertical or diagonal, but always as far as possible. Pieces always stop their movement either at the sides of the board or before another piece in the same row, column, or diagonal. The winner is the first player that manages to move his king piece to the central square of the board, which represents the King's Valley.
(game "King's Valley" (players 2) (equipment {(board (square 5)) (piece "Disc" Each (move (from) (to (sites LineOfSight Farthest at:(from))))) (piece "King" Each (move (from) (to (sites LineOfSight Farthest at:(from)))))}) (rules (start {(place "King1" (intersection (sites Bottom) (sites Column 2))) (place "King2" (intersection (sites Top) (sites Column 2))) (place "Disc1" (difference (sites Bottom) (sites Column 2))) (place "Disc2" (difference (sites Top) (sites Column 2)))}) (play (forEach Piece)) (end (if (is In (where "King" Mover) (sites Centre)) (result Mover Win))))) 
Pieces move as knights in Chess. The goal is to be the first player to reach the opposite side of the board from the starting position.
(game "Knightthrough" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} forward:True (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (regions P1 (sites Top)) (regions P2 (sites Bottom))}) (rules (start {(place "Knight1" (expand (sites Bottom))) (place "Knight2" (expand (sites Top)))}) (play (forEach Piece)) (end (if (is In (last To) (sites Mover)) (result Mover Win))))) 
The board is a square spiral of any number of spaces. Each player begins with one piece. Three casting sticks, each with a round and a flat side, are used as dice. The throws are as follows: One flat side up = 1; two flat sides up = 2; three flat sides up = 4, zero flat sides up = 6. The pieces begin on the outer end of the track, and must throw a 1 to begin play. Once a player has left the starting spot, they move according to the throws, except on throws of 1, which are tabulated for use later. Players continue to throw until they throw 2. Players must land on the last space of the track, I.e. at the center of the spiral, by an exact throw. The player must then roll 1 five times before leaving this space and proceeding back to the starting point. Accumulated rolls of 1 may be used for this. The first player to reach the starting space by an exact throw releases the hyena. The hyena proceeds along the track in the same manner, but moving twice the value of each throw. When the hyena reaches the end of the track, it must throw or pay 1 ten times. The hyena captures any piece it overtakes on the return to the starting space, eliminating that player from the game. The game has 4 players.
(game "Li'b el-Merafib" (players 4) (equipment {(board (merge {(shift 4 4 (rectangle 2 1)) (shift 4 4 (rectangle 1 4)) (shift 7 4 (rectangle 4 1)) (shift 2 7 (rectangle 1 6)) (shift 2 2 (rectangle 6 1)) (shift 2 2 (rectangle 1 8)) (shift 9 2 (rectangle 8 1)) (shift 0 9 (rectangle 1 10)) (rectangle 10 1) (rectangle 1 12) (shift 11 0 (rectangle 12 1)) (shift 0 11 (rectangle 1 12))}) {(track "Track" "73,E,S,W,N,E,S,W,N,E,S,W,N" directed:True) (track "ReverseTrack" "0,E,N,W,S,E,N,W,S,E,N,W" directed:True)}) (dice d:2 from:0 num:3) (piece "Stick" Each (if (= (from) 2) (if (= 4 (state at:(from) level:(level))) (move (from (from) level:(level)) (to 0)) (if (= (mapEntry "Throw" (count Pips)) 1) (move Select (from (from) level:(level)) (then (set State at:(last To) level:(last LevelTo) (+ 1 (state at:(last To) level:(last LevelTo)))))) (if (is In 1 (if (is Mover P1) (values Remembered "TabulatedP1") (if (is Mover P2) (values Remembered "TabulatedP2") (if (is Mover P3) (values Remembered "TabulatedP3") (if (is Mover P4) (values Remembered "TabulatedP4") (if (is Mover P5) (values Remembered "TabulatedP5") (if (is Mover P6) (values Remembered "TabulatedP6") (if (is Mover P7) (values Remembered "TabulatedP7") (values Remembered "TabulatedP8"))))))))) (move Select (from (from) level:(level)) (then (and (set State at:(last To) level:(last LevelTo) (+ 1 (state at:(last To) level:(last LevelTo)))) (if (is Mover P1) (forget Value "TabulatedP1" 1) (if (is Mover P2) (forget Value "TabulatedP2" 1) (if (is Mover P3) (forget Value "TabulatedP3" 1) (if (is Mover P4) (forget Value "TabulatedP4" 1) (if (is Mover P5) (forget Value "TabulatedP5" 1) (if (is Mover P6) (forget Value "TabulatedP6" 1) (if (is Mover P7) (forget Value "TabulatedP7" 1) (forget Value "TabulatedP8" 1)))))))))))))) (if (and {(= 0 (state at:(from) level:(level))) (= (from) 0) (is In 1 (if (is Mover P1) (values Remembered "TabulatedP1") (if (is Mover P2) (values Remembered "TabulatedP2") (if (is Mover P3) (values Remembered "TabulatedP3") (if (is Mover P4) (values Remembered "TabulatedP4") (if (is Mover P5) (values Remembered "TabulatedP5") (if (is Mover P6) (values Remembered "TabulatedP6") (if (is Mover P7) (values Remembered "TabulatedP7") (values Remembered "TabulatedP8")))))))))}) (move (from (from) level:(level)) (to 2) (then (if (is Mover P1) (forget Value "TabulatedP1" 1) (if (is Mover P2) (forget Value "TabulatedP2" 1) (if (is Mover P3) (forget Value "TabulatedP3" 1) (if (is Mover P4) (forget Value "TabulatedP4" 1) (if (is Mover P5) (forget Value "TabulatedP5" 1) (if (is Mover P6) (forget Value "TabulatedP6" 1) (if (is Mover P7) (forget Value "TabulatedP7" 1) (forget Value "TabulatedP8" 1)))))))))) (if (= (from) 73) (move (from (from) level:(level) if:(= (mapEntry "Throw" (count Pips)) 1)) (to (trackSite Move from:(from) "Track" steps:(mapEntry "Throw" (count Pips))))) (if (= 0 (state at:(from) level:(level))) (if (not (= (mapEntry "Throw" (count Pips)) 1)) (move (from (from) level:(level)) (to (trackSite Move from:(from) "Track" steps:(mapEntry "Throw" (count Pips))))) (move Pass (then (if (is Mover P1) (remember Value "TabulatedP1" (mapEntry "Throw" (count Pips))) (if (is Mover P2) (remember Value "TabulatedP2" (mapEntry "Throw" (count Pips))) (if (is Mover P3) (remember Value "TabulatedP3" (mapEntry "Throw" (count Pips))) (if (is Mover P4) (remember Value "TabulatedP4" (mapEntry "Throw" (count Pips))) (if (is Mover P5) (remember Value "TabulatedP5" (mapEntry "Throw" (count Pips))) (if (is Mover P6) (remember Value "TabulatedP6" (mapEntry "Throw" (count Pips))) (if (is Mover P7) (remember Value "TabulatedP7" (mapEntry "Throw" (count Pips))) (remember Value "TabulatedP8" (mapEntry "Throw" (count Pips))))))))))))) (or (move (from (from) level:(level)) (to (trackSite Move from:(from) "ReverseTrack" steps:(mapEntry "Throw" (count Pips)))) (then (if (= (last To) 73) (if (= (where "Hyena" Neutral) -1) (add (piece (id "Hyena" Neutral)) (to (last To))))))) (if (= (mapEntry "Throw" (count Pips)) 1) (move Pass (then (if (is Mover P1) (remember Value "TabulatedP1" (mapEntry "Throw" (count Pips))) (if (is Mover P2) (remember Value "TabulatedP2" (mapEntry "Throw" (count Pips))) (if (is Mover P3) (remember Value "TabulatedP3" (mapEntry "Throw" (count Pips))) (if (is Mover P4) (remember Value "TabulatedP4" (mapEntry "Throw" (count Pips))) (if (is Mover P5) (remember Value "TabulatedP5" (mapEntry "Throw" (count Pips))) (if (is Mover P6) (remember Value "TabulatedP6" (mapEntry "Throw" (count Pips))) (if (is Mover P7) (remember Value "TabulatedP7" (mapEntry "Throw" (count Pips))) (remember Value "TabulatedP8" (mapEntry "Throw" (count Pips))))))))))))))))))) (piece "Hyena" Neutral maxState:10) (map "Throw" {(pair 0 6) (pair 1 1) (pair 2 2) (pair 3 4)})}) (rules (start {(place Stack items:{"Stick4" "Stick3" "Stick2" "Stick1"} 73)}) (play (do (roll) next:(if (and (= 73 (where "Stick" Mover)) (!= 0 (state at:(where "Stick" Mover) level:(where Level "Stick" Mover at:(where "Stick" Mover))))) (if (= (where "Hyena" Neutral) 2) (if (= 9 (state at:(where "Hyena" Neutral) level:(where Level "Hyena" Neutral at:(where "Hyena" Neutral)))) (move (from (where "Hyena" Neutral) level:(where Level "Hyena" Neutral at:(where "Hyena" Neutral))) (to 0)) (if (= (mapEntry "Throw" (count Pips)) 1) (move Select (from (where "Hyena" Neutral) level:(where Level "Hyena" Neutral at:(where "Hyena" Neutral))) (then (set State at:(last To) level:(last LevelTo) (+ 1 (state at:(last To) level:(last LevelTo)))))) (if (is In 1 (if (is Mover P1) (values Remembered "TabulatedP1") (if (is Mover P2) (values Remembered "TabulatedP2") (if (is Mover P3) (values Remembered "TabulatedP3") (if (is Mover P4) (values Remembered "TabulatedP4") (if (is Mover P5) (values Remembered "TabulatedP5") (if (is Mover P6) (values Remembered "TabulatedP6") (if (is Mover P7) (values Remembered "TabulatedP7") (values Remembered "TabulatedP8"))))))))) (move Select (from (where "Hyena" Neutral) level:(where Level "Hyena" Neutral at:(where "Hyena" Neutral))) (then (and (set State at:(last To) level:(last LevelTo) (+ 1 (state at:(last To) level:(last LevelTo)))) (if (is Mover P1) (forget Value "TabulatedP1" 1) (if (is Mover P2) (forget Value "TabulatedP2" 1) (if (is Mover P3) (forget Value "TabulatedP3" 1) (if (is Mover P4) (forget Value "TabulatedP4" 1) (if (is Mover P5) (forget Value "TabulatedP5" 1) (if (is Mover P6) (forget Value "TabulatedP6" 1) (if (is Mover P7) (forget Value "TabulatedP7" 1) (forget Value "TabulatedP8" 1)))))))))))))) (if (= 0 (state at:(where "Hyena" Neutral) level:(where Level "Hyena" Neutral at:(where "Hyena" Neutral)))) (or {(if (= (mapEntry "Throw" (count Pips)) 1) (move Pass (then (if (is Mover P1) (remember Value "TabulatedP1" (mapEntry "Throw" (count Pips))) (if (is Mover P2) (remember Value "TabulatedP2" (mapEntry "Throw" (count Pips))) (if (is Mover P3) (remember Value "TabulatedP3" (mapEntry "Throw" (count Pips))) (if (is Mover P4) (remember Value "TabulatedP4" (mapEntry "Throw" (count Pips))) (if (is Mover P5) (remember Value "TabulatedP5" (mapEntry "Throw" (count Pips))) (if (is Mover P6) (remember Value "TabulatedP6" (mapEntry "Throw" (count Pips))) (if (is Mover P7) (remember Value "TabulatedP7" (mapEntry "Throw" (count Pips))) (remember Value "TabulatedP8" (mapEntry "Throw" (count Pips))))))))))))) (move (from (where "Hyena" Neutral) level:(where Level "Hyena" Neutral at:(where "Hyena" Neutral))) (to (trackSite Move from:(where "Hyena" Neutral) "Track" steps:(* 2 (mapEntry "Throw" (count Pips)))))) (if (is In 1 (if (is Mover P1) (values Remembered "TabulatedP1") (if (is Mover P2) (values Remembered "TabulatedP2") (if (is Mover P3) (values Remembered "TabulatedP3") (if (is Mover P4) (values Remembered "TabulatedP4") (if (is Mover P5) (values Remembered "TabulatedP5") (if (is Mover P6) (values Remembered "TabulatedP6") (if (is Mover P7) (values Remembered "TabulatedP7") (values Remembered "TabulatedP8"))))))))) (move (from (where "Hyena" Neutral) level:(where Level "Hyena" Neutral at:(where "Hyena" Neutral))) (to (trackSite Move from:(where "Hyena" Neutral) "Track" steps:1)) (then (if (is Mover P1) (forget Value "TabulatedP1" 1) (if (is Mover P2) (forget Value "TabulatedP2" 1) (if (is Mover P3) (forget Value "TabulatedP3" 1) (if (is Mover P4) (forget Value "TabulatedP4" 1) (if (is Mover P5) (forget Value "TabulatedP5" 1) (if (is Mover P6) (forget Value "TabulatedP6" 1) (if (is Mover P7) (forget Value "TabulatedP7" 1) (forget Value "TabulatedP8" 1)))))))))))}) (or (move (from (where "Hyena" Neutral) level:(where Level "Hyena" Neutral at:(where "Hyena" Neutral))) (to (trackSite Move from:(where "Hyena" Neutral) "ReverseTrack" steps:(* 2 (mapEntry "Throw" (count Pips))))) (then (forEach Site (sites Track "ReverseTrack" from:(last From) to:(trackSite Move from:(last From) "ReverseTrack" steps:(- (* 2 (mapEntry "Throw" (count Pips))) 1))) (forEach Level (site) FromTop (remove (site) level:(level)))))) (if (is In 1 (if (is Mover P1) (values Remembered "TabulatedP1") (if (is Mover P2) (values Remembered "TabulatedP2") (if (is Mover P3) (values Remembered "TabulatedP3") (if (is Mover P4) (values Remembered "TabulatedP4") (if (is Mover P5) (values Remembered "TabulatedP5") (if (is Mover P6) (values Remembered "TabulatedP6") (if (is Mover P7) (values Remembered "TabulatedP7") (values Remembered "TabulatedP8"))))))))) (move (from (where "Hyena" Neutral) level:(where Level "Hyena" Neutral at:(where "Hyena" Neutral))) (to (trackSite Move from:(where "Hyena" Neutral) "ReverseTrack" steps:1)) (then (and (if (is Mover P1) (forget Value "TabulatedP1" 1) (if (is Mover P2) (forget Value "TabulatedP2" 1) (if (is Mover P3) (forget Value "TabulatedP3" 1) (if (is Mover P4) (forget Value "TabulatedP4" 1) (if (is Mover P5) (forget Value "TabulatedP5" 1) (if (is Mover P6) (forget Value "TabulatedP6" 1) (if (is Mover P7) (forget Value "TabulatedP7" 1) (forget Value "TabulatedP8" 1)))))))) (forEach Level (last From) FromTop (remove (last From) level:(level)))))))))) (forEach Piece)) (then (if (not (= (mapEntry "Throw" (count Pips)) 2)) (moveAgain))))) (end {(forEach Player if:(= 0 (count Sites in:(sites Occupied by:Player top:False))) (result Player Loss)) (forEach Player if:(and {(if (!= 73 (where "Hyena" Neutral)) (= 1 (size Stack at:(where "Hyena" Neutral))) True) (!= (where "Hyena" Neutral) -1) (all Sites (sites Occupied by:All top:False) if:(is In (site) (union (sites Hand Shared) (sites {73 (where "Hyena" Neutral)}))))}) (result Player Win))}))) 
5x5 board, with the central square on each side and the central square of the board marked with an X. Two to four players, each with four pieces, which start on one of the marked squares on the edge of the board. Four cowrie shells used as dice. The throws are as follows, with the value of the throws equaling the number of mouths which land up, all mouths down = 8, and grants the player another throw. Pieces moves in a spiral track around the board in an anti-clockwise direction until they reach the space before the starting point, at which point they proceed around the inner circles in a clockwise direction, and then to the central space. When a player lands on a space occupied by an opponent's piece, the opponent's piece is sent back to their starting position. When a player reaches the central square by an exact throw, it is removed from the board. The first player to remove all four of their pieces from the board wins. The game involves 4 players.
(game "Main Pacheh" (players 4) (equipment {(board (square 5) {(track "Track1" "2,E,N,W,S,E1,N3,E2,S2,W1,12" P1 directed:True) (track "Track2" "22,W,S,E,N,W1,S3,W2,N2,E1,12" P2 directed:True) (track "Track3" "14,N,W,S,E,N1,W3,N2,E2,S1,12" P3 directed:True) (track "Track4" "10,S,E,N,W,S1,E3,S2,W2,N1,12" P4 directed:True)}) (piece "Marker" Each (if (!= (trackSite Move steps:(mapEntry "ThrowDiceValue" (count Pips))) -1) (if (or (is Empty (trackSite Move steps:(mapEntry "ThrowDiceValue" (count Pips)))) (is Enemy (who at:(trackSite Move steps:(mapEntry "ThrowDiceValue" (count Pips)))))) (move (from (from) level:(level)) (to (trackSite Move steps:(mapEntry "ThrowDiceValue" (count Pips))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry "StartingPoint" (who at:(to))))))))) (then (if (= 12 (last To)) (remove (last To)))))) (map "ThrowDiceValue" {(pair 0 8) (pair 1 1) (pair 2 2) (pair 3 3) (pair 4 4)}) (map "StartingPoint" {(pair 1 2) (pair 2 22) (pair 3 14) (pair 4 10)}) (dice d:2 from:0 num:4)}) (rules (start {(place Stack "Marker1" 2 count:4) (place Stack "Marker2" 22 count:4) (place Stack "Marker3" 14 count:4) (place Stack "Marker4" 10 count:4)}) (play (do (roll) next:(if (can Move (forEach Piece)) (forEach Piece (then (if (= (mapEntry "ThrowDiceValue" (count Pips)) 8) (moveAgain)))) (move Pass (then (if (= (mapEntry "ThrowDiceValue" (count Pips)) 8) (moveAgain))))))) (end (if (no Pieces Mover) (result Mover Win))))) 
On a player's turn he or she must perform one of the following actions: 1) Move a tower (2-stack) by distributing its two stones into the two nearest cells in any one direction. Each destination cell must be empty or contain a single friendly stone. 2) Sacrifice a single tower stone to remove an adjacent enemy wall (1-stack). Sacrifice is not forced. Goal: A player wins immediately by reaching any cell of his or her opponent's home row, or by stalemating his or her opponent. Stack limit is 2. Standard 7 x 8, one row Immediately after reaching goal.
(game "Murus Gallicus" (players {(player N) (player S)}) (equipment {(board (rectangle 7 8)) (piece "Counter_isometric" Each) (regions "RomanGoal1" P1 (sites Top)) (regions "GaulGoal2" P2 (sites Bottom))}) (rules (start {(place Stack "Counter_isometric1" (sites {0 1 2 3 4 5 6 7}) count:2) (place Stack "Counter_isometric2" (sites {48 49 50 51 52 53 54 55}) count:2)}) (play (if (is Prev Mover) (or (move (from (last From)) (to (last To)) stack:True (then (and (remove (last To)) (remove (last To))))) (move Pass)) (forEach Piece "Counter_isometric" (or {(move Hop (from if:(and (is Mover (who at:(from))) (= (size Stack at:(from)) 2))) (between if:(or (is Empty (between)) (and (is Mover (who at:(between))) (< (size Stack at:(between)) 2))) (apply (fromTo (from) (to (between))))) (to if:(or (is Empty (to)) (and (is Mover (who at:(to))) (< (size Stack at:(to)) 2)))) stack:True) (move Step (from if:(and (is Mover (who at:(from))) (= (size Stack at:(from)) 2))) (to if:(and (is Enemy (who at:(to))) (= 1 (size Stack at:(to)))) (apply (remove (to)))) stack:True (then (and (fromTo (from (last To)) (to (last From))) (remove (last To))))) (move Step (from if:(and (is Mover (who at:(from))) (= (size Stack at:(from)) 2))) (to if:(and (is Enemy (who at:(to))) (= (size Stack at:(to)) 3)) (apply (remove (to)))) stack:True (then (and {(fromTo (from (last To)) (to (last From))) (remove (last To)) (moveAgain)}))) (move Hop (from if:(and (is Mover (who at:(from))) (= (size Stack at:(from)) 3))) (difference All Backwards) (between (range 1 2) if:True) (to if:(and (not (is Enemy (who at:(to)))) (not (is Mover (who at:(to))))))) (move Hop (from if:(and (is Mover (who at:(from))) (= (size Stack at:(from)) 3))) (difference All Backwards) (between (range 1 2) if:True) (to if:(is Enemy (who at:(to)))) (then (and (remove (last To)) (remove (last To)))))}) top:True))) (end {(if (no Moves Next) (result Mover Win)) (if (and {(is In (last To) (sites Mover)) (not (is Enemy (who at:(last To)))) (is Mover (who at:(last To)))}) (result Mover Win))}))) 
The board is rectangular, with six points on either side, with each side divided in half by two short parallel lines, which are the "rivers." There are four arcs in the corners of the "square". The points and lines are the playing spaces. Players play on two teams. One stick, serving as the playing piece, per team, which start one each on the parallel lines on the bottom side. Each team has a number of scoring sticks, determined at the beginning of the game. There are four throwing sticks, three are blank on one side and marked on the other, one stick, the sahe, is marked distinctively on two sides, marked with a green line on the flat side, while the others are marked red. The number of marked sides is the value of the throw, except when all are face up, which scores 6, and when only flat sides are up, which scores 10. Throws of 6 or 10 give the player another throw, as do throws of 1 and 3 if the sahe's marked side is up. All of the players on team throw before the players of the other team throw. Play begins from the middle of the river on one side. Each team moves in an opposite direction around the board. If a team's stick lands on the edge of the river opposite the starting position, the piece is sent back to start. If a player lands on the same space as the opposing team's stick, the opposing team's stick is sent back to start. When a team reaches the starting point, having completed a circuit of the board, the team wins a scoring stick. When one team captures all of the scoring sticks, they win.  Each team has 10 scoring sticks.
(game "Nebakuthana" (players 4) (equipment {(board (graph vertices:{{0 0} {2 0} {3 0.33} {4 0.33} {5 0.33} {6 0} {7 0} {8 0.33} {9 0.33} {10 0.33} {11 0} {13 0} {0 2} {6 2} {7 2} {13 2} {0.33 3} {12.66 3} {0.33 4} {12.66 4} {0.33 5} {12.66 5} {0 6} {2 6} {11 6} {13 6} {0 7} {2 7} {11 7} {13 7} {0.33 8} {12.66 8} {0.33 9} {12.66 9} {0.33 10} {12.66 10} {0 11} {6 11} {7 11} {13 11} {0 13} {2 13} {3 12.66} {4 12.66} {5 12.66} {6 13} {7 13} {8 12.66} {9 12.66} {10 12.66} {11 13} {13 13}} edges:{{0 1} {1 5} {5 13} {6 14} {5 6} {6 10} {10 11} {12 1} {0 12} {10 15} {15 11} {12 22} {22 26} {22 23} {26 27} {26 36} {36 40} {15 25} {25 29} {24 25} {28 29} {29 39} {39 51} {40 41} {36 41} {39 50} {50 51} {41 45} {45 46} {45 37} {46 38} {46 50}}) {(track "Track1" "6,7,8,9,10,15,17,19,21,25,29,31,33,35,39,50,49,48,47,46,45,44,43,42,41,36,34,32,30,26,22,20,18,16,12,1,2,3,4,End" P1 directed:True) (track "Track2" "6,7,8,9,10,15,17,19,21,25,29,31,33,35,39,50,49,48,47,46,45,44,43,42,41,36,34,32,30,26,22,20,18,16,12,1,2,3,4,End" P2 directed:True) (track "Track3" "5,4,3,2,1,12,16,18,20,22,26,30,32,34,36,41,42,43,44,45,46,47,48,49,50,39,35,33,31,29,25,21,19,17,15,10,9,8,7,End" P3 directed:True) (track "Track4" "5,4,3,2,1,12,16,18,20,22,26,30,32,34,36,41,42,43,44,45,46,47,48,49,50,39,35,33,31,29,25,21,19,17,15,10,9,8,7,End" P4 directed:True)} use:Vertex) (piece "Stick" P1 (if (= (trackSite Move from:(from) steps:(mapEntry "Throw" (count Pips))) -2) (move Remove (from) (then (if (is Occupied (handSite (if (or (is Mover P1) (is Mover P2)) 1 3))) (fromTo (from (handSite (if (or (is Mover P1) (is Mover P2)) 1 3))) (to (mapEntry "Start" (if (or (is Mover P1) (is Mover P2)) 1 3))))))) (move (from (from)) (to (trackSite Move from:(from) steps:(mapEntry "Throw" (count Pips))) if:True (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry "Start" (who at:(to))))))) (then (if (= (last To) (mapEntry "Opposite" Mover)) (fromTo (from (last To)) (to (mapEntry "Start" Mover)))))))) (piece "Stick" P3 (if (= (trackSite Move from:(from) steps:(mapEntry "Throw" (count Pips))) -2) (move Remove (from) (then (if (is Occupied (handSite (if (or (is Mover P1) (is Mover P2)) 1 3))) (fromTo (from (handSite (if (or (is Mover P1) (is Mover P2)) 1 3))) (to (mapEntry "Start" (if (or (is Mover P1) (is Mover P2)) 1 3))))))) (move (from (from)) (to (trackSite Move from:(from) steps:(mapEntry "Throw" (count Pips))) if:True (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry "Start" (who at:(to))))))) (then (if (= (last To) (mapEntry "Opposite" Mover)) (fromTo (from (last To)) (to (mapEntry "Start" Mover)))))))) (dice d:2 from:0 num:4) (hand P1) (hand P3) (map "Throw" {(pair 0 10) (pair 1 1) (pair 2 2) (pair 3 3) (pair 4 6)}) (map "Start" {(pair P1 6) (pair P2 6) (pair P3 5) (pair P4 5)}) (map "Opposite" {(pair P1 46) (pair P2 46) (pair P3 45) (pair P4 45)})}) (rules (start {(set Team 1 {P1 P2}) (set Team 2 {P3 P4}) (place "Stick1" 6) (place "Stick3" 5) (place "Stick1" (handSite P1) count:10) (place "Stick3" (handSite P3) count:10)}) (play (do (roll) next:(if (or (is Mover P1) (is Mover P2)) (forEach Piece P1) (forEach Piece P3)) (then (if (or {(= (mapEntry "Throw" (count Pips)) 6) (= (mapEntry "Throw" (count Pips)) 10) (and (= 1 (face 57)) (= (mapEntry "Throw" (count Pips)) 1)) (and (= 1 (face 57)) (= (mapEntry "Throw" (count Pips)) 3))}) (moveAgain))))) (end (if (no Pieces TeamMover) (result TeamMover Win))))) 
Forty stones arranged in a circle, with a larger gap after every tenth stone. These gaps are known as doors. Any number of players, each player begins with one piece, which begins at the east door. Three sticks used as dice, black on one side, white on the other, with one stick notched on the white side. The throws are as follows: two black with one notched white side up = 15; three white sides up = 10; two black and one white, not notched = 3, two white and one black = 2, three black = 5. Throws of 10 and 15 grant the player another throw. Players may move in either direction around the circle. To win, the player must complete a circuit of the board and pass the east door. The game has 4 players. The goal is to pass the east door.
(game "Owasokotz" (players 4) (equipment {(board (add (remove (concentric {44}) vertices:{43 21 0 22}) edges:{{20 18} {0 1} {19 21} {38 39}}) {(track "TrackCW" {39 35 33 31 29 27 25 23 21 19 38 17 15 13 11 9 7 5 3 1 37 0 2 4 6 8 10 12 14 16 36 18 20 22 24 26 28 30 32 34} loop:True) (track "TrackCCW" {39 34 32 30 28 26 24 22 20 18 36 16 14 12 10 8 6 4 2 0 37 1 3 5 7 9 11 13 15 17 38 19 21 23 25 27 29 31 33 35} loop:True)} use:Edge) (regions "AllSites" (sites Board)) (piece "Stick" Each (if (= (state at:(from)) 0) (or (if (!= (trackSite Move "TrackCCW" steps:(if (= (count Pips) 3) 5 (if (= (count Pips) 0) 10 (if (= (count Pips) 1) 2 (if (= (face 44) 1) 15 3))))) -1) (move (from (from) level:(level)) (to (trackSite Move "TrackCCW" steps:(if (= (count Pips) 3) 5 (if (= (count Pips) 0) 10 (if (= (count Pips) 1) 2 (if (= (face 44) 1) 15 3))))) if:(is Empty (trackSite Move "TrackCCW" steps:(if (= (count Pips) 3) 5 (if (= (count Pips) 0) 10 (if (= (count Pips) 1) 2 (if (= (face 44) 1) 15 3)))))))) (then (set State at:(last To) 2))) (if (!= (trackSite Move "TrackCW" steps:(if (= (count Pips) 3) 5 (if (= (count Pips) 0) 10 (if (= (count Pips) 1) 2 (if (= (face 44) 1) 15 3))))) -1) (move (from (from) level:(level)) (to (trackSite Move "TrackCW" steps:(if (= (count Pips) 3) 5 (if (= (count Pips) 0) 10 (if (= (count Pips) 1) 2 (if (= (face 44) 1) 15 3))))) if:(is Empty (trackSite Move "TrackCW" steps:(if (= (count Pips) 3) 5 (if (= (count Pips) 0) 10 (if (= (count Pips) 1) 2 (if (= (face 44) 1) 15 3)))))))) (then (set State at:(last To) 1)))) (if (!= (if (= (state at:(from)) 1) (trackSite Move "TrackCW" steps:(if (= (count Pips) 3) 5 (if (= (count Pips) 0) 10 (if (= (count Pips) 1) 2 (if (= (face 44) 1) 15 3))))) (trackSite Move "TrackCCW" steps:(if (= (count Pips) 3) 5 (if (= (count Pips) 0) 10 (if (= (count Pips) 1) 2 (if (= (face 44) 1) 15 3)))))) -1) (move (from (from) level:(level)) (to (if (= (state at:(from)) 1) (trackSite Move "TrackCW" steps:(if (= (count Pips) 3) 5 (if (= (count Pips) 0) 10 (if (= (count Pips) 1) 2 (if (= (face 44) 1) 15 3))))) (trackSite Move "TrackCCW" steps:(if (= (count Pips) 3) 5 (if (= (count Pips) 0) 10 (if (= (count Pips) 1) 2 (if (= (face 44) 1) 15 3)))))) if:(is Empty (if (= (state at:(from)) 1) (trackSite Move "TrackCW" steps:(if (= (count Pips) 3) 5 (if (= (count Pips) 0) 10 (if (= (count Pips) 1) 2 (if (= (face 44) 1) 15 3))))) (trackSite Move "TrackCCW" steps:(if (= (count Pips) 3) 5 (if (= (count Pips) 0) 10 (if (= (count Pips) 1) 2 (if (= (face 44) 1) 15 3)))))))))))) (dice d:2 from:0 num:3) (hand Each)}) (rules (start (place Stack items:{"Stick4" "Stick3" "Stick2" "Stick1"} Edge 38)) (play (do (roll) next:(forEach Piece))) (end (if (and (not (was Pass)) (if (= 1 (state at:(where "Stick" Mover))) (is In 38 (sites Track "TrackCW" from:(trackSite Move from:(last From) "TrackCW" steps:1) to:(last To))) (is In 38 (sites Track "TrackCCW" from:(trackSite Move from:(last From) "TrackCCW" steps:1) to:(last To))))) (result Mover Win))))) 
Nine concentric circles. Any number of players. Each player plays as one piece. Two nut shells, used as dice. The values are as follows: two round sides = 2; two hollow sides = 1; one of each side = 0. Players move their pieces from outside the circles into progressive rings until they reach Paradise at the center, at which point the piece goes back to the outside of the board. The first player to reach Paradise three times wins. The game involves 8 players.
(game "Paradis" (players 8) (equipment {(board (concentric {8 8 8 8 8 8 8 8 8 8}) {(track "Track1" {72 64 56 48 40 32 24 16 8 0 8 16 24 32 40 48 56 64 72 64 56 48 40 32 24 16 8 0 8 16 24 32 40 48 56 64 72 64 56 48 40 32 24 16 8 0 8 16 24 32 40 48 56 64} P1 directed:True) (track "Track2" {73 65 57 49 41 33 25 17 9 1 9 17 25 33 41 49 57 65 73 65 57 49 41 33 25 17 9 1 9 17 25 33 41 49 57 65 73 65 57 49 41 33 25 17 9 1 9 17 25 33 41 49 57 65} P2 directed:True) (track "Track3" {74 66 58 50 42 34 26 18 10 2 10 18 26 34 42 50 58 66 74 66 58 50 42 34 26 18 10 2 10 18 26 34 42 50 58 66 74 66 58 50 42 34 26 18 10 2 10 18 26 34 42 50 58 66} P3 directed:True) (track "Track4" {75 67 59 51 43 35 27 19 11 3 11 19 27 35 43 51 59 67 75 67 59 51 43 35 27 19 11 3 11 19 27 35 43 51 59 67 75 67 59 51 43 35 27 19 11 3 11 19 27 35 43 51 59 67} P4 directed:True) (track "Track5" {76 68 60 52 44 36 28 20 12 4 12 20 28 36 44 52 60 68 76 68 60 52 44 36 28 20 12 4 12 20 28 36 44 52 60 68 76 68 60 52 44 36 28 20 12 4 12 20 28 36 44 52 60 68} P5 directed:True) (track "Track6" {77 69 61 53 45 37 29 21 13 5 13 21 29 37 45 53 61 69 77 69 61 53 45 37 29 21 13 5 13 21 29 37 45 53 61 69 77 69 61 53 45 37 29 21 13 5 13 21 29 37 45 53 61 69} P6 directed:True) (track "Track7" {78 70 62 54 46 38 30 22 14 6 14 22 30 38 46 54 62 70 78 70 62 54 46 38 30 22 14 6 14 22 30 38 46 54 62 70 78 70 62 54 46 38 30 22 14 6 14 22 30 38 46 54 62 70} P7 directed:True) (track "Track8" {79 71 63 55 47 39 31 23 15 7 15 23 31 39 47 55 63 71 79 71 63 55 47 39 31 23 15 7 15 23 31 39 47 55 63 71 79 71 63 55 47 39 31 23 15 7 15 23 31 39 47 55 63 71} P8 directed:True)} use:Vertex) (dice d:2 from:0 num:2) (piece "Marker" Each (move (from (from)) (to (trackSite Move steps:(mapEntry "Throw" (count Pips))) (apply (if (or (and (= 1 (mapEntry "Throw" (count Pips))) (= (mapEntry "Center" Mover) (to))) (and (= 2 (mapEntry "Throw" (count Pips))) (or (= (mapEntry "Center" Mover) (to)) (= (mapEntry "Center" Mover) (trackSite Move steps:1))))) (addScore Mover 1)))))) (map "Throw" {(pair 0 2) (pair 1 0) (pair 2 1)}) (map "Center" {(pair P1 0) (pair P2 1) (pair P3 2) (pair P4 3) (pair P5 4) (pair P6 5) (pair P7 6) (pair P8 7)})}) (rules (start {(place "Marker1" 72) (place "Marker2" 73) (place "Marker3" 74) (place "Marker4" 75) (place "Marker5" 76) (place "Marker6" 77) (place "Marker7" 78) (place "Marker8" 79)}) (play (do (roll) next:(if (!= (mapEntry "Throw" (count Pips)) 0) (forEach Piece)))) (end (if (= (score Mover) 3) (result Mover Win))))) 
Four 3x8 rectangles, arranged in a cross-shaped board. the fourth square, counting from the outer corners, in the outer rows of each arm are marked. Four pieces per player. Six cowrie shells are used as dice. The value of the throws is as follows: one mouth up = 10; two mouths up = 2, three mouths up = 3; four mouths up = 5; five mouths up = 25; six mouths up = 12; all mouths down = 6. On the first turn, players get three throws, and enter a piece for every throw of 10 or 25. On the top left square in their arm. Players move their pieces around the board in an anti-clockwise direction. When a piece lands on a space occupied by an opponent's piece, the opponent's piece is removed from the board and must enter again. Pieces resting on marked squares are safe from being removed from the board. When a piece completes a circuit of the board. It moves toward the central row in the player's arm, and progresses up the central row into the large square in the center of the board. The player who moves all of their pieces into the center first wine.
(game "Pasit" (players 4) (equipment {(board (add (hole (merge (shift 0 (/ (- 19 3) 2) (rectangle 3 19)) (shift (/ (- 19 3) 2) 0 (rectangle 19 3))) (poly {{8 8} {8 11} {11 11} {11 8}})) cells:{{8 28 48 68 69 70 71 51 31 11 10 9}}) {(track "Track1" "8,S,E,N,11,E,N,W,53,N,W,S,42,W,S,E,8,S,E1,N8" P1 directed:True) (track "Track2" "42,W,S,E,8,S,E,N,11,E,N,W,53,N,W,S,42,W,S1,E8" P2 directed:True) (track "Track3" "53,N,W,S,42,W,S,E,8,S,E,N,11,E,N,W,53,N,W1,S8" P3 directed:True) (track "Track4" "11,E,N,W,53,N,W,S,42,W,S,E,8,S,E,N,11,E,N1,W8" P4 directed:True)}) (hand Each) (dice d:2 from:0 num:6) (piece "Pawn" Each (if (= (trackSite Move from:(from) steps:(mapEntry "Throw" (count Pips))) -1) (move (from (from) level:(level)) (to (centrePoint))) (move (from (from) level:(level)) (to (trackSite Move from:(from) steps:(mapEntry "Throw" (count Pips))) if:True (apply (if (and (not (is In (to) (sites "SafeSites"))) (is Enemy (who at:(to)))) (forEach Level (to) FromTop (fromTo (from (to) level:(level)) (to (handSite (who at:(to) level:(level)))))))))))) (map "Throw" {(pair 0 6) (pair 1 10) (pair 2 2) (pair 3 3) (pair 4 5) (pair 5 25) (pair 6 12)}) (map "Entry" {(pair P1 8) (pair P2 42) (pair P3 53) (pair P4 11)}) (regions "SafeSites" (sites {63 65 15 47 84 86 38 3}))}) (rules (start {(place Stack "Pawn1" (handSite P1) count:4) (place Stack "Pawn2" (handSite P2) count:4) (place Stack "Pawn3" (handSite P3) count:4) (place Stack "Pawn4" (handSite P4) count:4)}) phases:{(phase "Opening" (play (do (roll) next:(if (is In (mapEntry "Throw" (count Pips)) (sites {10 25 30})) (move (from (handSite Mover)) (to (mapEntry "Entry" Mover))) (move Pass) (then (and (if (!= 1 (value Player Mover)) (moveAgain)) (set Value Mover (+ 1 (value Player Mover)))))))) (nextPhase Mover (= 2 (value Player Mover)) "Moving")) (phase "Moving" (play (do (roll) next:(or (if (and (is Occupied (handSite Mover)) (is In (mapEntry "Throw" (count Pips)) (sites {10 25 30}))) (move (from (handSite Mover)) (to (mapEntry "Entry" Mover)))) (forEach Piece)))))} (end (if (and (= 1 (count Sites in:(sites Occupied by:Mover top:False))) (is In (centrePoint) (sites Occupied by:Mover top:False))) (result Mover Win))))) 
Forty stones are arranged in a circle, with a larger gap between every tenth and eleventh stone. The gaps between the stones are the playing spaces. One piece per player. Any number of players. Three sticks used as dice, marked on one side and blank on the other. Throws are as follows: One marked side up = 3, two marked sides up = 2, three marked sides up = 10; all blank sides up = 5. Players enter their pieces from one of the wider gaps in the board, and chooses to move either clockwise or anti-clockwise. When a player's piece lands on a space occupied by the opponent, the opponent's piece is sent back to the space in which they entered. The first player to complete the circuit wins. The game has 2 players. Captures are possible.
(game "Patol" (players 2) (equipment {(board (add (remove (concentric {44}) vertices:{43 21 0 22}) edges:{{20 18} {0 1} {19 21} {38 39}}) {(track "TrackCW" {39 35 33 31 29 27 25 23 21 19 38 17 15 13 11 9 7 5 3 1 37 0 2 4 6 8 10 12 14 16 36 18 20 22 24 26 28 30 32 34} loop:True) (track "TrackCCW" {39 34 32 30 28 26 24 22 20 18 36 16 14 12 10 8 6 4 2 0 37 1 3 5 7 9 11 13 15 17 38 19 21 23 25 27 29 31 33 35} loop:True)} use:Edge) (regions "Gates" (sites {36 37 38 39})) (piece "Marker" Each (if (= (value Player Mover) -1) (or (if (!= (trackSite Move "TrackCW" steps:(mapEntry "ThrowDiceValue" (count Pips))) -1) (if (or (is In (trackSite Move "TrackCW" steps:(mapEntry "ThrowDiceValue" (count Pips))) (sites Empty)) (is Enemy (who at:(trackSite Move "TrackCW" steps:(mapEntry "ThrowDiceValue" (count Pips)))))) (move (from (from) level:(level)) (to (trackSite Move "TrackCW" steps:(mapEntry "ThrowDiceValue" (count Pips))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (value Piece at:(to)))))))) (then (if (= (value Player Mover) -1) (set Value Mover 1)))) (if (!= (trackSite Move "TrackCCW" steps:(mapEntry "ThrowDiceValue" (count Pips))) -1) (if (or (is In (trackSite Move "TrackCCW" steps:(mapEntry "ThrowDiceValue" (count Pips))) (sites Empty)) (is Enemy (who at:(trackSite Move "TrackCCW" steps:(mapEntry "ThrowDiceValue" (count Pips)))))) (move (from (from) level:(level)) (to (trackSite Move "TrackCCW" steps:(mapEntry "ThrowDiceValue" (count Pips))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (value Piece at:(to)))))))) (then (if (= (value Player Mover) -1) (set Value Mover 2))))) (if (!= (if (= (value Player Mover) 2) (trackSite Move "TrackCCW" steps:(mapEntry "ThrowDiceValue" (count Pips))) (trackSite Move "TrackCW" steps:(mapEntry "ThrowDiceValue" (count Pips)))) -1) (if (or (is In (if (= (value Player Mover) 2) (trackSite Move "TrackCCW" steps:(mapEntry "ThrowDiceValue" (count Pips))) (trackSite Move "TrackCW" steps:(mapEntry "ThrowDiceValue" (count Pips)))) (sites Empty)) (is Enemy (who at:(if (= (value Player Mover) 2) (trackSite Move "TrackCCW" steps:(mapEntry "ThrowDiceValue" (count Pips))) (trackSite Move "TrackCW" steps:(mapEntry "ThrowDiceValue" (count Pips))))))) (move (from (from) level:(level)) (to (if (= (value Player Mover) 2) (trackSite Move "TrackCCW" steps:(mapEntry "ThrowDiceValue" (count Pips))) (trackSite Move "TrackCW" steps:(mapEntry "ThrowDiceValue" (count Pips)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (value Piece at:(to))))))))))) (dice d:2 from:0 num:3) (map "ThrowDiceValue" {(pair 0 5) (pair 1 3) (pair 2 2) (pair 3 10)}) (hand Each)}) (rules (start (place "Marker" "Hand")) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites "Gates")) (then (set Value at:(last To) (last To))))) (nextPhase Mover "Playing")) (phase "Playing" (play (do (roll) next:(forEach Piece))) (end (if (if (= 1 (value Player Mover)) (is In (value Piece at:(where "Marker" Mover)) (sites Track "TrackCW" from:(trackSite Move from:(last From) "TrackCW" steps:1) to:(last To))) (is In (value Piece at:(where "Marker" Mover)) (sites Track "TrackCCW" from:(trackSite Move from:(last From) "TrackCCW" steps:1) to:(last To)))) (result Mover Win))))})) 
Five pieces per player. One six-sided die. Players move their pieces onto the board using the throws of the dice. A piece must be brought onto the board if it is possible. Pieces move in an anti-clockwise direction around the board. Only one piece may be placed on a point at a time, except for the central line, which is the "sacred line." The first person to collect all of their pieces on the sacred line by reaching it on the opponent's side of the board by an exact throw wins. No capture.
(game "Pente Grammai" (players 2) (equipment {(board (add (scale 1.5 (merge {(shift 2 0 (rectangle 2 1)) (shift 1.5 0 (rectangle 2 1)) (shift 1 0 (rectangle 2 1)) (shift 0.5 0 (rectangle 2 1)) (rectangle 2 1)})) vertices:{{1.5 0.75}}) {(track "Track1" "8,6,4,2,0,1,3,5,7,9" loop:True P1) (track "Track2" "1,3,5,7,9,8,6,4,2,0" loop:True P2)} use:Vertex) (piece "Marker" Each (if (and (!= (from) 10) (is Empty (trackSite Move steps:(count Pips)))) (move (from) (to (trackSite Move steps:(count Pips)))))) (hand Each) (dice d:6 num:1) (map "Goal" {(pair P1 5) (pair P2 4)})}) (rules (start {(place Stack "Marker1" (handSite P1) count:5) (place Stack "Marker2" (handSite P2) count:5)}) (play (do (roll) next:(priority {(if (and (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site))))) (is Empty (trackSite Move from:(handSite Mover) steps:(- (count Pips) 1)))) (move (from (handSite Mover)) (to (trackSite Move from:(handSite Mover) steps:(- (count Pips) 1))))) (forEach Piece)} (then (if (= (mapEntry "Goal" Mover) (last To)) (fromTo (from (last To)) (to 10))))))) (end (if (all Sites (sites Occupied by:Mover) if:(= (site) 10)) (result Mover Win))))) 
Each player starts off with 15 balls. Players take turns taking pieces from their reserve pile, and placing them on a 4x4 game board made up of 16 indentations. When four pieces are placed next to each other in a square, one piece can be put on top of the square. That piece can also be one of the player pieces on the board with no other piece on top of it. If the square is completed with all the same color, the player of that color may take two of their own pieces from the board (one or two that are not supporting anything) and put it back into their reserve pile. At the end of the game, the game board should have 4 levels. The first level with 16 pieces, the second level with 9 pieces, the third level with 4 pieces, and the fourth level with 1 piece. A player wins if they put the last piece on the 4th level.
(game "Pylos" (players 2) (equipment {(board (square 4 pyramidal:True) use:Vertex) (piece "Ball" Each) (hand Each)}) (rules (start (place "Ball" "Hand" count:15)) (play (if (is Prev Mover) (move (from (sites Occupied by:Mover) if:(and {(if (!= (from) (ahead (from) UNE)) (is Empty (ahead (from) UNE)) True) (if (!= (from) (ahead (from) USE)) (is Empty (ahead (from) USE)) True) (if (!= (from) (ahead (from) USW)) (is Empty (ahead (from) USW)) True) (if (!= (from) (ahead (from) UNW)) (is Empty (ahead (from) UNW)) True)})) (to (handSite Mover)) (then (if (= (var) 1) (and (set Var 0) (moveAgain))))) (or (do (move (from (sites Occupied by:Mover) if:(and {(if (!= (from) (ahead (from) UNE)) (is Empty (ahead (from) UNE)) True) (if (!= (from) (ahead (from) USE)) (is Empty (ahead (from) USE)) True) (if (!= (from) (ahead (from) USW)) (is Empty (ahead (from) USW)) True) (if (!= (from) (ahead (from) UNW)) (is Empty (ahead (from) UNW)) True)})) (to (sites Empty) if:(and (is Flat) (< (layer of:(from)) (layer of:(to)))))) ifAfterwards:(is Flat (last To))) (move (from (sites Occupied by:Mover container:(mover))) (to (sites Empty) if:(is Flat))) (then (if (is Pattern {F R F R F} whats:{(id "Ball" Mover)}) (and (set Var 1) (moveAgain))))))) (end (if (= (layer of:(last To)) 3) (result Mover Win))))) 
The abstract strategy game Quoridor is surprisingly deep for its simple rules. The object of the game is to advance your pawn to the opposite edge of the board. On your turn you may either move your pawn or place a wall. You may hinder your opponent with wall placement, but not completely block them off. Meanwhile, they are trying to do the same to you. The first pawn to reach the opposite side wins. The game has 2 players
(game "Quoridor" (players 2) (equipment {(board (square 9)) (piece "Pawn" Each (or (move Step Orthogonal (to if:(and (is Empty (to)) (all Sites (sites Occupied by:Shared on:Edge) if:(not (is In (site) (intersection (sites Incident Edge of:Cell at:(from)) (sites Incident Edge of:Cell at:(to))))))))) (move Hop Orthogonal (between if:(is Enemy (who at:(between)))) (to if:(and {(is Empty (to)) (all Sites (sites Occupied by:Shared on:Edge) if:(not (is In (site) (intersection (sites Incident Edge of:Cell at:(from)) (sites Incident Edge of:Cell at:(between)))))) (all Sites (sites Occupied by:Shared on:Edge) if:(not (is In (site) (intersection (sites Incident Edge of:Cell at:(between)) (sites Incident Edge of:Cell at:(to))))))}))))) (piece "Rectangle" Shared) (hand Each) (regions P1 (sites Top)) (regions P2 (sites Bottom))}) (rules (start {(place "Rectangle" (handSite P1) count:10) (place "Rectangle" (handSite P2) count:10) (place "Pawn1" (intersection (sites Bottom) (sites Column (column of:(centrePoint))))) (place "Pawn2" (intersection (sites Top) (sites Column (column of:(centrePoint)))))}) (play (or (do (if (is Occupied (handSite Mover)) (move (from (handSite Mover)) (to Edge (difference (sites Empty Edge) (sites Outer Edge))))) ifAfterwards:(and {(!= Infinity (count Steps (step Orthogonal (to if:(and (is Empty (to)) (all Sites (sites Occupied by:Shared on:Edge) if:(not (is In (site) (intersection (sites Incident Edge of:Cell at:(from)) (sites Incident Edge of:Cell at:(to))))))))) (where "Pawn" P1) (sites P1))) (!= Infinity (count Steps (step Orthogonal (to if:(and (is Empty (to)) (all Sites (sites Occupied by:Shared on:Edge) if:(not (is In (site) (intersection (sites Incident Edge of:Cell at:(from)) (sites Incident Edge of:Cell at:(to))))))))) (where "Pawn" P2) (sites P2)))})) (forEach Piece))) (end (if (and (is LastTo Cell) (is In (last To) (sites Mover))) (result Mover Win))))) 
Like regular Chess, but player wins, if any of his pieces reach the last rank of the enemy. Check still applies, but Checkmate only forces to pass.
(game "Reach Chess" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (or (if (is In (from) (sites Start (piece (what at:(from))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))) (then (set Pending (ahead (last To) Backward))))) (move Step (directions {FR FL}) (to if:(and (is Pending) (= (to) (value Pending)))) (then (remove (ahead (last To) Backward)))))} (then (and (if (is In (last To) (sites Mover "Promotion")) (moveAgain)) (set Counter))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (map "King" {(pair 1 "E1") (pair 2 "E8")}) (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")}) (map "RookRight" {(pair 1 "H1") (pair 2 "H8")}) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King1" coord:"E1" state:1) (place "Rook2" {"A8" "H8"} state:1) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King2" coord:"E8" state:1)}) (play (if (is Prev Mover) (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover) (do (or (forEach Piece) (if (and (= (state at:(mapEntry "King" (mover))) 1) (not (is Threatened (id "King" Mover)))) (or (if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) W (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:True) (to if:True (apply (set State at:(from) 0))))))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) E (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:True) (to if:True (apply (set State at:(from) 0)))))))))) ifAfterwards:(not (is Threatened (id "King" Mover)))))) (end (if (is Connected Mover) (result Mover Win))))) 
The game is played on a 5x5 grid where each turn players build a town by placing building pieces up to four levels high. To win the game, players must move one of their two workers to the third level of the town. Beginning turns : The first player places his two workers on the board, then the second does the same. Normal turns : Each turn, the current player moves one of his two workers in an adjacent position (in horizontal, vertical or diagonal, i.e. king chess move) then he places a building tile adjacent to the moved worker (in a horizontal, vertical or diagonal adjacent position). The level of a position (i.e. a grid square) is the number of tiles. Workers can move onto a position with zero, one, two, or three tiles (but not with four tiles) only if the level of the destination position is less than or equal to the level of departure destination plus one. There can be no more than 4 tiles per position. The primary winning condition is to get one of his workers onto the third level (i.e. on a position with three tiles), though players may also win if their opponent is unable to make a move.
(game "Santorini" (players 2) (equipment {(board (square 5)) (hand Each) (map {(pair 0 "SquareLarge0") (pair 1 "SquareSmall0") (pair 2 "Octagon0") (pair 3 "Marker0")}) (piece "Pawn3d" Each (move Step (to if:(and (<= (- (size Stack at:(to)) (topLevel at:(from))) 1) (= (who at:(to)) 0))) (then (moveAgain)))) (piece "SquareLarge" Neutral) (piece "SquareSmall" Neutral) (piece "Octagon" Neutral) (piece "Marker" Neutral)}) (rules (start {(place Stack "Pawn3d1" (handSite P1) count:2) (place Stack "Pawn3d2" (handSite P2) count:2)}) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)) (then (if (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site))))) (moveAgain))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Select (from (sites Around (last To) if:(and (< (size Stack at:(to)) 4) (= (who at:(to)) 0)))) (then (add (piece (mapEntry (size Stack at:(last To)))) (to (last To)) stack:True))) (forEach Piece))))} (end {(if (and (= 3 (topLevel at:(last To))) (= (what at:(last To) level:(topLevel at:(last To))) (id "Pawn3d" Mover))) (result Mover Win)) (if (no Moves P1) (result P2 Win)) (if (no Moves P2) (result P1 Win))}))) 
9x9 board, with the central square of each side marked, as well as the central space of the board. Two to four players, each player with two pieces. Played with two four-sided dice, marked 1, 3, 4, 6. Throws may be divided as the players see fit between their pieces. Doubles allow another throw. Players start with their pieces on the marked square on their side of the board. Pieces move along a spiraling track, starting in an anti-clockwise direction around the outer edges of the board, then changing to a clockwise direction when reaching the 32nd space in the track, and continuing in this direction in a spiral pattern until reaching the central square. If a player lands on a space occupied by an opponent's piece, the opponent's piece is removed from the board, and the player must throw a double 1 to enter it again on their starting square. Pieces resting on a marked space are safe from being sent to the start. The goal is to reach the central square with both pieces, which must be reached by an exact throw. If a piece is 1, 3, or 4 spaces from the center, the player must throw doubles of that number to reach the goal.  The game is played with 4 players.
(game "Saturankam" (players 4) (equipment {(board (square 9) {(track "Track1" "81,4,E,N,W,S,E3,N1,W2,N6,E6,S5,W5,N4,E4,S3,W3,N2,E2,S1,W1" P1 directed:True) (track "Track2" "82,36,S,E,N,W,S3,E1,N2,E6,S6,W5,N5,E4,S4,W3,N3,E2,S2,W1,N1" P2 directed:True) (track "Track3" "83,76,W,S,E,N,W3,S1,E2,S6,W6,N5,E5,S4,W4,N3,E3,S2,W2,N1,E1" P3 directed:True) (track "Track4" "84,44,N,W,S,E,N3,W1,S2,W6,N6,E5,S5,W4,N4,E3,S3,W2,N2,E1,S1" P4 directed:True)}) (dice d:4 faces:{1 3 4 6} num:2) (piece "Marker" Each (if (and (or {(= (trackSite Move from:(from) steps:1) (centrePoint)) (= (trackSite Move from:(from) steps:3) (centrePoint)) (= (trackSite Move from:(from) steps:4) (centrePoint))}) (= (value Player Mover) (count Pips))) (if (and (all DiceEqual) (= (trackSite Move from:(from) steps:(/ (count Pips) 2)) (centrePoint))) (move (from (from)) (to (centrePoint)) (then (and (moveAgain) (set Var "Double" 1))))) (forEach Value min:1 max:(value Player Mover) (move (from (from) level:(level)) (to (trackSite Move from:(from) steps:(value)) if:True (apply (and (if (and (not (is In (to) (sites "SafeSites"))) (is Enemy (who at:(to)))) (forEach Level (to) FromTop (fromTo (from (to) level:(level)) (to (handSite (who at:(to) level:(level))))))) (if (< 0 (- (value Player Mover) (value))) (and (moveAgain) (set Value Mover (- (value Player Mover) (value)))) (and (set Value Mover 0) (if (all DiceEqual) (and (moveAgain) (set Var "Double" 1)))))))))))) (hand Each) (regions "SafeSites" (sites {4 44 76 36 40})) (map "Entry" {(pair P1 4) (pair P2 36) (pair P3 76) (pair P4 44)})}) (rules (start {(place Stack "Marker1" 4 count:2) (place Stack "Marker2" 36 count:2) (place Stack "Marker3" 76 count:2) (place Stack "Marker4" 44 count:2)}) (play (if (or (= 1 (var "Double")) (not (is Prev Mover))) (do (roll) next:(move Pass (then (and {(set Value Mover (count Pips)) (if (= 1 (var "Double")) (set Var "Double" 0)) (moveAgain)})))) (if (can Move (or (if (and {(is Occupied (handSite Mover)) (all DiceEqual) (= 2 (value Player Mover))}) (move (from (handSite Mover)) (to (mapEntry "Entry" Mover)) (then (and (moveAgain) (set Var "Double" 1))))) (forEach Piece))) (or (if (and {(is Occupied (handSite Mover)) (all DiceEqual) (= 2 (value Player Mover))}) (move (from (handSite Mover)) (to (mapEntry "Entry" Mover)) (then (and (moveAgain) (set Var "Double" 1))))) (forEach Piece)) (move Pass (then (and (set Var "Double" 0) (set Value Mover 0))))))) (end (if (= 2 (count Pieces Mover in:(sites Centre))) (result Mover Win))))) 
Forty stones, arranged in a circle, with a larger gap after every tenth stone. The gaps between the stones are the playing spaces. Two to four players. One stick per player. Three sticks, each with one flat marked side and one round side, used as dice. The throws are as follows: one marked side up = 2; two marked sides up = 3; all marked sides up = 5; no marked sides up =10. Throws of 10 grant the player another throw. Each player starts at one of the larger gaps, and any players facing each other play on a team. Teams play in opposite directions: The player starting from the left or right space moves in a clockwise direction; the player(s) sitting at the top or bottom play anticlockwise). When a player's piece moves past or onto the space occupied by a piece belonging to the opposing team, the opposing team's piece is sent back to the starting space. The first team to circle the board three times wins.  The game has 4 players.
(game "Set Dilth'" (players 4) (equipment {(board (add (remove (concentric {44}) vertices:{43 21 0 22}) edges:{{20 18} {0 1} {19 21} {38 39}}) {(track "Track1" {39 34 32 30 28 26 24 22 20 18 36 16 14 12 10 8 6 4 2 0 37 1 3 5 7 9 11 13 15 17 38 19 21 23 25 27 29 31 33 35} loop:True P1) (track "Track2" {39 35 33 31 29 27 25 23 21 19 38 17 15 13 11 9 7 5 3 1 37 0 2 4 6 8 10 12 14 16 36 18 20 22 24 26 28 30 32 34} loop:True P2) (track "Track3" {39 34 32 30 28 26 24 22 20 18 36 16 14 12 10 8 6 4 2 0 37 1 3 5 7 9 11 13 15 17 38 19 21 23 25 27 29 31 33 35} loop:True P3) (track "Track4" {39 35 33 31 29 27 25 23 21 19 38 17 15 13 11 9 7 5 3 1 37 0 2 4 6 8 10 12 14 16 36 18 20 22 24 26 28 30 32 34} loop:True P4)} use:Edge) (regions "AllSites" (sites Board)) (map "Throw" {(pair 0 10) (pair 1 2) (pair 2 3) (pair 3 5)}) (map "Start" {(pair 1 37) (pair 2 38) (pair 3 39) (pair 4 36)}) (piece "Stick" Each (move (from (from) level:(level)) (to (trackSite Move steps:(mapEntry "Throw" (count Pips))) if:True (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry "Start" (who at:(to))))))) (then (forEach Site (sites Track Mover "Track" from:(trackSite Move from:(last From) "Track" steps:1) to:(last To)) (if (is Enemy (who at:(site))) (forEach Level (site) (move (from (site) level:(level)) (to (mapEntry "Start" (who at:(site) level:(level))))))))))) (dice d:2 from:0 num:3)}) (rules (start {(set Team 1 {P1 P3}) (set Team 2 {P2 P4}) (place Stack "Stick1" 37) (place Stack "Stick2" 38) (place Stack "Stick3" 39) (place Stack "Stick4" 36)}) (play (do (roll) next:(forEach Piece) (then (do (if (is In (mapEntry "Start" Mover) (sites Track Mover "Track" from:(trackSite Move from:(last From) "Track" steps:1) to:(last To))) (addScore Mover 1) (then (if (= (score Mover) 3) (remove (last To))))) next:(if (and (!= 3 (score Mover)) (= 10 (mapEntry "Throw" (count Pips)))) (moveAgain)))))) (end (if (>= (score Mover) 4) (result Mover Win))))) 
Forty stones arranged in a circle, with a larger gap after every tenth stone, the spaces between the stones are the playing spaces. Four or six players, played on two teams, with two sticks per team, starting in one of the gaps. Three sticks, round on one side and flat on the other, used as dice. The throws are as follows: three round sides = 10; two round sides = 2; one round side = 3; three flat sides = 5. A throw of 10 grants the player another throw. Pieces move according to the throws in opposite directions around the board. The team to get their pieces to the starting gap wins. The game has 6 players.
(game "Setichch" (players 6) (equipment {(board (add (remove (concentric {44}) vertices:{43 21 0 22}) edges:{{20 18} {0 1} {19 21} {38 39}}) {(track "TrackCW" {39 35 33 31 29 27 25 23 21 19 38 17 15 13 11 9 7 5 3 1 37 0 2 4 6 8 10 12 14 16 36 18 20 22 24 26 28 30 32 34} loop:True) (track "TrackCCW" {39 34 32 30 28 26 24 22 20 18 36 16 14 12 10 8 6 4 2 0 37 1 3 5 7 9 11 13 15 17 38 19 21 23 25 27 29 31 33 35} loop:True)} use:Edge) (regions "AllSites" (sites Board)) (piece "Stick" P1) (piece "Stick" P2) (dice d:2 from:0 num:3) (hand Each) (map "Throw" {(pair 0 5) (pair 1 3) (pair 2 2) (pair 3 10)})}) (rules (start {(place Stack "Stick1" Edge 36 count:2) (place Stack "Stick2" Edge 38 count:2) (set Team 1 {P1 P3 P5}) (set Team 2 {P2 P4 P6})}) (play (do (roll) next:(if (is In (mover) (players Team1)) (move (from (sites Occupied by:Team1)) (to (trackSite Move "TrackCW" steps:(mapEntry "Throw" (count Pips))) if:(not (is Enemy (who at:(to)))))) (move (from (sites Occupied by:Team2)) (to (trackSite Move "TrackCCW" steps:(mapEntry "Throw" (count Pips))) if:(not (is Enemy (who at:(to))))))) (then (if (= 10 (mapEntry "Throw" (count Pips))) (moveAgain))))) (end {(if (and {(is In (mover) (players Team1)) (= 1 (count Sites in:(sites Occupied by:Team1))) (= 36 (where "Stick" Team1))}) (result Team1 Win)) (if (and {(is In (mover) (players Team2)) (= 1 (count Sites in:(sites Occupied by:Team2))) (= 38 (where "Stick" Team2))}) (result Team2 Win))}))) 
98 spaces on the board. Six six-sided dice. One piece per player. Pieces are initially placed on the board based on the values of the throws of the dice. The throws are as follows: Space one: two 1s; Space 2: two 2s; Space 3: two 3s; Space 4: two 4s Space 5: two 5s; Space 6: two 6s; Space 7: five of any number; Space 8: six of any number; Space 9: three 1s; Space 10; three 2s; Space 11; three 3s; Space 12; three 4s; Space 13; three 5s; Space 14; three 6s; Space 16; four 1s; Space 17; four 2s; Space 18; four 3s; Space 19; four 4s; Space 20: four 5s; Space 21: four 6s. From here, the players move to prescribed spaces based on the throw they make, based on the instructions for the space they are currently on. There are three throws which result in a move: Te ("Influence"; double 4s), Cung ("Pair"; double 2, 3, 5, or 6) or Chang ("Failure"; double 1). The players use the throws as many times as allowed (e.g., six 5s = three Cung, allowing the player to move Cung from each successive square). Throws which do not produce a result where the player can move result in a pass. Throws of Te generally advance the player along the board. A throw of Te moves the player to the next consecutively numbered space, with the following exceptions: 1-3 to 37; 4-6 to 38; 7 to 73; 8 to 72; 9 to 52; 10 to 51; 11 to 50; 12 to 49; 13 to 48; 14 to 47; 15 to 55; 16-21 to 23; 27 to 56; 30 to 32; 35 to 67; 36 to 66; 46 to 89; 47 to 59; 48 to 74; 49 to 71; 50 to 47; 51 to 50; 52 to 51; 59 to 71; 60 to 62; 61 to 47; 62 to 61; 63 to 65; 64 to 69; 65 to 64; 66 to 60; 67 to 70; 68 to 86; 69 to 84; 70 to 68; 71 to 74; 72 to 90; 73 to 92; 75 to 93; 81 to 31; 82 to 91; 83-88 to the previous consecutively numbered square; 89 to 91; 90 to 92; 91 to 93; 92 to 94; 94 to 97; 95 to 98; 96 to 95. Throws of Cung move players from: 1, 2, and 3 to 76; 8 to 60; 9 to 23; 15 to 53; 16-21 to 22; 27 to 25; 37 to 36; 41 to 30; 42 to 31; 47 to 54; 48 to 65; 49 to 54; 69 to 88. Throws of Chang move the player to space 28 from spaces 54-59, or to space 29 from spaces 30-35 and 68. Players must throw Te to leave spaces 28 or 29, and return to the space they previously occupied. The player who throws Te while in space 97 or 98 first moves to the palace and wins. The game is played with 16 players.
(game "Shing Quon Tu" (players 16) (equipment {(board (union {(scale 2 2.2 (square 1)) (shift 0 -0.5 (scale 1 0.5 (square 1))) (shift 1 -0.5 (scale 1 0.5 (square 1))) (shift 0 -1 (scale 0.5 0.5 (rectangle 1 2))) (shift 1 -1 (scale 0.5 0.5 (rectangle 1 2))) (shift 0 -2 (scale 1 0.5 (rectangle 2 1))) (shift 1 -2 (scale 1 0.5 (rectangle 2 1))) (shift 2 -2 (scale 1 0.5 (rectangle 6 1))) (shift 2 1 (scale 1 1.2 (square 1))) (shift 0 2.2 (scale 0.5 1 (rectangle 1 6))) (shift -2 -2 (scale 1 1.04 (rectangle 5 2))) (shift -2 -3 (rectangle 1 5)) (shift 3 -3 (scale 1 1.55 (rectangle 4 1))) (shift -2 3.2 (scale 2 1 (rectangle 1 3))) (shift -2 4.2 (scale 3 1 (rectangle 1 2))) (shift -3.2 -2 (scale 1.2 (rectangle 6 1))) (shift 4 -2.6 (scale 1.3 (rectangle 6 1))) (shift 4 -3 (scale 1.3 0.4 (square 1))) (shift -2 -4.3 (scale 1 1.3 (square 1))) (shift -3.2 -4.3 (scale 1.2 0.383 (rectangle 6 1))) (shift -3.2 -5.5 (scale 1.2 (square 1))) (shift -1 -4.3 (scale 0.335 1.29 (rectangle 1 6))) (shift 1.01 -4.3 (scale 0.4 1.29 (rectangle 1 9))) (shift 4.61 -4.3 (scale 0.7 1.29 (square 1))) (shift -2 -5.5 (scale 0.501 1.2 (rectangle 1 6))) (shift 2 -5.5 (scale 0.4 1.2 (rectangle 1 6))) (shift 1.005 -5.5 (scale 1 1.2 (square 1))) (shift 4.4 -5.5 (scale 0.91 1.2 (square 1)))}) (track "Track" {98 96 95 94 93 92 91 97 90 89 88 87 86 85 68 62 63 64 65 66 67 48 49 50 51 52 53 46 47 59 58 57 56 55 54 60 84 83 82 81 80 79 78 77 76 75 74 73 72 71 70 69 61 34 24 26 28 30 32 43 44 45 42 41 40 39 38 37 36 35 25 27 29 31 33 18 19 20 21 22 23 17 16 15 14 13 12 11 9 7 10 8 6 5 4 3 2 1} directed:True)) (dice d:6 num:6) (hand Each) (piece "Pawn" Each) (map "Site" {(pair 1 98) (pair 2 96) (pair 3 95) (pair 4 94) (pair 5 93) (pair 6 92) (pair 7 91) (pair 8 97) (pair 9 90) (pair 10 89) (pair 11 88) (pair 12 87) (pair 13 86) (pair 14 85) (pair 15 68) (pair 16 62) (pair 17 63) (pair 18 64) (pair 19 65) (pair 20 66) (pair 21 67) (pair 22 48) (pair 23 49) (pair 24 50) (pair 25 51) (pair 26 52) (pair 27 53) (pair 28 46) (pair 29 47) (pair 30 59) (pair 31 58) (pair 32 57) (pair 33 56) (pair 34 55) (pair 35 54) (pair 36 60) (pair 37 84) (pair 38 83) (pair 39 82) (pair 40 81) (pair 41 80) (pair 42 79) (pair 43 78) (pair 44 77) (pair 45 76) (pair 46 75) (pair 47 74) (pair 48 73) (pair 49 72) (pair 50 71) (pair 51 70) (pair 52 69) (pair 53 61) (pair 54 34) (pair 55 24) (pair 56 26) (pair 57 28) (pair 58 30) (pair 59 32) (pair 60 43) (pair 61 44) (pair 62 45) (pair 63 42) (pair 64 41) (pair 65 40) (pair 66 39) (pair 67 38) (pair 68 37) (pair 69 36) (pair 70 35) (pair 71 25) (pair 72 27) (pair 73 29) (pair 74 31) (pair 75 33) (pair 76 18) (pair 77 19) (pair 78 20) (pair 79 21) (pair 80 22) (pair 81 23) (pair 82 17) (pair 83 16) (pair 84 15) (pair 85 14) (pair 86 13) (pair 87 12) (pair 88 11) (pair 89 9) (pair 90 7) (pair 91 10) (pair 92 8) (pair 93 6) (pair 94 5) (pair 95 4) (pair 96 3) (pair 97 2) (pair 98 1) (pair 0 0)}) (map "OppositeSite" {(pair 98 1) (pair 96 2) (pair 95 3) (pair 94 4) (pair 93 5) (pair 92 6) (pair 91 7) (pair 97 8) (pair 90 9) (pair 89 10) (pair 88 11) (pair 87 12) (pair 86 13) (pair 85 14) (pair 68 15) (pair 62 16) (pair 63 17) (pair 64 18) (pair 65 19) (pair 66 20) (pair 67 21) (pair 48 22) (pair 49 23) (pair 50 24) (pair 51 25) (pair 52 26) (pair 53 27) (pair 46 28) (pair 47 29) (pair 59 30) (pair 58 31) (pair 57 32) (pair 56 33) (pair 55 34) (pair 54 35) (pair 60 36) (pair 84 37) (pair 83 38) (pair 82 39) (pair 81 40) (pair 80 41) (pair 79 42) (pair 78 43) (pair 77 44) (pair 76 45) (pair 75 46) (pair 74 47) (pair 73 48) (pair 72 49) (pair 71 50) (pair 70 51) (pair 69 52) (pair 61 53) (pair 34 54) (pair 24 55) (pair 26 56) (pair 28 57) (pair 30 58) (pair 32 59) (pair 43 60) (pair 44 61) (pair 45 62) (pair 42 63) (pair 41 64) (pair 40 65) (pair 39 66) (pair 38 67) (pair 37 68) (pair 36 69) (pair 35 70) (pair 25 71) (pair 27 72) (pair 29 73) (pair 31 74) (pair 33 75) (pair 18 76) (pair 19 77) (pair 20 78) (pair 21 79) (pair 22 80) (pair 23 81) (pair 17 82) (pair 16 83) (pair 15 84) (pair 14 85) (pair 13 86) (pair 12 87) (pair 11 88) (pair 9 89) (pair 7 90) (pair 10 91) (pair 8 92) (pair 6 93) (pair 5 94) (pair 4 95) (pair 3 96) (pair 2 97) (pair 1 98) (pair 0 0)}) (map "TeMove" {(pair 1 37) (pair 2 37) (pair 3 37) (pair 4 38) (pair 5 38) (pair 6 38) (pair 7 73) (pair 8 72) (pair 9 52) (pair 10 51) (pair 11 50) (pair 12 49) (pair 13 48) (pair 14 47) (pair 15 55) (pair 16 23) (pair 17 23) (pair 18 23) (pair 19 23) (pair 20 23) (pair 21 23) (pair 27 56) (pair 30 32) (pair 35 67) (pair 36 66) (pair 46 89) (pair 47 59) (pair 48 74) (pair 49 71) (pair 50 47) (pair 51 50) (pair 52 51) (pair 59 71) (pair 60 62) (pair 61 47) (pair 62 61) (pair 63 65) (pair 64 69) (pair 65 64) (pair 66 60) (pair 67 70) (pair 68 86) (pair 69 84) (pair 70 68) (pair 71 74) (pair 72 90) (pair 73 92) (pair 75 93) (pair 81 31) (pair 82 91) (pair 83 82) (pair 84 83) (pair 85 84) (pair 86 85) (pair 87 86) (pair 88 87) (pair 89 91) (pair 90 92) (pair 91 93) (pair 92 94) (pair 94 97) (pair 95 98) (pair 96 95) (pair 97 0) (pair 98 0)}) (map "CungMove" {(pair 1 76) (pair 2 76) (pair 3 76) (pair 8 60) (pair 9 23) (pair 15 53) (pair 16 22) (pair 17 22) (pair 18 22) (pair 19 22) (pair 20 22) (pair 21 22) (pair 27 25) (pair 37 36) (pair 41 30) (pair 42 31) (pair 47 54) (pair 48 65) (pair 49 54) (pair 69 88)}) (map "ChangMove" {(pair 30 29) (pair 31 29) (pair 32 29) (pair 33 29) (pair 34 29) (pair 35 29) (pair 54 28) (pair 55 28) (pair 56 28) (pair 57 28) (pair 58 28) (pair 59 28) (pair 68 29)})}) (rules (start {(place Stack "Pawn1" (handSite P1)) (place Stack "Pawn2" (handSite P2)) (place Stack "Pawn3" (handSite P3)) (place Stack "Pawn4" (handSite P4)) (place Stack "Pawn5" (handSite P5)) (place Stack "Pawn6" (handSite P6)) (place Stack "Pawn7" (handSite P7)) (place Stack "Pawn8" (handSite P8)) (place Stack "Pawn9" (handSite P9)) (place Stack "Pawn10" (handSite P10)) (place Stack "Pawn11" (handSite P11)) (place Stack "Pawn12" (handSite P12)) (place Stack "Pawn13" (handSite P13)) (place Stack "Pawn14" (handSite P14)) (place Stack "Pawn15" (handSite P15)) (place Stack "Pawn16" (handSite P16))}) phases:{(phase "Opening" (play (do (roll) next:(or {(if (= 2 (count Value 1 in:(array {(face (+ (count Players) 99)) (face (+ (count Players) 100)) (face (+ (count Players) 101)) (face (+ (count Players) 102)) (face (+ (count Players) 103)) (face (+ (count Players) 104))}))) (move (from (handSite Mover)) (to (mapEntry "Site" 1)))) (if (= 2 (count Value 2 in:(array {(face (+ (count Players) 99)) (face (+ (count Players) 100)) (face (+ (count Players) 101)) (face (+ (count Players) 102)) (face (+ (count Players) 103)) (face (+ (count Players) 104))}))) (move (from (handSite Mover)) (to (mapEntry "Site" 2)))) (if (= 2 (count Value 4 in:(array {(face (+ (count Players) 99)) (face (+ (count Players) 100)) (face (+ (count Players) 101)) (face (+ (count Players) 102)) (face (+ (count Players) 103)) (face (+ (count Players) 104))}))) (move (from (handSite Mover)) (to (mapEntry "Site" 3)))) (if (= 2 (count Value 3 in:(array {(face (+ (count Players) 99)) (face (+ (count Players) 100)) (face (+ (count Players) 101)) (face (+ (count Players) 102)) (face (+ (count Players) 103)) (face (+ (count Players) 104))}))) (move (from (handSite Mover)) (to (mapEntry "Site" 4)))) (if (= 2 (count Value 5 in:(array {(face (+ (count Players) 99)) (face (+ (count Players) 100)) (face (+ (count Players) 101)) (face (+ (count Players) 102)) (face (+ (count Players) 103)) (face (+ (count Players) 104))}))) (move (from (handSite Mover)) (to (mapEntry "Site" 5)))) (if (= 2 (count Value 6 in:(array {(face (+ (count Players) 99)) (face (+ (count Players) 100)) (face (+ (count Players) 101)) (face (+ (count Players) 102)) (face (+ (count Players) 103)) (face (+ (count Players) 104))}))) (move (from (handSite Mover)) (to (mapEntry "Site" 6)))) (if (or {(= 5 (count Value 1 in:(array {(face (+ (count Players) 99)) (face (+ (count Players) 100)) (face (+ (count Players) 101)) (face (+ (count Players) 102)) (face (+ (count Players) 103)) (face (+ (count Players) 104))}))) (= 5 (count Value 2 in:(array {(face (+ (count Players) 99)) (face (+ (count Players) 100)) (face (+ (count Players) 101)) (face (+ (count Players) 102)) (face (+ (count Players) 103)) (face (+ (count Players) 104))}))) (= 5 (count Value 3 in:(array {(face (+ (count Players) 99)) (face (+ (count Players) 100)) (face (+ (count Players) 101)) (face (+ (count Players) 102)) (face (+ (count Players) 103)) (face (+ (count Players) 104))}))) (= 5 (count Value 4 in:(array {(face (+ (count Players) 99)) (face (+ (count Players) 100)) (face (+ (count Players) 101)) (face (+ (count Players) 102)) (face (+ (count Players) 103)) (face (+ (count Players) 104))}))) (= 5 (count Value 5 in:(array {(face (+ (count Players) 99)) (face (+ (count Players) 100)) (face (+ (count Players) 101)) (face (+ (count Players) 102)) (face (+ (count Players) 103)) (face (+ (count Players) 104))}))) (= 5 (count Value 6 in:(array {(face (+ (count Players) 99)) (face (+ (count Players) 100)) (face (+ (count Players) 101)) (face (+ (count Players) 102)) (face (+ (count Players) 103)) (face (+ (count Players) 104))})))}) (move (from (handSite Mover)) (to (mapEntry "Site" 7)))) (if (or {(= 6 (count Value 1 in:(array {(face (+ (count Players) 99)) (face (+ (count Players) 100)) (face (+ (count Players) 101)) (face (+ (count Players) 102)) (face (+ (count Players) 103)) (face (+ (count Players) 104))}))) (= 6 (count Value 2 in:(array {(face (+ (count Players) 99)) (face (+ (count Players) 100)) (face (+ (count Players) 101)) (face (+ (count Players) 102)) (face (+ (count Players) 103)) (face (+ (count Players) 104))}))) (= 6 (count Value 3 in:(array {(face (+ (count Players) 99)) (face (+ (count Players) 100)) (face (+ (count Players) 101)) (face (+ (count Players) 102)) (face (+ (count Players) 103)) (face (+ (count Players) 104))}))) (= 6 (count Value 4 in:(array {(face (+ (count Players) 99)) (face (+ (count Players) 100)) (face (+ (count Players) 101)) (face (+ (count Players) 102)) (face (+ (count Players) 103)) (face (+ (count Players) 104))}))) (= 6 (count Value 5 in:(array {(face (+ (count Players) 99)) (face (+ (count Players) 100)) (face (+ (count Players) 101)) (face (+ (count Players) 102)) (face (+ (count Players) 103)) (face (+ (count Players) 104))}))) (= 6 (count Value 6 in:(array {(face (+ (count Players) 99)) (face (+ (count Players) 100)) (face (+ (count Players) 101)) (face (+ (count Players) 102)) (face (+ (count Players) 103)) (face (+ (count Players) 104))})))}) (move (from (handSite Mover)) (to (mapEntry "Site" 8)))) (if (= 3 (count Value 1 in:(array {(face (+ (count Players) 99)) (face (+ (count Players) 100)) (face (+ (count Players) 101)) (face (+ (count Players) 102)) (face (+ (count Players) 103)) (face (+ (count Players) 104))}))) (move (from (handSite Mover)) (to (mapEntry "Site" 9)))) (if (= 3 (count Value 2 in:(array {(face (+ (count Players) 99)) (face (+ (count Players) 100)) (face (+ (count Players) 101)) (face (+ (count Players) 102)) (face (+ (count Players) 103)) (face (+ (count Players) 104))}))) (move (from (handSite Mover)) (to (mapEntry "Site" 10)))) (if (= 3 (count Value 3 in:(array {(face (+ (count Players) 99)) (face (+ (count Players) 100)) (face (+ (count Players) 101)) (face (+ (count Players) 102)) (face (+ (count Players) 103)) (face (+ (count Players) 104))}))) (move (from (handSite Mover)) (to (mapEntry "Site" 11)))) (if (= 3 (count Value 4 in:(array {(face (+ (count Players) 99)) (face (+ (count Players) 100)) (face (+ (count Players) 101)) (face (+ (count Players) 102)) (face (+ (count Players) 103)) (face (+ (count Players) 104))}))) (move (from (handSite Mover)) (to (mapEntry "Site" 12)))) (if (= 3 (count Value 5 in:(array {(face (+ (count Players) 99)) (face (+ (count Players) 100)) (face (+ (count Players) 101)) (face (+ (count Players) 102)) (face (+ (count Players) 103)) (face (+ (count Players) 104))}))) (move (from (handSite Mover)) (to (mapEntry "Site" 13)))) (if (= 3 (count Value 6 in:(array {(face (+ (count Players) 99)) (face (+ (count Players) 100)) (face (+ (count Players) 101)) (face (+ (count Players) 102)) (face (+ (count Players) 103)) (face (+ (count Players) 104))}))) (move (from (handSite Mover)) (to (mapEntry "Site" 14)))) (if (= 4 (count Value 1 in:(array {(face (+ (count Players) 99)) (face (+ (count Players) 100)) (face (+ (count Players) 101)) (face (+ (count Players) 102)) (face (+ (count Players) 103)) (face (+ (count Players) 104))}))) (move (from (handSite Mover)) (to (mapEntry "Site" 16)))) (if (= 4 (count Value 2 in:(array {(face (+ (count Players) 99)) (face (+ (count Players) 100)) (face (+ (count Players) 101)) (face (+ (count Players) 102)) (face (+ (count Players) 103)) (face (+ (count Players) 104))}))) (move (from (handSite Mover)) (to (mapEntry "Site" 17)))) (if (= 4 (count Value 3 in:(array {(face (+ (count Players) 99)) (face (+ (count Players) 100)) (face (+ (count Players) 101)) (face (+ (count Players) 102)) (face (+ (count Players) 103)) (face (+ (count Players) 104))}))) (move (from (handSite Mover)) (to (mapEntry "Site" 18)))) (if (= 4 (count Value 4 in:(array {(face (+ (count Players) 99)) (face (+ (count Players) 100)) (face (+ (count Players) 101)) (face (+ (count Players) 102)) (face (+ (count Players) 103)) (face (+ (count Players) 104))}))) (move (from (handSite Mover)) (to (mapEntry "Site" 19)))) (if (= 4 (count Value 5 in:(array {(face (+ (count Players) 99)) (face (+ (count Players) 100)) (face (+ (count Players) 101)) (face (+ (count Players) 102)) (face (+ (count Players) 103)) (face (+ (count Players) 104))}))) (move (from (handSite Mover)) (to (mapEntry "Site" 20)))) (if (= 4 (count Value 6 in:(array {(face (+ (count Players) 99)) (face (+ (count Players) 100)) (face (+ (count Players) 101)) (face (+ (count Players) 102)) (face (+ (count Players) 103)) (face (+ (count Players) 104))}))) (move (from (handSite Mover)) (to (mapEntry "Site" 21))))}))) (nextPhase Mover (is Empty (handSite Mover)) "Playing")) (phase "Playing" (play (if (is Prev Mover) (if (can Move (or {(if (!= 0 (size Array (values Remembered "Te"))) (if (!= (mapEntry "Site" (where "Pawn" Mover)) (mapEntry "TeMove" (mapEntry "Site" (where "Pawn" Mover)))) (move (from (where "Pawn" Mover)) (to (mapEntry "OppositeSite" (mapEntry "TeMove" (mapEntry "Site" (where "Pawn" Mover))))) (then (and (forget Value "Te" 1) (if (< 1 (+ {(size Array (values Remembered "Te")) (size Array (values Remembered "Cung")) (size Array (values Remembered "Chang"))})) (moveAgain))))) (move (from (where "Pawn" Mover)) (to (trackSite Move from:(where "Pawn" Mover) steps:1)) (then (and (forget Value "Te" 1) (if (< 1 (+ {(size Array (values Remembered "Te")) (size Array (values Remembered "Cung")) (size Array (values Remembered "Chang"))})) (moveAgain))))))) (if (!= 0 (size Array (values Remembered "Cung"))) (if (!= (mapEntry "Site" (where "Pawn" Mover)) (mapEntry "CungMove" (mapEntry "Site" (where "Pawn" Mover)))) (move (from (where "Pawn" Mover)) (to (mapEntry "OppositeSite" (mapEntry "CungMove" (mapEntry "Site" (where "Pawn" Mover))))) (then (and (forget Value "Cung" 1) (if (< 1 (+ {(size Array (values Remembered "Te")) (size Array (values Remembered "Cung")) (size Array (values Remembered "Chang"))})) (moveAgain))))))) (if (!= 0 (size Array (values Remembered "Chang"))) (if (!= (mapEntry "Site" (where "Pawn" Mover)) (mapEntry "ChangMove" (mapEntry "Site" (where "Pawn" Mover)))) (move (from (where "Pawn" Mover)) (to (mapEntry "OppositeSite" (mapEntry "ChangMove" (mapEntry "Site" (where "Pawn" Mover))))))))})) (or {(if (!= 0 (size Array (values Remembered "Te"))) (if (!= (mapEntry "Site" (where "Pawn" Mover)) (mapEntry "TeMove" (mapEntry "Site" (where "Pawn" Mover)))) (move (from (where "Pawn" Mover)) (to (mapEntry "OppositeSite" (mapEntry "TeMove" (mapEntry "Site" (where "Pawn" Mover))))) (then (and (forget Value "Te" 1) (if (< 1 (+ {(size Array (values Remembered "Te")) (size Array (values Remembered "Cung")) (size Array (values Remembered "Chang"))})) (moveAgain))))) (move (from (where "Pawn" Mover)) (to (trackSite Move from:(where "Pawn" Mover) steps:1)) (then (and (forget Value "Te" 1) (if (< 1 (+ {(size Array (values Remembered "Te")) (size Array (values Remembered "Cung")) (size Array (values Remembered "Chang"))})) (moveAgain))))))) (if (!= 0 (size Array (values Remembered "Cung"))) (if (!= (mapEntry "Site" (where "Pawn" Mover)) (mapEntry "CungMove" (mapEntry "Site" (where "Pawn" Mover)))) (move (from (where "Pawn" Mover)) (to (mapEntry "OppositeSite" (mapEntry "CungMove" (mapEntry "Site" (where "Pawn" Mover))))) (then (and (forget Value "Cung" 1) (if (< 1 (+ {(size Array (values Remembered "Te")) (size Array (values Remembered "Cung")) (size Array (values Remembered "Chang"))})) (moveAgain))))))) (if (!= 0 (size Array (values Remembered "Chang"))) (if (!= (mapEntry "Site" (where "Pawn" Mover)) (mapEntry "ChangMove" (mapEntry "Site" (where "Pawn" Mover)))) (move (from (where "Pawn" Mover)) (to (mapEntry "OppositeSite" (mapEntry "ChangMove" (mapEntry "Site" (where "Pawn" Mover))))))))}) (move Pass (then (and {(forget Value "Te" All) (forget Value "Cung" All) (forget Value "Chang" All)})))) (do (roll) next:(move Pass) (then (and {(moveAgain) (if (= 2 (count Value 4 in:(array {(face (+ (count Players) 99)) (face (+ (count Players) 100)) (face (+ (count Players) 101)) (face (+ (count Players) 102)) (face (+ (count Players) 103)) (face (+ (count Players) 104))}))) (remember Value "Te" 1) (if (= 4 (count Value 4 in:(array {(face (+ (count Players) 99)) (face (+ (count Players) 100)) (face (+ (count Players) 101)) (face (+ (count Players) 102)) (face (+ (count Players) 103)) (face (+ (count Players) 104))}))) (and (remember Value "Te" 1) (remember Value "Te" 1)) (if (= 6 (count Value 4 in:(array {(face (+ (count Players) 99)) (face (+ (count Players) 100)) (face (+ (count Players) 101)) (face (+ (count Players) 102)) (face (+ (count Players) 103)) (face (+ (count Players) 104))}))) (and {(remember Value "Te" 1) (remember Value "Te" 1) (remember Value "Te" 1)})))) (if (= 2 (count Value 1 in:(array {(face (+ (count Players) 99)) (face (+ (count Players) 100)) (face (+ (count Players) 101)) (face (+ (count Players) 102)) (face (+ (count Players) 103)) (face (+ (count Players) 104))}))) (remember Value "Chang" 1) (if (= 4 (count Value 1 in:(array {(face (+ (count Players) 99)) (face (+ (count Players) 100)) (face (+ (count Players) 101)) (face (+ (count Players) 102)) (face (+ (count Players) 103)) (face (+ (count Players) 104))}))) (and (remember Value "Chang" 1) (remember Value "Chang" 1)) (if (= 6 (count Value 1 in:(array {(face (+ (count Players) 99)) (face (+ (count Players) 100)) (face (+ (count Players) 101)) (face (+ (count Players) 102)) (face (+ (count Players) 103)) (face (+ (count Players) 104))}))) (and {(remember Value "Chang" 1) (remember Value "Chang" 1) (remember Value "Chang" 1)})))) (if (= 2 (count Value 2 in:(array {(face (+ (count Players) 99)) (face (+ (count Players) 100)) (face (+ (count Players) 101)) (face (+ (count Players) 102)) (face (+ (count Players) 103)) (face (+ (count Players) 104))}))) (remember Value "Cung" 1) (if (= 4 (count Value 2 in:(array {(face (+ (count Players) 99)) (face (+ (count Players) 100)) (face (+ (count Players) 101)) (face (+ (count Players) 102)) (face (+ (count Players) 103)) (face (+ (count Players) 104))}))) (and (remember Value "Cung" 1) (remember Value "Cung" 1)) (if (= 6 (count Value 2 in:(array {(face (+ (count Players) 99)) (face (+ (count Players) 100)) (face (+ (count Players) 101)) (face (+ (count Players) 102)) (face (+ (count Players) 103)) (face (+ (count Players) 104))}))) (and {(remember Value "Cung" 1) (remember Value "Cung" 1) (remember Value "Cung" 1)})))) (if (= 2 (count Value 3 in:(array {(face (+ (count Players) 99)) (face (+ (count Players) 100)) (face (+ (count Players) 101)) (face (+ (count Players) 102)) (face (+ (count Players) 103)) (face (+ (count Players) 104))}))) (remember Value "Cung" 1) (if (= 4 (count Value 3 in:(array {(face (+ (count Players) 99)) (face (+ (count Players) 100)) (face (+ (count Players) 101)) (face (+ (count Players) 102)) (face (+ (count Players) 103)) (face (+ (count Players) 104))}))) (and (remember Value "Cung" 1) (remember Value "Cung" 1)) (if (= 6 (count Value 3 in:(array {(face (+ (count Players) 99)) (face (+ (count Players) 100)) (face (+ (count Players) 101)) (face (+ (count Players) 102)) (face (+ (count Players) 103)) (face (+ (count Players) 104))}))) (and {(remember Value "Cung" 1) (remember Value "Cung" 1) (remember Value "Cung" 1)})))) (if (= 2 (count Value 5 in:(array {(face (+ (count Players) 99)) (face (+ (count Players) 100)) (face (+ (count Players) 101)) (face (+ (count Players) 102)) (face (+ (count Players) 103)) (face (+ (count Players) 104))}))) (remember Value "Cung" 1) (if (= 4 (count Value 5 in:(array {(face (+ (count Players) 99)) (face (+ (count Players) 100)) (face (+ (count Players) 101)) (face (+ (count Players) 102)) (face (+ (count Players) 103)) (face (+ (count Players) 104))}))) (and (remember Value "Cung" 1) (remember Value "Cung" 1)) (if (= 6 (count Value 5 in:(array {(face (+ (count Players) 99)) (face (+ (count Players) 100)) (face (+ (count Players) 101)) (face (+ (count Players) 102)) (face (+ (count Players) 103)) (face (+ (count Players) 104))}))) (and {(remember Value "Cung" 1) (remember Value "Cung" 1) (remember Value "Cung" 1)})))) (if (= 2 (count Value 6 in:(array {(face (+ (count Players) 99)) (face (+ (count Players) 100)) (face (+ (count Players) 101)) (face (+ (count Players) 102)) (face (+ (count Players) 103)) (face (+ (count Players) 104))}))) (remember Value "Cung" 1) (if (= 4 (count Value 6 in:(array {(face (+ (count Players) 99)) (face (+ (count Players) 100)) (face (+ (count Players) 101)) (face (+ (count Players) 102)) (face (+ (count Players) 103)) (face (+ (count Players) 104))}))) (and (remember Value "Cung" 1) (remember Value "Cung" 1)) (if (= 6 (count Value 6 in:(array {(face (+ (count Players) 99)) (face (+ (count Players) 100)) (face (+ (count Players) 101)) (face (+ (count Players) 102)) (face (+ (count Players) 103)) (face (+ (count Players) 104))}))) (and {(remember Value "Cung" 1) (remember Value "Cung" 1) (remember Value "Cung" 1)}))))}))))))} (end (if (= 0 (where "Pawn" Mover)) (result Mover Win))))) 
5x5 grid, with six spaces extending up from the rightmost column. The central space of the grid is the minaret, the final three spaces in the extending track are Cairo, Medina, and Mecca. Three pieces per player, each having one father, one mother, and one djinn, which all begin on the first space. The track is boustrophedon, starting in the bottom left corner and moving to the right, until it reaches the top right corner where it proceeds down the extended track. Six sticks, used as dice, with one polished side and one rough side. Throws equal the number of polished sides which land face-up, with the following exceptions: five polished or five rough sides = sig, this grants a move of one plus another throw, in which the player moves the number of polished sides up, six polished = sig of 6, grants the player another throw, and the player moves the number of polished sides up; if the second throw is regular sig, the value is 7, six rough = sig of twelve, grants the player three throws and the player moves the number of polished sides up; if any of those three extra throws are a regular sig, the total value of the extra throws is 13. Pieces move one at a time from the starting space. The first piece to move is the father, the second the djinn, and the third is the mother. The djinn moves twice the value of the throw in any space that does not require a sig to move through it. A player must throw a regular sig to leave the starting space; when they do, they move one space and throw again. When a player passes the piece of an opponent, the opponent's piece returns to the starting space and must enter the board according to the same rules. Certain spaces require a throw of sig to move into and out of them. This means that the move of 1 given by the regular sig can be used to do this, but the extra throw granted by it does not; however, the total value awarded by a sig of six or twelve does count. These are the Minaret, and all of the spaces in the extended track. If a player cannot enter a space because their is not a sig attached to their throw, they stop their move at the point before it. The space for Cairo counts for three of the value of the throw. When a piece reaches Mecca and there is still value left in the throw, the next piece may be entered and moved using the remaining moves left in the throw. The djinn is entered when the father reaches Mecca, and the mother is entered once the djinn reaches Mecca. The first player to place all of their pieces on Mecca wins. The game has 4 players.
(game "Sig (El Oued)" (players 4) (equipment {(board (scale 2 1 (merge {(square 5) (shift 4 5 (rectangle 3 1)) (scale 2 1 (shift 1.5 8 (rectangle 3 1)))})) {(track "FirstTrack" "0,E,N1,W,N1,E1" directed:True) (track "SecondTrack" "13,E,N1,W,N1,E" directed:True)}) (dice d:2 from:0 num:6) (piece "Father" Each (or {(if (and (!= (from) 0) (is In (from) (sites Track "FirstTrack"))) (move (from (from) level:(level)) (to (trackSite Move "FirstTrack" steps:(if (= 1 (var "SpecialSig")) (+ 1 (mapEntry "Throw" (count Pips))) (mapEntry "Throw" (count Pips)))))) (then (forEach Site (sites Track Mover "FirstTrack" from:(last From) to:(last To)) (if (!= (site) (last To)) (forEach Level (site) FromTop (if (is Enemy (who at:(site) level:(level))) (fromTo (from (site) level:(level)) (to 0)))))))) (if (is In (from) (sites Track "SecondTrack")) (move (from (from) level:(level)) (to (trackSite Move "SecondTrack" steps:(if (= 1 (var "SpecialSig")) (+ 1 (mapEntry "Throw" (count Pips))) (mapEntry "Throw" (count Pips))))) (then (forEach Site (sites Track Mover "SecondTrack" from:(last From) to:(last To)) (if (!= (site) (last To)) (forEach Level (site) FromTop (if (is Enemy (who at:(site) level:(level))) (fromTo (from (site) level:(level)) (to 0))))))))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 0) (if (not (is Prev Mover)) True (= 1 (var "SpecialSig")))}) (move (from (from) level:(level)) (to 1))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 11) (if (not (is Prev Mover)) True (= 1 (var "SpecialSig")))}) (move (from (from) level:(level)) (to 12))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 12) (if (not (is Prev Mover)) True (= 1 (var "SpecialSig")))}) (move (from (from) level:(level)) (to 13))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 24) (if (not (is Prev Mover)) True (= 1 (var "SpecialSig")))}) (move (from (from) level:(level)) (to 25))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 25) (if (not (is Prev Mover)) True (= 1 (var "SpecialSig")))}) (move (from (from) level:(level)) (to 26))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 26) (if (not (is Prev Mover)) True (= 1 (var "SpecialSig")))}) (move (from (from) level:(level)) (to 28))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 28) (if (not (is Prev Mover)) True (= 1 (var "SpecialSig")))}) (move (from (from) level:(level)) (to 27))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 27) (if (not (is Prev Mover)) True (= 1 (var "SpecialSig")))}) (move (from (from) level:(level)) (to 29))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 29) (if (not (is Prev Mover)) True (= 1 (var "SpecialSig")))}) (move (from (from) level:(level)) (to 30)))})) (piece "Djinn" Each (if (= 30 (where "Father" Mover)) (or {(if (and (!= (from) 0) (is In (from) (sites Track "FirstTrack"))) (move (from (from) level:(level)) (to (trackSite Move "FirstTrack" steps:(* 2 (if (= 1 (var "SpecialSig")) (+ 1 (mapEntry "Throw" (count Pips))) (mapEntry "Throw" (count Pips))))))) (then (forEach Site (sites Track Mover "FirstTrack" from:(last From) to:(last To)) (if (!= (site) (last To)) (forEach Level (site) FromTop (if (is Enemy (who at:(site) level:(level))) (fromTo (from (site) level:(level)) (to 0)))))))) (if (is In (from) (sites Track "SecondTrack")) (move (from (from) level:(level)) (to (trackSite Move "SecondTrack" steps:(* 2 (if (= 1 (var "SpecialSig")) (+ 1 (mapEntry "Throw" (count Pips))) (mapEntry "Throw" (count Pips)))))) (then (forEach Site (sites Track Mover "SecondTrack" from:(last From) to:(last To)) (if (!= (site) (last To)) (forEach Level (site) FromTop (if (is Enemy (who at:(site) level:(level))) (fromTo (from (site) level:(level)) (to 0))))))))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 0) (if (not (is Prev Mover)) True (= 1 (var "SpecialSig")))}) (move (from (from) level:(level)) (to 1))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 11) (if (not (is Prev Mover)) True (= 1 (var "SpecialSig")))}) (move (from (from) level:(level)) (to 12))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 12) (if (not (is Prev Mover)) True (= 1 (var "SpecialSig")))}) (move (from (from) level:(level)) (to 13))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 24) (if (not (is Prev Mover)) True (= 1 (var "SpecialSig")))}) (move (from (from) level:(level)) (to 25))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 25) (if (not (is Prev Mover)) True (= 1 (var "SpecialSig")))}) (move (from (from) level:(level)) (to 26))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 26) (if (not (is Prev Mover)) True (= 1 (var "SpecialSig")))}) (move (from (from) level:(level)) (to 28))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 28) (if (not (is Prev Mover)) True (= 1 (var "SpecialSig")))}) (move (from (from) level:(level)) (to 27))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 27) (if (not (is Prev Mover)) True (= 1 (var "SpecialSig")))}) (move (from (from) level:(level)) (to 29))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 29) (if (not (is Prev Mover)) True (= 1 (var "SpecialSig")))}) (move (from (from) level:(level)) (to 30))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 23) (if (not (is Prev Mover)) True (= 1 (var "SpecialSig")))}) (move (from (from) level:(level)) (to 25)))}))) (piece "Mother" Each (if (= 30 (where "Djinn" Mover)) (or {(if (and (!= (from) 0) (is In (from) (sites Track "FirstTrack"))) (move (from (from) level:(level)) (to (trackSite Move "FirstTrack" steps:(if (= 1 (var "SpecialSig")) (+ 1 (mapEntry "Throw" (count Pips))) (mapEntry "Throw" (count Pips)))))) (then (forEach Site (sites Track Mover "FirstTrack" from:(last From) to:(last To)) (if (!= (site) (last To)) (forEach Level (site) FromTop (if (is Enemy (who at:(site) level:(level))) (fromTo (from (site) level:(level)) (to 0)))))))) (if (is In (from) (sites Track "SecondTrack")) (move (from (from) level:(level)) (to (trackSite Move "SecondTrack" steps:(if (= 1 (var "SpecialSig")) (+ 1 (mapEntry "Throw" (count Pips))) (mapEntry "Throw" (count Pips))))) (then (forEach Site (sites Track Mover "SecondTrack" from:(last From) to:(last To)) (if (!= (site) (last To)) (forEach Level (site) FromTop (if (is Enemy (who at:(site) level:(level))) (fromTo (from (site) level:(level)) (to 0))))))))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 0) (if (not (is Prev Mover)) True (= 1 (var "SpecialSig")))}) (move (from (from) level:(level)) (to 1))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 11) (if (not (is Prev Mover)) True (= 1 (var "SpecialSig")))}) (move (from (from) level:(level)) (to 12))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 12) (if (not (is Prev Mover)) True (= 1 (var "SpecialSig")))}) (move (from (from) level:(level)) (to 13))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 24) (if (not (is Prev Mover)) True (= 1 (var "SpecialSig")))}) (move (from (from) level:(level)) (to 25))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 25) (if (not (is Prev Mover)) True (= 1 (var "SpecialSig")))}) (move (from (from) level:(level)) (to 26))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 26) (if (not (is Prev Mover)) True (= 1 (var "SpecialSig")))}) (move (from (from) level:(level)) (to 28))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 28) (if (not (is Prev Mover)) True (= 1 (var "SpecialSig")))}) (move (from (from) level:(level)) (to 27))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 27) (if (not (is Prev Mover)) True (= 1 (var "SpecialSig")))}) (move (from (from) level:(level)) (to 29))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 29) (if (not (is Prev Mover)) True (= 1 (var "SpecialSig")))}) (move (from (from) level:(level)) (to 30)))}))) (map "Throw" {(pair 0 12) (pair 1 1) (pair 2 2) (pair 3 3) (pair 4 4) (pair 5 1) (pair 6 6)}) (map "ExtraThrow" {(pair 0 3) (pair 1 1) (pair 2 0) (pair 3 0) (pair 4 0) (pair 5 1) (pair 6 1)})}) (rules (start {(place Stack "Father1" 0) (place Stack "Djinn1" 0) (place Stack "Mother1" 0) (place Stack "Father2" 0) (place Stack "Djinn2" 0) (place Stack "Mother2" 0) (place Stack "Father3" 0) (place Stack "Djinn3" 0) (place Stack "Mother3" 0) (place Stack "Father4" 0) (place Stack "Djinn4" 0) (place Stack "Mother4" 0)}) (play (do (roll) next:(if (can Move (forEach Piece)) (forEach Piece) (move Pass)) (then (if (!= 0 (mapEntry "ExtraThrow" (count Pips))) (and (if (= 3 (mapEntry "ExtraThrow" (count Pips))) (if (<= (var) 0) (set Var 2))) (if (!= (mover) (prev)) (and (moveAgain) (if (!= 1 (mapEntry "Throw" (count Pips))) (set Var "SpecialSig" 1))))) (if (> (var) 0) (and {(set Var (- (var) 1)) (moveAgain)}) (set Var "SpecialSig" 0)))))) (end (if (and {(= 30 (where "Djinn" Mover)) (= 30 (where "Father" Mover)) (= 30 (where "Mother" Mover))}) (result Mover Win))))) 
86 spaces in a spiral track. Any number of players, each having one piece, which starts on the first space in the outer ring of the spiral. A lump of charcoal, the Ghoula, also is placed on this space. Four sticks, with one green side and one white side, used as dice. The throws are as follows: One white side up = 1, this throw is known as "sig"; two white sides up = 0; three white sides up = 3; four white sides up = 4; all green sides up = 6. Throws of sig, 6, and 4 grant the player another throw. Players move their pieces along the track toward the central space. when they reach the sixth space from the end, they must make seven throws of sig before moving on, moving to the sixteenth spot on the seventh throw. After reaching the next spot, only throws of sig and 3 are used; sig to move one space, and 3 to move the Ghoula three spaces. When players reach the central space, Players control the Ghoula. When controlling the Ghoula, throws of 0 count as 6. Any pieces which have not moved from the starting space when the Ghoula is first moved are dragged with the Ghoula, and then may move normally on their next turn. The Ghoula, when reaching a space occupied by a player, continues their turn dragging the player back to the starting space. A player that is forced back to the starting space by any means loses. All players reaching the central space of the board win. The game has 4 players.
(game "Sig wa Duqqan (Houmt Taourit)" (players 4) (equipment {(board (spiral turns:5 sites:86) {(track "Track" {85 84 83 82 81 80 79 78 77 76 75 74 73 72 71 70 69 68 67 66 65 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5} directed:True) (track "ExtensionTrack" {4 3 2 1 0} directed:True) (track "GhoulaTrack" {86 85 84 83 82 81 80 79 78 77 76 75 74 73 72 71 70 69 68 67 66 65 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5} directed:True) (track "ReverseGhoulaTrack" {5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85} directed:True)} use:Vertex) (dice d:2 from:0 num:4) (map "Throw" {(pair 0 4) (pair 1 3) (pair 2 0) (pair 3 1) (pair 4 6)}) (piece "Stick" Each (if (= (from) 5) (if (= (state at:(from) level:(level)) 7) (move (from (from) level:(level)) (to 4)) (if (= (mapEntry "Throw" (count Pips)) 1) (move Select (from (from) level:(level)) (then (set State at:(last To) level:(last LevelTo) (+ 1 (state at:(last To) level:(last LevelTo)))))))) (if (is In (from) (sites Track "Track")) (move (from (from) level:(level)) (to (trackSite Move "Track" steps:(mapEntry "Throw" (count Pips))) if:True)) (if (is In (from) (sites Track "ExtensionTrack")) (or {(if (and (!= (from) 0) (= (mapEntry "Throw" (count Pips)) 1)) (move (from (from) level:(level)) (to (trackSite Move "ExtensionTrack" steps:1)))) (if (= (from) 0) (move Pass (then (and (if (= 0 (mapEntry "Throw" (count Pips))) (set Var 6) (set Var (mapEntry "Throw" (count Pips)))) (moveAgain)))) (if (= 3 (mapEntry "Throw" (count Pips))) (move Pass (then (and (set Var 3) (moveAgain))))))})))) maxState:7) (piece "Ghoula" Neutral) (hand P1 size:1)}) (rules (start {(place Stack "Ghoula0" 86) (place Stack items:{"Stick4" "Stick3" "Stick2" "Stick1"} 85)}) (play (do (if (<= (var) 0) (roll)) next:(if (> (var) 0) (if (= 1 (size Stack at:(if (!= (where "Ghoula" Neutral) -1) (where "Ghoula" Neutral) (handSite P1)))) (move (from (if (!= (where "Ghoula" Neutral) -1) (where "Ghoula" Neutral) (handSite P1)) level:(where Level "Ghoula" Neutral at:(if (!= (where "Ghoula" Neutral) -1) (where "Ghoula" Neutral) (handSite P1)))) (to (trackSite Move from:(if (!= (where "Ghoula" Neutral) -1) (where "Ghoula" Neutral) (handSite P1)) "GhoulaTrack" steps:1))) (move (from (if (!= (where "Ghoula" Neutral) -1) (where "Ghoula" Neutral) (handSite P1)) level:(where Level "Ghoula" Neutral at:(if (!= (where "Ghoula" Neutral) -1) (where "Ghoula" Neutral) (handSite P1)))) (to (trackSite Move from:(if (!= (where "Ghoula" Neutral) -1) (where "Ghoula" Neutral) (handSite P1)) "ReverseGhoulaTrack" steps:1)) (then (if (= (last From) 84) (forEach Level (last From) FromTop (remove (last From) level:(level))) (forEach Level (last From) FromTop (fromTo (from (last From) level:(level)) (to (last To))))))) (then (if (and (= 1 (size Stack at:(if (!= (where "Ghoula" Neutral) -1) (where "Ghoula" Neutral) (handSite P1)))) (= 5 (if (!= (where "Ghoula" Neutral) -1) (where "Ghoula" Neutral) (handSite P1)))) (set Var 0) (and (if (> (var) 1) (moveAgain)) (set Var (- (var) 1)))))) (if (!= 0 (mapEntry "Throw" (count Pips))) (forEach Piece))) (then (if (is In (mapEntry "Throw" (count Pips)) (sites {1 6 4})) (moveAgain))))) (end {(forEach Player if:(no Pieces Player) (result Player Loss)) (forEach Player if:(and (= 1 (size Stack at:(if (!= (where "Ghoula" Neutral) -1) (where "Ghoula" Neutral) (handSite P1)))) (= 5 (if (!= (where "Ghoula" Neutral) -1) (where "Ghoula" Neutral) (handSite P1)))) (result Player Win))}))) 
4x4 board, with an extension of four squares extending from the left of the bottom row. Two or more players, each with one piece. A piece of charcoal plays the part of the Ghoula. Four sticks, with one green side and one white side, used as dice. The throws are as follows: One white side up = 1, this throw is known as "sig"; two white sides up = 0; three white sides up = 3; four white sides up = 4; all green sides up = 6. Throws of sig, 6, and 4 grant the player another throw. All pieces begin on the top left square of the grid, proceed in a boustrophedon path down the grid, toward the space at the end of the extension, the Ka'aba. Players must throw a sig to move from the first space. When a player reaches the fifteenth space in the track, they must make seven throws of sig before moving on, moving to the sixteenth spot on the seventh throw. After reaching the sixteenth spot, only throws of sig and 3 are used; sig to move one space, and 3 to move the Ghoula three spaces. The goal for each player is to reach the Ka'aba. Upon reaching the Ka'aba, the player continues to throw, all throws used to control the Ghoula, but throws of 0 now counts as 2. The Ghoula, when reaching a space occupied by a player, continues their turn dragging the player back to the starting space. If the Ghoula succeeds in bringing the piece back to the starting space, that player loses. The Ghoula cannot move past the fifteenth space in the track. The game has 4 players.
(game "Sig wa Duqqan (Houmt al-Arbah)" (players 4) (equipment {(board (merge {(shift -4 0 (rectangle 1 4)) (square 4) (shift -4 3 (square 1))}) {(track "Track" "16,E,S1,W,S1,E,S1,W2" directed:True) (track "ExtensionTrack" "4,W" directed:True) (track "GhoulaTrack" "20,16,E,S1,W,S1,E,S1,W2" directed:True) (track "ReverseGhoulaTrack" "6,E,N1,W,N1,E,N1,W" directed:True)}) (piece "Ghoula" Neutral) (piece "Stick" Each (if (= (from) 6) (if (= (state at:(from) level:(level)) 8) (move (from (from) level:(level)) (to 4)) (if (= (mapEntry "Throw" (count Pips)) 1) (move Select (from (from) level:(level)) (then (set State at:(last To) level:(last LevelTo) (+ 1 (state at:(last To) level:(last LevelTo)))))))) (if (is In (from) (sites Track "Track")) (move (from (from) level:(level) if:(if (<= 1 (state at:(from) level:(level))) True (= (mapEntry "Throw" (count Pips)) 1))) (to (trackSite Move "Track" steps:(mapEntry "Throw" (count Pips))) if:True) (then (if (not (<= 1 (state at:(last To) level:(topLevel at:(last To))))) (set State at:(last To) level:(topLevel at:(last To)) 1)))) (if (is In (from) (sites Track "ExtensionTrack")) (or {(if (and (!= (from) 0) (= (mapEntry "Throw" (count Pips)) 1)) (move (from (from) level:(level)) (to (trackSite Move "ExtensionTrack" steps:1)))) (if (= (from) 0) (move Pass (then (and (if (= 0 (mapEntry "Throw" (count Pips))) (set Var 2) (set Var (mapEntry "Throw" (count Pips)))) (moveAgain)))) (if (= 3 (mapEntry "Throw" (count Pips))) (move Pass (then (and (set Var 3) (moveAgain))))))})))) maxState:8) (dice d:2 from:0 num:4) (map "Throw" {(pair 0 4) (pair 1 3) (pair 2 0) (pair 3 1) (pair 4 6)})}) (rules (start {(place Stack "Ghoula0" 20) (place Stack items:{"Stick4" "Stick3" "Stick2" "Stick1"} 16)}) (play (do (if (<= (var) 0) (roll)) next:(if (> (var) 0) (if (= 1 (size Stack at:(where "Ghoula" Neutral))) (move (from (where "Ghoula" Neutral) level:(where Level "Ghoula" Neutral at:(where "Ghoula" Neutral))) (to (trackSite Move from:(where "Ghoula" Neutral) "GhoulaTrack" steps:1))) (move (from (where "Ghoula" Neutral) level:(where Level "Ghoula" Neutral at:(where "Ghoula" Neutral))) (to (trackSite Move from:(where "Ghoula" Neutral) "ReverseGhoulaTrack" steps:1)) (then (if (= (last From) 17) (forEach Level (last From) FromTop (remove (last From) level:(level))) (forEach Level (last From) FromTop (fromTo (from (last From) level:(level)) (to (last To))))))) (then (if (and (= 1 (size Stack at:(where "Ghoula" Neutral))) (= 6 (where "Ghoula" Neutral))) (set Var 0) (and (if (> (var) 1) (moveAgain)) (set Var (- (var) 1)))))) (if (!= 0 (mapEntry "Throw" (count Pips))) (forEach Piece))) (then (if (is In (mapEntry "Throw" (count Pips)) (sites {1 6 4})) (moveAgain))))) (end {(forEach Player if:(no Pieces Player) (result Player Loss)) (forEach Player if:(and (= 1 (size Stack at:(where "Ghoula" Neutral))) (= 6 (where "Ghoula" Neutral))) (result Player Win))}))) 
5x5 board, with an X in the central square of each side of the board, as well as the central square of the board. Two players. Two pieces per player. Four cowrie shells used as dice. Throws have the value of the number of mouths that land face up, with no mouths up = 8. Players start on opposite sides of the board, the first point on their track being the marked square on that side. Players move in an anti-clockwise direction around the board, until reaching the space before the starting space, at which point they move into the space above it, and proceed around the inner part of the board in a clockwise direction, until below the central square. Players enter a piece with a throw of 1. Throws of 1 or 8 give the player another turn. When a player's piece lands on the same space as a space with an opponent's piece, the opponent's piece is removed from the board and must enter again, and the player causing this receives another throw. Pieces resting on a marked square cannot be sent back to start. To reach the central space, the player must throw the exact number required. The first player to move both pieces to the central space first wins.
(game "Siga (Sri Lanka)" (players 2) (equipment {(board (square 5) {(track "Track1" "2,E,N,W,S,E1,N3,E2,S2,W1,N1" P1 directed:True) (track "Track2" "22,W,S,E,N,W1,S3,W2,N2,E1,S1" P2 directed:True)}) (piece "Marker" Each (move (from (from) level:(level)) (to (trackSite Move from:(from) steps:(mapEntry "Throw" (count Pips))) if:True (apply (if (and (not (is In (to) (sites "SafeSites"))) (is Enemy (who at:(to)))) (and (forEach Level (to) FromTop (fromTo (from (to) level:(level)) (to (handSite (who at:(to) level:(level)))))) (moveAgain))))))) (hand Each) (dice d:2 from:0 num:4) (map "Throw" {(pair 0 8) (pair 1 1) (pair 2 2) (pair 3 3) (pair 4 4)}) (map "Entry" {(pair P1 2) (pair P2 22)}) (regions "SafeSites" (sites {2 10 12 14 22}))}) (rules (start {(place Stack "Marker1" (handSite P1) count:2) (place Stack "Marker2" (handSite P2) count:2)}) (play (do (roll) next:(or (if (and (is Occupied (handSite Mover)) (= (mapEntry "Throw" (count Pips)) 1)) (move (from (handSite Mover)) (to (mapEntry "Entry" (mover))))) (forEach Piece)) (then (if (is In (mapEntry "Throw" (count Pips)) (sites {1 8})) (moveAgain))))) (end (if (and (= 1 (count Sites in:(sites Occupied by:Mover top:False))) (is In (centrePoint) (sites Occupied by:Mover top:False))) (result Mover Win))))) 
Spiral board of any number of spaces, rendered as holes in the sand. The first space is a mound. Any number of players. One piece per player, and one piece, the "bankor," all of which begin on the first space on the outer ring of the spiral. Four sticks, with one green and one white side, used as dice. The throws are as follows: One white side up = 1; two white sides up = 0, or 8 when playing as the bankor; three white sides up = 3; four white sides up = 4; four green sides up = 6. A player must throw a 1 to begin moving their piece. Pieces proceed along the spiral toward the central spot. The first player to reach the spot allows the other players three turns, and then begins playing as the bankor. When the bankor overtakes another player's piece, it drags them with it. When the bankor reaches the penultimate spot, the players it is dragging with them loses.  The game has 4 players.
(game "Sik" (players 4) (equipment {(board (spiral turns:5 sites:86) {(track "Track" {85 84 83 82 81 80 79 78 77 76 75 74 73 72 71 70 69 68 67 66 65 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0} directed:True)} use:Vertex) (dice d:2 from:0 num:4) (map "Throw" {(pair 0 4) (pair 1 3) (pair 2 0) (pair 3 1) (pair 4 6)}) (piece "Stick" Each (move (from (from) level:(level) if:(or (= 1 (state at:(from) level:(level))) (= (mapEntry "Throw" (count Pips)) 1))) (to (trackSite Move "Track" steps:(mapEntry "Throw" (count Pips))) if:True) (then (if (!= 1 (state at:(last To) level:(last LevelTo))) (set State at:(last To) level:(last LevelTo) 1))))) (piece "Bankor" Neutral)}) (rules (start {(place Stack items:{"Stick4" "Stick3" "Stick2" "Stick1"} 85) (place Stack "Bankor0" 85)}) (play (do (roll) next:(if (= 0 (where "Stick" Mover)) (if (< (value Player Mover) 2) (move Pass (then (set Value Mover (+ 1 (value Player Mover))))) (if (or (= (mover) (state at:(where "Bankor" Neutral) level:(where Level "Bankor" Neutral at:(where "Bankor" Neutral)))) (= 0 (state at:(where "Bankor" Neutral) level:(where Level "Bankor" Neutral at:(where "Bankor" Neutral))))) (if (!= 0 (mapEntry "Throw" (count Pips))) (move (from (where "Bankor" Neutral) level:(where Level "Bankor" Neutral at:(where "Bankor" Neutral))) (to (trackSite Move from:(where "Bankor" Neutral) "Track" steps:(mapEntry "Throw" (count Pips)))) (then (and (if (!= (mover) (state at:(where "Bankor" Neutral) level:(where Level "Bankor" Neutral at:(where "Bankor" Neutral)))) (set State at:(where "Bankor" Neutral) level:(where Level "Bankor" Neutral at:(where "Bankor" Neutral)) (mover))) (if (= (last To) 0) (forEach Site (sites Track "Track" from:(last From) to:(last To)) (if (!= (site) (last To)) (forEach Level (site) FromTop (remove (site) level:(level))))) (forEach Site (sites Track "Track" from:(last From) to:(last To)) (if (!= (site) (last To)) (forEach Level (site) FromTop (fromTo (from (site) level:(level)) (to (last To))))))))))))) (if (!= 0 (mapEntry "Throw" (count Pips))) (forEach Piece))))) (end {(forEach Player if:(no Pieces Player) (result Player Loss)) (forEach Player if:(or (= (where "Bankor" Neutral) 0) (and (is Occupied 0) (>= 1 (count Sites in:(difference (sites Occupied by:All) (where "Bankor" Neutral)))))) (result Player Win))}))) 
5x5 grid, with six spaces extending from the central row; the final three of this extension rendered as rectangles rather than squares (Cairo, Medina, and Mecca, in that order). The central square of the grid is marked with a circle (the Minaret). Any number of players. Three pieces per player, a father, a mother, and an angel. Six sticks, black on one side and white on the other, used as dice. The throws are as follows: Five of any color plus one of the other color (known as "sir") = 1, plus an extra throw; six white = an extra throw, and the player moves the number of white faces; six black = three extra throws, and the player moves the number of white faces up. Any other throws = 0. The angel moves double the values of these throws. The father begins on the top left corner space, the angel on the next space below it, and the mother on the space below the angel. Players move vertically in a boustrophedon track in the main grid, and when reaching the bottom right corner they progress into the extended row. Players must throw sir to enter the Minaret, and then another sir to exit it. To progress into the first three spaces of the extended row, a player must throw a sir to move one space. To enter each of the three final spaces (Cairo, Medina, and Mecca), a player must throw sir three times. Upon entering the extended row, the angel no longer moves double. When a player passes the piece of an opponent, the opponent's piece is sent back to the space where it started. The first player to move their three pieces to Mecca wins.  The game has 4 players.
(game "Siryu (Race)" (players 4) (equipment {(board (merge {(rectangle 5 2) (shift 2 -3 (scale 1.2 1 (rectangle 8 1))) (shift 3.2 0 (rectangle 5 2)) (shift 1.6 -6 (scale 2 1 (rectangle 3 1)))}) {(track "FirstTrack" "13,S,E1,N,E1,S1" directed:True) (track "SecondTrack" "6,S1,E1,N,E1,S" directed:True)}) (dice d:2 from:0 num:6) (map "Throw" {(pair 0 6) (pair 1 1) (pair 2 0) (pair 3 0) (pair 4 0) (pair 5 1) (pair 6 6)}) (map "ExtraThrow" {(pair 0 1) (pair 1 1) (pair 2 0) (pair 3 0) (pair 4 0) (pair 5 1) (pair 6 3)}) (piece "Father" Each (if (!= 0 (mapEntry "Throw" (count Pips))) (or {(if (is In (from) (sites Track "FirstTrack")) (move (from (from) level:(level)) (to (trackSite Move "FirstTrack" steps:(mapEntry "Throw" (count Pips))))) (then (forEach Site (sites Track Mover "FirstTrack" from:(trackSite Move from:(last From) "FirstTrack" steps:1) to:(last To)) (forEach Level (site) FromTop (if (is Enemy (who at:(site) level:(level))) (fromTo (from (site) level:(level)) (to (if (= (site) (where "Father" (who at:(site) level:(level)))) 13 (if (= (site) (where "Mother" (who at:(site) level:(level)))) 7 10))))))))) (if (is In (from) (sites Track "SecondTrack")) (move (from (from) level:(level)) (to (trackSite Move "SecondTrack" steps:(mapEntry "Throw" (count Pips)))) (then (forEach Site (sites Track Mover "SecondTrack" from:(trackSite Move from:(last From) "SecondTrack" steps:1) to:(last To)) (forEach Level (site) FromTop (if (is Enemy (who at:(site) level:(level))) (fromTo (from (site) level:(level)) (to (if (= (site) (where "Father" (who at:(site) level:(level)))) 13 (if (= (site) (where "Mother" (who at:(site) level:(level)))) 7 10)))))))))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 12)) (move (from (from) level:(level)) (to 9))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 9)) (move (from (from) level:(level)) (to 6))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 23)) (move (from (from) level:(level)) (to 2))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 2)) (move (from (from) level:(level)) (to 17))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 17)) (move (from (from) level:(level)) (to 16))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (is In (from) (sites {16 29 30})) (< (state at:(from) level:(level)) 2)}) (move (from (from) level:(level)) (to (from) (apply (set State at:(to) level:(level) (+ 1 (state at:(to) level:(level)))))))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 16) (= 2 (state at:(from) level:(level)))}) (move (from (from) level:(level)) (to 30 (apply (set State at:(from) level:(level) 0))))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 30) (= 2 (state at:(from) level:(level)))}) (move (from (from) level:(level)) (to 29 (apply (set State at:(from) level:(level) 0))))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 29) (= 2 (state at:(from) level:(level)))}) (move (from (from) level:(level)) (to 28 (apply (set State at:(from) level:(level) 0)))))}))) (piece "Angel" Each (if (!= 0 (* 2 (mapEntry "Throw" (count Pips)))) (or {(if (is In (from) (sites Track "FirstTrack")) (move (from (from) level:(level)) (to (trackSite Move "FirstTrack" steps:(* 2 (mapEntry "Throw" (count Pips)))))) (then (forEach Site (sites Track Mover "FirstTrack" from:(trackSite Move from:(last From) "FirstTrack" steps:1) to:(last To)) (forEach Level (site) FromTop (if (is Enemy (who at:(site) level:(level))) (fromTo (from (site) level:(level)) (to (if (= (site) (where "Father" (who at:(site) level:(level)))) 13 (if (= (site) (where "Mother" (who at:(site) level:(level)))) 7 10))))))))) (if (is In (from) (sites Track "SecondTrack")) (move (from (from) level:(level)) (to (trackSite Move "SecondTrack" steps:(* 2 (mapEntry "Throw" (count Pips))))) (then (forEach Site (sites Track Mover "SecondTrack" from:(trackSite Move from:(last From) "SecondTrack" steps:1) to:(last To)) (forEach Level (site) FromTop (if (is Enemy (who at:(site) level:(level))) (fromTo (from (site) level:(level)) (to (if (= (site) (where "Father" (who at:(site) level:(level)))) 13 (if (= (site) (where "Mother" (who at:(site) level:(level)))) 7 10)))))))))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 12)) (move (from (from) level:(level)) (to 9))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 9)) (move (from (from) level:(level)) (to 6))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 23)) (move (from (from) level:(level)) (to 2))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 2)) (move (from (from) level:(level)) (to 17))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 17)) (move (from (from) level:(level)) (to 16))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 24)) (move (from (from) level:(level)) (to 2))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (is In (from) (sites {16 29 30})) (< (state at:(from) level:(level)) 2)}) (move (from (from) level:(level)) (to (from) (apply (set State at:(to) level:(level) (+ 1 (state at:(to) level:(level)))))))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 16) (= 2 (state at:(from) level:(level)))}) (move (from (from) level:(level)) (to 30 (apply (set State at:(from) level:(level) 0))))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 30) (= 2 (state at:(from) level:(level)))}) (move (from (from) level:(level)) (to 29 (apply (set State at:(from) level:(level) 0))))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 29) (= 2 (state at:(from) level:(level)))}) (move (from (from) level:(level)) (to 28 (apply (set State at:(from) level:(level) 0)))))}))) (piece "Mother" Each (if (!= 0 (mapEntry "Throw" (count Pips))) (or {(if (is In (from) (sites Track "FirstTrack")) (move (from (from) level:(level)) (to (trackSite Move "FirstTrack" steps:(mapEntry "Throw" (count Pips))))) (then (forEach Site (sites Track Mover "FirstTrack" from:(trackSite Move from:(last From) "FirstTrack" steps:1) to:(last To)) (forEach Level (site) FromTop (if (is Enemy (who at:(site) level:(level))) (fromTo (from (site) level:(level)) (to (if (= (site) (where "Father" (who at:(site) level:(level)))) 13 (if (= (site) (where "Mother" (who at:(site) level:(level)))) 7 10))))))))) (if (is In (from) (sites Track "SecondTrack")) (move (from (from) level:(level)) (to (trackSite Move "SecondTrack" steps:(mapEntry "Throw" (count Pips)))) (then (forEach Site (sites Track Mover "SecondTrack" from:(trackSite Move from:(last From) "SecondTrack" steps:1) to:(last To)) (forEach Level (site) FromTop (if (is Enemy (who at:(site) level:(level))) (fromTo (from (site) level:(level)) (to (if (= (site) (where "Father" (who at:(site) level:(level)))) 13 (if (= (site) (where "Mother" (who at:(site) level:(level)))) 7 10)))))))))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 12)) (move (from (from) level:(level)) (to 9))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 9)) (move (from (from) level:(level)) (to 6))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 23)) (move (from (from) level:(level)) (to 2))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 2)) (move (from (from) level:(level)) (to 17))) (if (and (= (mapEntry "Throw" (count Pips)) 1) (= (from) 17)) (move (from (from) level:(level)) (to 16))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (is In (from) (sites {16 29 30})) (< (state at:(from) level:(level)) 2)}) (move (from (from) level:(level)) (to (from) (apply (set State at:(to) level:(level) (+ 1 (state at:(to) level:(level)))))))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 16) (= 2 (state at:(from) level:(level)))}) (move (from (from) level:(level)) (to 30 (apply (set State at:(from) level:(level) 0))))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 30) (= 2 (state at:(from) level:(level)))}) (move (from (from) level:(level)) (to 29 (apply (set State at:(from) level:(level) 0))))) (if (and {(= (mapEntry "Throw" (count Pips)) 1) (= (from) 29) (= 2 (state at:(from) level:(level)))}) (move (from (from) level:(level)) (to 28 (apply (set State at:(from) level:(level) 0)))))})))}) (rules (start {(place Stack "Father1" 13) (place Stack "Angel1" 10) (place Stack "Mother1" 7) (place Stack "Father2" 13) (place Stack "Angel2" 10) (place Stack "Mother2" 7) (place Stack "Father3" 13) (place Stack "Angel3" 10) (place Stack "Mother3" 7) (place Stack "Father4" 13) (place Stack "Angel4" 10) (place Stack "Mother4" 7)}) (play (do (roll) next:(forEach Piece) (then (if (!= 0 (mapEntry "ExtraThrow" (count Pips))) (and (if (= 3 (mapEntry "ExtraThrow" (count Pips))) (if (<= (var) 0) (set Var 2) (set Var (+ 2 (var))))) (moveAgain)) (if (> (var) 0) (and (set Var (- (var) 1)) (moveAgain))))))) (end (if (and {(= 28 (where "Angel" Mover)) (= 28 (where "Father" Mover)) (= 28 (where "Mother" Mover))}) (result Mover Win))))) 
When a capture is made, the capturing piece is revealed to the opponent. If an orthogonal move is attempted to a spot with a hidden piece of the opponent, the move is not completed and the enemy piece is revealed. The goal is to reach the opposite side of the board like in Breakthrough.
(game "Sneakthrough" (players 2) (equipment {(board (square 8)) (piece "Pawn" P1 N (or {(move Step Forward (to if:(is Empty (to)))) (move Step Forward (to if:(and (is Enemy (who at:(to))) (is Hidden at:(to) to:Mover))) (then (fromTo (from (last To)) (to (last From)) (then (and {(add (piece (next)) (to (last To))) (set Hidden at:(last To) False to:Next) (set Hidden at:(last To) False to:Mover)}))))) (move Step (directions {FR FL}) (to if:(is Empty (to)) (apply (remove (to))))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))) (then (set Hidden at:(last To) to:Next)))})) (piece "Pawn" P2 S (or {(move Step Forward (to if:(is Empty (to)))) (move Step Forward (to if:(and (is Enemy (who at:(to))) (is Hidden at:(to) to:Mover))) (then (fromTo (from (last To)) (to (last From)) (then (and {(add (piece (next)) (to (last To))) (set Hidden at:(last To) False to:Next) (set Hidden at:(last To) False to:Mover)}))))) (move Step (directions {FR FL}) (to if:(is Empty (to)) (apply (remove (to))))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))) (then (set Hidden at:(last To) to:Next)))})) (regions P2 (sites Top)) (regions P1 (sites Bottom))}) (rules (start {(place "Pawn1" (expand (sites Bottom))) (place "Pawn2" (expand (sites Top))) (set Hidden (difference (sites Board) (sites Occupied by:P1)) to:P1) (set Hidden (difference (sites Board) (sites Occupied by:P2)) to:P2)}) (play (forEach Piece)) (end (if (not (= (count Sites in:(sites Occupied by:Mover)) (count Sites in:(difference (sites Occupied by:Mover) (sites Next))))) (result Mover Win))))) 
Each player starts with their five pieces in troughs on their side of the game board, with players sitting perpendicular to one another. When you move a piece, you move it a distance based on the strength indicated in the trough that you're leaving. Once the piece has made its way across the board, you move it back based on the strength on the other side. If you pass over an opposing piece while moving, then that opposing piece must return to its last departing base and your moving piece advances one cell further than where the opposing piece was. To win Squadro, you need to be the first player to make a return trip with four of your five pieces.
(game "Squadro" (players {(player E) (player S)}) (equipment {(board (remove (square 7) vertices:{0 6 42 48}) use:Vertex) (piece "Minus" Each (if (= 3 (state at:(from))) (if (can Move (move Slide (if (= 1 (value Piece at:(from))) Forward Backward) (between (exact 3)) (to if:(is Empty (to))))) (move Slide (if (= 1 (value Piece at:(from))) Forward Backward) (between (exact 3)) (to if:(is Empty (to)))) (if (can Move (move Slide (if (= 1 (value Piece at:(from))) Forward Backward) (between (exact 2)) (to if:(is Empty (to))))) (move Slide (if (= 1 (value Piece at:(from))) Forward Backward) (between (exact 2)) (to if:(is Empty (to))) (then (if (is Enemy (who at:(ahead (last To) (if (= 1 (value Piece at:(last To))) Forward Backward)))) (moveAgain)))) (if (can Move (move Slide (if (= 1 (value Piece at:(from))) Forward Backward) (between (exact 1)) (to if:(is Empty (to))))) (move Slide (if (= 1 (value Piece at:(from))) Forward Backward) (between (exact 1)) (to if:(is Empty (to))) (then (if (is Enemy (who at:(ahead (last To) (if (= 1 (value Piece at:(last To))) Forward Backward)))) (moveAgain)))) (move Select (from) (then (moveAgain)))))) (if (= 2 (state at:(from))) (if (can Move (move Slide (if (= 1 (value Piece at:(from))) Forward Backward) (between (exact 2)) (to if:(is Empty (to))))) (move Slide (if (= 1 (value Piece at:(from))) Forward Backward) (between (exact 2)) (to if:(is Empty (to)))) (if (can Move (move Slide (if (= 1 (value Piece at:(from))) Forward Backward) (between (exact 1)) (to if:(is Empty (to))))) (move Slide (if (= 1 (value Piece at:(from))) Forward Backward) (between (exact 1)) (to if:(is Empty (to))) (then (if (is Enemy (who at:(ahead (last To) (if (= 1 (value Piece at:(last To))) Forward Backward)))) (moveAgain)))) (move Select (from) (then (moveAgain))))) (if (can Move (move Slide (if (= 1 (value Piece at:(from))) Forward Backward) (between (exact 1)) (to if:(is Empty (to))))) (move Slide (if (= 1 (value Piece at:(from))) Forward Backward) (between (exact 1)) (to if:(is Empty (to)))) (move Select (from) (then (moveAgain))))))) (regions "Home" P1 (sites Left)) (regions "Home" P2 (sites Top)) (regions "OppositeHome" P1 (sites Right)) (regions "OppositeHome" P2 (sites Bottom)) (map {(pair 39 1) (pair 32 3) (pair 25 2) (pair 18 3) (pair 11 1) (pair 0 3) (pair 1 1) (pair 2 2) (pair 3 1) (pair 4 3)})}) (rules (start {(place "Minus1" coord:"A2" state:3 value:1) (place "Minus1" coord:"A3" state:1 value:1) (place "Minus1" coord:"A4" state:2 value:1) (place "Minus1" coord:"A5" state:1 value:1) (place "Minus1" coord:"A6" state:3 value:1) (place "Minus2" coord:"B7" state:1 value:1) (place "Minus2" coord:"C7" state:3 value:1) (place "Minus2" coord:"D7" state:2 value:1) (place "Minus2" coord:"E7" state:3 value:1) (place "Minus2" coord:"F7" state:1 value:1)}) (play (if (is Prev Mover) (move Hop (from (last To)) (between (range 1 (count Columns)) if:(is Enemy (who at:(between))) (apply (fromTo (from (between)) (to (if (is Mover P1) (coord row:(if (= (value Piece at:(between)) 1) (- (count Rows) 1) 0) column:(column of:(between))) (coord row:(row of:(between)) column:(if (= (value Piece at:(between)) 1) 0 (- (count Columns) 1)))))))) (to if:(is Empty (to)))) (forEach Piece) (then (if (is In (last To) (sites Mover "OppositeHome")) (and (set Value at:(last To) 2) (set State at:(last To) (mapEntry (last To)))) (if (and (!= (last From) (last To)) (is In (last To) (sites Mover "Home"))) (remove (last To))))))) (end (if (= (count Pieces Mover) 1) (result Mover Win))))) 
5x5 board; the central row and column being slightly wider than the others. Two to four players. Four pieces per player. Pieces begin on one of the central squares around the perimeter of the squares; if there are two players, they begin from opposite sides. Four cowrie shells are used as dice, with the count of the throw determined by the number of mouths which land face-up, with none facing up equaling 8. A throw of 4 gives the player another throw. Only the first throw matters for winning extra throws. Pieces move anti-clockwise from their origin point around the perimeter of the square, until they come to the final square before returning to the origin point. They then turn left and proceed around the inner perimeter of squares in a clockwise direction, until the space directly between the origin point and the central square, from which the pieces proceed to the center. When a piece overtakes a piece owned by the opponent, and the opponent's piece is not on one of the central squares of the perimeter, the opponent's pieces are sent back to the origin point, and the player is awarded an extra throw for each piece sent back. The first player to place their four pieces in the center wins.  The game is played with 4 players.
(game "Tamman" (players 4) (equipment {(board (merge {(add (merge {(square 2) (shift 4 0 (square 2)) (shift 0 4 (square 2)) (shift 4 4 (square 2))}) edges:{{2 9} {5 12} {8 15} {6 18} {8 20} {15 27} {17 29} {20 27} {23 30} {26 33} {7 19} {16 28}})}) {(track "Track1" "2,E,N,W,S,E1,N3,E2,S2,W1,N1" P1 directed:True) (track "Track2" "6,S,E,N,W,S1,E3,S2,W2,N1,E1" P2 directed:True) (track "Track3" "20,W,S,E,N,W1,S3,W2,N2,E1,S1" P3 directed:True) (track "Track4" "14,N,W,S,E,N1,W3,N2,E2,S1,W1" P4 directed:True)}) (dice d:2 from:0 num:4) (piece "Marker" Each (move (from (from) level:(level)) (to (trackSite Move from:(from) steps:(mapEntry "Throw" (count Pips))) if:True (apply (if (< 1 (mapEntry "Throw" (count Pips))) (forEach Site (sites Track Mover "Track" from:(trackSite Move from:(from) steps:1) to:(trackSite Move from:(from) steps:(- (mapEntry "Throw" (count Pips)) 1))) (if (not (is In (sites "SafeSites"))) (forEach Level (site) FromTop (if (is Enemy (who at:(site) level:(level))) (fromTo (from (site) level:(level)) (to (mapEntry "Entry" (who at:(site) level:(level)))))))))))))) (regions "SafeSites" (sites {2 6 14 20})) (map "Throw" {(pair 0 8) (pair 1 1) (pair 2 2) (pair 3 3) (pair 4 4)}) (map "Entry" {(pair P1 2) (pair P2 6) (pair P3 20) (pair P4 14)})}) (rules (start {(place Stack "Marker1" 2 count:4) (place Stack "Marker2" 6 count:4) (place Stack "Marker3" 20 count:4) (place Stack "Marker4" 14 count:4)}) (play (do (roll) next:(forEach Piece) (then (if (and (= (mapEntry "Throw" (count Pips)) 4) (not (is Prev Mover))) (moveAgain))))) (end (if (all Sites (sites Occupied by:Mover) if:(is In (site) (sites {(centrePoint)}))) (result Mover Win))))) 
Forty stones, arranged in a circle, with a larger gap (called a door) after every tenth stone. Two or four players, each player playing with one piece. Each piece begins in one of the doors: north/winter is yellow, west/spring is blue, south/summer is red, east/autumn is white. North and west move anti-clockwise around the circle, south and east move clockwise. Three sticks, red on one side and black on the other, used as dice, the throws are as follows: three red = 10, three black = 5, two red and one black = 3, two black and one red = 2. A throw of 10 grants the player another throw. When a player lands on a spot occupied by an opponent, the opponent's piece is sent back to start. The first player to complete four circuits of the board wins. Circuits are usually counted with beans or corn. The game has 4 players.
(game "Tasholiwe" (players 4) (equipment {(board (add (remove (concentric {44}) vertices:{43 21 0 22}) edges:{{20 18} {0 1} {19 21} {38 39}}) {(track "TrackCW" {39 35 33 31 29 27 25 23 21 19 38 17 15 13 11 9 7 5 3 1 37 0 2 4 6 8 10 12 14 16 36 18 20 22 24 26 28 30 32 34} loop:True) (track "TrackCCW" {39 34 32 30 28 26 24 22 20 18 36 16 14 12 10 8 6 4 2 0 37 1 3 5 7 9 11 13 15 17 38 19 21 23 25 27 29 31 33 35} loop:True)} use:Edge) (map "Throw" {(pair 0 10) (pair 1 3) (pair 2 2) (pair 3 5)}) (map "Start" {(pair 1 39) (pair 2 36) (pair 3 37) (pair 4 38)}) (regions "AllSites" (sites Board Vertex)) (piece "Stick" Each) (dice d:2 from:0 num:3) (hand Each)}) (rules (start {(place "Stick1" Edge (mapEntry "Start" P1)) (place "Stick2" Edge (mapEntry "Start" P2)) (place "Stick3" Edge (mapEntry "Start" P3)) (place "Stick4" Edge (mapEntry "Start" P4))}) (play (do (roll) next:(if (or (is Mover P1) (is Mover P2)) (forEach Piece (move (from (from) level:(level)) (to (trackSite Move "TrackCCW" steps:(mapEntry "Throw" (count Pips))) if:(not (is Friend (who at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry "Start" (who at:(to))))))))) (forEach Piece (move (from (from) level:(level)) (to (trackSite Move "TrackCW" steps:(mapEntry "Throw" (count Pips))) if:(not (is Friend (who at:(to)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (mapEntry "Start" (who at:(to)))))))))) (then (do (if (if (or (is Mover P1) (is Mover P2)) (is In (mapEntry "Start" Mover) (sites Track "TrackCCW" from:(trackSite Move from:(last From) "TrackCCW" steps:1) to:(last To))) (is In (mapEntry "Start" Mover) (sites Track "TrackCW" from:(trackSite Move from:(last From) "TrackCW" steps:1) to:(last To)))) (addScore Mover 1) (then (if (= (score Mover) 4) (remove (last To))))) next:(if (and (!= 4 (score Mover)) (= 10 (mapEntry "Throw" (count Pips)))) (moveAgain)))))) (end (if (>= (score Mover) 4) (result Mover Win))))) 
Each side has a line of pawns. The pawns move as in chess i.e. The pawn moves forwards one square (optionally two squares on its first move) and captures diagonally forwards one square by replacing the opponent’s piece. The rule of En Passant is also allowed. White goes first. The first person to reach the other side is the winner. You also win if it is your opponent’s move and they have no moves left. In Ludii, options are also available to add each of the five other Chess piece types. In the variant with the king piece, if you capture the opponent king, you win as well. The game is played with only pawns.
(game "The Pawn Game" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (or (if (is In (from) (sites Start (piece (what at:(from))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))) (then (set Pending (ahead (last To) Backward))))) (move Step (directions {FR FL}) (to if:(and (is Pending) (= (to) (value Pending)))) (then (remove (ahead (last To) Backward)))))})) (regions P1 (sites Top)) (regions P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6))}) (play (forEach Piece)) (end {(if (is In (last To) (sites Mover)) (result Mover Win)) (if (no Moves Next) (result Mover Win))}))) 
Played on a Backgammon board. Three pieces per player. Two dice. Only the lower value of the dice is used. One player plays from their let toward their right, and the other player from their right to their left. Pieces begin on the outer edge of the board. Pieces move according to the throw of the dice toward the point on the opposite side of their side of the board. No more than one piece can be on a point (except the final point) at any time. Pieces cannot pass each other. When a piece lands on an empty point that is opposite an opponent's point with a piece on it, the opponent's piece is sent back to start. The first player to place all three of their pieces on the final point wins.
(game "Tourne-Case" (players 2) (equipment {(board (rectangle 2 13) {(track "Track1" {6 0 1 2 3 4 5 7 8 9 10 11 12 25 24 23 22 21 20 18 17 16 15 14 13} P1 directed:True) (track "Track2" {19 13 14 15 16 17 18 20 21 22 23 24 25 12 11 10 9 8 7 5 4 3 2 1 0} P2 directed:True)} use:Vertex) (dice d:6 num:2) (piece "Disc" Each (move (from (from)) (to (trackSite Move from:(from) steps:(min (face 26) (face 27))) if:(and (or (is Empty (to)) (and (= (to) (mapEntry "FinalPoint" Mover)) (no Pieces Next in:(sites {(mapEntry "FinalPoint" Mover)})))) (if (< 1 (min (face 26) (face 27))) (no Pieces Mover in:(sites Track Mover from:(trackSite Move from:(from) steps:1) to:(trackSite Move from:(from) steps:(- (min (face 26) (face 27)) 1)))) True)) (apply (if (and (is Enemy (who at:(mapEntry "Opposite" (to)))) (= 1 (size Stack at:(mapEntry "Opposite" (to))))) (fromTo (from (mapEntry "Opposite" (to))) (to (mapEntry "Bar" Next)))))))) (map "FinalPoint" {(pair P1 13) (pair P2 0)}) (map "Bar" {(pair P1 6) (pair P2 19)}) (map "Opposite" {(pair 0 13) (pair 1 14) (pair 2 15) (pair 3 16) (pair 4 17) (pair 5 18) (pair 7 20) (pair 8 21) (pair 9 22) (pair 10 23) (pair 11 24) (pair 12 25) (pair 13 0) (pair 14 1) (pair 15 2) (pair 16 3) (pair 17 4) (pair 18 5) (pair 20 7) (pair 21 8) (pair 22 9) (pair 23 10) (pair 24 11) (pair 25 12)})}) (rules (start {(place Stack "Disc1" 6 count:3) (place Stack "Disc2" 19 count:3)}) (play (do (roll) next:(forEach Piece top:True))) (end (if (= 3 (count Pieces Mover in:(sites {(mapEntry "FinalPoint" Mover)}))) (result Mover Win))))) 
Forty stones, placed in a circle with a larger space after every tenth stone. The spaces between the stones are the playing spaces. Two to four players, each with one counter. Three sticks, round on one side and flat on the other, used as dice. The throws are as follows: three round sides = 10; three flat sides up = 5; one round and two flat = 3; two round and one flat = 1 or 2. Players move from one of the wider spaces around the board in opposite directions. When a player lands on the same spot as the opponent's piece, the opponent's piece is sent back to the beginning. The first player to complete a circuit of the board wins.  The game has 2 players.
(game "Tsaydithl" (players 2) (equipment {(board (add (remove (concentric {44}) vertices:{43 21 0 22}) edges:{{20 18} {0 1} {19 21} {38 39}}) {(track "TrackCW" {39 35 33 31 29 27 25 23 21 19 38 17 15 13 11 9 7 5 3 1 37 0 2 4 6 8 10 12 14 16 36 18 20 22 24 26 28 30 32 34} loop:True) (track "TrackCCW" {39 34 32 30 28 26 24 22 20 18 36 16 14 12 10 8 6 4 2 0 37 1 3 5 7 9 11 13 15 17 38 19 21 23 25 27 29 31 33 35} loop:True)} use:Edge) (piece "Stick" Each (or (if (= 2 (mapEntry "ThrowDiceValue" (count Pips))) (if (!= (if (= (state at:(from)) 1) (trackSite Move "TrackCCW" steps:(- (mapEntry "ThrowDiceValue" (count Pips)) 1)) (trackSite Move "TrackCW" steps:(- (mapEntry "ThrowDiceValue" (count Pips)) 1))) -1) (if (or (is Empty (if (= (state at:(from)) 1) (trackSite Move "TrackCCW" steps:(- (mapEntry "ThrowDiceValue" (count Pips)) 1)) (trackSite Move "TrackCW" steps:(- (mapEntry "ThrowDiceValue" (count Pips)) 1)))) (is Enemy (who at:(if (= (state at:(from)) 1) (trackSite Move "TrackCCW" steps:(- (mapEntry "ThrowDiceValue" (count Pips)) 1)) (trackSite Move "TrackCW" steps:(- (mapEntry "ThrowDiceValue" (count Pips)) 1)))))) (move (from (from) level:(level)) (to (if (= (state at:(from)) 1) (trackSite Move "TrackCCW" steps:(- (mapEntry "ThrowDiceValue" (count Pips)) 1)) (trackSite Move "TrackCW" steps:(- (mapEntry "ThrowDiceValue" (count Pips)) 1))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (value Piece at:(to)))))))))) (if (!= (if (= (state at:(from)) 1) (trackSite Move "TrackCCW" steps:(mapEntry "ThrowDiceValue" (count Pips))) (trackSite Move "TrackCW" steps:(mapEntry "ThrowDiceValue" (count Pips)))) -1) (if (or (is Empty (if (= (state at:(from)) 1) (trackSite Move "TrackCCW" steps:(mapEntry "ThrowDiceValue" (count Pips))) (trackSite Move "TrackCW" steps:(mapEntry "ThrowDiceValue" (count Pips))))) (is Enemy (who at:(if (= (state at:(from)) 1) (trackSite Move "TrackCCW" steps:(mapEntry "ThrowDiceValue" (count Pips))) (trackSite Move "TrackCW" steps:(mapEntry "ThrowDiceValue" (count Pips))))))) (move (from (from) level:(level)) (to (if (= (state at:(from)) 1) (trackSite Move "TrackCCW" steps:(mapEntry "ThrowDiceValue" (count Pips))) (trackSite Move "TrackCW" steps:(mapEntry "ThrowDiceValue" (count Pips)))) (apply if:(is Enemy (who at:(to))) (fromTo (from (to)) (to (value Piece at:(to))))))))))) (regions "Gates" (sites {36 37 38 39})) (map "ThrowDiceValue" {(pair 0 5) (pair 1 3) (pair 2 2) (pair 3 10)}) (dice d:2 from:0 num:3) (hand Each)}) (rules (start {(place "Stick1" 36 state:1 value:36) (place "Stick2" 38 state:2 value:38)}) (play (do (roll) next:(forEach Piece))) (end (if (if (= 1 (state at:(where "Stick" Mover))) (is In (value Piece at:(where "Stick" Mover)) (sites Track "TrackCCW" from:(trackSite Move from:(last From) "TrackCCW" steps:1) to:(last To))) (is In (value Piece at:(where "Stick" Mover)) (sites Track "TrackCW" from:(trackSite Move from:(last From) "TrackCW" steps:1) to:(last To)))) (result Mover Win))))) 
The board is roughly rectangular. There are six points on either side, with each side divided in half by two short parallel lines, the rivers. There are four arcs in the corners of the "square". The points and lines are the playing spaces. Players play on two teams. One stick, serving as the playing piece, per team, which start one each on the parallel lines on the bottom side. Each team has four scoring sticks. There are also four throwing sticks, blank on one side and marked on the other. The number of marked sides is the value of the throw, except when all are face up, which scores 5, and when only blank sides are up, which scores 10. Throws of 5 or 10 give the player another throw. All of the players on a team throw before the players of the other team throw. Each team moves in an opposite direction around the board. If a team's stick lands in the river across from the starting space, the team forfeits one of their scoring sticks to the other team, and begins again from start. If a player lands on the same space as the opposing team's stick, the opposing team's stick is sent back to start, and the playing team wins a scoring stick from the opposing team. When a team reaches the river after the starting point, having completed a circuit of the board, the team wins a scoring stick from the opposing team. When one team captures all of the scoring sticks, they win.  Each team has 10 scoring sticks.
(game "Zohn Ahl" (players 4) (equipment {(board (graph vertices:{{0 0} {1 0.4} {2 0.4} {3 0.4} {4 0} {5 0} {6 0.4} {7 0.4} {8 0.4} {9 0} {4 1} {5 1} {-6 3} {-5.6 4} {-5.6 5} {-5.6 6} {-6 7} {-6 8} {-5 7} {-5 8} {-5.6 9} {-5.6 10} {-5.6 11} {-6 12} {0 15} {1 14.6} {2 14.6} {3 14.6} {4 15} {5 15} {6 14.6} {7 14.6} {8 14.6} {9 15} {4 14} {5 14} {15 3} {14.6 4} {14.6 5} {14.6 6} {15 7} {15 8} {14 7} {14 8} {14.6 9} {14.6 10} {14.6 11} {15 12}} edges:{{0 12} {23 24} {33 47} {36 9} {4 10} {5 11} {16 18} {17 19} {28 34} {35 29} {43 41} {42 40}}) {(track "Track1" "5,6,7,8,9,36,37,38,39,40,41,44,45,46,47,33,32,31,30,29,28,27,26,25,24,23,22,21,20,17,16,15,14,13,12,0,1,2,3,End" P1 directed:True) (track "Track2" "5,6,7,8,9,36,37,38,39,40,41,44,45,46,47,33,32,31,30,29,28,27,26,25,24,23,22,21,20,17,16,15,14,13,12,0,1,2,3,End" P2 directed:True) (track "Track3" "4,3,2,1,0,12,13,14,15,16,17,20,21,22,23,24,25,26,27,28,29,30,31,32,33,47,46,45,44,41,40,39,38,37,36,9,8,7,6,End" P3 directed:True) (track "Track4" "4,3,2,1,0,12,13,14,15,16,17,20,21,22,23,24,25,26,27,28,29,30,31,32,33,47,46,45,44,41,40,39,38,37,36,9,8,7,6,End" P4 directed:True)} use:Vertex) (piece "Stick" P1 (if (= (trackSite Move from:(from) steps:(mapEntry "Throw" (count Pips))) -2) (move (from (from)) (to (mapEntry "Start" Mover)) (then (fromTo (from (handSite (if (or (is Mover P1) (is Mover P2)) 3 1))) (to (handSite (if (or (is Mover P1) (is Mover P2)) 1 3)))))) (move (from (from)) (to (trackSite Move from:(from) steps:(mapEntry "Throw" (count Pips))) if:True (apply (if (is Enemy (who at:(to))) (and (fromTo (from (to)) (to (mapEntry "Start" (who at:(to))))) (fromTo (from (handSite (if (or (is Mover P1) (is Mover P2)) 3 1))) (to (handSite (if (or (is Mover P1) (is Mover P2)) 1 3)))))))) (then (if (= (last To) (mapEntry "Opposite" Mover)) (and (fromTo (from (last To)) (to (mapEntry "Start" Mover))) (fromTo (from (handSite (if (or (is Mover P1) (is Mover P2)) 1 3))) (to (handSite (if (or (is Mover P1) (is Mover P2)) 3 1)))))))))) (piece "Stick" P3 (if (= (trackSite Move from:(from) steps:(mapEntry "Throw" (count Pips))) -2) (move (from (from)) (to (mapEntry "Start" Mover)) (then (fromTo (from (handSite (if (or (is Mover P1) (is Mover P2)) 3 1))) (to (handSite (if (or (is Mover P1) (is Mover P2)) 1 3)))))) (move (from (from)) (to (trackSite Move from:(from) steps:(mapEntry "Throw" (count Pips))) if:True (apply (if (is Enemy (who at:(to))) (and (fromTo (from (to)) (to (mapEntry "Start" (who at:(to))))) (fromTo (from (handSite (if (or (is Mover P1) (is Mover P2)) 3 1))) (to (handSite (if (or (is Mover P1) (is Mover P2)) 1 3)))))))) (then (if (= (last To) (mapEntry "Opposite" Mover)) (and (fromTo (from (last To)) (to (mapEntry "Start" Mover))) (fromTo (from (handSite (if (or (is Mover P1) (is Mover P2)) 1 3))) (to (handSite (if (or (is Mover P1) (is Mover P2)) 3 1)))))))))) (piece "Stick" Neutral) (dice d:2 from:0 num:4) (hand P1) (hand P3) (map "Throw" {(pair 0 10) (pair 1 1) (pair 2 2) (pair 3 3) (pair 4 5)}) (map "Opposite" {(pair P1 29) (pair P2 29) (pair P3 28) (pair P4 28)}) (map "Start" {(pair P1 5) (pair P2 5) (pair P3 4) (pair P4 4)})}) (rules (start {(set Team 1 {P1 P2}) (set Team 2 {P3 P4}) (place "Stick1" 5) (place "Stick3" 4) (place "Stick0" (handSite P1) count:10) (place "Stick0" (handSite P3) count:10)}) (play (do (roll) next:(if (or (is Mover P1) (is Mover P2)) (forEach Piece P1) (forEach Piece P3)) (then (if (or (= (mapEntry "Throw" (count Pips)) 5) (= (mapEntry "Throw" (count Pips)) 10)) (moveAgain))))) (end (if (is Empty (handSite (if (or (is Mover P1) (is Mover P2)) 3 1))) (result TeamMover Win))))) 
TURN - On each turn, each player drops a friendly stone on an empty cell. If a diagonal line is full (i.e., there are no empty cells on that diagonal), the player who dropped the last stone achieves so many points as the number of friendly stones on the finished line. Two lines can be finished on one turn, the player achieves points for both lines (the dropped stone counts twice, once for each diagonal). A diagonal line must have at least 2 stones. So, corner cells do not count as diagonals. GOAL - When all cells are occupied, wins the player with more points.
(game "Diagonals" (players 2) (equipment {(board (square 8) use:Vertex) (piece "Ball" Each)}) (rules (play (move Add (to (sites Empty)) (then (and (if (not (is In (last To) (sites {"A8" "H1"}))) (if (all Sites (union (sites Direction from:(last To) NE included:True) (sites Direction from:(last To) SW)) if:(is Occupied (site))) (addScore Mover (count Sites in:(forEach (union (sites Direction from:(last To) NE included:True) (sites Direction from:(last To) SW)) if:(is Friend (who at:(site)))))))) (if (not (is In (last To) (sites {"A1" "H8"}))) (if (all Sites (union (sites Direction from:(last To) SE included:True) (sites Direction from:(last To) NW)) if:(is Occupied (site))) (addScore Mover (count Sites in:(forEach (union (sites Direction from:(last To) SE included:True) (sites Direction from:(last To) NW)) if:(is Friend (who at:(site)))))))))))) (end (if (is Full) (byScore))))) 
Seven players. Seven concentric circles, divided into twelve equal sections, labeled after the twelve zodiac signs. The inner circle has one space per section, the next circle out has two per section, and so on, with the outer circle having seven spaces per section. Each player controls one piece, which travels in its circle only. Each piece begins in a different section, on the first space in that section: Saturn, beginning in Aquarius; Jupiter, beginning in Sagittarius; Mars, beginning in Scorpio; Sun, beginning in Leo; Venus, beginning in Taurus; Mercury, beginning in Virgo, and the Moon, beginning in Cancer. Each player rolls a seven-sided die, to determine which piece they play as, seven being Saturn and one being the Moon, and the others in order as already given. Movement is determined by the roll of this die, and proceeds in a clockwise direction. When a piece enters a new section, the player gains or loses points. Points are allocated based on how many sections away (either forward or behind) from the new section the other pieces are located. If a piece is two sections away, the player gains 24 points; if four sections away, 36; if three sections away, the player loses 36, if six sections away, loses 72; if the same section; 144. 
(game "Los Escaques" (players 7) (equipment {(board (remove (concentric {0 12 24 36 48 60 72 84}) cells:{1}) {(track "Ring7" {11 10 9 8 7 6 5 4 3 2 0 1} loop:True) (track "Ring6" {35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 12 13} loop:True) (track "Ring5" {71 70 69 68 67 66 65 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 36 37} loop:True) (track "Ring4" {119 118 117 116 115 114 113 112 111 110 109 108 107 106 105 104 103 102 101 100 99 98 97 96 95 94 93 92 91 90 89 88 87 86 85 84 83 82 81 80 79 78 77 76 75 74 72 73} loop:True) (track "Ring3" {179 178 177 176 175 174 173 172 171 170 169 168 167 166 165 164 163 162 161 160 159 158 157 156 155 154 153 152 151 150 149 148 147 146 145 144 143 142 141 140 139 138 137 136 135 134 133 132 131 130 129 128 127 126 125 124 123 122 120 121} loop:True) (track "Ring2" {251 250 249 248 247 246 245 244 243 242 241 240 239 238 237 236 235 234 233 232 231 230 229 228 227 226 225 224 223 222 221 220 219 218 217 216 215 214 213 212 211 210 209 208 207 206 205 204 203 202 201 200 199 198 197 196 195 194 193 192 191 190 189 188 187 186 185 184 183 182 180 181} loop:True) (track "Ring1" {335 334 333 332 331 330 329 328 327 326 325 324 323 322 321 320 319 318 317 316 315 314 313 312 311 310 309 308 307 306 305 304 303 302 301 300 299 298 297 296 295 294 293 292 291 290 289 288 287 286 285 284 283 282 281 280 279 278 277 276 275 274 273 272 271 270 269 268 267 266 265 264 263 262 261 260 259 258 257 256 255 254 252 253} loop:True)}) (regions "AllSites" (sites Board)) (piece "Marker" Each (move (from) (to (if (is In (from) (sites Track "Ring7")) (trackSite Move "Ring7" steps:(count Pips)) (if (is In (from) (sites Track "Ring6")) (trackSite Move "Ring6" steps:(count Pips)) (if (is In (from) (sites Track "Ring5")) (trackSite Move "Ring5" steps:(count Pips)) (if (is In (from) (sites Track "Ring4")) (trackSite Move "Ring4" steps:(count Pips)) (if (is In (from) (sites Track "Ring3")) (trackSite Move "Ring3" steps:(count Pips)) (if (is In (from) (sites Track "Ring2")) (trackSite Move "Ring2" steps:(count Pips)) (trackSite Move "Ring1" steps:(count Pips))))))))) (then (if (not (or {(and (is In (last From) (sites "Section0")) (is In (last To) (sites "Section0"))) (and (is In (last From) (sites "Section1")) (is In (last To) (sites "Section1"))) (and (is In (last From) (sites "Section2")) (is In (last To) (sites "Section2"))) (and (is In (last From) (sites "Section3")) (is In (last To) (sites "Section3"))) (and (is In (last From) (sites "Section4")) (is In (last To) (sites "Section4"))) (and (is In (last From) (sites "Section5")) (is In (last To) (sites "Section5"))) (and (is In (last From) (sites "Section6")) (is In (last To) (sites "Section6"))) (and (is In (last From) (sites "Section7")) (is In (last To) (sites "Section7"))) (and (is In (last From) (sites "Section8")) (is In (last To) (sites "Section8"))) (and (is In (last From) (sites "Section9")) (is In (last To) (sites "Section9"))) (and (is In (last From) (sites "Section10")) (is In (last To) (sites "Section10"))) (and (is In (last From) (sites "Section11")) (is In (last To) (sites "Section11")))})) (forEach Site (sites Occupied by:Enemy) (addScore Mover (mapEntry "Score" (if (is In (last To) (sites "Section0")) (if (is In (site) (sites "Section0")) 0 (if (or (is In (site) (sites "Section1")) (is In (site) (sites "Section11"))) 1 (if (or (is In (site) (sites "Section2")) (is In (site) (sites "Section10"))) 2 (if (or (is In (site) (sites "Section3")) (is In (site) (sites "Section9"))) 3 (if (or (is In (site) (sites "Section4")) (is In (site) (sites "Section8"))) 4 (if (or (is In (site) (sites "Section5")) (is In (site) (sites "Section7"))) 5 6)))))) (if (is In (last To) (sites "Section1")) (if (is In (site) (sites "Section1")) 0 (if (or (is In (site) (sites "Section2")) (is In (site) (sites "Section0"))) 1 (if (or (is In (site) (sites "Section3")) (is In (site) (sites "Section11"))) 2 (if (or (is In (site) (sites "Section4")) (is In (site) (sites "Section10"))) 3 (if (or (is In (site) (sites "Section5")) (is In (site) (sites "Section9"))) 4 (if (or (is In (site) (sites "Section6")) (is In (site) (sites "Section8"))) 5 6)))))) (if (is In (last To) (sites "Section2")) (if (is In (site) (sites "Section2")) 0 (if (or (is In (site) (sites "Section3")) (is In (site) (sites "Section1"))) 1 (if (or (is In (site) (sites "Section4")) (is In (site) (sites "Section0"))) 2 (if (or (is In (site) (sites "Section5")) (is In (site) (sites "Section11"))) 3 (if (or (is In (site) (sites "Section6")) (is In (site) (sites "Section10"))) 4 (if (or (is In (site) (sites "Section7")) (is In (site) (sites "Section9"))) 5 6)))))) (if (is In (last To) (sites "Section3")) (if (is In (site) (sites "Section3")) 0 (if (or (is In (site) (sites "Section4")) (is In (site) (sites "Section2"))) 1 (if (or (is In (site) (sites "Section5")) (is In (site) (sites "Section1"))) 2 (if (or (is In (site) (sites "Section6")) (is In (site) (sites "Section0"))) 3 (if (or (is In (site) (sites "Section7")) (is In (site) (sites "Section11"))) 4 (if (or (is In (site) (sites "Section8")) (is In (site) (sites "Section10"))) 5 6)))))) (if (is In (last To) (sites "Section4")) (if (is In (site) (sites "Section4")) 0 (if (or (is In (site) (sites "Section5")) (is In (site) (sites "Section3"))) 1 (if (or (is In (site) (sites "Section6")) (is In (site) (sites "Section2"))) 2 (if (or (is In (site) (sites "Section7")) (is In (site) (sites "Section1"))) 3 (if (or (is In (site) (sites "Section8")) (is In (site) (sites "Section0"))) 4 (if (or (is In (site) (sites "Section9")) (is In (site) (sites "Section11"))) 5 6)))))) (if (is In (last To) (sites "Section5")) (if (is In (site) (sites "Section5")) 0 (if (or (is In (site) (sites "Section6")) (is In (site) (sites "Section4"))) 1 (if (or (is In (site) (sites "Section7")) (is In (site) (sites "Section3"))) 2 (if (or (is In (site) (sites "Section8")) (is In (site) (sites "Section2"))) 3 (if (or (is In (site) (sites "Section9")) (is In (site) (sites "Section1"))) 4 (if (or (is In (site) (sites "Section10")) (is In (site) (sites "Section0"))) 5 6)))))) (if (is In (last To) (sites "Section6")) (if (is In (site) (sites "Section6")) 0 (if (or (is In (site) (sites "Section7")) (is In (site) (sites "Section5"))) 1 (if (or (is In (site) (sites "Section8")) (is In (site) (sites "Section4"))) 2 (if (or (is In (site) (sites "Section9")) (is In (site) (sites "Section3"))) 3 (if (or (is In (site) (sites "Section10")) (is In (site) (sites "Section2"))) 4 (if (or (is In (site) (sites "Section11")) (is In (site) (sites "Section1"))) 5 6)))))) (if (is In (last To) (sites "Section7")) (if (is In (site) (sites "Section7")) 0 (if (or (is In (site) (sites "Section8")) (is In (site) (sites "Section6"))) 1 (if (or (is In (site) (sites "Section9")) (is In (site) (sites "Section5"))) 2 (if (or (is In (site) (sites "Section10")) (is In (site) (sites "Section4"))) 3 (if (or (is In (site) (sites "Section11")) (is In (site) (sites "Section3"))) 4 (if (or (is In (site) (sites "Section0")) (is In (site) (sites "Section2"))) 5 6)))))) (if (is In (last To) (sites "Section8")) (if (is In (site) (sites "Section8")) 0 (if (or (is In (site) (sites "Section9")) (is In (site) (sites "Section7"))) 1 (if (or (is In (site) (sites "Section10")) (is In (site) (sites "Section6"))) 2 (if (or (is In (site) (sites "Section11")) (is In (site) (sites "Section5"))) 3 (if (or (is In (site) (sites "Section0")) (is In (site) (sites "Section4"))) 4 (if (or (is In (site) (sites "Section1")) (is In (site) (sites "Section3"))) 5 6)))))) (if (is In (last To) (sites "Section9")) (if (is In (site) (sites "Section9")) 0 (if (or (is In (site) (sites "Section10")) (is In (site) (sites "Section8"))) 1 (if (or (is In (site) (sites "Section11")) (is In (site) (sites "Section7"))) 2 (if (or (is In (site) (sites "Section0")) (is In (site) (sites "Section6"))) 3 (if (or (is In (site) (sites "Section1")) (is In (site) (sites "Section5"))) 4 (if (or (is In (site) (sites "Section2")) (is In (site) (sites "Section4"))) 5 6)))))) (if (is In (last To) (sites "Section10")) (if (is In (site) (sites "Section10")) 0 (if (or (is In (site) (sites "Section11")) (is In (site) (sites "Section9"))) 1 (if (or (is In (site) (sites "Section0")) (is In (site) (sites "Section8"))) 2 (if (or (is In (site) (sites "Section1")) (is In (site) (sites "Section7"))) 3 (if (or (is In (site) (sites "Section2")) (is In (site) (sites "Section6"))) 4 (if (or (is In (site) (sites "Section3")) (is In (site) (sites "Section5"))) 5 6)))))) (if (is In (site) (sites "Section11")) 0 (if (or (is In (site) (sites "Section0")) (is In (site) (sites "Section10"))) 1 (if (or (is In (site) (sites "Section1")) (is In (site) (sites "Section9"))) 2 (if (or (is In (site) (sites "Section2")) (is In (site) (sites "Section8"))) 3 (if (or (is In (site) (sites "Section3")) (is In (site) (sites "Section7"))) 4 (if (or (is In (site) (sites "Section4")) (is In (site) (sites "Section6"))) 5 6)))))))))))))))))))))))) (dice d:7 num:1) (hand Each) (map "FirstSite" {(pair 7 1) (pair 6 13) (pair 5 37) (pair 4 73) (pair 3 121) (pair 2 181) (pair 1 253)}) (map "Score" {(pair 0 144) (pair 1 0) (pair 2 24) (pair 3 -36) (pair 4 36) (pair 5 0) (pair 6 -72)}) (regions "Section0" (expand origin:1 steps:6 Out)) (regions "Section1" (expand origin:0 steps:6 Out)) (regions "Section2" (expand origin:2 steps:6 Out)) (regions "Section3" (expand origin:3 steps:6 Out)) (regions "Section4" (expand origin:4 steps:6 Out)) (regions "Section5" (expand origin:5 steps:6 Out)) (regions "Section6" (expand origin:6 steps:6 Out)) (regions "Section7" (expand origin:7 steps:6 Out)) (regions "Section8" (expand origin:8 steps:6 Out)) (regions "Section9" (expand origin:9 steps:6 Out)) (regions "Section10" (expand origin:10 steps:6 Out)) (regions "Section11" (expand origin:11 steps:6 Out))}) (rules (start (place "Marker" "Hand")) phases:{(phase "Opening" (play (do (roll) next:(if (is Empty (mapEntry "FirstSite" (count Pips))) (move (from (handSite Mover)) (to (mapEntry "FirstSite" (count Pips)))) (move Pass (then (moveAgain)))))) (nextPhase (and (is Mover P7) (is Next P1)) "Playing")) (phase "Playing" (play (if (is Proposed "End") (or (move Vote "End") (move Vote "No")) (do (roll) next:(or (forEach Piece) (move Propose "End"))))))} (end (if (is Decided "End") (byScore))))) 
The board is a double-headed eagle, with two lines of ten holes. One seven-sided die. One side has a special mark, one is blank, and the others are numbered 1-5. The special mark scores 10, the blank side scores -10. Players roll the die, and add up their scores as they go, placing a peg in a hole to mark ten points. The player who reaches 100 points first wins.
(game "Pasa" (players 2) (equipment {(board (rectangle 10 2)) (piece "Disc" Each) (dice d:7 from:0 num:1) (map {(pair 0 -10) (pair 1 1) (pair 2 2) (pair 3 3) (pair 4 4) (pair 5 5) (pair 6 6) (pair 7 10)})}) (rules (play (do (roll (then (addScore Mover (mapEntry (count Pips))))) next:(move Pass (then (and (remove (sites Column (- (mover) 1))) (if (>= (score Mover) 10) (add (piece (id "Disc" Mover)) (to (intersection (sites Column (- (mover) 1)) (sites Row (- (/ (score Mover) 10) 1))))))))))) (end (if (>= (score Mover) 100) (result Mover Win))))) 
4x8 board. Three counters in each hole. Players pick up counters from any of their holes and sow them in either direction. If the last counter falls into an occupied hole, they pick the counters in this hole up and continue sowing. Sowing ends when the last counter falls into an empty hole. If the empty hole is in the inner row, the player captures any of the counters in the opponent's two holes opposite it. Play ends when all of one player's seeds have been captured.
(game "Bao Ki Arabu (Zanzibar 1)" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "TrackCCW1" "0,E,N1,W" loop:True P1) (track "TrackCCW2" "16,E,N1,W" loop:True P2) (track "TrackCW1" "7,W,N1,E" loop:True P1) (track "TrackCW2" "24,E,S1,W" loop:True P2)}) (regions "Home" P1 (sites Track "TrackCCW1")) (regions "Home" P2 (sites Track "TrackCCW2")) (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top))) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 3 to:(sites Board))) (play (or (move Select (from (if (is Prev Mover) (if (is Pending) (sites {(last To afterConsequence:True)})) (sites Mover "Home")) if:(> (count at:(from)) 0)) (then (sow "TrackCW" owner:(mover) apply:(if (= (count at:(to)) 1) (if (is In (to) (sites Mover "Inner")) (and (if (> (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))) 0) (fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))))) (if (> (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) 0) (fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))))))) (and (moveAgain) (set Pending)))))) (move Select (from (if (is Prev Mover) (if (not (is Pending)) (sites {(last To afterConsequence:True)})) (sites Mover "Home")) if:(> (count at:(from)) 0)) (then (sow "TrackCCW" owner:(mover) apply:(if (= (count at:(to)) 1) (if (is In (to) (sites Mover "Inner")) (and (if (> (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))) 0) (fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))))) (if (> (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) 0) (fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))))))) (moveAgain))))))) (end (if (no Moves Mover) (byScore {(score P1 (+ (count Cell at:(handSite P1)) (count in:(sites P1 "Home")))) (score P2 (+ (count Cell at:(handSite P2)) (count in:(sites P2 "Home"))))}))))) 
4x8 board. Play begins with two counters in each hole. Sowing occurs in an anti-clockwise direction. When the last counter falls into an occupied hole, the counters in it are picked up and sowing continues. Sowing ends when the last counter falls into an empty hole. When this hole is in the inner row, the counters in the opponent's inner row opposite it are captured; if there are also counters in the opponent's outer row opposite, these are also captured, but not if the inner row is empty. Play continues until one player has lost all of their counters.
(game "Bao Ki Arabu (Zanzibar 2)" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "16,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 2 to:(sites Board))) (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(> (count at:(from)) 0)) (then (sow "Track" owner:(mover) apply:(if (= (count at:(to)) 1) (if (is In (to) (sites Mover "Inner")) (if (> (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))) 0) (and (fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (if (> (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) 0) (fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))))))) (moveAgain)))))) (end (if (no Moves Mover) (byScore {(score P1 (+ (count Cell at:(handSite P1)) (count in:(sites P1 "Home")))) (score P2 (+ (count Cell at:(handSite P2)) (count in:(sites P2 "Home"))))}))))) 
4x8 board. The fifth hole from the left in the inner row is rectangular, the rest are circular. 64 counters. Play begins with one counter in each hole in the inner row. Players take turns placing their remaining counters on the board in their inner rows. When they place a counter, they capture the hole facing it in the opponent's inner row, and sows the counters from either the leftmost or the rightmost hole of the player's inner row, sowing along the inner row. However, if the capture occurs from the rightmost, leftmost, or the next hole adjacent to each in the inner row, the captured pieces must be placed in the leftmost or rightmost hole, whichever is closer. The player may choose which hole to place captured counters in when captures are made from the central four holes in the inner row. The player must capture if possible, if not possible they place a counter into any of the holes in their inner row, pick up the contents of that hole, and sow in either direction. While sowing, if the final counter falls into an occupied hole and the opponent's hole opposite it has counters, the counters in the opponent's hole are captured. If the final counter falls into an occupied hole and the hole opposite it is empty, the counters are picked up and sowing continues in the same direction. If the final counter falls into an empty hole, the turn ends. If during this phase, the opponent's inner row is cleared of counters, the player wins. If all of the counters have been introduced and both players still have counters in their inner row, play proceeds to a second phase. Second Phase: Counters are picked up from any hole on the player's side and sown in either direction. The same capture, sowing, and victory rules apply as before. Captures, however, can only be made on subsequent sowings if there was a capture in the first round of a sowing.
(game "Bao Kiswahili (DR Congo)" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "TrackCCW1" "0,E,N1,W" loop:True P1) (track "TrackCCW2" "16,E,N1,W" loop:True P2) (track "TrackCW1" "7,W,N1,E" loop:True P1) (track "TrackCW2" "23,W,N1,E" loop:True P2)}) (piece "Seed" Shared) (hand Each) (regions "Home" P1 (expand (sites Bottom))) (regions "Home" P2 (expand (sites Top))) (regions "Inner" P1 (sites Row 1)) (regions "Inner" P2 (sites Row 2)) (map "LeftMostInner" {(pair P1 8) (pair P2 23)}) (map "RightMostInner" {(pair P1 15) (pair P2 16)}) (map "AdjacentLeftMostInner" {(pair P1 9) (pair P2 22)}) (map "AdjacentRightMostInner" {(pair P1 14) (pair P2 17)})}) (rules (start {(set Count 24 at:(handSite P1)) (set Count 24 at:(handSite P2)) (set Count 1 to:(union (sites Row 1) (sites Row 2)))}) phases:{(phase "Placement" (play (if (is Prev Mover) (if (is Pending) (or (if (or (= 1 (value Player Mover)) (= 0 (value Player Mover))) (do (fromTo (from (if (is Mover P1) (+ (last To afterConsequence:True) 8) (- (last To afterConsequence:True) 8))) (to (mapEntry "LeftMostInner" Mover)) count:(count at:(if (is Mover P1) (+ (last To afterConsequence:True) 8) (- (last To afterConsequence:True) 8)))) next:(move Select (from (mapEntry "LeftMostInner" Mover)) (then (sow "TrackCW" owner:(mover) apply:(if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (and {(moveAgain) (set Pending) (if (is In (to) (expand (sites Right))) (set Value Mover 2) (if (is In (to) (expand (sites Left))) (set Value Mover 1) (set Value Mover 0)))}) (if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 1)}))) (if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 1)})))))))) (if (or (= 2 (value Player Mover)) (= 0 (value Player Mover))) (do (fromTo (from (if (is Mover P1) (+ (last To afterConsequence:True) 8) (- (last To afterConsequence:True) 8))) (to (mapEntry "RightMostInner" Mover)) count:(count at:(if (is Mover P1) (+ (last To afterConsequence:True) 8) (- (last To afterConsequence:True) 8)))) next:(move Select (from (mapEntry "RightMostInner" Mover)) (then (sow "TrackCCW" owner:(mover) apply:(if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (and {(moveAgain) (set Pending) (if (is In (to) (expand (sites Right))) (set Value Mover 2) (if (is In (to) (expand (sites Left))) (set Value Mover 1) (set Value Mover 0)))}) (if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 2)}))) (if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 2)}))))))))) (or (if (or (= (var "Direction") 1) (= (var "Direction") 3)) (move Select (from (var "Replay")) (then (sow "TrackCW" owner:(mover) apply:(if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (and {(moveAgain) (set Pending) (if (is In (to) (expand (sites Right))) (set Value Mover 2) (if (is In (to) (expand (sites Left))) (set Value Mover 1) (set Value Mover 0)))}) (if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 1)}))) (if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 1)}))))))) (if (or (= (var "Direction") 2) (= (var "Direction") 3)) (move Select (from (var "Replay")) (then (sow "TrackCCW" owner:(mover) apply:(if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (and {(moveAgain) (set Pending) (if (is In (to) (expand (sites Right))) (set Value Mover 2) (if (is In (to) (expand (sites Left))) (set Value Mover 1) (set Value Mover 0)))}) (if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 2)}))) (if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 2)}))))))))) (if (is Occupied (handSite Mover)) (priority {(move (from (handSite Mover)) (to (sites Mover "Inner") if:(is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8)))) count:1 (then (and {(moveAgain) (set Pending) (if (is In (last To) (expand (sites Right))) (set Value Mover 2) (if (is In (last To) (expand (sites Left))) (set Value Mover 1) (set Value Mover 0)))}))) (move (from (handSite Mover)) (to (sites Mover "Inner")) count:1 (then (and {(moveAgain) (set Var "Replay" (last To)) (set Var "Direction" 3)})))}) (or (move Select (from (sites Mover) if:(is Occupied (from))) (then (sow "TrackCW" owner:(mover) apply:(if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 1)}))))) (move Select (from (sites Mover) if:(is Occupied (from))) (then (sow "TrackCCW" owner:(mover) apply:(if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 2)}))))))))))} (end (forEach Player if:(all Sites (sites Player "Inner") if:(= 0 (count at:(site)))) (result Player Loss))))) 
4x8 board. The fourth hole from the right in the inner rows of each player is larger and square. Total of 64 counters. Starting position: in the inner row, the first four holes, number of counters from the right: 0; 2; 2; 6. Play begins with each player alternately introducing the remaining counters in their holes. Each is introduced in such a way as to capture an opponent's counters, by placing it into an occupied hole which is opposite one of the opponent's occupied inner-row holes. The opponent's counters are then captured and sown along the inner row from either the leftmost or rightmost hole. If the capture occurs in the rightmost or leftmost holes in the inner row, or the hole immediately adjacent to them in the inner row, the counters must be sown from the leftmost or rightmost hole (whichever is closest), and sown along the inner row. Captures on these subsequent sowings happen according to the same rules as in the second phase, with certain exceptions explained below. If no capture is available, a counter may be placed in any occupied hole in the inner hole except the square hole, and sows them in either direction. If the square hole is the only occupied hole in the inner row, the counter is placed there and the player sows only two seeds from it in either direction. If a loaded square hole is reduced to six counters, the player places a counter there and sows the entire contents, forfeiting the special status for this hole for the rest of the game. Moves that start without a capture on the first sowing which end in the square hole stops there without further sowing. Sowing cannot start from a square hole except to capture, except as described above. If a sowing from an initial capturing move ends in an occupied square hole and no capture is possible, the player may choose to stop there or continue to sow. Once the contents of this hole have been relayed or captured the square hole loses its special status and the player may not introduce a counter into hole with one counter if there are other holes in the inner row containing multiple counters. Once all of the counters are introduced, second phase starts. Players move by sowing seeds from a player's holes. Sowing can happen in any direction, but must continue in that direction throughout the turn except in the special cases below. When the final counter of a sowing lands in a hole in the inner row and there are counters in the opponent's hole in the inner row opposite, these are captured. The captured counters are placed in the leftmost or rightmost hole of the inner row and sown along the inner row. The leftmost or rightmost hole is chosen based on which continues the sowing direction of the move that made the capture. If the capture occurs in the rightmost or leftmost holes in the inner row, or the hole immediately adjacent to them in the inner row, the counters must be sown from the leftmost or rightmost hole (whichever is closest), and sown along the inner row, even if this incurs a change of direction. If the final counter lands in an occupied hole and a capture is not possible, the counters are picked up and sowing continues. If the final counter lands in an empty hole, the turn ends. A player must make a capturing move on their initial sowing if it is available. If a capturing move is not possible on the first sowing, no captures can be made on subsequent sowings in that turn. The game is won when the opponent's inner row is cleared of counters.
(game "Bao Kiswahili (East Africa)" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "TrackCCW1" "0,E,N1,W" loop:True P1) (track "TrackCCW2" "16,E,N1,W" loop:True P2) (track "TrackCW1" "7,W,N1,E" loop:True P1) (track "TrackCW2" "23,W,N1,E" loop:True P2)}) (piece "Seed" Shared) (hand Each) (regions "Home" P1 (expand (sites Bottom))) (regions "Home" P2 (expand (sites Top))) (regions "Inner" P1 (sites Row 1)) (regions "Inner" P2 (sites Row 2)) (regions "SquaresHoles" (sites {12 19})) (map "LeftMostInner" {(pair P1 8) (pair P2 23)}) (map "RightMostInner" {(pair P1 15) (pair P2 16)}) (map "AdjacentLeftMostInner" {(pair P1 9) (pair P2 22)}) (map "AdjacentRightMostInner" {(pair P1 14) (pair P2 17)})}) (rules (start {(set Count 22 at:(handSite P1)) (set Count 22 at:(handSite P2)) (set Count 2 to:(sites {"G2" "F2" "B3" "C3"})) (set Count 6 to:(sites {"E2" "D3"}))}) (play (if (is Prev Mover) (if (is Pending) (or (if (or (= 1 (var "Side")) (= 0 (var "Side"))) (do (fromTo (from (if (is Mover P1) (+ (last To afterConsequence:True) 8) (- (last To afterConsequence:True) 8))) (to (mapEntry "LeftMostInner" Mover)) count:(count at:(if (is Mover P1) (+ (last To afterConsequence:True) 8) (- (last To afterConsequence:True) 8)))) next:(move Select (from (mapEntry "LeftMostInner" Mover)) (then (sow count:(if (!= (value Player Mover) 1) (if (is In (last From) (sites "SquaresHoles")) (if (<= (count at:(last From)) 6) (count at:(last From)) (min 2 (count at:(last From)))) (count at:(last From))) (count at:(last From))) "TrackCW" owner:(mover) apply:(if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (and {(moveAgain) (set Pending) (if (is In (to) (expand (sites Right))) (set Var "Side" 2) (if (is In (to) (expand (sites Left))) (set Var "Side" 1) (set Var "Side" 0)))}) (if (< 1 (count at:(to))) (if (or (= 1 (value Player Mover)) (and (!= 1 (value Player Mover)) (not (is In (to) (sites "SquaresHoles"))))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 1)}) (set Var "Direction" 0)))) (if (< 1 (count at:(to))) (if (or (= 1 (value Player Mover)) (and (!= 1 (value Player Mover)) (not (is In (to) (sites "SquaresHoles"))))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 1)}) (set Var "Direction" 0)))) (then (if (and {(!= 1 (value Player Mover)) (is In (last From) (sites "SquaresHoles")) (< (count at:(last From)) 6)}) (set Value Mover 1)))))))) (if (or (= 2 (var "Side")) (= 0 (var "Side"))) (do (fromTo (from (if (is Mover P1) (+ (last To afterConsequence:True) 8) (- (last To afterConsequence:True) 8))) (to (mapEntry "RightMostInner" Mover)) count:(count at:(if (is Mover P1) (+ (last To afterConsequence:True) 8) (- (last To afterConsequence:True) 8)))) next:(move Select (from (mapEntry "RightMostInner" Mover)) (then (sow count:(if (!= (value Player Mover) 1) (if (is In (last From) (sites "SquaresHoles")) (if (<= (count at:(last From)) 6) (count at:(last From)) (min 2 (count at:(last From)))) (count at:(last From))) (count at:(last From))) "TrackCCW" owner:(mover) apply:(if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (and {(moveAgain) (set Pending) (if (is In (to) (expand (sites Right))) (set Var "Side" 2) (if (is In (to) (expand (sites Left))) (set Var "Side" 1) (set Var "Side" 0)))}) (if (< 1 (count at:(to))) (if (or (= 1 (value Player Mover)) (and (!= 1 (value Player Mover)) (not (is In (to) (sites "SquaresHoles"))))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 2)}) (set Var "Direction" 0)))) (if (< 1 (count at:(to))) (if (or (= 1 (value Player Mover)) (and (!= 1 (value Player Mover)) (not (is In (to) (sites "SquaresHoles"))))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 2)}) (set Var "Direction" 0)))) (then (if (and {(!= 1 (value Player Mover)) (is In (last From) (sites "SquaresHoles")) (< (count at:(last From)) 6)}) (set Value Mover 1))))))))) (or (if (or (= (var "Direction") 1) (= (var "Direction") 3)) (move Select (from (var "Replay")) (then (sow count:(if (!= (value Player Mover) 1) (if (is In (last From) (sites "SquaresHoles")) (if (<= (count at:(last From)) 6) (count at:(last From)) (min 2 (count at:(last From)))) (count at:(last From))) (count at:(last From))) "TrackCW" owner:(mover) apply:(if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (and {(moveAgain) (set Pending) (if (is In (to) (expand (sites Right))) (set Var "Side" 2) (if (is In (to) (expand (sites Left))) (set Var "Side" 1) (set Var "Side" 0)))}) (if (< 1 (count at:(to))) (if (or (= 1 (value Player Mover)) (and (!= 1 (value Player Mover)) (not (is In (to) (sites "SquaresHoles"))))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 1)}) (set Var "Direction" 0)))) (if (< 1 (count at:(to))) (if (or (= 1 (value Player Mover)) (and (!= 1 (value Player Mover)) (not (is In (to) (sites "SquaresHoles"))))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 1)}) (set Var "Direction" 0)))) (then (if (and {(!= 1 (value Player Mover)) (is In (last From) (sites "SquaresHoles")) (< (count at:(last From)) 6)}) (set Value Mover 1))))))) (if (or (= (var "Direction") 2) (= (var "Direction") 3)) (move Select (from (var "Replay")) (then (sow count:(if (!= (value Player Mover) 1) (if (is In (last From) (sites "SquaresHoles")) (if (<= (count at:(last From)) 6) (count at:(last From)) (min 2 (count at:(last From)))) (count at:(last From))) (count at:(last From))) "TrackCCW" owner:(mover) apply:(if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (and {(moveAgain) (set Pending) (if (is In (to) (expand (sites Right))) (set Var "Side" 2) (if (is In (to) (expand (sites Left))) (set Var "Side" 1) (set Var "Side" 0)))}) (if (< 1 (count at:(to))) (if (or (= 1 (value Player Mover)) (and (!= 1 (value Player Mover)) (not (is In (to) (sites "SquaresHoles"))))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 2)}) (set Var "Direction" 0)))) (if (< 1 (count at:(to))) (if (or (= 1 (value Player Mover)) (and (!= 1 (value Player Mover)) (not (is In (to) (sites "SquaresHoles"))))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 2)}) (set Var "Direction" 0)))) (then (if (and {(!= 1 (value Player Mover)) (is In (last From) (sites "SquaresHoles")) (< (count at:(last From)) 6)}) (set Value Mover 1))))))))) (if (is Occupied (handSite Mover)) (priority {(move (from (handSite Mover)) (to (sites Mover "Inner") if:(is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8)))) count:1 (then (and {(moveAgain) (set Pending) (if (is In (last To) (expand (sites Right))) (set Var "Side" 2) (if (is In (last To) (expand (sites Left))) (set Var "Side" 1) (set Var "Side" 0)))}))) (if (!= (value Player Mover) 1) (move (from (handSite Mover)) (to (difference (sites Mover "Inner") (sites "SquaresHoles")) if:(is Occupied (to))) count:1 (then (and {(moveAgain) (set Var "Replay" (last To)) (set Var "Direction" 3)}))) (move (from (handSite Mover)) (to (sites Mover "Inner") if:(is Occupied (to))) count:1 (then (and {(moveAgain) (set Var "Replay" (last To)) (set Var "Direction" 3)})))) (if (!= (value Player Mover) 1) (move (from (handSite Mover)) (to (sites "SquaresHoles") if:(is Occupied (to))) count:1 (then (and {(moveAgain) (set Var "Replay" (last To)) (set Var "Direction" 3)}))))}) (priority {(or (move Select (from (sites Mover) if:(and (is Occupied (from)) (is Occupied (if (is Mover P1) (+ (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) 8) (- (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) 8))))) (then (sow "TrackCW" owner:(mover) apply:(if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (and {(moveAgain) (set Pending) (if (is In (to) (expand (sites Right))) (set Var "Side" 2) (if (is In (to) (expand (sites Left))) (set Var "Side" 1) (set Var "Side" 0)))}) (if (< 1 (count at:(to))) (if (or (= 1 (value Player Mover)) (and (!= 1 (value Player Mover)) (not (is In (to) (sites "SquaresHoles"))))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 1)}) (set Var "Direction" 0)))) (if (< 1 (count at:(to))) (if (or (= 1 (value Player Mover)) (and (!= 1 (value Player Mover)) (not (is In (to) (sites "SquaresHoles"))))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 1)}) (set Var "Direction" 0))))))) (move Select (from (sites Mover) if:(and (is Occupied (from)) (is Occupied (if (is Mover P1) (+ (trackSite Move from:(from) "TrackCCW" steps:(count at:(from))) 8) (- (trackSite Move from:(from) "TrackCCW" steps:(count at:(from))) 8))))) (then (sow "TrackCCW" owner:(mover) apply:(if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (and {(moveAgain) (set Pending) (if (is In (to) (expand (sites Right))) (set Var "Side" 2) (if (is In (to) (expand (sites Left))) (set Var "Side" 1) (set Var "Side" 0)))}) (if (< 1 (count at:(to))) (if (or (= 1 (value Player Mover)) (and (!= 1 (value Player Mover)) (not (is In (to) (sites "SquaresHoles"))))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 2)}) (set Var "Direction" 0)))) (if (< 1 (count at:(to))) (if (or (= 1 (value Player Mover)) (and (!= 1 (value Player Mover)) (not (is In (to) (sites "SquaresHoles"))))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 2)}) (set Var "Direction" 0)))))))) (or (move Select (from (if (!= (value Player Mover) 1) (sites Mover) (difference (sites Mover) (sites "SquaresHoles"))) if:(is Occupied (from))) (then (sow "TrackCW" owner:(mover) apply:(if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (and {(moveAgain) (set Pending) (if (is In (to) (expand (sites Right))) (set Var "Side" 2) (if (is In (to) (expand (sites Left))) (set Var "Side" 1) (set Var "Side" 0)))}) (if (< 1 (count at:(to))) (if (or (= 1 (value Player Mover)) (and (!= 1 (value Player Mover)) (not (is In (to) (sites "SquaresHoles"))))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 1)}) (set Var "Direction" 0)))) (if (< 1 (count at:(to))) (if (or (= 1 (value Player Mover)) (and (!= 1 (value Player Mover)) (not (is In (to) (sites "SquaresHoles"))))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 1)}) (set Var "Direction" 0))))))) (move Select (from (if (!= (value Player Mover) 1) (sites Mover) (difference (sites Mover) (sites "SquaresHoles"))) if:(is Occupied (from))) (then (sow "TrackCCW" owner:(mover) apply:(if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (and {(moveAgain) (set Pending) (if (is In (to) (expand (sites Right))) (set Var "Side" 2) (if (is In (to) (expand (sites Left))) (set Var "Side" 1) (set Var "Side" 0)))}) (if (< 1 (count at:(to))) (if (or (= 1 (value Player Mover)) (and (!= 1 (value Player Mover)) (not (is In (to) (sites "SquaresHoles"))))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 2)}) (set Var "Direction" 0)))) (if (< 1 (count at:(to))) (if (or (= 1 (value Player Mover)) (and (!= 1 (value Player Mover)) (not (is In (to) (sites "SquaresHoles"))))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 2)}) (set Var "Direction" 0))))))))})))) (end (forEach Player if:(all Sites (sites Player "Inner") if:(= 0 (count at:(site)))) (result Player Loss))))) 
4x8 board. One hole, the Nyumba, is square, and is the hole immediately to the right of center in the player's inner row. The holes on both ends of both players' inner rows are Kichwa, and the next holes in from those are the Kimbi. Players sow from one of their holes in either direction on the board. When the final counter lands in an occupied hole, these counters are picked up and sowing continues, when a capture is not possible. When the final counter lands in an empty hole, the turn ends. Play begins with six counters in the Nyumba, two in each of the holes to its right, and 22 counters to be entered on the board. Namua is the stage of the game where there are still counters to be placed on the board. During Namua, the Nyumba is the house, as long as it has at least six counters in it and it has not been emptied. Players place counters into an occupied hole in their front row. If this hole is opposite one of the opponent's occupied holes, the opponent's counters in that hole are captured. Captures must be made if possible. If a capture is not possible, the counter is placed into a hole and the contents of that hole are sown. The house cannot be emptied, but if it is the only occupied hole, the counter placed into it, and only that one counter, can be sown to one of the adjacent holes. Sowing from a Kichwa in the direction of the back row is not allowed unless it is the only occupied hole in the front row. Players cannot place a counter in holes with single counters unless only holes in the front row with single counters exist or the house is still present. If the final counter of a sowing lands in the house, the turn ends. Once all of the counters are placed on the board for both players, Namua ends. The next stage begins. The rules for the house mentioned above during the Namua stage no longer apply, but the rules below remain in effect until the first capture in this phase of the game has been made. Players alternate turns taking the counters from one of their holes that has more than one and less than sixteen counters and sowing them. When the final counter lands in an occupied hole in the front row opposite one of the opponent's occupied holes, the opponent's counters are captured, unless the hole from which sowing began contained sixteen or more counters. Captures must be made if possible. Single counters cannot be sown. Sowing must occur from an inner row hole when possible. A Kichwa cannot be sown toward the back row if it is the only occupied hole in the front row. Capturing rules: The counters captured from the opponent's hole are captured and sown on the player's front row. If they were captured from a Kimbi or Kichwa, they must be sown from the nearest Kichwa. If they were not captured from one of these holes, they must be sown from the Kichwa in the direction toward which the sowing was proceeding when the capture was made. If the capture was not made from a Kimbi or Kichwa and it was not made while sowing, the player can choose which Kichwa to sow from. Further captures in the same turn must be made with this sowing if possible, and are made if the final counter lands in an occupied hole in the inner row which is opposite an occupied hole in the opponent's inner row. If a capture is not possible, the sowing must end in the house. When the final counter lands in the house, the player may choose to continue sowing from the house or to end their turn. If the player cannot capture and cannot drop the final counter in the house, they must sow into an occupied hole, and continue sowing from that hole. The player may sow such that the final counter lands in an empty hole only when none of the other options are possible. When a player sows in such a way that they do not capture and the opponent is unable to capture on their next turn but the player will be able to capture on their own following move, the opponent cannot sow from this hole. The opponent is able to sow from such a hole if they can capture from this hole; if the hole in question is the house (this remains true for all phases of the game); if it is the only occupied hole in the front row; or if it is the only hole in the front row with greater than one counter. This rule does not apply during the Namua phase. A player wins when their opponent's inner row holes are empty. This includes in the middle of sowing (e.g., sowing into the outer row directly from a Kichwa when it is the only occupied hole in the front row). A player may also lose if they only have single counters in their holes. 
(game "Bao" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "TrackCCW1" "0,E,N1,W" loop:True P1) (track "TrackCCW2" "16,E,N1,W" loop:True P2) (track "TrackCW1" "7,W,N1,E" loop:True P1) (track "TrackCW2" "23,W,N1,E" loop:True P2)}) (piece "Seed" Shared) (hand Each) (regions "Home" P1 (expand (sites Bottom))) (regions "Home" P2 (expand (sites Top))) (regions "Inner" P1 (sites Row 1)) (regions "Inner" P2 (sites Row 2)) (regions "SquaresHoles" (sites {19 12})) (regions "RightSquare" (sites {18 13})) (map "LeftMostInner" {(pair P1 8) (pair P2 23)}) (map "RightMostInner" {(pair P1 15) (pair P2 16)}) (map "AdjacentLeftMostInner" {(pair P1 9) (pair P2 22)}) (map "AdjacentRightMostInner" {(pair P1 14) (pair P2 17)})}) (rules (start {(set Count 22 at:(handSite P1)) (set Count 22 at:(handSite P2)) (set Count 6 to:(sites "SquaresHoles")) (set Count 2 to:(sites "RightSquare"))}) (play (if (is Prev Mover) (if (is Pending) (or (if (or (= 1 (var "Side")) (= 0 (var "Side"))) (do (fromTo (from (if (is Mover P1) (+ (last To afterConsequence:True) 8) (- (last To afterConsequence:True) 8))) (to (mapEntry "LeftMostInner" Mover)) count:(count at:(if (is Mover P1) (+ (last To afterConsequence:True) 8) (- (last To afterConsequence:True) 8)))) next:(move Select (from (mapEntry "LeftMostInner" Mover)) (then (sow count:(if (!= (value Player Mover) 1) (if (is In (last From) (sites "SquaresHoles")) (if (<= (count at:(from)) 6) (count at:(last From)) (min 1 (count at:(last From)))) (count at:(last From))) (count at:(last From))) "TrackCW" owner:(mover) apply:(if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (and {(moveAgain) (set Pending) (if (is In (to) (expand (sites Right))) (set Var "Side" 2) (if (is In (to) (expand (sites Left))) (set Var "Side" 1) (set Var "Side" 0)))}) (if (< 1 (count at:(to))) (if (or (= 1 (value Player Mover)) (and (!= 1 (value Player Mover)) (not (is In (to) (sites "SquaresHoles"))))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 1)}) (set Var "Direction" 0)))) (if (< 1 (count at:(to))) (if (or (= 1 (value Player Mover)) (and (!= 1 (value Player Mover)) (not (is In (to) (sites "SquaresHoles"))))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 1)}) (set Var "Direction" 0)))) (then (if (and {(!= 1 (value Player Mover)) (is In (last From) (sites "SquaresHoles")) (< (count at:(last From)) 6)}) (set Value Mover 1)))))))) (if (or (= 2 (var "Side")) (= 0 (var "Side"))) (do (fromTo (from (if (is Mover P1) (+ (last To afterConsequence:True) 8) (- (last To afterConsequence:True) 8))) (to (mapEntry "RightMostInner" Mover)) count:(count at:(if (is Mover P1) (+ (last To afterConsequence:True) 8) (- (last To afterConsequence:True) 8)))) next:(move Select (from (mapEntry "RightMostInner" Mover)) (then (sow count:(if (!= (value Player Mover) 1) (if (is In (last From) (sites "SquaresHoles")) (if (<= (count at:(from)) 6) (count at:(last From)) (min 1 (count at:(last From)))) (count at:(last From))) (count at:(last From))) "TrackCCW" owner:(mover) apply:(if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (and {(moveAgain) (set Pending) (if (is In (to) (expand (sites Right))) (set Var "Side" 2) (if (is In (to) (expand (sites Left))) (set Var "Side" 1) (set Var "Side" 0)))}) (if (< 1 (count at:(to))) (if (or (= 1 (value Player Mover)) (and (!= 1 (value Player Mover)) (not (is In (to) (sites "SquaresHoles"))))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 2)}) (set Var "Direction" 0)))) (if (< 1 (count at:(to))) (if (or (= 1 (value Player Mover)) (and (!= 1 (value Player Mover)) (not (is In (to) (sites "SquaresHoles"))))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 2)}) (set Var "Direction" 0)))) (then (if (and {(!= 1 (value Player Mover)) (is In (last From) (sites "SquaresHoles")) (< (count at:(last From)) 6)}) (set Value Mover 1))))))))) (or (if (and (if (!= (var "Replay") (mapEntry "RightMostInner" Mover)) True (all Sites (difference (sites Mover "Inner") (mapEntry "RightMostInner" Mover)) if:(is Empty (site)))) (or (= (var "Direction") 1) (= (var "Direction") 3))) (move Select (from (var "Replay")) (then (sow count:(if (!= (value Player Mover) 1) (if (is In (last From) (sites "SquaresHoles")) (if (<= (count at:(from)) 6) (count at:(last From)) (min 1 (count at:(last From)))) (count at:(last From))) (count at:(last From))) "TrackCW" owner:(mover) apply:(if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (and {(moveAgain) (set Pending) (if (is In (to) (expand (sites Right))) (set Var "Side" 2) (if (is In (to) (expand (sites Left))) (set Var "Side" 1) (set Var "Side" 0)))}) (if (< 1 (count at:(to))) (if (or (= 1 (value Player Mover)) (and (!= 1 (value Player Mover)) (not (is In (to) (sites "SquaresHoles"))))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 1)}) (set Var "Direction" 0)))) (if (< 1 (count at:(to))) (if (or (= 1 (value Player Mover)) (and (!= 1 (value Player Mover)) (not (is In (to) (sites "SquaresHoles"))))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 1)}) (set Var "Direction" 0)))) (then (if (and {(!= 1 (value Player Mover)) (is In (last From) (sites "SquaresHoles")) (< (count at:(last From)) 6)}) (set Value Mover 1))))))) (if (and (if (!= (var "Replay") (mapEntry "LeftMostInner" Mover)) True (all Sites (difference (sites Mover "Inner") (mapEntry "LeftMostInner" Mover)) if:(is Empty (site)))) (or (= (var "Direction") 2) (= (var "Direction") 3))) (move Select (from (var "Replay")) (then (sow count:(if (!= (value Player Mover) 1) (if (is In (last From) (sites "SquaresHoles")) (if (<= (count at:(from)) 6) (count at:(last From)) (min 1 (count at:(last From)))) (count at:(last From))) (count at:(last From))) "TrackCCW" owner:(mover) apply:(if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (and {(moveAgain) (set Pending) (if (is In (to) (expand (sites Right))) (set Var "Side" 2) (if (is In (to) (expand (sites Left))) (set Var "Side" 1) (set Var "Side" 0)))}) (if (< 1 (count at:(to))) (if (or (= 1 (value Player Mover)) (and (!= 1 (value Player Mover)) (not (is In (to) (sites "SquaresHoles"))))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 2)}) (set Var "Direction" 0)))) (if (< 1 (count at:(to))) (if (or (= 1 (value Player Mover)) (and (!= 1 (value Player Mover)) (not (is In (to) (sites "SquaresHoles"))))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 2)}) (set Var "Direction" 0)))) (then (if (and {(!= 1 (value Player Mover)) (is In (last From) (sites "SquaresHoles")) (< (count at:(last From)) 6)}) (set Value Mover 1))))))))) (if (is Occupied (handSite Mover)) (priority {(move (from (handSite Mover)) (to (sites Mover "Inner") if:(and (is Occupied (to)) (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))))) count:1 (then (and {(moveAgain) (set Pending) (if (is In (last To) (expand (sites Right))) (set Var "Side" 2) (if (is In (last To) (expand (sites Left))) (set Var "Side" 1) (set Var "Side" 0)))}))) (if (!= (value Player Mover) 1) (move (from (handSite Mover)) (to (difference (sites Mover "Inner") (sites "SquaresHoles")) if:(is Occupied (to))) count:1 (then (and {(moveAgain) (set Var "Replay" (last To)) (set Var "Direction" 3)}))) (move (from (handSite Mover)) (to (sites Mover "Inner") if:(is Occupied (to))) count:1 (then (and {(moveAgain) (set Var "Replay" (last To)) (set Var "Direction" 3)})))) (if (!= (value Player Mover) 1) (move (from (handSite Mover)) (to (intersection (sites "SquaresHoles") (sites Mover "Inner")) if:(is Occupied (to))) count:1 (then (and {(moveAgain) (set Var "Replay" (last To)) (set Var "Direction" 3)}))))}) (priority {(or (move Select (from (sites Mover) if:(and (or (< 1 (count at:(from))) (> 16 (count at:(from)))) (is Occupied (if (is Mover P1) (+ (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) 8) (- (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) 8))))) (then (sow "TrackCW" owner:(mover) apply:(if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (and {(moveAgain) (set Pending) (if (is In (to) (expand (sites Right))) (set Var "Side" 2) (if (is In (to) (expand (sites Left))) (set Var "Side" 1) (set Var "Side" 0)))}) (if (< 1 (count at:(to))) (if (or (= 1 (value Player Mover)) (and (!= 1 (value Player Mover)) (not (is In (to) (sites "SquaresHoles"))))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 1)}) (set Var "Direction" 0)))) (if (< 1 (count at:(to))) (if (or (= 1 (value Player Mover)) (and (!= 1 (value Player Mover)) (not (is In (to) (sites "SquaresHoles"))))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 1)}) (set Var "Direction" 0))))))) (move Select (from (sites Mover) if:(and (or (< 1 (count at:(from))) (> 16 (count at:(from)))) (is Occupied (if (is Mover P1) (+ (trackSite Move from:(from) "TrackCCW" steps:(count at:(from))) 8) (- (trackSite Move from:(from) "TrackCCW" steps:(count at:(from))) 8))))) (then (sow "TrackCCW" owner:(mover) apply:(if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (and {(moveAgain) (set Pending) (if (is In (to) (expand (sites Right))) (set Var "Side" 2) (if (is In (to) (expand (sites Left))) (set Var "Side" 1) (set Var "Side" 0)))}) (if (< 1 (count at:(to))) (if (or (= 1 (value Player Mover)) (and (!= 1 (value Player Mover)) (not (is In (to) (sites "SquaresHoles"))))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 2)}) (set Var "Direction" 0)))) (if (< 1 (count at:(to))) (if (or (= 1 (value Player Mover)) (and (!= 1 (value Player Mover)) (not (is In (to) (sites "SquaresHoles"))))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 2)}) (set Var "Direction" 0)))))))) (or (move Select (from (if (!= (value Player Mover) 1) (sites Mover) (difference (sites Mover) (sites "SquaresHoles"))) if:(or (< 1 (count at:(from))) (> 16 (count at:(from))))) (then (sow "TrackCW" owner:(mover) apply:(if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (and {(moveAgain) (set Pending) (if (is In (to) (expand (sites Right))) (set Var "Side" 2) (if (is In (to) (expand (sites Left))) (set Var "Side" 1) (set Var "Side" 0)))}) (if (< 1 (count at:(to))) (if (or (= 1 (value Player Mover)) (and (!= 1 (value Player Mover)) (not (is In (to) (sites "SquaresHoles"))))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 1)}) (set Var "Direction" 0)))) (if (< 1 (count at:(to))) (if (or (= 1 (value Player Mover)) (and (!= 1 (value Player Mover)) (not (is In (to) (sites "SquaresHoles"))))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 1)}) (set Var "Direction" 0))))))) (move Select (from (if (!= (value Player Mover) 1) (sites Mover) (difference (sites Mover) (sites "SquaresHoles"))) if:(or (< 1 (count at:(from))) (> 16 (count at:(from))))) (then (sow "TrackCCW" owner:(mover) apply:(if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (and {(moveAgain) (set Pending) (if (is In (to) (expand (sites Right))) (set Var "Side" 2) (if (is In (to) (expand (sites Left))) (set Var "Side" 1) (set Var "Side" 0)))}) (if (< 1 (count at:(to))) (if (or (= 1 (value Player Mover)) (and (!= 1 (value Player Mover)) (not (is In (to) (sites "SquaresHoles"))))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 2)}) (set Var "Direction" 0)))) (if (< 1 (count at:(to))) (if (or (= 1 (value Player Mover)) (and (!= 1 (value Player Mover)) (not (is In (to) (sites "SquaresHoles"))))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 2)}) (set Var "Direction" 0))))))))})))) (end (forEach Player if:(no Moves Player) (result Player Loss))))) 
4 row board, of any number of holes. Four counters in each player's outer row. Sowing occurs from the player's rearmost hole and in an anti-clockwise direction. When the final counter lands in an empty hole in the inner row, any counters in the opposite hole in the opponent's inner row are captured. The player who captures all of the opponent's counters wins. Each player has 16 holes per row.
(game "Chiana wa Bwalo" (players 2) (equipment {(mancalaBoard 4 16 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "32,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 4 to:(union (sites Top) (sites Bottom)))) (play (move Select (from (sites Mover "Home") if:(> (count at:(from)) 0)) (then (sow "Track" owner:(mover) apply:(if (and (= (count at:(to)) 1) (> (count at:(if (is Mover P1) (+ (to) 16) (- (to) 16))) 0)) (fromTo (from (if (is Mover P1) (+ (to) 16) (- (to) 16))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 16) (- (to) 16))))))))) (end (if (no Moves Next) (byScore {(score P1 (+ (count Cell at:(handSite P1)) (count in:(sites P1 "Home")))) (score P2 (+ (count Cell at:(handSite P2)) (count in:(sites P2 "Home"))))}))))) 
4-row board, of any number of holes. Only the outer rows are used. Four counters in each hole in the outer row. Sowing occurs in an anti-clockwise direction. Players do not own rows, instead, over the course of their sowing, their counters are always grouped together, and sowing must occur from the rearmost counter in the player's series. If, after sowing, a player's series has one counter in the foremost hole and two in the next hole behind it, the player sows again from the rearmost hole. If the player overtakes the opponent's series, the player captures any counters in the opponent's series and places all of them in the hole immediately behind the player's series, now becoming the rearmost hole. If the rearmost hole contains a single counter, it is moved into the next hole which then becomes the rearmost hole for the next turn. If a player is reduced to a single counter, it can be moved two holes on the player's turn. The player who successfully captures all of the opponent's counters wins.  Each row has 16 holes.
(game "Chiana wa Kunja" (players 2) (equipment {(mancalaBoard 4 16 store:None (track "Track" "0,E,63,W" loop:True)) (piece "Seed" Each) (hand Shared)}) (rules (start {(place "Seed1" (sites Bottom) counts:{4}) (place "Seed2" (sites Top) counts:{4})}) (play (or (move Select (from (trackSite FirstSite from:(trackSite FirstSite if:(not (is Mover (who at:(to))))) if:(is Mover (who at:(to))))) (then (do (and (forEach Site (sites Track "Track" from:(last From) to:(trackSite Move from:(last From) steps:(count at:(last From)))) (if (!= (mover) (who at:(site))) (and (remove (site) count:(count at:(site))) (add (piece (id "Seed" Mover)) (to Cell (handSite Shared)) count:(count at:(site)))))) (set Var "NumSowed" (count at:(last From)))) next:(sow) (then (and {(if (< 1 (var "NumSowed")) (if (and (= 1 (count at:(trackSite Move from:(last From) "Track" steps:(var "NumSowed")))) (= 2 (count at:(trackSite Move from:(last From) "Track" steps:(- (var "NumSowed") 1))))) (moveAgain))) (if (!= 0 (what Cell at:(handSite Shared))) (fromTo (from Cell (handSite Shared)) (to (last From)) count:(count Cell at:(handSite Shared)))) (set Var "NumSowed" 0)}))))) (if (and (= 1 (count Pieces Mover)) (is Empty (trackSite Move from:(from) "Track" steps:1))) (move (from (trackSite FirstSite from:(trackSite FirstSite if:(not (is Mover (who at:(to))))) if:(is Mover (who at:(to))))) (to (trackSite Move from:(from) "Track" steps:2) (apply (and (remove (to) count:(count at:(to))) (add (piece (id "Seed" Mover)) (to (to)) count:(count at:(to)))))))))) (end (if (no Moves Next) (result Mover Win))))) 
4x7-10 board (seven most common). Three counters in each hole, except the leftmost four in the inner row which have, from right to left: 0-0-1-2. On the first turn, sowing occurs in a clockwise direction. On the second turn, the player may sow in either direction, but must continue in the chosen direction for the rest of the game. When the final counter lands in an empty hole in the inner row, the contents of the hole in the opponent's inner row are also captured. If there are also contents in the opponent's outer row hole opposite, these are also taken. When a capture is made, the player may then capture the counters in any one of the opponent's holes as well. If the final counter lands in an occupied hole, the player picks up these counters and continues sowing. The player who captures all of the opponent's counters wins. Each player has 7 holes on each row. Starting positions of the Natatu ruleset. No Opening. Capture all the opposite holes.
(game "Chisolo" (players 2) (equipment {(mancalaBoard 4 7 store:None {(track "TrackCCW1" "0,E,N1,W" loop:True P1) (track "TrackCCW2" "14,E,N1,W" loop:True P2) (track "TrackCW1" "6,W,N1,E" loop:True P1) (track "TrackCW2" "21,E,S1,W" loop:True P2)}) (regions "Home" P1 (sites Track "TrackCCW1")) (regions "Home" P2 (sites Track "TrackCCW2")) (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top))) (regions "FourLeftInner" P1 (sites {7 8 9 10})) (regions "FourLeftInner" P2 (sites {17 18 19 20})) (piece "Seed" Shared) (hand Each)}) (rules (start {(set Count 3 to:(difference (union (sites P1 "Home") (sites P2 "Home")) (union (sites P1 "FourLeftInner") (sites P2 "FourLeftInner")))) (set Count 1 to:(sites {8 19})) (set Count 2 to:(sites {7 20}))}) phases:{(phase "SowingCW" (play (if (and (is Prev Mover) (= (var "CaptureOther") 1)) (move (from (sites Next) if:(is Occupied (from))) (to (handSite Mover)) count:(count at:(from)) (then (set Var "CaptureOther" 0))) (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(is Occupied (from))) (then (sow "TrackCW" owner:(mover) apply:(if (< 1 (count at:(to))) (moveAgain) (if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 7) (- (to) 7))) (and {(fromTo (from (if (is Mover P1) (+ (to) 7) (- (to) 7))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 7) (- (to) 7)))) (if (is Occupied (if (is Mover P1) (+ (to) (* 7 2)) (- (to) (* 7 2)))) (fromTo (from (if (is Mover P1) (+ (to) (* 7 2)) (- (to) (* 7 2)))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) (* 7 2)) (- (to) (* 7 2)))))) (moveAgain) (set Var "CaptureOther" 1)}))))))))) (nextPhase Mover (not (is Next Mover)) "Sowing")) (phase "Sowing" (play (if (and (is Prev Mover) (= (var "CaptureOther") 1)) (move (from (sites Next) if:(is Occupied (from))) (to (handSite Mover)) count:(count at:(from)) (then (set Var "CaptureOther" 0))) (or (if (or (<= (value Player Mover) 0) (= (value Player Mover) 1)) (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(is Occupied (from))) (then (and (sow "TrackCW" owner:(mover) apply:(if (< 1 (count at:(to))) (moveAgain) (if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 7) (- (to) 7))) (and {(fromTo (from (if (is Mover P1) (+ (to) 7) (- (to) 7))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 7) (- (to) 7)))) (if (is Occupied (if (is Mover P1) (+ (to) (* 7 2)) (- (to) (* 7 2)))) (fromTo (from (if (is Mover P1) (+ (to) (* 7 2)) (- (to) (* 7 2)))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) (* 7 2)) (- (to) (* 7 2)))))) (moveAgain) (set Var "CaptureOther" 1)}))))) (set Value Mover 1))))) (if (or (<= (value Player Mover) 0) (= (value Player Mover) 2)) (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(is Occupied (from))) (then (and (sow "TrackCCW" owner:(mover) apply:(if (< 1 (count at:(to))) (moveAgain) (if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 7) (- (to) 7))) (and {(fromTo (from (if (is Mover P1) (+ (to) 7) (- (to) 7))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 7) (- (to) 7)))) (if (is Occupied (if (is Mover P1) (+ (to) (* 7 2)) (- (to) (* 7 2)))) (fromTo (from (if (is Mover P1) (+ (to) (* 7 2)) (- (to) (* 7 2)))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) (* 7 2)) (- (to) (* 7 2)))))) (moveAgain) (set Var "CaptureOther" 1)}))))) (set Value Mover 2)))))))))} (end (forEach Player if:(no Moves Player) (result Player Loss))))) 
4x8 board. Two counters in each hole. Opening play: Two players play simultaneously, lifting and sowing counters from their outer rows. Rules for sowing and capturing are the same as in the main phase of the game except that all holes in each player's outer rows are considered to be in opposition and back captures can be made from them. Once a counter has been sown into the inner row, this ceases and captures can only be made from the inner row. The opening ends when both players reach an empty hole, and the first player to do so begins play in the main phase. Main phase: Play begins from any hole on the player's side of the board with counters in it. Singletons cannot move. Sowing happens in an anti-clockwise direction. If the last counter lands in an empty hole, the turn is over For capturing: Holes are in 'opposition' when one player has the front row hole occupied and the opponent has both of the holes opposite it occupied. If the last hole in a sowing is in opposition, the player takes the counters in both of the opponent's holes and places them in the empty hole from which the player lifted the counters. The player then sows the captured counters from this hole. Further captures in the sowing can occur in the same way. However, each player has two holes from which clockwise plays can be made: the leftmost hole in the outer row and the second from the left in the inner row. Clockwise moves can only be made from these holes if they immediately lead to a capture. When the captured counters are sown, starting from the same hole, they can also be sown clockwise if they lead to a capture. If they cannot lead to a capture, they are sown anti-clockwise. Another alternative the player has is that, if the player plays clockwise from one of these holes and therefore makes a capture, the captured counters may be placed in the hole and left there, and the player may play instead from the other hole from which clockwise captures are allowed in a clockwise direction, if it leads to a capture. The player may continue playing from this hole as above until the possibilities to move are exhausted, and then may move from any hole in an anti-clockwise direction. Multiple captures can only be made in a clockwise direction from these holes if it is made on the first sowing of the turn. Otherwise, only one clockwise capture can be made and sowing must proceed in an anti-clockwise direction. If the last counter lands on a hole that is occupied but not in opposition, these counters are picked up and sowing continues. Play ends when one player captures all the opponent's counters or one player cannot play. The player who cannot play loses.
(game "Choro (Acholi)" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "TrackCCW1" "0,E,N1,W" loop:True P1) (track "TrackCCW2" "16,E,N1,W" loop:True P2) (track "TrackCW1" "7,W,N1,E" loop:True P1) (track "TrackCW2" "24,E,S1,W" loop:True P2)}) (regions "Home" P1 (sites Track "TrackCCW1")) (regions "Home" P2 (sites Track "TrackCCW2")) (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top))) (regions "Outer" P1 (sites Bottom)) (regions "Outer" P2 (sites Top)) (piece "Seed" Shared) (map "LeftMostOuter" {(pair P1 0) (pair P2 31)}) (map "SecondLeftInner" {(pair P1 9) (pair P2 22)})}) (rules (start (set Count 2 to:(union (sites P1 "Home") (sites P2 "Home")))) phases:{(phase "OuterPhase" (play (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover "Outer")) if:(if (is Prev Mover) (< 0 (count at:(from))) (< 1 (count at:(from))))) (then (sow "TrackCCW" owner:(mover) apply:(and (if (and (!= 1 (value Player Mover)) (is In (to) (sites Mover "Inner"))) (set Value Mover 1)) (if (< 1 (count at:(to))) (and (moveAgain) (if (= 1 (value Player Mover)) (if (and {(is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (is In (to) (sites Mover "Inner"))}) (and {(fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (set Var "Replay" (from))}) (set Var "Replay" (to))) (if (is Occupied (if (is Mover P1) (+ (to) (* 3 8)) (- (to) (* 8 3)))) (and (fromTo (from (if (is Mover P1) (+ (to) (* 3 8)) (- (to) (* 8 3)))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) (* 3 8)) (- (to) (* 8 3))))) (set Var "Replay" (from))) (set Var "Replay" (to))))))))))) (nextPhase Mover (= 1 (count at:(last To afterConsequence:True))) "MainPhase")) (phase "MainPhase" (play (or (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites {(mapEntry "LeftMostOuter" Mover) (mapEntry "SecondLeftInner" Mover)})) if:(and {(if (is Prev Mover) (< 0 (count at:(from))) (< 1 (count at:(from)))) (is In (from) (sites {(mapEntry "LeftMostOuter" Mover) (mapEntry "SecondLeftInner" Mover)})) (is In (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) (sites Mover "Inner")) (is Occupied (if (is Mover P1) (+ (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) 8) (- (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) 8))) (is Occupied (if (is Mover P1) (+ (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) (* 8 2)) (- (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) (* 8 2))))})) (then (sow "TrackCW" owner:(mover) apply:(if (< 1 (count at:(to))) (and (moveAgain) (if (and {(is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (is In (to) (sites Mover "Inner"))}) (and {(fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (set Var "Replay" (from))}) (set Var "Replay" (to)))))))) (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover)) if:(if (is Prev Mover) (< 0 (count at:(from))) (< 1 (count at:(from))))) (then (sow "TrackCCW" owner:(mover) apply:(if (< 1 (count at:(to))) (and (moveAgain) (if (and {(is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (is In (to) (sites Mover "Inner"))}) (and {(fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (set Var "Replay" (from))}) (set Var "Replay" (to)))))))))))} (end (if (no Moves Next) (result Mover Win))))) 
4x8 board. Two counters in each hole. Opening play: Two players play simultaneously, lifting and sowing counters from their outer rows. The game must begin from one of the rightmost two holes. Rules for sowing and capturing are the same as in the main phase of the game. The opening ends when both players reach an empty hole, and the first player to do so begins play in the main phase. Main phase: Play begins from any hole on the player's side of the board with counters in it. Singletons cannot move. Sowing happens in an anti-clockwise direction. If the last counter lands in an empty hole, the turn is over. For capturing: Holes are in 'opposition' when one player has the inner row hole occupied and the opponent has at least the opposite hole in the inner row occupied; if the outer row hole is also occupied it is also in opposition. However, if the opponent's inner row hole is empty and the outer row is occupied, it is not in opposition. If the last hole in a sowing falls into a hole that is is in opposition, the player takes the counters in the opponent's holes in opposition and places them in the outer row hole next to the hole from which the capture occurred. The player then sows the captured counters from this hole. If the capture is only of one counter, the contents of the appropriate outer row hole on the player's side are sown along with the one captured counter. Further captures in the sowing can occur in the same way. If a player can make a capture on the first sowing they must. Otherwise, they can choose any hole on their side to sow. However, each player has four holes from which clockwise plays can be made: the leftmost two holes in both the inner and outer rows. Clockwise moves can only be made from these holes if they immediately lead to a capture. When the captured counters are sown, they may, starting from the same hole, also be sown clockwise as long as they lead to a capture. If they cannot lead to a capture, they are sown anti-clockwise in the normal way from the outer row hole opposite the hole from which the capture was made. A player is not required to capture in a clockwise direction. If the last counter lands on a hole that is occupied but not in opposition, these counters are picked up and sowing continues. Play ends when one player captures all the opponent's counters or one player cannot play. The player who cannot play loses.
(game "Choro (Lango)" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "TrackCCW1" "0,E,N1,W" loop:True P1) (track "TrackCCW2" "16,E,N1,W" loop:True P2) (track "TrackCW1" "7,W,N1,E" loop:True P1) (track "TrackCW2" "24,E,S1,W" loop:True P2)}) (regions "Home" P1 (sites Track "TrackCCW1")) (regions "Home" P2 (sites Track "TrackCCW2")) (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top))) (regions "Outer" P1 (sites Bottom)) (regions "Outer" P2 (sites Top)) (regions "FourLeftMost" P1 (intersection (expand (sites Left)) (expand (sites Bottom)))) (regions "FourLeftMost" P2 (intersection (expand (sites Right)) (expand (sites Top)))) (regions "TwoRightMostOuter" P1 (intersection (expand (sites Right)) (sites Bottom))) (regions "TwoRightMostOuter" P2 (intersection (expand (sites Left)) (sites Top))) (piece "Seed" Shared)}) (rules (start (set Count 2 to:(union (sites P1 "Home") (sites P2 "Home")))) phases:{(phase "OuterPhase" (play (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (if (= 1 (value Player Mover)) (sites Mover "Outer") (sites Mover "TwoRightMostOuter"))) if:(if (is Prev Mover) (< 0 (count at:(from))) (and (if (= 0 (count Sites in:(forEach (sites Mover "Outer") if:(and {(< 1 (count at:(site))) (is In (trackSite Move from:(site) "TrackCCW" steps:(count at:(site))) (sites Mover "Inner")) (is Occupied (if (is Mover P1) (+ (trackSite Move from:(site) "TrackCCW" steps:(count at:(site))) 8) (- (trackSite Move from:(site) "TrackCCW" steps:(count at:(site))) 8)))})))) True (is In (from) (forEach (sites Mover "Outer") if:(and {(< 1 (count at:(site))) (is In (trackSite Move from:(site) "TrackCCW" steps:(count at:(site))) (sites Mover "Inner")) (is Occupied (if (is Mover P1) (+ (trackSite Move from:(site) "TrackCCW" steps:(count at:(site))) 8) (- (trackSite Move from:(site) "TrackCCW" steps:(count at:(site))) 8)))})))) (< 1 (count at:(from)))))) (then (sow count:(if (is Prev Mover) (var "Count") (count at:(last From))) "TrackCCW" owner:(mover) apply:(and (if (< 1 (count at:(to))) (and (moveAgain) (if (and (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (is In (to) (sites Mover "Inner"))) (and {(fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (if (is Mover P1) (- (to) 8) (+ (to) 8))) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (if (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (if (is Mover P1) (- (to) 8) (+ (to) 8))) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))))) (set Var "Replay" (if (is Mover P1) (- (to) 8) (+ (to) 8))) (if (= 1 (count at:(if (is Mover P1) (- (to) 8) (+ (to) 8)))) (set Var "Count" (+ {1 (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))) (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))})) (set Var "Count" (+ (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))) (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))))))}) (and (set Var "Replay" (to)) (set Var "Count" (count at:(to))))))) (if (!= 1 (value Player Mover)) (set Value Mover 1))))))) (nextPhase Mover (= 1 (count at:(last To afterConsequence:True))) "MainPhase")) (phase "MainPhase" (play (or (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover "FourLeftMost")) if:(and {(if (is Prev Mover) (< 0 (count at:(from))) (< 1 (count at:(from)))) (is In (from) (sites Mover "FourLeftMost")) (is In (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) (sites Mover "Inner")) (is Occupied (if (is Mover P1) (+ (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) 8) (- (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) 8)))})) (then (sow count:(if (is Prev Mover) (var "Count") (count at:(last From))) "TrackCW" owner:(mover) apply:(if (< 1 (count at:(to))) (and (moveAgain) (if (and (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (is In (to) (sites Mover "Inner"))) (and {(fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (if (is Mover P1) (- (to) 8) (+ (to) 8))) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (if (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (if (is Mover P1) (- (to) 8) (+ (to) 8))) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))))) (set Var "Replay" (if (is Mover P1) (- (to) 8) (+ (to) 8))) (if (= 1 (count at:(if (is Mover P1) (- (to) 8) (+ (to) 8)))) (set Var "Count" (+ {1 (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))) (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))})) (set Var "Count" (+ (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))) (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))))))}) (and (set Var "Replay" (to)) (set Var "Count" (count at:(to)))))))))) (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover)) if:(if (is Prev Mover) (< 0 (count at:(from))) (and (if (= 0 (count Sites in:(forEach (sites Mover) if:(and {(< 1 (count at:(site))) (is In (trackSite Move from:(site) "TrackCCW" steps:(count at:(site))) (sites Mover "Inner")) (is Occupied (if (is Mover P1) (+ (trackSite Move from:(site) "TrackCCW" steps:(count at:(site))) 8) (- (trackSite Move from:(site) "TrackCCW" steps:(count at:(site))) 8)))})))) True (is In (from) (forEach (sites Mover) if:(and {(< 1 (count at:(site))) (is In (trackSite Move from:(site) "TrackCCW" steps:(count at:(site))) (sites Mover "Inner")) (is Occupied (if (is Mover P1) (+ (trackSite Move from:(site) "TrackCCW" steps:(count at:(site))) 8) (- (trackSite Move from:(site) "TrackCCW" steps:(count at:(site))) 8)))})))) (< 1 (count at:(from)))))) (then (sow count:(if (is Prev Mover) (var "Count") (count at:(last From))) "TrackCCW" owner:(mover) apply:(if (< 1 (count at:(to))) (and (moveAgain) (if (and {(is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (is In (to) (sites Mover "Inner"))}) (and {(fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (if (is Mover P1) (- (to) 8) (+ (to) 8))) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (if (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (if (is Mover P1) (- (to) 8) (+ (to) 8))) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))))) (set Var "Replay" (if (is Mover P1) (- (to) 8) (+ (to) 8))) (if (= 1 (count at:(if (is Mover P1) (- (to) 8) (+ (to) 8)))) (set Var "Count" (+ {1 (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))) (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))})) (set Var "Count" (+ (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))) (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))))))}) (and (set Var "Replay" (to)) (set Var "Count" (count at:(to)))))))))))))} (end (if (no Moves Next) (result Mover Win))))) 
4x5 board. Five counters per hole. Players can sow from any hole. Sowing occurs orthogonally in any direction, and a player can change direction orthogonally at any point in the move, but can never double back. When the last counter falls into a hole, sowing continues if there are counters in the following holes; these are picked up and sowing continues from there. The hole from which the sowing continues will always be the next one in the opposite direction from the penultimate hole in which a counter was dropped. Therefore, if the sowing ends when a sowing hits an edge or corner, sowing does not continue. When the hole after the end of a sowing is empty, the counters in the next hole following it are captured, but captures cannot be made when the final counter falls into a hole from which a new direction must be chosen. Captures cannot be made from the central two holes of the board. The player who captures the most counters wins. 
(game "Dongjintian (Four Players)" (players 4) (equipment {(mancalaBoard 4 5 store:None) (piece "Seed" Shared) (hand Each) (regions "ProtectingHoles" (sites {7 12}))}) (rules (start (set Count 5 to:(sites Board))) (play (if (and (is Prev Mover) (!= 0 (var "NumToSow"))) (if (can Move (move Select (from (last To)) (to (difference (sites Around (last To)) (sites (values Remembered "SowedSites")))) (then (and (add (piece (id "Seed" Shared)) (to (last To))) (if (< 1 (var "NumToSow")) (and {(set Var "NumToSow" (- (var "NumToSow") 1)) (moveAgain) (remember Value "SowedSites" (last From))}) (and {(forget Value "SowedSites" All) (set Var "NumToSow" 0) (if (!= (last To) (ahead (last To) steps:1 (directions Vertex from:(last From) to:(last To)))) (if (is Occupied (ahead (last To) steps:1 (directions Vertex from:(last From) to:(last To)))) (moveAgain) (if (!= (last To) (ahead (last To) steps:2 (directions Vertex from:(last From) to:(last To)))) (if (is Occupied (ahead (last To) steps:2 (directions Vertex from:(last From) to:(last To)))) (and (fromTo (from (ahead (last To) steps:2 (directions Vertex from:(last From) to:(last To)))) (to (handSite Mover)) count:(count at:(ahead (last To) steps:2 (directions Vertex from:(last From) to:(last To))))) (if (and (!= (last To) (ahead (last To) steps:3 (directions Vertex from:(last From) to:(last To)))) (!= (last To) (ahead (last To) steps:4 (directions Vertex from:(last From) to:(last To))))) (if (and (is Occupied (ahead (last To) steps:4 (directions Vertex from:(last From) to:(last To)))) (is Empty (ahead (last To) steps:3 (directions Vertex from:(last From) to:(last To))))) (fromTo (from (ahead (last To) steps:4 (directions Vertex from:(last From) to:(last To)))) (to (handSite Mover)) count:(count at:(ahead (last To) steps:4 (directions Vertex from:(last From) to:(last To))))))))))))})))))) (move Select (from (last To)) (to (difference (sites Around (last To)) (sites (values Remembered "SowedSites")))) (then (and (add (piece (id "Seed" Shared)) (to (last To))) (if (< 1 (var "NumToSow")) (and {(set Var "NumToSow" (- (var "NumToSow") 1)) (moveAgain) (remember Value "SowedSites" (last From))}) (and {(forget Value "SowedSites" All) (set Var "NumToSow" 0) (if (!= (last To) (ahead (last To) steps:1 (directions Vertex from:(last From) to:(last To)))) (if (is Occupied (ahead (last To) steps:1 (directions Vertex from:(last From) to:(last To)))) (moveAgain) (if (!= (last To) (ahead (last To) steps:2 (directions Vertex from:(last From) to:(last To)))) (if (is Occupied (ahead (last To) steps:2 (directions Vertex from:(last From) to:(last To)))) (and (fromTo (from (ahead (last To) steps:2 (directions Vertex from:(last From) to:(last To)))) (to (handSite Mover)) count:(count at:(ahead (last To) steps:2 (directions Vertex from:(last From) to:(last To))))) (if (and (!= (last To) (ahead (last To) steps:3 (directions Vertex from:(last From) to:(last To)))) (!= (last To) (ahead (last To) steps:4 (directions Vertex from:(last From) to:(last To))))) (if (and (is Occupied (ahead (last To) steps:4 (directions Vertex from:(last From) to:(last To)))) (is Empty (ahead (last To) steps:3 (directions Vertex from:(last From) to:(last To))))) (fromTo (from (ahead (last To) steps:4 (directions Vertex from:(last From) to:(last To)))) (to (handSite Mover)) count:(count at:(ahead (last To) steps:4 (directions Vertex from:(last From) to:(last To))))))))))))}))))) (do (and {(add (piece (id "Seed" Shared)) (to (last To)) count:(var "NumToSow")) (forget Value "SowedSites" All) (set Var "NumToSow" 0)}) next:(move Pass))) (if (is Prev Mover) (move (from (ahead (last To) steps:1 (directions Vertex from:(last From) to:(last To)))) (to (sites Around (from))) (then (and {(if (is Occupied (last From)) (and {(moveAgain) (set Var "NumToSow" (count at:(last From))) (remember Value "SowedSites" (last From))}) (if (!= (last To) (ahead (last To) steps:1 (directions Vertex from:(last From) to:(last To)))) (if (is Occupied (ahead (last To) steps:1 (directions Vertex from:(last From) to:(last To)))) (moveAgain) (if (!= (last To) (ahead (last To) steps:2 (directions Vertex from:(last From) to:(last To)))) (if (is Occupied (ahead (last To) steps:2 (directions Vertex from:(last From) to:(last To)))) (and (fromTo (from (ahead (last To) steps:2 (directions Vertex from:(last From) to:(last To)))) (to (handSite Mover)) count:(count at:(ahead (last To) steps:2 (directions Vertex from:(last From) to:(last To))))) (if (and (!= (last To) (ahead (last To) steps:3 (directions Vertex from:(last From) to:(last To)))) (!= (last To) (ahead (last To) steps:4 (directions Vertex from:(last From) to:(last To))))) (if (and (is Occupied (ahead (last To) steps:4 (directions Vertex from:(last From) to:(last To)))) (is Empty (ahead (last To) steps:3 (directions Vertex from:(last From) to:(last To))))) (fromTo (from (ahead (last To) steps:4 (directions Vertex from:(last From) to:(last To)))) (to (handSite Mover)) count:(count at:(ahead (last To) steps:4 (directions Vertex from:(last From) to:(last To))))))))))))) (remove (last From) count:(count at:(last From)))}))) (move (from (sites Board) if:(is Occupied (from))) (to (sites Around (from))) (then (and {(if (is Occupied (last From)) (and {(moveAgain) (set Var "NumToSow" (count at:(last From))) (remember Value "SowedSites" (last From))}) (if (!= (last To) (ahead (last To) steps:1 (directions Vertex from:(last From) to:(last To)))) (if (is Occupied (ahead (last To) steps:1 (directions Vertex from:(last From) to:(last To)))) (moveAgain) (if (!= (last To) (ahead (last To) steps:2 (directions Vertex from:(last From) to:(last To)))) (if (is Occupied (ahead (last To) steps:2 (directions Vertex from:(last From) to:(last To)))) (and (fromTo (from (ahead (last To) steps:2 (directions Vertex from:(last From) to:(last To)))) (to (handSite Mover)) count:(count at:(ahead (last To) steps:2 (directions Vertex from:(last From) to:(last To))))) (if (and (!= (last To) (ahead (last To) steps:3 (directions Vertex from:(last From) to:(last To)))) (!= (last To) (ahead (last To) steps:4 (directions Vertex from:(last From) to:(last To))))) (if (and (is Occupied (ahead (last To) steps:4 (directions Vertex from:(last From) to:(last To)))) (is Empty (ahead (last To) steps:3 (directions Vertex from:(last From) to:(last To))))) (fromTo (from (ahead (last To) steps:4 (directions Vertex from:(last From) to:(last To)))) (to (handSite Mover)) count:(count at:(ahead (last To) steps:4 (directions Vertex from:(last From) to:(last To))))))))))))) (remove (last From) count:(count at:(last From)))})))))) (end (if (<= (count Pieces All in:(sites Board)) 1) (byScore {(score P1 (count Cell at:(handSite P1))) (score P2 (count Cell at:(handSite P2))) (score P3 (count Cell at:(handSite P3))) (score P4 (count Cell at:(handSite P4)))}))))) 
Play begins with two seeds in each hole. Each player owns the two rows closest to them. Play proceeds by taking the seeds from one hole and sowing them one by one in consecutive holes in an anti-clockwise direction. If the last seed falls in a hole in the inner row, and the opponent's hole opposite it is not empty, then the opponent's seeds in that hole are captured. Players can only play from holes with single counters when there is no other option, and they may not sow into another hole that already contains a counter. Play continues until one player no longer has any seeds.
(game "Hawalis" (players 2) (equipment {(mancalaBoard 4 7 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "14,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 2 to:(union (sites P1 "Home") (sites P2 "Home")))) (play (priority (move Select (from (sites Mover "Home") if:(> (count at:(from)) 1)) (then (sow "Track" owner:(mover) if:(and {(= (count at:(to)) 1) (is In (to) (sites Mover "Inner")) (> (count at:(if (is Mover P1) (+ (to) 7) (- (to) 7))) 0)}) apply:(fromTo (from (if (is Mover P1) (+ (to) 7) (- (to) 7))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 7) (- (to) 7))))))) (move Select (from (sites Mover "Home") if:(= (count at:(from)) 1)) (then (sow "Track" owner:(mover) if:(and {(= (count at:(to)) 1) (is In (to) (sites Mover "Inner")) (> (count at:(if (is Mover P1) (+ (to) 7) (- (to) 7))) 0)}) apply:(fromTo (from (if (is Mover P1) (+ (to) 7) (- (to) 7))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 7) (- (to) 7))))))))) (end (if (no Moves Mover) (byScore {(score P1 (+ (count Cell at:(handSite P1)) (count in:(sites P1 "Home")))) (score P2 (+ (count Cell at:(handSite P2)) (count in:(sites P2 "Home"))))}))))) 
4x12-24 (only even numbers allowed) board. Play begins with two counters in the outer row of each players' holes and two counter in each of the four holes on the right hand side of both players' inner row of holes. Player picks up contents of any hole containing two or more counters and sows them anti-clockwise. If the final counter of the sowing falls into an empty hole, the turn is over. If the last counter falls into an occupied hole, sowing continues by picking up the counters in that hole and continuing in the same direction. If the last counter falls into an occupied hole in the player's inner row, and the opponent's two holes opposite it are occupied, these are captured and sowing continues using these counters beginning at the next hole after the one which caused the capture. Play ends when one player cannot move; i.e. when they have only single counters in holes or all their counters have been captured. Each player has 12 holes. The player can sow from any hole with one or more seeds.
(game "Hus (Damara)" (players 2) (equipment {(mancalaBoard 4 12 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "24,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (regions "Outer" P1 (sites Bottom)) (regions "Outer" P2 (sites Top)) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 2 to:(union {(expand (intersection (sites Row 1) (sites Right)) steps:3 W) (expand (intersection (sites Row 2) (sites Left)) steps:3 E) (sites P1 "Outer") (sites P2 "Outer")}))) (play (move Select (from (if (is Prev Mover) (if (is Pending) (sites {(value Pending)}) (sites {(last To afterConsequence:True)})) (sites Mover "Home")) if:(> (count at:(from)) 0)) (then (sow "Track" owner:(mover) apply:(if (> (count at:(to)) 1) (if (and {(is In (to) (sites Mover "Inner")) (> (count at:(if (is Mover P1) (+ (to) 12) (- (to) 12))) 0) (> (count at:(if (is Mover P1) (+ (to) (* 12 2)) (- (to) (* 12 2)))) 0)}) (and {(fromTo (from (to)) (to (handSite Mover)) count:(count at:(to))) (fromTo (from (if (is Mover P1) (+ (to) 12) (- (to) 12))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 12) (- (to) 12)))) (fromTo (from (if (is Mover P1) (+ (to) (* 12 2)) (- (to) (* 12 2)))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) (* 12 2)) (- (to) (* 12 2))))) (if (> (count at:(trackSite Move from:(to) "Track" steps:1)) 1) (and (set Pending (trackSite Move from:(to) "Track" steps:1)) (moveAgain)))}) (moveAgain))))))) (end (if (no Moves Mover) (byScore {(score P1 (+ (count Cell at:(handSite P1)) (count in:(sites P1)))) (score P2 (+ (count Cell at:(handSite P2)) (count in:(sites P2))))}))))) 
4x16-22 board. Two counters in each player's outer row and the right half of the holes in the inner row. The opening move is stylized; each player must make one of the following moves on their first turn: Take counters from the hole that is two to the right of the center of the board in the outer row. Sow them to the right starting in the hole third from the center in the inner row; Take counters from the hole that is three to the right of the center of the board in the outer row. Sown them to the right starting from the hole second from the center in the inner row; Take counters from the hole next to the center of the board in the inner row. Sow them to the right; Take counters from the hole next to the left of the center of the board in the outer row. Sow them to the right starting from the hole next to the right of the center of the board. Players then sow from any of their holes in an anti-clockwise direction. If the last counter of a sowing lands in an empty hole, the turn ends. If the last counter falls into an occupied hole, the counters in that hole are picked up and sowing continues, unless the hole in the inner row on the opponent's side opposite the one the player last sowed into is occupied, in which case any counters in this hole and any in the opponent's opposite outer row hole are captured. The captured counters are then sown on the player's side of the board, starting with the hole following the one from which the capture was made. Sowing cannot occur from holes with single counters. The game ends when one player can no longer move. Each player has 16 holes on each row.
(game "Hus (Nama)" (players 2) (equipment {(mancalaBoard 4 16 store:None {(track "TrackCCW1" "0,E,N1,W" loop:True P1) (track "TrackCCW2" "32,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "TrackCCW1")) (regions "Home" P2 (sites Track "TrackCCW2")) (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top))) (regions "Outer" P1 (difference (sites Track "TrackCCW1") (sites P1 "Inner"))) (regions "Outer" P2 (difference (sites Track "TrackCCW2") (sites P2 "Inner"))) (regions "HalfRightInner" P1 (sites {24 25 26 27 28 29 30 31})) (regions "HalfRightInner" P2 (sites {32 33 34 35 36 37 38 39})) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 2 to:(union {(sites P1 "Outer") (sites P2 "Outer") (sites P1 "HalfRightInner") (sites P2 "HalfRightInner")}))) phases:{(phase "OpeningP1" P1 (play (or {(move Select (from (- (/ 16 2) 2)) (then (and (fromTo (from (last To)) (to (+ (/ 16 2) 1)) count:2) (sow (+ (/ 16 2) 1) count:2 "TrackCCW" owner:(mover))))) (move Select (from (+ (/ 16 2) 2)) (then (and (fromTo (from (last To)) (to (+ (+ 16 (/ 16 2)) 1))) (fromTo (from (last To)) (to (+ (+ 16 (/ 16 2)) 2)))))) (move Select (from (+ 16 (/ 16 2))) (then (and (fromTo (from (last To)) (to (+ (+ 16 (/ 16 2)) 1))) (fromTo (from (last To)) (to (+ (+ 16 (/ 16 2)) 2)))))) (move Select (from (- (/ 16 2) 1)) (then (sow "TrackCCW" owner:(mover))))})) (nextPhase Mover "Sowing")) (phase "OpeningP2" P2 (play (or {(move Select (from (+ (- (* 4 16) (/ 16 2)) 1)) (then (and (fromTo (from (last To)) (to (- (- (* 4 16) (/ 16 2)) 2)) count:2) (sow (- (- (* 4 16) (/ 16 2)) 2) count:2 "TrackCCW" owner:(mover))))) (move Select (from (- (- (* 4 16) (/ 16 2)) 3)) (then (and (fromTo (from (last To)) (to (- (- (* 3 16) (/ 16 2)) 2))) (fromTo (from (last To)) (to (- (- (* 3 16) (/ 16 2)) 3)))))) (move Select (from (- (- (* 3 16) (/ 16 2)) 1)) (then (and (fromTo (from (last To)) (to (- (- (* 3 16) (/ 16 2)) 2))) (fromTo (from (last To)) (to (- (- (* 3 16) (/ 16 2)) 3)))))) (move Select (from (- (* 4 16) (/ 16 2))) (then (sow "TrackCCW" owner:(mover))))})) (nextPhase Mover "Sowing")) (phase "Sowing" (play (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover "Home")) if:(< 1 (count at:(from)))) (then (sow "TrackCCW" owner:(mover) apply:(if (< 1 (count at:(to))) (if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 16) (- (to) 16))) (and {(fromTo (from (if (is Mover P1) (+ (to) 16) (- (to) 16))) (to (to)) count:(count at:(if (is Mover P1) (+ (to) 16) (- (to) 16)))) (if (is Occupied (if (is Mover P1) (+ (to) (* 16 2)) (- (to) (* 16 2)))) (and (fromTo (from (if (is Mover P1) (+ (to) (* 16 2)) (- (to) (* 16 2)))) (to (to)) count:(count at:(if (is Mover P1) (+ (to) (* 16 2)) (- (to) (* 16 2))))) (sow (to) count:(+ (count at:(if (is Mover P1) (+ (to) (* 16 3)) (- (to) (* 16 3)))) (count at:(if (is Mover P1) (+ (to) (* 16 2)) (- (to) (* 16 2))))) "TrackCCW" owner:(mover))) (sow (to) count:(count at:(if (is Mover P1) (+ (to) 16) (- (to) 16))) "TrackCCW" owner:(mover)))}) (and (moveAgain) (set Var "Replay" (to)))) (if (is Occupied (if (is Mover P1) (+ (to) (* 16 2)) (- (to) (* 16 2)))) (and {(fromTo (from (if (is Mover P1) (+ (to) (* 16 2)) (- (to) (* 16 2)))) (to (to)) count:(count at:(if (is Mover P1) (+ (to) (* 16 2)) (- (to) (* 16 2))))) (if (is Occupied (if (is Mover P1) (+ (to) (* 16 3)) (- (to) (* 16 3)))) (and (fromTo (from (if (is Mover P1) (+ (to) (* 16 3)) (- (to) (* 16 3)))) (to (to)) count:(count at:(if (is Mover P1) (+ (to) (* 16 3)) (- (to) (* 16 3))))) (sow (to) count:(+ (count at:(if (is Mover P1) (+ (to) (* 16 3)) (- (to) (* 16 3)))) (count at:(if (is Mover P1) (+ (to) (* 16 2)) (- (to) (* 16 2))))) "TrackCCW" owner:(mover))) (sow (to) count:(count at:(if (is Mover P1) (+ (to) (* 16 2)) (- (to) (* 16 2)))) "TrackCCW" owner:(mover)))}) (and (moveAgain) (set Var "Replay" (to)))))))))) (end (forEach NonMover if:(no Moves Player) (result Player Loss))))})) 
4x8 board. Two counters in each hole. Opening play: Players simultaneously arrange their counters in the following patter, beginning from the bottom left and proceeding anti-clockwise: 0, 6, 0, 0, 0, 0, 0, 17, 0, 3, 0, 3, 0, 3, 0, 0. Players then move alternately. The first three turns are made by sowing from the holes with three holes, proceeding in order from the one furthest to the left, sowing two in the next hole and one in the following. They then sow from the next hole to the right with three counters on the next turn in the same way. Main phase: Play begins from any hole on the player's side of the board with counters in it. Singletons cannot move. Sowing happens in an anti-clockwise direction. If the last counter lands in an empty hole, the turn is over. For capturing: Holes are in 'opposition' when one player has the front row hole occupied and the opponent has both of the holes opposite it occupied. If the last hole in a sowing is in opposition, the player takes the counters in both of the opponent's holes and places them in the empty hole from which the player lifted the counters. The player then sows the captured counters from this hole. Further captures in the sowing can occur in the same way. However, each player has two hole from which clockwise plays can be made: the leftmost hole in the outer row and the second from the left in the inner row. Clockwise moves can only be made from these holes if they immediately lead to a capture. When the captured counters are sown, starting from the same hole, they can also be sown clockwise if they lead to a capture. If they cannot lead to a capture, they are sown anti-clockwise. Another alternative the player has is that, if the player plays clockwise from one of these holes and therefore makes a capture, the captured counters may be placed in the hole and left there, and the player may play instead from the other hole from which clockwise captures are allowed in a clockwise direction, if it leads to a capture. The player may continue playing from this hole as above until the possibilities to move are exhausted, and then may move from any hole in an anti-clockwise direction. Multiple captures can only be made in a clockwise direction from these holes if it is made on the first sowing of the turn. Otherwise, only one clockwise capture can be made and sowing must proceed in an anti-clockwise direction. If the last counter lands on a hole that is occupied but not in opposition, these counters are picked up and sowing continues. Play ends when one player captures all the opponent's counters or one player cannot play. The player who cannot play loses. A player may also win by capturing the counters from both of the opponent's end holes in the inner row in a single turn.
(game "Ikibuguzo (Opening 1)" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "TrackCCW1" "0,E,N1,W" loop:True P1) (track "TrackCCW2" "16,E,N1,W" loop:True P2) (track "TrackCW1" "7,W,N1,E" loop:True P1) (track "TrackCW2" "24,E,S1,W" loop:True P2)}) (regions "Home" P1 (sites Track "TrackCCW1")) (regions "Home" P2 (sites Track "TrackCCW2")) (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top))) (map "FirstMove" {(pair P1 10) (pair P2 21)}) (map "SecondMove" {(pair P1 12) (pair P2 19)}) (map "ThirdMove" {(pair P1 14) (pair P2 17)}) (map "LeftMostOuter" {(pair P1 0) (pair P2 31)}) (map "SecondLeftInner" {(pair P1 9) (pair P2 22)}) (piece "Seed" Shared) (hand Each)}) (rules (start {(set Count 6 to:(sites {"G4" "B1"})) (set Count 17 to:(sites {"H1" "A4"})) (set Count 3 to:(sites {"G2" "E2" "C2" "B3" "D3" "F3"}))}) phases:{(phase "FirstMove" (play (move (from (mapEntry "FirstMove" Mover)) (to (trackSite Move from:(from) "TrackCCW" steps:1)) count:2 (then (fromTo (from (mapEntry "FirstMove" Mover)) (to (trackSite Move from:(from) "TrackCCW" steps:2)) count:1)))) (nextPhase Mover "SecondMove")) (phase "SecondMove" (play (move (from (mapEntry "SecondMove" Mover)) (to (trackSite Move from:(from) "TrackCCW" steps:1)) count:2 (then (fromTo (from (mapEntry "SecondMove" Mover)) (to (trackSite Move from:(from) "TrackCCW" steps:2)) count:1)))) (nextPhase Mover "ThirdMove")) (phase "ThirdMove" (play (move (from (mapEntry "ThirdMove" Mover)) (to (trackSite Move from:(from) "TrackCCW" steps:1)) count:2 (then (fromTo (from (mapEntry "ThirdMove" Mover)) (to (trackSite Move from:(from) "TrackCCW" steps:2)) count:1)))) (nextPhase Mover "MainPhase")) (phase "MainPhase" (play (or (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites {(mapEntry "LeftMostOuter" Mover) (mapEntry "SecondLeftInner" Mover)})) if:(and {(if (is Prev Mover) (< 0 (count at:(from))) (< 1 (count at:(from)))) (is In (from) (sites {(mapEntry "LeftMostOuter" Mover) (mapEntry "SecondLeftInner" Mover)})) (is In (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) (sites Mover "Inner")) (is Occupied (if (is Mover P1) (+ (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) 8) (- (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) 8))) (is Occupied (if (is Mover P1) (+ (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) (* 8 2)) (- (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) (* 8 2))))})) (then (sow "TrackCW" owner:(mover) apply:(if (< 1 (count at:(to))) (and (moveAgain) (if (and {(is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (is In (to) (sites Mover "Inner"))}) (and {(fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (set Var "Replay" (from))}) (set Var "Replay" (to)))))))) (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover)) if:(if (is Prev Mover) (< 0 (count at:(from))) (< 1 (count at:(from))))) (then (sow "TrackCCW" owner:(mover) apply:(if (< 1 (count at:(to))) (and (moveAgain) (if (and {(is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (is In (to) (sites Mover "Inner"))}) (and {(fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (set Var "Replay" (from))}) (set Var "Replay" (to)))))))))) (end (if (no Moves Next) (result Mover Win))))})) 
4x8 board. Two counters in each hole. Opening play: Players rearrange their counters so that there are four counters in each hole of their outer row. If they play with the second array, they take turns sowing from each of the holes with four counters, beginning with the rightmost hole, placing two in the first hole and one in each of the following. Main phase: Play begins from any hole on the player's side of the board with counters in it. Singletons cannot move. Sowing happens in an anti-clockwise direction. If the last counter lands in an empty hole, the turn is over. For capturing: Holes are in 'opposition' when one player has the front row hole occupied and the opponent has both of the holes opposite it occupied. If the last hole in a sowing is in opposition, the player takes the counters in both of the opponent's holes and places them in the empty hole from which the player lifted the counters. The player then sows the captured counters from this hole. Further captures in the sowing can occur in the same way. However, each player has two hole from which clockwise plays can be made: the leftmost hole in the outer row and the second from the left in the inner row. Clockwise moves can only be made from these holes if they immediately lead to a capture. When the captured counters are sown, starting from the same hole, they can also be sown clockwise if they lead to a capture. If they cannot lead to a capture, they are sown anti-clockwise. Another alternative the player has is that, if the player plays clockwise from one of these holes and therefore makes a capture, the captured counters may be placed in the hole and left there, and the player may play instead from the other hole from which clockwise captures are allowed in a clockwise direction, if it leads to a capture. The player may continue playing from this hole as above until the possibilities to move are exhausted, and then may move from any hole in an anti-clockwise direction. Multiple captures can only be made in a clockwise direction from these holes if it is made on the first sowing of the turn. Otherwise, only one clockwise capture can be made and sowing must proceed in an anti-clockwise direction. If the last counter lands on a hole that is occupied but not in opposition, these counters are picked up and sowing continues. Play ends when one player captures all the opponent's counters or one player cannot play. The player who cannot play loses. A player may also win by capturing the counters from both of the opponent's end holes in the inner row in a single turn. 
(game "Ikibuguzo (Opening 2)" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "TrackCCW1" "0,E,N1,W" loop:True P1) (track "TrackCCW2" "16,E,N1,W" loop:True P2) (track "TrackCW1" "7,W,N1,E" loop:True P1) (track "TrackCW2" "24,E,S1,W" loop:True P2)}) (regions "Home" P1 (sites Track "TrackCCW1")) (regions "Home" P2 (sites Track "TrackCCW2")) (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top))) (map "RightMost" {(pair P1 7) (pair P2 24)}) (map "LeftMostOuter" {(pair P1 0) (pair P2 31)}) (map "SecondLeftInner" {(pair P1 9) (pair P2 22)}) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 4 to:(union (sites Bottom) (sites Top)))) phases:{(phase "FirstMove" (play (move (from (trackSite FirstSite Mover "TrackCW" from:(if (= (value Player Mover) -1) (mapEntry "RightMost" Mover) (value Player Mover)) if:(= 4 (count at:(to))))) (to (trackSite Move from:(from) "TrackCCW" steps:1)) count:2 (then (and {(fromTo (from (last From)) (to (trackSite Move from:(last From) "TrackCCW" steps:2)) count:1) (fromTo (from (last From)) (to (trackSite Move from:(last From) "TrackCCW" steps:3)) count:1) (set Value Mover (last From))})))) (nextPhase Mover (= (last From) (mapEntry "LeftMostOuter" Mover)) "MainPhase")) (phase "MainPhase" (play (or (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites {(mapEntry "LeftMostOuter" Mover) (mapEntry "SecondLeftInner" Mover)})) if:(and {(if (is Prev Mover) (< 0 (count at:(from))) (< 1 (count at:(from)))) (is In (from) (sites {(mapEntry "LeftMostOuter" Mover) (mapEntry "SecondLeftInner" Mover)})) (is In (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) (sites Mover "Inner")) (is Occupied (if (is Mover P1) (+ (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) 8) (- (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) 8))) (is Occupied (if (is Mover P1) (+ (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) (* 8 2)) (- (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) (* 8 2))))})) (then (sow "TrackCW" owner:(mover) apply:(if (< 1 (count at:(to))) (and (moveAgain) (if (and {(is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (is In (to) (sites Mover "Inner"))}) (and {(fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (set Var "Replay" (from))}) (set Var "Replay" (to)))))))) (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover)) if:(if (is Prev Mover) (< 0 (count at:(from))) (< 1 (count at:(from))))) (then (sow "TrackCCW" owner:(mover) apply:(if (< 1 (count at:(to))) (and (moveAgain) (if (and {(is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (is In (to) (sites Mover "Inner"))}) (and {(fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (set Var "Replay" (from))}) (set Var "Replay" (to)))))))))) (end (if (no Moves Next) (result Mover Win))))})) 
4x8 board. Play begins with two counters in each hole. Opening moves: Players place all of the counters in the outer row into their rightmost hole. They then take one counter from each of the holes in the inner row and redistribute them into the outer row, one in each hole. Then, each player sows counters in an anti-clockwise direction beginning from the rightmost hole in the inner row, proceeding, picking up the contents of holes when the last counter falls into an occupied hole and continuing sowing. However, the final counter that would fall into the rightmost hole in the outer row (which should now contain 17 counters) is not placed there, but rather on the second to right hole in the inner row, which should now contain one counter. Initial phase: In the initial phase, the rightmost hole in the inner and outer row for each player are out of play. All sowing and capturing only occurs on the remaining holes. Sowing occurs in an anti-clockwise direction. When the final counter of a sowing lands in an empty hole, the turn ends. When it falls into an occupied hole in the player's inner row the contents of the opponent's opposite holes in the inner and outer row are captured. These are then sown in the player's holes beginning with the hole from where the previous sowing began. If the final counter of a sowing falls into an occupied hole that cannot make a capture, then the counters in this hole are picked up and sowing continues. Second phase: The initial phase ends when a player plays from the rightmost hole in the outer row. This can be by necessity or by choice. Once this happens, that player must play in all of their holes. The opponent may remain in the initial phase after this point until they play from their rightmost hole. The same sowing and capturing rules as before. Play continues until one player can no longer move.
(game "Isolo" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "TrackCCW1" "0,E,N1,W" loop:True P1) (track "TrackCCW2" "16,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "TrackCCW1")) (regions "Home" P2 (sites Track "TrackCCW2")) (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top))) (regions "Outer" P1 (sites Bottom)) (regions "Outer" P2 (sites Top)) (piece "Seed" Shared) (hand Each) (map "RightmostOuter" {(pair P1 7) (pair P2 24)}) (map "RightmostInner" {(pair P1 15) (pair P2 16)}) (map "SecondRightmostInner" {(pair P1 14) (pair P2 17)})}) (rules (start (set Count 2 to:(union (sites P1 "Home") (sites P2 "Home")))) phases:{(phase "Opening1" (play (forEach Site (difference (sites Mover "Outer") (mapEntry "RightmostOuter" Mover)) (if (is Occupied (site)) (move (from (site)) (to (mapEntry "RightmostOuter" Mover)) count:(count at:(site)))))) (nextPhase Mover (all Sites (difference (sites Mover "Outer") (mapEntry "RightmostOuter" Mover)) if:(is Empty (site))) "Opening2")) (phase "Opening2" (play (forEach Site (sites Mover "Inner") (if (= 2 (count at:(site))) (move (from (site)) (to (if (is Mover P1) (- (site) 8) (+ (site) 8))) count:1)))) (nextPhase Mover (all Sites (sites Mover "Inner") if:(= (count at:(site)) 1)) "Opening3")) (phase "Opening3" (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites {(mapEntry "RightmostInner" Mover)}))) (then (sow "TrackCCW" owner:(mover) apply:(if (!= (to) (mapEntry "RightmostOuter" Mover)) (moveAgain) (fromTo (from (to)) (to (mapEntry "SecondRightmostInner" Mover)) count:1)))))) (nextPhase Mover (not (is Next Mover)) "InitialSowing")) (phase "InitialSowing" (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(is Occupied (from))) (then (sow "TrackCCW" owner:(mover) apply:(if (< 1 (count at:(to))) (if (is In (to) (sites Mover "Inner")) (if (or (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (and {(if (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))))) (if (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))))) (sow (last From) count:(+ (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) "TrackCCW" owner:(mover) skipIf:(is In (to) (sites {(mapEntry "RightmostOuter" Mover) (mapEntry "RightmostInner" Mover)})))}) (moveAgain)) (moveAgain))) skipIf:(is In (to) (sites {(mapEntry "RightmostOuter" Mover) (mapEntry "RightmostInner" Mover)})))))) (nextPhase Mover (is In (last From) (sites {(mapEntry "RightmostOuter" Mover) (mapEntry "RightmostInner" Mover)})) "InitialSowing")) (phase "Sowing" (play (move Select (from (sites Mover "Home") if:(is Occupied (from))) (then (sow "TrackCCW" owner:(mover) apply:(if (< 1 (count at:(to))) (if (is In (to) (sites Mover "Inner")) (if (or (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (and {(if (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))))) (if (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))))) (sow (last From) count:(+ (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) "TrackCCW" owner:(mover))}) (moveAgain)) (moveAgain))))))))} (end (forEach Player if:(no Moves Player) (result Player Loss))))) 
4x8 board. Two counters in each hole. Each player may sow in either direction on their first move, but must continue in the same direction for the remainder of the game. When the final counter of a sowing lands in an occupied hole, the counters in that hole are picked up and sowing continues. If the final hole of a sowing is in the inner row, regardless of whether it is occupied or empty, the player then captures the counters in both of the opponent's holes opposite it, and continues sowing with these counters as well as the ones in the final hole of sowing. Captures cannot be made when the final hole of a sowing was empty, and the opponent's opposite holes have only a single counter. When the final counter lands in an empty hole, the turn is over. The player who captures all the counters wins.
(game "Katra Boaoaka" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "TrackCCW1" "0,E,N1,W" loop:True P1) (track "TrackCCW2" "16,E,N1,W" loop:True P2) (track "TrackCW1" "7,W,N1,E" loop:True P1) (track "TrackCW2" "24,E,S1,W" loop:True P2)}) (regions "Home" P1 (sites Track "TrackCCW1")) (regions "Home" P2 (sites Track "TrackCCW2")) (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top))) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 2 to:(union (sites P1 "Home") (sites P2 "Home")))) (play (or (if (!= (value Player Mover) 2) (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover "Home")) if:(> (count at:(from)) 0)) (then (and (sow "TrackCCW" owner:(mover) apply:(and (if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to)))) (if (is In (to) (sites Mover "Inner")) (if (not (and {(= 1 (count at:(to))) (= 1 (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (= 1 (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))))})) (if (or (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (and {(fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (to)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (to)) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (if (= 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to))))})))))) (if (!= (value Player Mover) 1) (set Value Mover 1)))))) (if (!= (value Player Mover) 1) (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover "Home")) if:(> (count at:(from)) 0)) (then (and (sow "TrackCW" owner:(mover) apply:(and (if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to)))) (if (is In (to) (sites Mover "Inner")) (if (not (and {(= 1 (count at:(to))) (= 1 (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (= 1 (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))))})) (if (or (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (and {(fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (to)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (to)) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (if (= 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to))))})))))) (if (!= (value Player Mover) 2) (set Value Mover 2)))))))) (end (forEach NonMover if:(no Moves Player) (result Player Loss))))) 
4x6, 8, or 10 holes. Eight is most common. Two counters in each hole. Sowing begins from any hole on the player's side, in either direction, but the direction chosen on the first turn must be maintained throughout the game. If the final counter lands in an empty hole, the turn ends. If the final counter lands in the outer row in an occupied hole, these are picked up and sowing continues. If the final counter lands in an occupied hole in the inner row, and the opponent's inner row hole opposite contains more than one counter, these are captured and the sowing continues from the hole from which the capture was made using the captured counters and the final counter from the sowing that caused the capture. If the opponent has no counters in any of their inner row holes, the counters in their outer row holes can be captured, in the same manner. Evidence Map Each player has 8 holes on each row.
(game "Katra" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "TrackCCW1" "0,E,N1,W" loop:True P1) (track "TrackCCW2" "16,E,N1,W" loop:True P2) (track "TrackCW1" "7,W,N1,E" loop:True P1) (track "TrackCW2" "24,E,S1,W" loop:True P2)}) (regions "Home" P1 (sites Track "TrackCCW1")) (regions "Home" P2 (sites Track "TrackCCW2")) (regions "Outer" P1 (sites Bottom)) (regions "Outer" P2 (sites Top)) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 2 to:(union (sites P1 "Home") (sites P2 "Home")))) (play (or (if (!= (value Player Mover) 2) (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover "Home")) if:(> (count at:(from)) 0)) (then (and (sow "TrackCCW" owner:(mover) apply:(if (< 1 (count at:(to))) (if (is In (to) (sites Mover "Outer")) (and (moveAgain) (set Var "Replay" (to))) (if (< 1 (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (and {(fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (to)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (moveAgain) (set Var "Replay" (to))}) (if (< 1 (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (and {(fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (to)) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (moveAgain) (set Var "Replay" (to))})))))) (if (!= (value Player Mover) 1) (set Value Mover 1)))))) (if (!= (value Player Mover) 1) (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover "Home")) if:(> (count at:(from)) 0)) (then (and (sow "TrackCW" owner:(mover) apply:(if (< 1 (count at:(to))) (if (is In (to) (sites Mover "Outer")) (and (moveAgain) (set Var "Replay" (to))) (if (< 1 (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (and {(fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (to)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (moveAgain) (set Var "Replay" (to))}) (if (< 1 (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (and {(fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (to)) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (moveAgain) (set Var "Replay" (to))})))))) (if (!= (value Player Mover) 2) (set Value Mover 2)))))))) (end (forEach NonMover if:(no Moves Player) (result Player Loss))))) 
4x8 board. Four counters in each of the holes in each player's inner row. Sowing occurs in an anti-clockwise direction, with the first counter being sown into the hole from which the counters were picked up. When the final counter lands in an empty hole, the player's turn ends. When the final counter lands in an occupied hole in the inner row, the player captures the counters in the opponent's opposite inner row hole, and continues sowing with these counters and the counters in the hole where the final counter was dropped.. When the final counter lands in an occupied hole but a capture is not possible, these counters are picked up and sowing continues. Play continues until one player can no longer play, and the opponent wins.
(game "Kisolo (Lali)" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "16,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 4 to:(union (sites P1 "Inner") (sites P2 "Inner")))) (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(< 1 (count at:(from)))) (then (sow "Track" owner:(mover) apply:(if (> (count at:(to)) 1) (and (moveAgain) (if (and (!= (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))) 0) (is In (to) (sites Mover "Inner"))) (fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (to)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))))))) origin:True)))) (end (if (and (!= (next) (mover)) (no Moves Next)) (result Mover Win))))) 
4x7 board. Play begins with three counters in each hole of the outer rows. Players pick up all of the counters in one hole and sow them anti-clockwise. Holes with single counters can be chosen for sowing. When the final counter is sown, the counters in the following hole are picked up and sowing continues with those counters. If this hole is empty, play ends. Captures are made from the player's inner row at the beginning of a turn or a subsequent sowing within a turn. Counters are captured when a player's inner row has occupied holes. Counters in the opponent's holes opposite a player's occupied holes are captured: either from both of the opponent's rows or only the inner row if the corresponding hole in the outer row is empty. If the inner row is empty but the outer row is occupied, there is no capture, and when both rows are occupied they both must be captured. Captures are also made on a subsequent sowing within a turn, in the same manner as above but from the hole the next sowing begins, i.e., the one following the hole in which the last seed of the previous sowing is made. Captured counters are placed in the player's outer row opposite the hole from which the capture was made. Game is won when the opponent's outer row is emptied. At the initial state 3 seeds are in each outer hole.
(game "Kisolo" (players 2) (equipment {(mancalaBoard 4 7 store:None {(track "TrackCCW1" "0,E,N1,W" loop:True P1) (track "TrackCCW2" "14,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "TrackCCW1")) (regions "Home" P2 (sites Track "TrackCCW2")) (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top))) (regions "Outer" P1 (difference (sites Track "TrackCCW1") (sites P1 "Inner"))) (regions "Outer" P2 (difference (sites Track "TrackCCW2") (sites P2 "Inner"))) (piece "Seed" Shared)}) (rules (start {(set Count 3 to:(union (sites P1 "Outer") (sites P2 "Outer")))}) (play (if (and (or (= 0 (count MovesThisTurn)) (is In 1 (sites Pending))) (!= 0 (count Sites in:(forEach (difference (sites Mover "Inner") (sites Empty)) if:(is Occupied (if (is Mover P1) (+ (site) 7) (- (site) 7))))))) (move Select (from (forEach (difference (sites Mover "Inner") (sites Empty)) if:(is Occupied (if (is Mover P1) (+ (site) 7) (- (site) 7))))) (then (and {(fromTo (from (if (is Mover P1) (+ (last To) 7) (- (last To) 7))) (to (if (is Mover P1) (- (last To) 7) (+ (last To) 7)))) (if (is Occupied (if (is Mover P1) (+ (last To) (* 7 2)) (- (last To) (* 7 2)))) (fromTo (from (if (is Mover P1) (+ (last To) (* 7 2)) (- (last To) (* 7 2)))) (to (if (is Mover P1) (- (last To) 7) (+ (last To) 7))))) (moveAgain)} (then (if (!= 0 (count Sites in:(forEach (difference (sites Mover "Inner") (sites Empty)) if:(is Occupied (if (is Mover P1) (+ (site) 7) (- (site) 7)))))) (set Pending 1)))))) (move Select (from (if (and (is In 2 (sites Pending)) (is Prev Mover)) (sites {(trackSite Move from:(last To afterConsequence:True) "TrackCCW" steps:1)}) (sites Mover "Home")) if:(> (count at:(from)) 0)) (then (sow "TrackCCW" owner:(mover) apply:(if (is Occupied (trackSite Move from:(to) "TrackCCW" steps:1)) (and {(if (and (is In (trackSite Move from:(to) "TrackCCW" steps:1) (sites Mover "Inner")) (is Occupied (if (is Mover P1) (+ (trackSite Move from:(to) "TrackCCW" steps:1) 7) (- (trackSite Move from:(to) "TrackCCW" steps:1) 7)))) (and (fromTo (from (if (is Mover P1) (+ (trackSite Move from:(to) "TrackCCW" steps:1) 7) (- (trackSite Move from:(to) "TrackCCW" steps:1) 7))) (to (if (is Mover P1) (- (trackSite Move from:(to) "TrackCCW" steps:1) 7) (+ (trackSite Move from:(to) "TrackCCW" steps:1) 7)))) (if (is Occupied (if (is Mover P1) (+ (trackSite Move from:(to) "TrackCCW" steps:1) (* 7 2)) (- (trackSite Move from:(to) "TrackCCW" steps:1) (* 7 2)))) (fromTo (from (if (is Mover P1) (+ (trackSite Move from:(to) "TrackCCW" steps:1) (* 7 2)) (- (trackSite Move from:(to) "TrackCCW" steps:1) (* 7 2)))) (to (if (is Mover P1) (- (trackSite Move from:(to) "TrackCCW" steps:1) 7) (+ (trackSite Move from:(to) "TrackCCW" steps:1) 7))))))) (moveAgain) (set Pending 2)}))))))) (end (forEach Player if:(all Sites (sites Player "Outer") if:(= 0 (count at:(site)))) (result Player Loss))))) 
4x8 board. Four pieces in each of the holes in the inner two rows. Sowing occurs in an anti-clockwise direction. Single counters cannot be sown. When the final counter of a sowing falls into an occupied hole, these counters are picked up and the sowing continues. If this hole is in the player's inner row, the counters in the opponent's opposite holes in both rows are captured. Both the inner and outer opposite holes must contain counters for a capture to occur. Play continues with the captured counters, and the player sows these beginning with the next hole after the last one on the player's side from which they picked up holes. Captures cannot be made on the first move. Clockwise sowing can begin from the following holes only if it will allow a capture to occur: the rightmost and leftmost holes of the outer row, the second from the right and second from the left holes in the inner row. Direction can be changed in the middle of a turn if the final counter lands in one of these holes and a clockwise move will result in a capture. When no capture is available, the player must resume in an anti-clockwise direction. When the final counter falls into an empty hole, the turn ends. 
(game "Kubuguza" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "TrackCCW1" "0,E,N1,W" loop:True P1) (track "TrackCCW2" "16,E,N1,W" loop:True P2) (track "TrackCW1" "7,W,N1,E" loop:True P1) (track "TrackCW2" "23,W,N1,E" loop:True P2)}) (regions "Home" P1 (sites Track "TrackCCW1")) (regions "Home" P2 (sites Track "TrackCCW2")) (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top))) (regions "HolesCW" P1 (sites {15 8 1 6})) (regions "HolesCW" P2 (sites {16 23 25 30})) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 3 to:(union (sites P1 "Inner") (sites P2 "Inner")))) (play (or (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover "Home")) if:(> (count at:(from)) 1)) (then (sow "TrackCCW" owner:(mover) apply:(if (< 1 (count at:(to))) (and (if (and {(> (count Turns) 2) (is In (to) (sites Mover "Inner")) (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8)))}) (and {(fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (set Var "Replay" (last From))}) (set Var "Replay" (to))) (moveAgain)))))) (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover "HolesCW")) if:(and {(> (count at:(from)) 1) (is In (from) (sites Mover "HolesCW")) (if (is In (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) (sites Mover "Inner")) (and (is Occupied (if (is Mover P1) (+ (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) (* 8 2)) (- (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) (* 8 2)))) (is Occupied (if (is Mover P1) (+ (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) 8) (- (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) 8)))) False)})) (then (sow "TrackCW" owner:(mover) apply:(if (< 1 (count at:(to))) (and (if (and {(> (count Turns) 2) (is In (to) (sites Mover "Inner")) (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8)))}) (and {(fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (set Var "Replay" (last From))}) (set Var "Replay" (to))) (moveAgain)))))))) (end (forEach Player if:(no Moves Player) (result Player Loss))))) 
4x8 board. Two counters in each hole. Before play, players may arrange their counters as they see fit in their holes. Players alternate turns sowing the counters from one of their holes in an anticlockwise direction. When the final counter lands in an empty hole, their turn is over. If the final counter lands in an occupied hole, the contents of the two opposite hole in the opponent's rows are captured. If both do not have counters, then the player picks up the counters from the hole the last counter fell into and continues sowing. The player who captures all of the opponent's counters wins.
(game "Lisolo" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "16,E,N1,W" loop:True P2)}) (piece "Seed" Shared) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top)))}) (rules (start (set Count 2 to:(union (sites P1 "Home") (sites P2 "Home")))) phases:{(phase "Opening" (play (or (forEach Site (sites Mover "Home") (if (is Occupied (site)) (move (from (site)) (to (forEach (sites Mover "Home") if:(!= (to) (site))))))) (move Pass))) (nextPhase (all Passed) "Sowing")) (phase "Sowing" (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover)) if:(> (count at:(from)) 0)) (then (sow "Track" owner:(mover) apply:(if (> (count at:(to)) 1) (if (not (is In (to) (sites Mover "Inner"))) (moveAgain) (if (and (= 0 (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (= 0 (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))))) (moveAgain) (and (if (!= 0 (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (remove (if (is Mover P1) (+ (to) 8) (- (to) 8)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))))) (if (!= 0 (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (remove (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))))))))))))))} (end (forEach Player if:(= 0 (count in:(sites Player "Home"))) (result Player Loss))))) 
4x8 board. The counters begin in the following arrangement, starting from a player's left most hole in the outer row and proceeding anticlockwise: 0,0,1,0,0,1,6,0,8,0,1,0,0,1,6,8. To start, players may not sow into or sow from the leftmost and rightmost holes in both of their rows. When it is no longer possible for the player to make a legal move using only these twelve holes, they may then play using all of the holes. The opponent must continue using only twelve holes until they also cannot make a legal move with them. Sowing proceeds in an anti-clockwise direction. When the final counter falls into an occupied hole in the player's inner row and both of the opposite holes on the opponent's side of the board are occupied, the counters in the opposite holes are captured and sown beginning in the first hole that was sown into to begin the sowing that caused the capture. When the final counter falls into an occupied hole and a capture is not possible, the contents of the hole are picked up and sowing continues. When the final counter lands in an empty hole, the turn ends. Players cannot sow from a hole containing a single counter. The player who captures all of their opponent's counters wins. 
(game "Lobudok" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "16,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (regions "SideHoles" P1 (intersection (sites Track "Track1") (union (sites Left) (sites Right)))) (regions "SideHoles" P2 (intersection (sites Track "Track2") (union (sites Right) (sites Left)))) (piece "Seed" Shared) (hand Each)}) (rules (start {(set Count 1 to:(sites {2 5 13 10 29 26 18 21})) (set Count 8 to:(sites {15 16 8 23})) (set Count 6 to:(sites {6 9 22 25}))}) (play (or (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (difference (sites Mover "Home") (sites Mover "SideHoles"))) if:(> (count at:(from)) 1)) (then (sow "Track" owner:(mover) apply:(if (and {(is In (to) (sites Mover "Inner")) (< 1 (count at:(to))) (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8)))}) (and {(fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (sow (last From) count:(+ (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))) (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) "Track" owner:(mover) skipIf:(and (!= 1 (value Player Mover)) (is In (to) (sites "SideHoles"))))}) (if (< 1 (count at:(to))) (moveAgain))) skipIf:(and (!= 1 (value Player Mover)) (is In (to) (sites "SideHoles")))))) (if (if (= 1 (value Player Mover)) True (all Sites (difference (sites Mover "Home") (sites Mover "SideHoles")) if:(<= (count at:(site)) 1))) (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "SideHoles")) if:(> (count at:(from)) 1)) (then (and (sow "Track" owner:(mover) apply:(if (and {(is In (to) (sites Mover "Inner")) (< 1 (count at:(to))) (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8)))}) (and {(fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (sow (last From) count:(+ (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))) (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) "Track" owner:(mover))}) (if (< 1 (count at:(to))) (moveAgain)))) (if (= 0 (value Player Mover)) (set Value Mover 1)))))))) (end (forEach Player if:(no Moves Player) (result Player Loss))))) 
4x10 board. Forty counters in total. Play begins with one counter in each hole. One player then rearranges these counters however they like, as long as they remain on their side of the board and they remain on the board. They can arrange it so that they capture counters from the opponent's side according to the capture rules. The other player then does the same. Play begins with a player picking up counters from one of the holes with more than one on their side. Counters are sown in an anti-clockwise direction. When the last counter lands in an occupied hole, these counters are picked up and sowing continues until the last counter falls in an empty hole. When the last counter falls into an empty hole, either the turn ends or the player captures. Captures are only made from the inner row; if the corresponding hole in the opponent's inner row holds counters, these are captured; if there are also counters in the corresponding hole in the opponent's outer row, these are also captured. Play continues until one player has nothing left or one player has only single counters in their holes. If the player has no counters left, they have lost. If only single counters remain in a player's holes, they may now move single counters, but only into empty holes. Captures are made in the same way as before.
(game "Makonn" (players 2) (equipment {(mancalaBoard 4 10 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "20,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (piece "Seed" Shared)}) (rules (start (set Count 1 to:(union (sites P1 "Home") (sites P2 "Home")))) phases:{(phase "Rearrangement" (play (or (move (from (sites Mover "Home") if:(is Occupied (from))) (to (sites Mover "Home") if:(!= (from) (to))) (then (and (if (and {(!= 1 (value Player Mover)) (is In (last To) (sites Mover "Inner")) (= 1 (count at:(last To)))}) (if (is Occupied (if (is Mover P1) (+ (last To) 10) (- (last To) 10))) (and {(set Value Mover 1) (remove (if (is Mover P1) (+ (last To) 10) (- (last To) 10))) (if (is Occupied (if (is Mover P1) (+ (last To) (* 10 2)) (- (last To) (* 10 2)))) (remove (if (is Mover P1) (+ (last To) (* 10 2)) (- (last To) (* 10 2)))))}))) (moveAgain)))) (move Pass))) (nextPhase Mover (was Pass) "Sowing")) (phase "Sowing" (play (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover "Home")) if:(if (is Prev Mover) True (if (all Sites (sites Mover "Home") if:(>= 1 (count at:(site)))) (is Occupied (from)) (< 1 (count at:(from)))))) (then (sow "Track" owner:(mover) apply:(if (< 1 (count at:(to))) (and (set Var "Replay" (to)) (moveAgain)) (if (is Occupied (if (is Mover P1) (+ (to) 10) (- (to) 10))) (and (remove (if (is Mover P1) (+ (to) 10) (- (to) 10))) (if (is Occupied (if (is Mover P1) (+ (to) (* 10 2)) (- (to) (* 10 2)))) (remove (if (is Mover P1) (+ (to) (* 10 2)) (- (to) (* 10 2)))))))))))))} (end (if (all Sites (sites Next "Home") if:(= 0 (count at:(site)))) (result Next Loss))))) 
4x8 board. Two counters in each hole. Play begins with each player taking the two counters in the leftmost hole of either the inner or outer row and placing them both in the following hole in an anti-clockwise direction, and continuing with the two counters in the next hole, until there is an alternating pattern of holes with four counters followed by empty holes in all of the player's holes. On the next turn, the player sows from one of the holes on the end of one of their rows. Sowing occurs in an anti-clockwise direction. After this turn, sowing can be from any hole on the player's side of the board. Single counters cannot be sown. When the final counter falls into an occupied hole, the player picks up these counters and continues to sow. When the final counter is supposed to fall into an empty hole, it is not placed there but placed in the next hole. When the final counter falls into an occupied hole in the inner row, any counters in the opponent's two holes opposite are captured. These are then sown on the player's side of the board, beginning with the first occupied hole immediately after an empty hole before the hole from which the capture was made. Play continues until one player can no longer play, and the opponent wins.
(game "Mangola" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "TrackCCW1" "0,E,N1,W" loop:True P1) (track "TrackCCW2" "16,E,N1,W" loop:True P2) (track "TrackCW1" "7,W,N1,E" loop:True P1) (track "TrackCW2" "23,W,N1,E" loop:True P2)}) (regions "Home" P1 (sites Track "TrackCCW1")) (regions "Home" P2 (sites Track "TrackCCW2")) (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top))) (regions "LeftMost" P1 (intersection (sites Left) (sites Track "TrackCCW1"))) (regions "LeftMost" P2 (intersection (sites Right) (sites Track "TrackCCW2"))) (regions "EndHoles" P1 (intersection (union (sites Left) (sites Right)) (sites Track "TrackCCW1"))) (regions "EndHoles" P2 (intersection (union (sites Left) (sites Right)) (sites Track "TrackCCW2"))) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 2 to:(union (sites P1 "Home") (sites P2 "Home")))) phases:{(phase "Opening1" (play (move Select (from (if (is Prev Mover) (sites {(trackSite Move from:(last To afterConsequence:True) "TrackCCW" steps:1)}) (sites Mover "LeftMost")) if:(> (count at:(from)) 0)) (then (sow numPerHole:2 "TrackCCW" owner:(mover) apply:(if (is Occupied (trackSite Move from:(to) "TrackCCW" steps:1)) (moveAgain)))))) (nextPhase Mover (not (is Next Mover)) "Opening2")) (phase "Opening2" (play (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover "EndHoles")) if:(> (count at:(from)) 1)) (then (sow "TrackCCW" owner:(mover) apply:(if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (if (and {(is In (to) (sites Mover "Inner")) (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8)))}) (and {(fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (trackSite Move from:(trackSite FirstSite Mover "TrackCW" from:(to) if:(is Empty (to))) "TrackCCW" steps:1)) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (trackSite Move from:(trackSite FirstSite Mover "TrackCW" from:(to) if:(is Empty (to))) "TrackCCW" steps:1)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (sow (trackSite Move from:(trackSite FirstSite Mover "TrackCW" from:(to) if:(is Empty (to))) "TrackCCW" steps:1) count:(+ (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))) (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) "TrackCCW" owner:(mover))}))}) (fromTo (from (to)) (to (trackSite Move from:(to) "TrackCCW" steps:1)) count:1)))))) (nextPhase Mover (not (is Next Mover)) "Sowing")) (phase "Sowing" (play (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover "Home")) if:(> (count at:(from)) 1)) (then (sow "TrackCCW" owner:(mover) apply:(if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (if (and {(is In (to) (sites Mover "Inner")) (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8)))}) (and {(fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (trackSite Move from:(trackSite FirstSite Mover "TrackCW" from:(to) if:(is Empty (to))) "TrackCCW" steps:1)) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (trackSite Move from:(trackSite FirstSite Mover "TrackCW" from:(to) if:(is Empty (to))) "TrackCCW" steps:1)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (sow (trackSite Move from:(trackSite FirstSite Mover "TrackCW" from:(to) if:(is Empty (to))) "TrackCCW" steps:1) count:(+ (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))) (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) "TrackCCW" owner:(mover))}))}) (fromTo (from (to)) (to (trackSite Move from:(to) "TrackCCW" steps:1)) count:1)))))))} (end (forEach Player if:(no Moves Player) (result Player Loss))))) 
4x6-28 board; 16-20 is most common, only even numbers of holes. Two counters in each hole except the leftmost on the inner row, which is left empty, and the one to its right which contains one counter. Players sow by picking up the counters in any of their holes and sowing them in an anti-clockwise direction. Sowing continues when the last counter falls into an occupied hole by picking up the counters in that hole and continuing in the same direction. When the final counter lands in an empty hole in the inner row, the counters in the opponent's hole opposite in the inner row are captured; if there are also counters in the opponent's outer row opposite, these are also captured. The player is also entitled to capture counters in any other hole on the opponent's side. The turn ends with a capture and the opponent's turn begins. Play always begins with a stylized move, where the counters are taken from the third hole from the left in the inner row, sowing and making captures as described above. Players may not sow single counters unless there are no holes on their side containing multiple counters. Play ends when one player has captured all of their opponent's counters. Each player has 16 holes per row.
(game "Mefuvha" (players 2) (equipment {(mancalaBoard 4 16 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "32,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (piece "Seed" Shared) (hand Each)}) (rules (start {(set Count 2 to:(difference (union (sites P1 "Home") (sites P2 "Home")) (union (expand (intersection (sites Row 1) (sites Left)) steps:1 E) (expand (intersection (sites Row 2) (sites Right)) steps:1 W)))) (set Count 1 to:(union (difference (expand (intersection (sites Row 1) (sites Left)) steps:1 E) (sites Left)) (difference (expand (intersection (sites Row 2) (sites Right)) steps:1 W) (sites Right))))}) (play (if (and (is Pending) (is Prev Mover)) (move Select (from (sites Next "Home") if:(> (count at:(from)) 0)) (then (fromTo (from (last From)) (to (handSite Mover)) count:(count at:(last From))))) (priority (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (if (< (count Turns) 3) (if (is Mover P1) (difference (expand (intersection (sites Row 1) (sites Left)) steps:2 E) (expand (intersection (sites Row 1) (sites Left)) steps:1 E)) (difference (expand (intersection (sites Row 2) (sites Right)) steps:2 W) (expand (intersection (sites Row 2) (sites Right)) steps:1 W))) (sites Mover "Home"))) if:(> (count at:(from)) 1)) (then (sow "Track" owner:(mover) apply:(if (> (count at:(to)) 1) (moveAgain) (if (is In (to) (sites Mover "Inner")) (and {(fromTo (from (to)) (to (handSite Mover)) count:(count at:(to))) (if (> (count at:(if (is Mover P1) (+ (to) 16) (- (to) 16))) 0) (fromTo (from (if (is Mover P1) (+ (to) 16) (- (to) 16))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 16) (- (to) 16))))) (if (> (count at:(if (is Mover P1) (+ (to) (* 16 2)) (- (to) (* 16 2)))) 0) (fromTo (from (if (is Mover P1) (+ (to) (* 16 2)) (- (to) (* 16 2)))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) (* 16 2)) (- (to) (* 16 2)))))) (set Pending) (moveAgain)})))))) (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(= (count at:(from)) 1)) (then (sow "Track" owner:(mover) apply:(if (> (count at:(to)) 1) (moveAgain) (if (is In (to) (sites Mover "Inner")) (and {(fromTo (from (to)) (to (handSite Mover)) count:(count at:(to))) (if (> (count at:(if (is Mover P1) (+ (to) 16) (- (to) 16))) 0) (fromTo (from (if (is Mover P1) (+ (to) 16) (- (to) 16))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 16) (- (to) 16))))) (if (> (count at:(if (is Mover P1) (+ (to) (* 16 2)) (- (to) (* 16 2)))) 0) (fromTo (from (if (is Mover P1) (+ (to) (* 16 2)) (- (to) (* 16 2)))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) (* 16 2)) (- (to) (* 16 2)))))) (set Pending) (moveAgain)}))))))))) (end (if (no Moves Mover) (byScore {(score P1 (+ (count Cell at:(handSite P1)) (count in:(sites P1 "Home")))) (score P2 (+ (count Cell at:(handSite P2)) (count in:(sites P2 "Home"))))}))))) 
4x6-21 board; 8 is most common, 12, 15, and 18 are also popular. Two counters in each hole in the players' outer rows. Two holes in each player's outer row are selected as misoro. Typically, the left two holes are chosen. At the beginning of the game, players choose whether to capture from one, two, or three extra holes. Sowing occurs in an anti-clockwise direction, only in the two rows belonging to the player. When the final counter lands in an occupied hole, these are picked up and sowing continues. If this final hole is one of the misoro, the player may choose to end their turn instead of continuing to sow. When the final counter lands in an empty hole in the inner row, any counters in the opposite hole in the opponent's inner row are captured. If there also are counters in the opposite hole in the opponent's outer row, these are also captured, but only if there was first a capture from the inner row hole. The player also captures the counters from the agreed-upon number of holes on the opponent's side of the board. Counters in misoro cannot be captured with one of these additional captures. Players cannot sow from a hole with a single counter unless there are no holes with multiple counters. Single counters can only be sown into an empty hole. Play continues until one player has captured all of the opponent's counters, thus winning the game. Players choose the misoro holes. 8 Holes per row. 3 extra captures.
(game "Misoro Tsoro (Additional Capture)" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "16,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (regions "Outer" P1 (sites Bottom)) (regions "Outer" P2 (sites Top)) (piece "Seed" Shared)}) (rules (start (set Count 2 to:(union (sites Top) (sites Bottom)))) phases:{(phase "Misoro" (play (move Select (from (forEach (sites Mover "Outer") if:(= 0 (state at:(site))))) (then (set State at:(last To) (mover))))) (nextPhase (= 4 (count Turns)) "Playing")) (phase "Playing" (play (if (< 0 (var "ExtraCapture")) (move Select (from (forEach (sites Next) if:(and (= 0 (state at:(site))) (< 0 (count at:(site)))))) (then (and {(if (< 1 (var "ExtraCapture")) (moveAgain)) (set Var "ExtraCapture" (- (var "ExtraCapture") 1)) (remove (last To)) (forEach Site (sites Board) (if (!= 0 (state at:(site))) (set State at:(site) (state at:(site)))))}))) (or (if (and (!= 0 (state at:(var))) (is Prev Mover)) (move Pass)) (move Select (from (if (is Prev Mover) (sites {(var)}) (sites Mover "Home")) if:(if (not (all Sites (forEach (sites Mover) if:(< 1 (count at:(site)))) if:(= 0 (count at:(site))))) (> (count at:(from)) 1) (and (= (count at:(from)) 1) (= 0 (count at:(trackSite Move from:(from) Mover steps:1)))))) (then (and (sow "Track" owner:(mover) apply:(if (= (count at:(to)) 1) (if (is In (to) (sites Mover "Inner")) (if (> (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))) 0) (and {(remove (if (is Mover P1) (+ (to) 8) (- (to) 8))) (if (> (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) 0) (remove (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (moveAgain) (set Var "ExtraCapture" 3)}))) (and (moveAgain) (set Var (to))))) (forEach Site (sites Board) (if (!= 0 (state at:(site))) (set State at:(site) (state at:(site))))))))))))} (end (forEach NonMover if:(all Sites (sites Player "Home") if:(= 0 (count at:(site)))) (result Player Loss))))) 
4x6-21 board; 8 is most common, 12, 15, and 18 are also popular. Two counters in each hole in the players' outer rows. Two holes in each player's outer row are selected as misoro. Typically, the left two holes are chosen. Sowing occurs in an anti-clockwise direction, only in the two rows belonging to the player. When the final counter lands in an occupied hole, these are picked up and sowing continues. If this final hole is one of the misoro, the player may choose to end their turn instead of continuing to sow. When the final counter lands in an empty hole in the inner row, any counters in the opposite hole in the opponent's inner row are captured. If there also are counters in the opposite hole in the opponent's outer row, these are also captured, but only if there was first a capture from the inner row hole. Players cannot sow from a hole with a single counter unless there are no holes with multiple counters. Single counters can only be sown into an empty hole. Play continues until one player has captured all of the opponent's counters, thus winning the game.  Players choose the misoro holes. 8 Holes per row.
(game "Misoro Tsoro" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "16,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (regions "Outer" P1 (sites Bottom)) (regions "Outer" P2 (sites Top)) (piece "Seed" Shared)}) (rules (start (set Count 2 to:(union (sites Top) (sites Bottom)))) phases:{(phase "Misoro" (play (move Select (from (forEach (sites Mover "Outer") if:(= 0 (state at:(site))))) (then (set State at:(last To) (mover))))) (nextPhase (= 4 (count Turns)) "Playing")) (phase "Playing" (play (or (if (and (!= 0 (state at:(var))) (is Prev Mover)) (move Pass)) (move Select (from (if (is Prev Mover) (sites {(var)}) (sites Mover "Home")) if:(if (not (all Sites (forEach (sites Mover) if:(< 1 (count at:(site)))) if:(= 0 (count at:(site))))) (> (count at:(from)) 1) (and (= (count at:(from)) 1) (= 0 (count at:(trackSite Move from:(from) Mover steps:1)))))) (then (and (sow "Track" owner:(mover) apply:(if (= (count at:(to)) 1) (if (is In (to) (sites Mover "Inner")) (if (> (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))) 0) (and (remove (if (is Mover P1) (+ (to) 8) (- (to) 8))) (if (> (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) 0) (remove (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))))))) (and (moveAgain) (set Var (to))))) (forEach Site (sites Board) (if (!= 0 (state at:(site))) (set State at:(site) (state at:(site)))))))))))} (end (forEach NonMover if:(all Sites (sites Player "Home") if:(= 0 (count at:(site)))) (result Player Loss))))) 
4x12 board. Four counters in each hole. Players alternate turns sowing the counters from one hole in an anti-clockwise direction. When the counters fall into a hole in their inner row, the contents of the opponent's opposite inner row hole are captured, as are any in the opponent's corresponding outer row hole, but only if counters were captured from the inner row hole. The player who captures the most counters wins.
(game "Moruba" (players 2) (equipment {(mancalaBoard 4 12 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "24,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 4 to:(union (sites P1 "Home") (sites P2 "Home")))) (play (move Select (from (sites Mover "Home") if:(> (count at:(from)) 0)) (then (sow "Track" owner:(mover) if:(and {(is In (to) (sites Mover "Inner")) (> (count at:(if (is Mover P1) (+ (to) 12) (- (to) 12))) 0)}) apply:(and (fromTo (from (if (is Mover P1) (+ (to) 12) (- (to) 12))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 12) (- (to) 12)))) (if (> (count at:(if (is Mover P1) (+ (to) (* 12 2)) (- (to) (* 12 2)))) 0) (fromTo (from (if (is Mover P1) (+ (to) (* 12 2)) (- (to) (* 12 2)))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) (* 12 2)) (- (to) (* 12 2))))))))))) (end (if (no Moves Mover) (byScore {(score P1 (count Cell at:(handSite P1))) (score P2 (count Cell at:(handSite P2)))}))))) 
4x10-20 holes, with even numbers. Two counters in each hole in the outer row. Sowing occurs in an anti-clockwise direction. When the final counter lands in an occupied hole, these are picked up and sowing continues. When the final counter lands in an empty hole in the inner row, the counters in the opposite hole in the opponent's inner row are captured. If counters are captured from the inner row, and there are also counters in the outer row, the counters in the outer row are also captured. If counters in the inner and outer row are captured, the player may also capture counters from two other holes on the opponent's side of the board. Single counters cannot be sown until there are no holes with multiple counters on the player's side of the board, and then single counters may only be sown into empty holes. Play continues until one player captures all of their opponent's counters, thus winning the game.  Each row has 10 holes.
(game "Msuwa wa Kunja" (players 2) (equipment {(mancalaBoard 4 10 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "20,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (piece "Seed" Shared)}) (rules (start (set Count 2 to:(union (sites Top) (sites Bottom)))) (play (if (and (is Prev Mover) (< 0 (var))) (move Remove (forEach (sites Next "Home") if:(< 0 (count at:(site)))) (then (and (if (> (var) 1) (moveAgain)) (set Var (- (var) 1))))) (if (not (all Sites (forEach (sites Mover "Home") if:(< 1 (count at:(site)))) if:(= 0 (count at:(site))))) (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(< 1 (count at:(from)))) (then (sow "Track" owner:(mover) apply:(if (< 1 (count at:(to))) (moveAgain) (if (is In (to) (sites Mover "Inner")) (if (< 0 (count at:(if (is Mover P1) (+ (to) 10) (- (to) 10)))) (and (remove (if (is Mover P1) (+ (to) 10) (- (to) 10))) (if (< 0 (count at:(if (is Mover P1) (+ (to) (* 10 2)) (- (to) (* 10 2))))) (and {(remove (if (is Mover P1) (+ (to) (* 10 2)) (- (to) (* 10 2)))) (set Var 2) (moveAgain)}))))))))) (move Select (from (sites Mover "Home") if:(and (= 1 (count at:(from))) (= 0 (count at:(trackSite Move from:(from) steps:1))))) (then (sow "Track" owner:(mover) apply:(if (is In (to) (sites Mover "Inner")) (if (< 0 (count at:(if (is Mover P1) (+ (to) 10) (- (to) 10)))) (and (remove (if (is Mover P1) (+ (to) 10) (- (to) 10))) (if (< 0 (count at:(if (is Mover P1) (+ (to) (* 10 2)) (- (to) (* 10 2))))) (and {(remove (if (is Mover P1) (+ (to) (* 10 2)) (- (to) (* 10 2)))) (set Var 2) (moveAgain)}))))))))))) (end (forEach NonMover if:(all Sites (sites Player "Home") if:(= 0 (count at:(site)))) (result Player Loss))))) 
4x10-20 holes, with even numbers. Two counters in each hole, except the rightmost hole in the inner row of each player, which has zero, and the hole to its left, which has one. Sowing occurs in an anti-clockwise direction. When the final counter lands in an occupied hole, these are picked up and sowing continues. When the final counter lands in an empty hole in the inner row, the counters in the opposite hole in the opponent's inner row are captured. If counters are captured from the inner row, and there are also counters in the outer row, the counters in the outer row are also captured. If counters in the inner and outer row are captured, the player may also capture counters from two other holes on the opponent's side of the board. Single counters cannot be sown until there are no holes with multiple counters on the player's side of the board, and then single counters may only be sown into empty holes. Play continues until one player captures all of their opponent's counters, thus winning the game. Each row has 10 holes.
(game "Msuwa" (players 2) (equipment {(mancalaBoard 4 10 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "20,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (piece "Seed" Shared)}) (rules (start {(set Count 2 to:(difference (sites Board) (sites {18 19 20 21}))) (set Count 1 to:(sites {18 21}))}) (play (if (and (is Prev Mover) (< 0 (var))) (move Remove (forEach (sites Next "Home") if:(< 0 (count at:(site)))) (then (and (if (> (var) 1) (moveAgain)) (set Var (- (var) 1))))) (if (not (all Sites (forEach (sites Mover "Home") if:(< 1 (count at:(site)))) if:(= 0 (count at:(site))))) (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(< 1 (count at:(from)))) (then (sow "Track" owner:(mover) apply:(if (< 1 (count at:(to))) (moveAgain) (if (is In (to) (sites Mover "Inner")) (if (< 0 (count at:(if (is Mover P1) (+ (to) 10) (- (to) 10)))) (and (remove (if (is Mover P1) (+ (to) 10) (- (to) 10))) (if (< 0 (count at:(if (is Mover P1) (+ (to) (* 10 2)) (- (to) (* 10 2))))) (and {(remove (if (is Mover P1) (+ (to) (* 10 2)) (- (to) (* 10 2)))) (set Var 2) (moveAgain)}))))))))) (move Select (from (sites Mover "Home") if:(and (= 1 (count at:(from))) (= 0 (count at:(trackSite Move from:(from) steps:1))))) (then (sow "Track" owner:(mover) apply:(if (is In (to) (sites Mover "Inner")) (if (< 0 (count at:(if (is Mover P1) (+ (to) 10) (- (to) 10)))) (and (remove (if (is Mover P1) (+ (to) 10) (- (to) 10))) (if (< 0 (count at:(if (is Mover P1) (+ (to) (* 10 2)) (- (to) (* 10 2))))) (and {(remove (if (is Mover P1) (+ (to) (* 10 2)) (- (to) (* 10 2)))) (set Var 2) (moveAgain)}))))))))))) (end (forEach NonMover if:(all Sites (sites Player "Home") if:(= 0 (count at:(site)))) (result Player Loss))))) 
4x6-21 board; 8 is most common, 12, 15, and 18 are also popular. Each player's rightmost hole is the musoro. Two counters in each hole in the players' outer rows, except each musoro which has three. Sowing occurs in an anti-clockwise direction. When the final counter lands in an occupied hole, these are picked up and sowing continues. If this final hole is one of the musoro, the player may choose to end their turn instead of continuing to sow. When the final counter lands in an empty hole in the inner row, any counters in the opposite hole in the opponent's inner row are captured. If there also are counters in the opposite hole in the opponent's outer row, these are also captured, but only if there was first a capture from the inner row hole. Players cannot sow from a hole with a single counter unless there are no holes with multiple counters. Single counters can only be sown into an empty hole. Play continues until one player has captured all of the opponent's counters, thus winning the game.  8 Holes per row.
(game "Musoro Tsoro" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "16,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (regions "Outer" P1 (sites Bottom)) (regions "Outer" P2 (sites Top)) (piece "Seed" Shared)}) (rules (start {(place "Seed" (intersection (sites Top) (sites Left)) counts:{3} state:2) (place "Seed" (intersection (sites Bottom) (sites Right)) counts:{3} state:1) (set Count 2 to:(union (difference (sites Top) (sites Left)) (difference (sites Bottom) (sites Right))))}) (play (or (if (and (!= 0 (state at:(var))) (is Prev Mover)) (move Pass)) (move Select (from (if (is Prev Mover) (sites {(var)}) (sites Mover "Home")) if:(if (not (all Sites (forEach (sites Mover) if:(< 1 (count at:(site)))) if:(= 0 (count at:(site))))) (> (count at:(from)) 1) (and (= (count at:(from)) 1) (= 0 (count at:(trackSite Move from:(from) Mover steps:1)))))) (then (and (sow "Track" owner:(mover) apply:(if (= (count at:(to)) 1) (if (is In (to) (sites Mover "Inner")) (if (> (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))) 0) (and (remove (if (is Mover P1) (+ (to) 8) (- (to) 8))) (if (> (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) 0) (remove (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))))))) (and (moveAgain) (set Var (to))))) (forEach Site (sites Board) (if (!= 0 (state at:(site))) (set State at:(site) (state at:(site)))))))))) (end (forEach NonMover if:(all Sites (sites Player "Home") if:(= 0 (count at:(site)))) (result Player Loss))))) 
4x6-16 board. Play begins with two counters in each hole. The first move must be from the inner row. Play begins from any of the player's holes, sowing clockwise. When the final counter lands in an occupied hole, these are picked up and sowing continues. Captures are made when the final counter falls into an empty hole in the inner row, and the opponent's hole opposite contains counters. If it is, they are captured, and if the hole in to outer row opposite also contains counters, these are also captured. If the final counter falls into an empty hole and a capture cannot happen, the turn is over. Play ends when one player cannot move. Each player has 6 holes.
(game "Muvalavala (Luena)" (players 2) (equipment {(mancalaBoard 4 6 store:None {(track "Track1" "5,W,N1,E" loop:True P1) (track "Track2" "17,W,N1,E" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 2 to:(union (sites P1 "Home") (sites P2 "Home")))) phases:{(phase "Opening" (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Inner")) if:(> (count at:(from)) 0)) (then (sow "Track" owner:(mover) apply:(if (= (count at:(to)) 1) (if (is In (to) (sites Mover "Inner")) (if (> (count at:(if (is Mover P1) (+ (to) 6) (- (to) 6))) 0) (and (fromTo (from (if (is Mover P1) (+ (to) 6) (- (to) 6))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 6) (- (to) 6)))) (if (> (count at:(if (is Mover P1) (+ (to) (* 6 2)) (- (to) (* 6 2)))) 0) (fromTo (from (if (is Mover P1) (+ (to) (* 6 2)) (- (to) (* 6 2)))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) (* 6 2)) (- (to) (* 6 2))))))))) (moveAgain)))))) (nextPhase (>= (count Turns) 2) "Playing")) (phase "Playing" (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(> (count at:(from)) 0)) (then (sow "Track" owner:(mover) apply:(if (= (count at:(to)) 1) (if (is In (to) (sites Mover "Inner")) (if (> (count at:(if (is Mover P1) (+ (to) 6) (- (to) 6))) 0) (and (fromTo (from (if (is Mover P1) (+ (to) 6) (- (to) 6))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 6) (- (to) 6)))) (if (> (count at:(if (is Mover P1) (+ (to) (* 6 2)) (- (to) (* 6 2)))) 0) (fromTo (from (if (is Mover P1) (+ (to) (* 6 2)) (- (to) (* 6 2)))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) (* 6 2)) (- (to) (* 6 2))))))))) (moveAgain)))))))} (end (if (no Moves Mover) (byScore {(score P1 (+ (count Cell at:(handSite P1)) (count in:(sites P1)))) (score P2 (+ (count Cell at:(handSite P2)) (count in:(sites P2))))}))))) 
4x6-16 board. Number of counters per player is four times the number of holes in a row minus two. Counters are distributed only in the outer row, with two counters in each hole, except the hole on the far left which contains the rest. The counters are then redistributed so that there is one in every hole, except the one on the extreme left in the inner and outer hole. The one on the left in the inner hole remains empty and the one in the outer row retains the same number initially placed there. Play begins from any of the player's holes, sowing anti-clockwise. When the final counter lands in an occupied hole, these are picked up and sowing continues, unless a capture can be made. Captures are made when the final counter falls into an occupied hole in the inner row, and the opponent's hole opposite contains counters. If it is, they are captured, and if the hole in to outer row opposite also contains counters, these are also captured. These are then sown from the hole following the one from which the capture occurred. If the final counter falls into an empty hole, the turn is over. Single counters cannot be sown. Play ends when one player cannot move. Each row has 6 holes.
(game "Muvalavala (Quioco)" (players 2) (equipment {(mancalaBoard 4 6 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "12,E,N1,W" loop:True P2)}) (piece "Seed" Shared) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (regions "Outer" P1 (sites Bottom)) (regions "Outer" P2 (sites Top))}) (rules (start {(set Count 1 to:(union {(difference (sites P1 "Home") (sites Left)) (difference (sites P2 "Home") (sites Right))})) (set Count (- (- (* 4 6) 2) (* 2 (- 6 1))) to:(union (intersection (sites Left) (sites P1 "Outer")) (intersection (sites Right) (sites P2 "Outer"))))}) (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(> (count at:(from)) 1)) (then (sow "Track" owner:(mover) apply:(if (and {(> (count at:(to)) 1) (is In (to) (sites Mover "Inner")) (> (count at:(if (is Mover P1) (+ (to) 6) (- (to) 6))) 0)}) (and {(fromTo (from (if (is Mover P1) (+ (to) 6) (- (to) 6))) (to (to)) count:(count at:(if (is Mover P1) (+ (to) 6) (- (to) 6)))) (if (> (count at:(if (is Mover P1) (+ (to) (* 6 2)) (- (to) (* 6 2)))) 0) (fromTo (from (if (is Mover P1) (+ (to) (* 6 2)) (- (to) (* 6 2)))) (to (to)) count:(count at:(if (is Mover P1) (+ (to) (* 6 2)) (- (to) (* 6 2)))))) (sow (to) count:(+ (count at:(if (is Mover P1) (+ (to) 6) (- (to) 6))) (count at:(if (is Mover P1) (+ (to) (* 6 2)) (- (to) (* 6 2))))) "Track" owner:(mover))}) (if (> (count at:(to)) 1) (moveAgain))))))) (end (if (no Moves Next) (result Mover Win))))) 
4x8 board. Two counters in each hole, the holes in the inner row are then vacated. These counters become the "store." Sowing occurs in an anti-clockwise direction in the player's two rows. When the final counter of a sowing lands in any occupied hole, the contents of the opponent's inner row holes opposite are captured. If there are also counters in the opponent's outer hole opposite, these are also captured, but only if there are counters in the opponent's inner hole. Captured counters are then sown from the hole that the sowing began. If the final counter lands in an occupied hole and capturing cannot happen, these counters are picked up and sowing continues. At any time during the game if a player is running low on counters, they may enter counters from the "store" and add one counter to each hole. The player who is unable to move loses.
(game "Mwambulula" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "16,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 2 to:(union (sites P1 "Home") (sites P2 "Home")))) phases:{(phase "Opening" (play (move (from (sites Mover "Inner") if:(is Occupied (from))) (to Cell (handSite Mover)) count:2)) (nextPhase Mover (all Sites (sites Mover "Inner") if:(= 0 (count at:(site)))) "Sowing")) (phase "Sowing" (play (or (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(> (count at:(from)) 0)) (then (sow "Track" owner:(mover) apply:(if (< 1 (count at:(to))) (if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (and {(fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (if (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))))) (sow (last From) count:(+ (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))) (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) "Track" owner:(mover))}) (moveAgain)) (if (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (and {(fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (if (is Occupied (if (is Mover P1) (+ (to) (* 8 3)) (- (to) (* 8 3)))) (fromTo (from (if (is Mover P1) (+ (to) (* 8 3)) (- (to) (* 8 3)))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) (* 8 3)) (- (to) (* 8 3)))))) (sow (last From) count:(+ (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (count at:(if (is Mover P1) (+ (to) (* 8 3)) (- (to) (* 8 3))))) "Track" owner:(mover))}) (moveAgain))))))) (if (and (not (is Prev Mover)) (is Occupied Cell (handSite Mover))) (move Select (from Cell (handSite Mover)) (then (forEach Site (sites Mover "Home") (fromTo (from Cell (handSite Mover)) (to (site))))))))))} (end (forEach NonMover if:(no Moves Player) (result Player Loss))))) 
4x8 board. Two counters in each hole. Opening play: Two players play simultaneously, lifting and sowing counters from their outer rows. Rules for sowing and capturing are the same as in the main phase of the game. Sowing cannot begin from the fourth or fifth hole from the left in the player's outer hole. Players play until both drop the final counter in an empty hole, the first to do so plays first in the main phase. Players then move alternately. Main phase: Play begins from any hole on the player's side of the board with counters in it. Singletons cannot move. Sowing happens in an anti-clockwise direction. If the last counter lands in an empty hole, the turn is over. For capturing: Holes are in 'opposition' when one player has the front row hole occupied and the opponent has both of the holes opposite it occupied. If the last hole in a sowing is in opposition, the player takes the counters in both of the opponent's holes and places them in the empty hole from which the player lifted the counters. The player then sows the captured counters from this hole. Further captures in the sowing can occur in the same way. However, each player has two hole from which clockwise plays can be made: the leftmost hole in the outer row and the second from the left in the inner row. Clockwise moves can only be made from these holes if they immediately lead to a capture. When the captured counters are sown, starting from the same hole, they can also be sown clockwise if they lead to a capture. If they cannot lead to a capture, they are sown anti-clockwise. Another alternative the player has is that, if the player plays clockwise from one of these holes and therefore makes a capture, the captured counters may be placed in the hole and left there, and the player may play instead from the other hole from which clockwise captures are allowed in a clockwise direction, if it leads to a capture. The player may continue playing from this hole as above until the possibilities to move are exhausted, and then may move from any hole in an anti-clockwise direction. Multiple captures can only be made in a clockwise direction from these holes if it is made on the first sowing of the turn. Otherwise, only one clockwise capture can be made and sowing must proceed in an anti-clockwise direction. If the last counter lands on a hole that is occupied but not in opposition, these counters are picked up and sowing continues. Play ends when one player captures all the opponent's counters or one player cannot play. The player who cannot play loses. A player may also win by capturing the counters from both of the opponent's end holes in the inner row in a single turn.
(game "Mweiso" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "TrackCCW1" "0,E,N1,W" loop:True P1) (track "TrackCCW2" "16,E,N1,W" loop:True P2) (track "TrackCW1" "7,W,N1,E" loop:True P1) (track "TrackCW2" "24,E,S1,W" loop:True P2)}) (regions "Home" P1 (sites Track "TrackCCW1")) (regions "Home" P2 (sites Track "TrackCCW2")) (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top))) (regions "Outer" P1 (difference (sites Bottom) (sites {3 4}))) (regions "Outer" P2 (difference (sites Top) (sites {27 28}))) (map "LeftMostOuter" {(pair P1 0) (pair P2 31)}) (map "SecondLeftInner" {(pair P1 9) (pair P2 22)}) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 2 to:(union (sites P1 "Home") (sites P2 "Home")))) phases:{(phase "OuterPhase" (play (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover "Outer")) if:(if (is Prev Mover) (< 0 (count at:(from))) (< 1 (count at:(from))))) (then (sow "TrackCCW" owner:(mover) apply:(if (< 1 (count at:(to))) (and (moveAgain) (if (and {(is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (is In (to) (sites Mover "Inner"))}) (and {(fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (set Var "Replay" (from))}) (set Var "Replay" (to))))))))) (nextPhase Mover (= 1 (count at:(last To afterConsequence:True))) "MainPhase")) (phase "MainPhase" (play (or (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites {(mapEntry "LeftMostOuter" Mover) (mapEntry "SecondLeftInner" Mover)})) if:(and {(if (is Prev Mover) (< 0 (count at:(from))) (< 1 (count at:(from)))) (is In (from) (sites {(mapEntry "LeftMostOuter" Mover) (mapEntry "SecondLeftInner" Mover)})) (is In (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) (sites Mover "Inner")) (is Occupied (if (is Mover P1) (+ (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) 8) (- (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) 8))) (is Occupied (if (is Mover P1) (+ (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) (* 8 2)) (- (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) (* 8 2))))})) (then (sow "TrackCW" owner:(mover) apply:(if (< 1 (count at:(to))) (and (moveAgain) (if (and {(is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (is In (to) (sites Mover "Inner"))}) (and {(fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (set Var "Replay" (from))}) (set Var "Replay" (to)))))))) (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover)) if:(if (is Prev Mover) (< 0 (count at:(from))) (< 1 (count at:(from))))) (then (sow "TrackCCW" owner:(mover) apply:(if (< 1 (count at:(to))) (and (moveAgain) (if (and {(is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (is In (to) (sites Mover "Inner"))}) (and {(fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (set Var "Replay" (from))}) (set Var "Replay" (to)))))))))) (end (if (no Moves Next) (result Mover Win))))})) 
4x4-16 board, played only along the perimeter. Three counters per hole. Any number of players. Holes are distributed equally among the players. Sowing occurs in a clockwise direction. Counters are sown one per occupied hole, two per empty hole. Each player owns the holes in which their counters are located at the beginning of their turn, and they must sow from the rightmost hole. If the final counter of a sowing falls into an empty hole, the player sows again from the rightmost hole. Alternatively, a player may place all of the counters from the rightmost counter into the next hole, but this cannot be done after a move. When counters fall into holes belonging to an opponent, these hole and the counters in it are captured by the player, but remain in play. When a player has a single counter and empty holes in from of it, this counter leaps to the next hole occupied by the opponent. The player who captures all of the opponent's holes wins. Each row has 10 holes.
(game "Mwendo" (players 4) (equipment {(mancalaBoard 4 10 store:None (track "Track" "10,N,E,S,W" loop:True)) (piece "Seed" Each) (regions P1 (sites {0 1 2 3 4 5})) (regions P2 (sites {6 7 8 9 19 29})) (regions P3 (sites {39 38 37 36 35 34})) (regions P4 (sites {33 32 31 30 20 10}))}) (rules (start {(place "Seed1" (sites P1) counts:{3}) (place "Seed2" (sites P2) counts:{3}) (place "Seed3" (sites P3) counts:{3}) (place "Seed4" (sites P4) counts:{3})}) (play (if (!= 1 (count Pieces Mover)) (or (move Select (from (trackSite FirstSite from:(trackSite FirstSite if:(not (is Mover (who at:(to))))) if:(is Mover (who at:(to))))) (then (sow numPerHole:(if (is Empty (to)) 2 1) sowEffect:(if (and (!= (mover) (what at:(to))) (is Occupied (to))) (and (remove (to) count:(count at:(to))) (add (piece (id "Seed" Mover)) (to (to)) count:(count at:(to))))) apply:(if (= 2 (count at:(to))) (moveAgain))))) (if (not (is Prev Mover)) (move (from (trackSite FirstSite from:(trackSite FirstSite if:(not (is Mover (who at:(to))))) if:(is Mover (who at:(to))))) (to (trackSite Move from:(trackSite FirstSite from:(trackSite FirstSite if:(not (is Mover (who at:(to))))) if:(is Mover (who at:(to)))) steps:1) (apply (if (and (!= (mover) (what at:(to))) (is Occupied (to))) (and (remove (to) count:(count at:(to))) (add (piece (id "Seed" Mover)) (to (to)) count:(count at:(to))))))) count:(count at:(trackSite FirstSite from:(trackSite FirstSite if:(not (is Mover (who at:(to))))) if:(is Mover (who at:(to)))))))) (move (from (trackSite FirstSite from:(trackSite FirstSite if:(not (is Mover (who at:(to))))) if:(is Mover (who at:(to))))) (to (trackSite FirstSite from:(from) if:(is Enemy (who at:(to)))) (apply (and (remove (to) count:(count at:(to))) (add (piece (id "Seed" Mover)) (to (to)) count:(count at:(to))))))))) (end (forEach NonMover if:(no Pieces Player) (result Player Loss))))) 
4x8 board. 32 counters per player. Players may arrange the counters however they like in their holes. Players sow by taking the counters from one of their holes and dropping them one by one in an anti-clockwise direction only in the two rows closest to them. When the last counter lands in an empty hole, the turn is over. When the last counter falls into an occupied hole, the contents of this hole are picked up and sowing continues. If the final counter falls into an occupied hole in the inner row, and the two holes opposite it in the opponent's rows are occupied, the counters in these two rows of the opponent are taken. They are then sown on the player's side of the board beginning from the hole that received the first counter of the sowing that led to the capture. Both of the opponent's holes must be occupied to capture. Clockwise sowing is allowed in certain circumstances. If a clockwise move from the four holes on the left hand side of the players board (i.e., the left two holes in the outer row or the left two hole in the inner row) can lead to a capture, a clockwise move is allowed. Sowing cannot occur with single counters. The player who can no longer move loses.
(game "Mweso" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "TrackCCW1" "0,E,N1,W" loop:True P1) (track "TrackCCW2" "16,E,N1,W" loop:True P2) (track "TrackCW1" "7,W,N1,E" loop:True P1) (track "TrackCW2" "24,E,S1,W" loop:True P2)}) (piece "Seed" Shared) (regions "Home" P1 (sites Track "TrackCCW1")) (regions "Home" P2 (sites Track "TrackCCW2")) (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top))) (regions "Left" P1 (intersection (sites Track "TrackCCW1") (expand (sites Left)))) (regions "Left" P2 (intersection (sites Track "TrackCCW2") (expand (sites Right)))) (hand Each)}) (rules (start {(set Count 32 at:(handSite P1)) (set Count 32 at:(handSite P2))}) phases:{(phase "Placing" (play (move (from (handSite Mover)) (to (sites Mover "Home")) count:1)) (nextPhase Mover (is Empty (handSite Mover)) "Sowing")) (phase "Sowing" (play (or {(if (!= 2 (var "Direction")) (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover "Home")) if:(< 1 (count at:(from)))) (then (sow "TrackCCW" owner:(mover) apply:(if (< 1 (count at:(to))) (and {(set Var "Direction" 1) (moveAgain) (set Var "Replay" (to)) (if (is In (to) (sites Mover "Inner")) (if (and (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (and {(fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (sow (last From) count:(+ (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))) (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) "TrackCCW" owner:(mover))})))}) (set Var "Direction" 0)))))) (if (!= 1 (var "Direction")) (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover "Left")) if:(and (< 1 (count at:(from))) (if (is Prev Mover) True (if (is In (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) (sites Mover "Inner")) (and (is Occupied (if (is Mover P1) (+ (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) 8) (- (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) 8))) (is Occupied (if (is Mover P1) (+ (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) (* 8 2)) (- (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) (* 8 2))))) False)))) (then (sow "TrackCW" owner:(mover) apply:(if (< 1 (count at:(to))) (and {(set Var "Direction" 2) (moveAgain) (set Var "Replay" (to)) (if (is In (to) (sites Mover "Inner")) (if (and (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (and {(fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (sow (last From) count:(+ (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))) (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) "TrackCCW" owner:(mover))})))}) (set Var "Direction" 0))))))})) (end (if (and (not (is Next Mover)) (no Moves Next)) (result Mover Win))))})) 
4x7-10 board (seven most common). One counter in each hole, with the player's leftmost hole in the outer row empty. On the first turn, sowing occurs in a clockwise direction. On the second turn, the player may sow in either direction, but must continue in the chosen direction for the rest of the game. Captures are made when the final counter of a sowing lands in an empty hole in the inner row. Captures are only made from the opponent's opposite outer row hole, and only when their inner row hole is empty. If the final counter lands in an occupied hole, the player picks up these counters and continues sowing. The player who captures all of the opponent's counters wins. Each player has 7 holes.
(game "Namudilakunze" (players 2) (equipment {(mancalaBoard 4 7 store:None {(track "TrackCCW1" "0,E,N1,W" loop:True P1) (track "TrackCCW2" "14,E,N1,W" loop:True P2) (track "TrackCW1" "6,W,N1,E" loop:True P1) (track "TrackCW2" "20,W,N1,E" loop:True P2)}) (piece "Seed" Shared) (regions "Home" P1 (sites Track "TrackCCW1")) (regions "Home" P2 (sites Track "TrackCCW2")) (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top))) (hand Each)}) (rules (start (set Count 1 to:(difference (sites Board) (sites {0 (- (* 7 4) 1)})))) phases:{(phase "FirstTurn" (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(is Occupied (from))) (then (sow "TrackCW" owner:(mover) apply:(if (< 1 (count at:(to))) (moveAgain) (if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 7) (- (to) 7))) (remove (if (is Mover P1) (+ (to) 7) (- (to) 7))) (if (is Occupied (if (is Mover P1) (+ (to) (* 7 2)) (- (to) (* 7 2)))) (remove (if (is Mover P1) (+ (to) (* 7 2)) (- (to) (* 7 2)))))))))))) (nextPhase Mover (not (is Next Mover)) "Main")) (phase "Main" (play (or (if (or (>= 0 (value Player Mover)) (= (value Player Mover) 1)) (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(is Occupied (from))) (then (sow "TrackCCW" owner:(mover) apply:(and (if (< 1 (count at:(to))) (moveAgain) (if (is In (to) (sites Mover "Inner")) (if (is Empty (if (is Mover P1) (+ (to) 7) (- (to) 7))) (if (is Occupied (if (is Mover P1) (+ (to) (* 7 2)) (- (to) (* 7 2)))) (remove (if (is Mover P1) (+ (to) (* 7 2)) (- (to) (* 7 2)))))))) (if (!= 1 (value Player Mover)) (set Value Mover 1))))))) (if (or (>= 0 (value Player Mover)) (= (value Player Mover) 2)) (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(is Occupied (from))) (then (sow "TrackCW" owner:(mover) apply:(and (if (< 1 (count at:(to))) (moveAgain) (if (is In (to) (sites Mover "Inner")) (if (is Empty (if (is Mover P1) (+ (to) 7) (- (to) 7))) (if (is Occupied (if (is Mover P1) (+ (to) (* 7 2)) (- (to) (* 7 2)))) (remove (if (is Mover P1) (+ (to) (* 7 2)) (- (to) (* 7 2)))))))) (if (!= 2 (value Player Mover)) (set Value Mover 2))))))))))} (end (forEach NonMover if:(all Sites (sites Player "Home") if:(= 0 (count at:(site)))) (result Player Loss))))) 
4x5 or 8 board. One counter in each hole. Players alternate turns picking up the counters in one of their holes and sowing them in an anti-clockwise direction. When the final counter lands in a hole with counters, these counters are picked up and sowing continues. When the final counter lands in an empty hole in the inner row, any counters in the opponent's opposite inner row hole are captured, and if this capture was possible, any counters in the outer row hole are also captured. The player who captures all of the opponent's counters wins. Each player has 6 holes per row.
(game "Nchayo" (players 2) (equipment {(mancalaBoard 4 5 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "10,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 1 to:(sites Board))) (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(is Occupied (from))) (then (sow "Track" owner:(mover) apply:(if (< 1 (count at:(to))) (moveAgain) (if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 5) (- (to) 5))) (and (fromTo (from (if (is Mover P1) (+ (to) 5) (- (to) 5))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 5) (- (to) 5)))) (if (is Occupied (if (is Mover P1) (+ (to) (* 5 2)) (- (to) (* 5 2)))) (fromTo (from (if (is Mover P1) (+ (to) (* 5 2)) (- (to) (* 5 2)))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) (* 5 2)) (- (to) (* 5 2)))))))))))))) (end (if (no Moves Next) (byScore {(score P1 (+ (count Cell at:(handSite P1)) (count in:(sites P1 "Home")))) (score P2 (+ (count Cell at:(handSite P2)) (count in:(sites P2 "Home"))))}))))) 
4x6, 9, 12, or 15. Two counters in each hole. Players begin by sowing from the rightmost hole in the inner row, placing one counter in each of the first two holes, then picking up the counters from the next hole and continuing to sow until the next hole after the sowing is empty (this should be the hole from which the sowing began). Each player then takes two counters from any of the holes in their inner row and places them in any empty hole in the outer row. The player then captures the counters in the opponent's opposite holes. The player then removes the contents of any one of the opponent's holes. Once both players have done this, the main phase begins. Players move by sowing from any of the holes on their side of the board in an anti-clockwise direction. When the final counter lands in an occupied hole, these are picked up and sowing continues. When they fall into an empty hole, the sowing ends. If this hole is in the inner row, the contents of the opponent's opposite hole in the inner row are also taken. If there are also counters in the opponent's outer row opposite, these are also taken. The player may also capture the contents of any other hole in the inner or outer row. Single counters may be moved. The player who captures all of their opponent's counters wins. Each player has 6 holes by row.
(game "Nchuwa" (players 2) (equipment {(mancalaBoard 4 6 store:None {(track "TrackCCW1" "0,E,N1,W" loop:True P1) (track "TrackCCW2" "12,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "TrackCCW1")) (regions "Home" P2 (sites Track "TrackCCW2")) (regions "Inner" P1 (sites Row 1)) (regions "Inner" P2 (sites Row 2)) (regions "Outer" P1 (sites Row 0)) (regions "Outer" P2 (sites Row 3)) (piece "Seed" Shared)}) (rules (start (set Count 2 to:(union (sites P1 "Home") (sites P2 "Home")))) phases:{(phase "Opening1" (play (move Select (from (if (is Mover P1) (intersection (sites Right) (sites Row 1)) (intersection (sites Left) (sites Row 2)))) (then (sow "TrackCCW" owner:(mover) apply:(set Value Mover (trackSite Move from:(to) steps:1)))))) (nextPhase Mover "Opening2")) (phase "Opening2" (play (move Select (from (value Player Mover)) (then (sow "TrackCCW" owner:(mover) apply:(if (= (count at:(trackSite Move from:(to) steps:1)) 0) (set Value Mover -1) (set Value Mover (trackSite Move from:(to) steps:1))))))) (nextPhase Mover (= (value Player Mover) -1) "Opening3")) (phase "Opening3" (play (move (from (forEach (sites Mover "Inner") if:(!= 0 (count at:(site))))) (to (forEach (sites Mover "Outer") if:(= 0 (count at:(site))))) count:2)) (nextPhase Mover "Opening4")) (phase "Opening4" (play (move Remove (sites Next "Home"))) (nextPhase Mover "Opening5")) (phase "Opening5" (play (move Remove (sites Next "Home"))) (nextPhase Mover "Playing")) (phase "Playing" (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(> (count at:(from)) 0)) (then (sow "TrackCCW" owner:(mover) apply:(if (= (count at:(to)) 1) (if (is In (to) (sites Mover "Inner")) (if (> (count at:(if (is Mover P1) (+ (to) 6) (- (to) 6))) 0) (and (remove (if (is Mover P1) (+ (to) 6) (- (to) 6))) (if (> (count at:(if (is Mover P1) (+ (to) (* 6 2)) (- (to) (* 6 2)))) 0) (remove (if (is Mover P1) (+ (to) (* 6 2)) (- (to) (* 6 2)))))))) (moveAgain)))))))} (end (forEach Player if:(= 0 (count in:(sites Player "Home"))) (result Player Loss))))) 
4x9 board. Two counters in each hole. Players alternate turns sowing from one of the holes in their rows in an anti-clockwise direction. When a counter falls into a hole in their inner row, the player captures the counters from both of the opposite holes on the opponent's side of the board; if one of the two opposite holes is empty, no capture is made. Captures counters are sown on the player's side of the board. Play continues until one player captures all of the counters or one player forfeits.
(game "Ngolo" (players 2) (equipment {(mancalaBoard 4 9 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "18,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (piece "Seed" Shared)}) (rules (start (set Count 2 to:(union (sites P1 "Home") (sites P2 "Home")))) (play (or (move Pass) (move Select (from (sites Mover "Home") if:(< 0 (count at:(from)))) (then (sow "Track" owner:(mover) apply:(if (and {(!= (count at:(if (is Mover P1) (+ (to) (* 9 2)) (- (to) (* 9 2)))) 0) (!= (count at:(if (is Mover P1) (+ (to) 9) (- (to) 9))) 0) (is In (to) (sites Mover "Inner"))}) (and {(fromTo (from (if (is Mover P1) (+ (to) (* 9 2)) (- (to) (* 9 2)))) (to (to)) count:(count at:(if (is Mover P1) (+ (to) (* 9 2)) (- (to) (* 9 2))))) (fromTo (from (if (is Mover P1) (+ (to) 9) (- (to) 9))) (to (to)) count:(count at:(if (is Mover P1) (+ (to) 9) (- (to) 9)))) (sow (to) count:(+ (count at:(if (is Mover P1) (+ (to) 9) (- (to) 9))) (count at:(if (is Mover P1) (+ (to) (* 9 2)) (- (to) (* 9 2))))) "Track" owner:(mover))}))))))) (end {(if (= (count in:(sites Next "Home")) 0) (result Mover Win)) (if (was Pass) (result Next Win))}))) 
4x7 board, using only the outer two rows. Three counters in each hole. Sowing occurs in an anticlockwise direction. The first player takes the counters out of their leftmost hole and sows them. Instead of each player owning a row of holes, they own the series of holes which currently contain their counters. Players always sow from the rearmost of their holes. When the frontmost two holes of a player's sequence contain one counter each, the player gets another turn. When a player sows into the rear holes of the opponent, the player takes ownership of those holes. When one player is reduced to one counter, they jump to the nearest corner hole in the direction of play, and continue jumping from corner to corner until they capture counters belonging to the opponent, at which point they revert to the normal playing style. The first player to capture all their opponent's pieces wins.
(game "Ngulungu" (players 2) (equipment {(mancalaBoard 4 7 store:None {(track "Track" "0,E,27,W" loop:True) (track "TrackCorner" "0,6,27,21" loop:True) (track "ReverseTrack" "6,W,21,E" loop:True)}) (piece "Seed" Each)}) (rules (start {(place "Seed1" (sites Bottom) counts:{3}) (place "Seed2" (sites Top) counts:{3})}) (play (if (and (all Sites (sites Occupied by:Mover) if:(is In (sites Corners))) (= 1 (count Pieces Mover))) (move (from (trackSite FirstSite from:(trackSite FirstSite if:(not (is Mover (who at:(to))))) if:(is Mover (who at:(to))))) (to (trackSite FirstSite "TrackCorner" from:(from) if:(is Enemy (who at:(to)))) (apply (and (remove (to) count:(count at:(to))) (add (piece (id "Seed" Mover)) (to (to)) count:(count at:(to))))))) (move Select (from (trackSite FirstSite from:(trackSite FirstSite if:(not (is Mover (who at:(to))))) if:(is Mover (who at:(to))))) (then (sow sowEffect:(if (and (!= (mover) (what at:(to))) (is Occupied (to))) (and (remove (to) count:(count at:(to))) (add (piece (id "Seed" Mover)) (to (to)) count:(count at:(to))))) apply:(if (and (= 1 (count at:(trackSite Move from:(to) "ReverseTrack" steps:1))) (= 1 (count at:(to)))) (moveAgain))))))) (end (forEach NonMover if:(no Pieces Player) (result Player Loss))))) 
4x8 board, occasionally 4x9 or 10. One counter in each hole. Sowing occurs in an anti-clockwise direction. The players start by each making a stylised move. Sowing begins from the rightmost hole in the outer row. When the final counter lands in an occupied hole, these counters are picked up and sowing continues. When the sowing reaches the hole immediately before the one from which the sowing began (I.e,, the second-to-right hole in the outer row), these two counters are picked up and both placed in the rightmost hole in the outer row. The player then removes the two counters in the second-to-right hole in the inner row from the board. When both players complete this move, the main phase of the game begins. Players sow from any hole in their two rows. When the final counter lands in an occupied hole, these counters are picked up and sowing continues. When the final counter lands in an empty hole in the inner row, the counters in the opponent's opposite hole in their inner row are captured. If there are also counters in the opponent's opposite hole in the outer row, these are also captured, but only when a capture from the inner row was also made. Players cannot sow single counters, unless there are no holes with multiple counters left, in which case single counters may be sown into an empty hole. Play continues until one player has captured all of the opponent's counters, thus winning the game. Each row has 8 holes.
(game "Njombwa (One Counter)" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "16,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (regions "Outer" P1 (sites Bottom)) (regions "Outer" P2 (sites Top)) (piece "Seed" Shared)}) (rules (start (set Count 1 to:(sites Board))) phases:{(phase "Opening1" (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (if (is Mover P1) (intersection (sites Mover "Outer") (sites Right)) (intersection (sites Mover "Outer") (sites Left)))) if:(> (count at:(from)) 0)) (then (sow "Track" owner:(mover) apply:(if (and (not (is In (trackSite Move from:(to) "Track" steps:1) (if (is Mover P1) (intersection (sites Mover "Outer") (sites Right)) (intersection (sites Mover "Outer") (sites Left))))) (< 1 (count at:(to)))) (moveAgain)))))) (nextPhase Mover (not (is Next Mover)) "Opening2")) (phase "Opening2" (play (move (from (sites Mover "Home") if:(is In (trackSite Move from:(from) "Track" steps:1) (if (is Mover P1) (intersection (sites Mover "Outer") (sites Right)) (intersection (sites Mover "Outer") (sites Left))))) (to (if (is Mover P1) (intersection (sites Mover "Outer") (sites Right)) (intersection (sites Mover "Outer") (sites Left)))) count:2)) (nextPhase Mover "Opening3")) (phase "Opening3" (play (move Remove (if (is Mover P1) (intersection (sites Mover "Inner") (difference (expand (sites Right)) (sites Right))) (intersection (sites Mover "Inner") (difference (expand (sites Left)) (sites Left)))))) (nextPhase Mover "Sowing")) (phase "Sowing" (play (if (all Sites (sites Mover "Home") if:(>= 1 (count at:(site)))) (move Select (from (sites Mover "Home") if:(and (is Occupied (from)) (is Empty (trackSite Move from:(from) "Track" steps:1)))) (then (sow "Track" owner:(mover)))) (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(> (count at:(from)) 1)) (then (sow "Track" owner:(mover) apply:(if (< 1 (count at:(to))) (moveAgain) (if (and (is In (to) (sites Mover "Inner")) (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8)))) (and (remove (if (is Mover P1) (+ (to) 8) (- (to) 8))) (if (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (remove (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))))))))))))} (end (forEach NonMover if:(all Sites (sites Player) if:(= 0 (count at:(site)))) (result Player Loss))))) 
4x8 board, occasionally 4x9 or 10. Two counters in each hole, except the leftmost hole in the inner row, which has zero, and the hole to its right, which has one. Sowing occurs in an anti-clockwise direction. Players sow from any hole in their two rows. When the final counter lands in an occupied hole, these counters are picked up and sowing continues. When the final counter lands in an empty hole in the inner row, the counters in the opponent's opposite hole in their inner row are captured. If there are also counters in the opponent's opposite hole in the outer row, these are also captured, but only when a capture from the inner row was also made. Players cannot sow single counters, unless there are no holes with multiple counters left, in which case single counters may be sown into an empty hole. Play continues until one player has captured all of the opponent's counters, thus winning the game. Each row has 8 holes.
(game "Njombwa (Two Counters)" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "16,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (piece "Seed" Shared)}) (rules (start {(set Count 2 to:(difference (sites Board) (sites {8 (+ 1 8) (- (* 8 3) 1) (- (* 8 3) 2)}))) (set Count 1 to:(sites {(+ 8 1) (- (* 8 3) 2)}))}) (play (if (all Sites (sites Mover "Home") if:(>= 1 (count at:(site)))) (move Select (from (sites Mover "Home") if:(and (is Occupied (from)) (is Empty (trackSite Move from:(from) "Track" steps:1)))) (then (sow "Track" owner:(mover)))) (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(> (count at:(from)) 1)) (then (sow "Track" owner:(mover) apply:(if (< 1 (count at:(to))) (moveAgain) (if (and (is In (to) (sites Mover "Inner")) (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8)))) (and (remove (if (is Mover P1) (+ (to) 8) (- (to) 8))) (if (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (remove (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))))))))))) (end (forEach NonMover if:(all Sites (sites Player) if:(= 0 (count at:(site)))) (result Player Loss))))) 
4x8 board, occasionally 4x9 or 10. 29 counters in each player's leftmost hole in their outer row, two in the hole to the right of it and one in the hole to the right of that one. Sowing occurs in an anti-clockwise direction in the player's two rows. Each player begins with a stylised move, by sowing the contents of the hole with two counters. Players alternate turns sowing only from their hole with two counters. When finally a single counter is sown into an inner-row hole that is opposite a hole with a single counter in the opponent's inner row, this counter is captured. The opponent then sows their two remaining counters, capturing two from the opponent. Then, the players sow from their hole with 29 counters, picking up the contents of a hole when the final counter lands in an occupied hole, ending the turn when the final counter lands in an empty hole. When both players have completed this phase, the main phase of the game begins. Players sow from any hole in their two rows. When the final counter lands in an occupied hole, these counters are picked up and sowing continues. When the final counter lands in an empty hole in the inner row, the counters in the opponent's opposite hole in their inner row are captured. If there are also counters in the opponent's opposite hole in the outer row, these are also captured, but only when a capture from the inner row was also made. Players cannot sow single counters, unless there are no holes with multiple counters left, in which case single counters may be sown into an empty hole. Play continues until one player has captured all of the opponent's counters, thus winning the game. Each row has 8 holes.
(game "Njombwa" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "16,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (piece "Seed" Shared)}) (rules (start {(set Count 29 to:(sites {0 (- (* 4 8) 1)})) (set Count 2 to:(sites {1 (- (* 4 8) 2)})) (set Count 1 to:(sites {2 (- (* 4 8) 3)}))}) phases:{(phase "Opening1" (play (move Select (from (forEach (sites Mover "Home") if:(= 2 (count at:(site))))) (then (sow "Track" owner:(mover) apply:(if (and (is In (to) (sites Mover "Inner")) (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8)))) (remove (if (is Mover P1) (+ (to) 8) (- (to) 8)))))))) (nextPhase (all Sites (sites Mover "Home") if:(!= 2 (count at:(site)))) "Opening2")) (phase "Opening2" (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (forEach (sites Mover "Home") if:(= 29 (count at:(site))))) if:(> (count at:(from)) 0)) (then (sow "Track" owner:(mover) apply:(if (< 1 (count at:(to))) (moveAgain)))))) (nextPhase (not (is Next Mover)) "Sowing")) (phase "Sowing" (play (if (all Sites (sites Mover "Home") if:(>= 1 (count at:(site)))) (move Select (from (sites Mover "Home") if:(and (is Occupied (from)) (is Empty (trackSite Move from:(from) "Track" steps:1)))) (then (sow "Track" owner:(mover)))) (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(> (count at:(from)) 1)) (then (sow "Track" owner:(mover) apply:(if (< 1 (count at:(to))) (moveAgain) (if (and (is In (to) (sites Mover "Inner")) (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8)))) (and (remove (if (is Mover P1) (+ (to) 8) (- (to) 8))) (if (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (remove (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))))))))))))} (end (forEach NonMover if:(all Sites (sites Player) if:(= 0 (count at:(site)))) (result Player Loss))))) 
4x10-20 board, with even numbers. Two counters in each hole, except the rightmost hole in the inner row of each player, which has zero. Sowing occurs in an anti-clockwise direction. When the final counter lands in an occupied hole, these are picked up and sowing continues. When the final counter lands in an empty hole in the inner row, the counters in the opposite hole in the opponent's inner row are captured. If counters are captured from the inner row, and there are also counters in the outer row, the counters in the outer row are also captured. If counters in the inner and outer row are captured, the player may also capture counters from one other hole on the opponent's side of the board. Single counters cannot be sown until there are no holes with multiple counters on the player's side of the board, and then single counters may only be sown into empty holes. Play continues until one player captures all of their opponent's counters, thus winning the game. Each row has 10 holes.
(game "Nsolo" (players 2) (equipment {(mancalaBoard 4 10 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "20,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (piece "Seed" Shared)}) (rules (start (set Count 2 to:(union {(sites Bottom) (sites Top) (difference (sites P1 "Inner") (sites Right)) (difference (sites P2 "Inner") (sites Left))}))) (play (if (and (is Prev Mover) (= (var "Replay") -1)) (move Remove (sites Next "Home")) (if (all Sites (sites Mover "Home") if:(>= 1 (count at:(site)))) (move Select (from (sites Mover "Home") if:(and (is Occupied (from)) (is Empty (trackSite Move from:(from) "Track" steps:1)))) (then (sow "Track" owner:(mover)))) (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover "Home")) if:(> (count at:(from)) 1)) (then (sow "Track" owner:(mover) apply:(if (< 1 (count at:(to))) (if (and (is In (to) (sites Mover "Inner")) (is Occupied (if (is Mover P1) (+ (to) 10) (- (to) 10)))) (and (remove (if (is Mover P1) (+ (to) 10) (- (to) 10))) (if (is Occupied (if (is Mover P1) (+ (to) (* 10 2)) (- (to) (* 10 2)))) (and {(moveAgain) (set Var "Replay" -1) (remove (if (is Mover P1) (+ (to) (* 10 2)) (- (to) (* 10 2))))}))) (and (moveAgain) (set Var "Replay" (to))))))))))) (end (forEach NonMover if:(all Sites (sites Player "Home") if:(= 0 (count at:(site)))) (result Player Loss))))) 
4x8 board. Two counters in each hole. Players sow in an anti-clockwise direction from any of their holes. Singletons may not be sowed. Players capture when the sowing ends in a player's inner row and the opponent's inner and outer row holes opposite contain counters; these are captured and sown in the player's rows starting from the same hole that the previous sowing began. If the final counter lands in an occupied hole but capture is not possible, the counters in this hole are picked up and sowing continues. If the final counter ends in an empty hole, the turn ends. Captures cannot be made on each player's first turn. Play continues until one player has no holes with two or more counters, and the opponent wins.
(game "Nsumbi" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "16,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (piece "Seed" Shared)}) (rules (start (set Count 2 to:(union (sites P1 "Home") (sites P2 "Home")))) phases:{(phase "Opening" (play (move Select (from (sites Mover)) (then (sow "Track" owner:(mover))))) (nextPhase Mover "Playing")) (phase "Playing" (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover)) if:(< 1 (count at:(from)))) (then (sow "Track" owner:(mover) apply:(if (and {(< 1 (count at:(to))) (is In (to) (sites Mover "Inner")) (> (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))) 0) (> (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) 0)}) (and {(fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (sow (last From) count:(+ (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))) (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) "Track" owner:(mover) origin:True)}) (if (< 1 (count at:(to))) (moveAgain))))))))} (end (if (no Moves Next) (result Mover Win))))) 
4x8 board. Two counters in each hole. Sowing proceeds in an anti-clockwise direction. The first move must begin from the second hole from the right in the player's outer row, and proceed as follows, and is played simultaneously by both players: sow the two counters from that first hole, capture the counters in the opponent's two opposite holes and sow them, starting in the rightmost hole in the outer row, capture from the opposite two holes on the opponent's side and sow them again from the same hole. When the final counter falls in an occupied hole, those counters are picked up and sowing continues. The opening move ends when the final counter falls in an empty hole. The main phase then begins. When the final counter falls into an occupied hole in the player's inner row and both of the opposite holes on the opponent's side of the board are occupied, the counters in the opposite holes are captured and sown beginning in the first hole that was sown into to begin the sowing that caused the capture. When the final counter falls into an occupied hole and a capture is not possible, the contents of the hole are picked up and sowing continues. When the final counter lands in an empty hole, the turn ends. Players cannot sow from a hole containing a single counter. The player who captures all of their opponent's counters wins. 
(game "Otep" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "16,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (piece "Seed" Shared) (map "SecondRightOuter" {(pair P1 14) (pair P2 17)}) (map "RightOuter" {(pair P1 15) (pair P2 16)}) (hand Each)}) (rules (start (set Count 2 to:(sites Board))) phases:{(phase "Opening1" (play (move Select (from (mapEntry "SecondRightOuter" Mover)) (then (sow "Track" owner:(mover) apply:(and (fromTo (from (if (is Mover P1) (+ (last From) 8) (- (last From) 8))) (to (mapEntry "RightOuter" Mover)) count:2) (fromTo (from (if (is Mover P1) (+ (last From) (* 8 2)) (- (last From) (* 8 2)))) (to (mapEntry "RightOuter" Mover)) count:2)))))) (nextPhase Mover "Opening2")) (phase "Opening2" (play (move Select (from (mapEntry "RightOuter" Mover)) (then (sow "Track" owner:(mover) apply:(and (fromTo (from (if (is Mover P1) (+ (last From) 8) (- (last From) 8))) (to (mapEntry "RightOuter" Mover)) count:2) (fromTo (from (if (is Mover P1) (+ (last From) (* 8 2)) (- (last From) (* 8 2)))) (to (mapEntry "RightOuter" Mover)) count:2)))))) (nextPhase Mover "Opening3")) (phase "Opening3" (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites {(mapEntry "RightOuter" Mover)}))) (then (sow "Track" owner:(mover) apply:(if (< 1 (count at:(to))) (moveAgain)))))) (nextPhase Mover (not (is Next Prev)) "Sowing")) (phase "Sowing" (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover)) if:(> (count at:(from)) 1)) (then (sow "Track" owner:(mover) apply:(if (and {(is In (to) (sites Mover "Inner")) (< 1 (count at:(to))) (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8)))}) (and {(fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (sow (last From) count:(+ (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))) (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) "Track" owner:(mover))}) (if (< 1 (count at:(to))) (moveAgain))))))))} (end (forEach Player if:(no Moves Player) (result Player Loss))))) 
4x12-20 board. Play begins with a number of counters that is three times the number of holes in a row minus two for a game with an even number of holes in a row; three times the number of holes minus one for odd. Counters are distributed beginning in the leftmost hole in the outer row, placing two counters in each hole in an anti-clockwise direction. Play begins from any of the player's holes, sowing anti-clockwise. When the final counter lands in an occupied hole, these are picked up and sowing continues, unless a capture can be made. Captures are made when the final counter falls into an occupied hole in the inner row, and the opponent's hole opposite contains counters. If it is, they are captured, and if the hole in to outer row opposite also contains counters, these are also captured. These are then sown from the hole following the one from which the capture occurred. If the final counter falls into an empty hole, the turn is over. Single counters cannot be sown. Play ends when one player cannot move. Each player has 12 holes.
(game "Owela (Benguela)" (players 2) (equipment {(mancalaBoard 4 12 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "24,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (regions "Outer" P1 (sites Bottom)) (regions "Outer" P2 (sites Top)) (regions "InnerInit" P1 (sites {19 20 21 22 23})) (regions "InnerInit" P2 (sites {24 25 26 27 28})) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 2 to:(union {(sites P1 "Outer") (sites P1 "InnerInit") (sites P2 "Outer") (sites P2 "InnerInit")}))) (play (move Select (from (if (is Prev Mover) (if (is Pending) (sites {(value Pending)}) (sites {(last To afterConsequence:True)})) (sites Mover "Home")) if:(> (count at:(from)) 1)) (then (sow "Track" owner:(mover) apply:(if (> (count at:(to)) 1) (if (and (is In (to) (sites Mover "Inner")) (> (count at:(if (is Mover P1) (+ (to) 12) (- (to) 12))) 0)) (and {(fromTo (from (to)) (to (handSite Mover)) count:(count at:(to))) (fromTo (from (if (is Mover P1) (+ (to) 12) (- (to) 12))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 12) (- (to) 12)))) (if (> (count at:(if (is Mover P1) (+ (to) (* 12 2)) (- (to) (* 12 2)))) 0) (fromTo (from (if (is Mover P1) (+ (to) (* 12 2)) (- (to) (* 12 2)))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) (* 12 2)) (- (to) (* 12 2)))))) (if (> (count at:(if (is Mover P1) (trackSite Move from:(to) "Track1" steps:1) (trackSite Move from:(to) "Track2" steps:1))) 1) (and (set Pending (if (is Mover P1) (trackSite Move from:(to) "Track1" steps:1) (trackSite Move from:(to) "Track2" steps:1))) (moveAgain)))}) (moveAgain))))))) (end (if (no Moves Mover) (byScore {(score P1 (+ (count Cell at:(handSite P1)) (count in:(sites P1)))) (score P2 (+ (count Cell at:(handSite P2)) (count in:(sites P2))))}))))) 
4x8 board. Two counters in each hole. Opening play: Two players play simultaneously, lifting and sowing counters from their outer rows. Rules for sowing and capturing are the same as in the main phase of the game except that all holes in each player's outer rows are considered to be in opposition and back captures can be made from them. Once a counter has been sown into the inner row, this ceases and captures can only be made from the inner row. The opening ends when both players reach an empty hole, and the first player to do so begins play in the main phase. Main phase: Play begins from any hole on the player's side of the board with counters in it. Singletons cannot move. Sowing happens in an anti-clockwise direction. If the last counter lands in an empty hole, the turn is over. For capturing: four holes are in opposition when one player has the front row hole occupied and the opponent has both of the holes opposite it occupied. If the last hole in a sowing is in opposition, the player takes the counters in both of the opponent's holes and places them in the empty hole from which the player lifted the counters. The player then sows the captured counters from this hole. Further captures in the sowing can occur in the same way. If the last counter lands on a hole that is occupied but not in opposition, these counters are picked up and sowing continues. Play ends when one player captures all the opponent's counters or one player cannot play. The player who cannot play loses. Each row has 8 holes.
(game "Pereauni" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "TrackCCW1" "0,E,N1,W" loop:True P1) (track "TrackCCW2" "16,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "TrackCCW1")) (regions "Home" P2 (sites Track "TrackCCW2")) (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top))) (regions "Outer" P1 (sites Bottom)) (regions "Outer" P2 (sites Top)) (piece "Seed" Shared)}) (rules (start (set Count 2 to:(union (sites P1 "Home") (sites P2 "Home")))) phases:{(phase "OuterPhase" (play (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover "Outer")) if:(if (is Prev Mover) (< 0 (count at:(from))) (< 1 (count at:(from))))) (then (sow count:(if (is Prev Mover) (var "Count") (count at:(last From))) "TrackCCW" owner:(mover) apply:(and (if (< 1 (count at:(to))) (and (moveAgain) (if (and (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (is In (to) (sites Mover "Inner"))) (and {(fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (if (is Mover P1) (- (to) 8) (+ (to) 8))) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (if (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (if (is Mover P1) (- (to) 8) (+ (to) 8))) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))))) (set Var "Replay" (if (is Mover P1) (- (to) 8) (+ (to) 8))) (if (= 1 (count at:(if (is Mover P1) (- (to) 8) (+ (to) 8)))) (set Var "Count" (+ {1 (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))) (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))})) (set Var "Count" (+ (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))) (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))))))}) (and (set Var "Replay" (to)) (set Var "Count" (count at:(to))))))) (if (!= 1 (value Player Mover)) (set Value Mover 1))))))) (nextPhase Mover (= 1 (count at:(last To afterConsequence:True))) "MainPhase")) (phase "MainPhase" (play (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover)) if:(if (is Prev Mover) (< 0 (count at:(from))) (< 1 (count at:(from))))) (then (sow count:(if (is Prev Mover) (var "Count") (count at:(last From))) "TrackCCW" owner:(mover) apply:(if (< 1 (count at:(to))) (and (moveAgain) (if (and {(is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (is In (to) (sites Mover "Inner"))}) (and {(fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (if (is Mover P1) (- (to) 8) (+ (to) 8))) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (if (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (if (is Mover P1) (- (to) 8) (+ (to) 8))) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))))) (set Var "Replay" (if (is Mover P1) (- (to) 8) (+ (to) 8))) (if (= 1 (count at:(if (is Mover P1) (- (to) 8) (+ (to) 8)))) (set Var "Count" (+ {1 (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))) (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))})) (set Var "Count" (+ (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))) (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))))))}) (and (set Var "Replay" (to)) (set Var "Count" (count at:(to))))))))))))} (end (if (no Moves Next) (result Mover Win))))) 
4x6-7 board. Two counters in each hole; before beginning each player rearranges these as they wish, with the following rules: The leftmost hole in the outer row must have the most counters; holes in the inner row may only have one counter. Initial phase: In this phase, only holes with two or fewer counters may be used to sow. Sowing occurs in an anti-clockwise direction, and when a counter lands in an occupied hole the sowing continues. When the final counter lands in an empty hole, the turn ends. If the empty hole is in the player's inner row, counters in the opponent's inner row opposite are captured, and if there are also counters in the opponent's outer row hole opposite, these are also taken. The initial phase ends for a player when two of the player's counters have been taken. On the next turn they must play from the hole with the largest number of counters, and from that point they may move from any hole. The rules for play remain the same as in the initial phase otherwise. The player who captures all of the opponent's counters wins. Each player has 6 holes by row.
(game "Quela" (players 2) (equipment {(mancalaBoard 4 6 store:None {(track "TrackCCW1" "0,E,N1,W" loop:True P1) (track "TrackCCW2" "12,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "TrackCCW1")) (regions "Home" P2 (sites Track "TrackCCW2")) (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top))) (map "LeftMost" {(pair P1 0) (pair P2 23)}) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 2 to:(union (sites P1 "Home") (sites P2 "Home")))) phases:{(phase "Rearrangement" (play (or (move (from (sites Mover "Home") if:(is Occupied (from))) (to (difference (sites Mover) (from)))) (if (and (all Sites (difference (sites Mover "Home") (mapEntry "LeftMost" Mover)) if:(> (count at:(mapEntry Mover)) (count at:(site)))) (all Sites (sites Mover "Inner") if:(= 1 (count at:(site))))) (move Pass)))) (nextPhase (all Passed) "InitialPhase")) (phase "InitialPhase" (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(or (is Prev Mover) (and (> 3 (count at:(from))) (is Occupied (from))))) (then (sow "TrackCCW" owner:(mover) apply:(if (< 1 (count at:(to))) (moveAgain) (if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 6) (- (to) 6))) (and (fromTo (from (if (is Mover P1) (+ (to) 6) (- (to) 6))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 6) (- (to) 6)))) (if (is Occupied (if (is Mover P1) (+ (to) (* 6 2)) (- (to) (* 6 2)))) (fromTo (from (if (is Mover P1) (+ (to) (* 6 2)) (- (to) (* 6 2)))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) (* 6 2)) (- (to) (* 6 2)))))))))))))) {(nextPhase P1 (< 1 (count Cell at:(handSite P2))) "MiddlePhase") (nextPhase P2 (< 1 (count Cell at:(handSite P1))) "MiddlePhase")}) (phase "MiddlePhase" (play (move Select (from (forEach (sites Mover "Home") if:(= (max (results from:(sites Mover "Home") to:(sites Mover "Home") (count at:(to)))) (count at:(site))))) (then (sow "TrackCCW" owner:(mover) apply:(if (< 1 (count at:(to))) (moveAgain) (if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 6) (- (to) 6))) (and (fromTo (from (if (is Mover P1) (+ (to) 6) (- (to) 6))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 6) (- (to) 6)))) (if (is Occupied (if (is Mover P1) (+ (to) (* 6 2)) (- (to) (* 6 2)))) (fromTo (from (if (is Mover P1) (+ (to) (* 6 2)) (- (to) (* 6 2)))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) (* 6 2)) (- (to) (* 6 2)))))))))))))) (nextPhase Mover "FinalPhase")) (phase "FinalPhase" (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(is Occupied (from))) (then (sow "TrackCCW" owner:(mover) apply:(if (< 1 (count at:(to))) (moveAgain) (if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 6) (- (to) 6))) (and (fromTo (from (if (is Mover P1) (+ (to) 6) (- (to) 6))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 6) (- (to) 6)))) (if (is Occupied (if (is Mover P1) (+ (to) (* 6 2)) (- (to) (* 6 2)))) (fromTo (from (if (is Mover P1) (+ (to) (* 6 2)) (- (to) (* 6 2)))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) (* 6 2)) (- (to) (* 6 2)))))))))))))) (end (if (no Moves Next) (result Mover Win))))})) 
4x8 board, played only along the perimeter. One to four counters per hole. Any number of players, holes are distributed equally among the players. Sowing occurs in an anti-clockwise direction. Each player owns the holes in which their counters are located at the beginning of their turn, and they must sow from the leftmost hole. When a counter falls into a hole containing counters belonging to the opponent, this hole and the counters in it are captured by the player, but remain in place and in play. When a player has a single counter and empty holes in from of it, this counter leaps to the next hole occupied by the opponent. The player who captures all of the opponent's holes wins.  4 seeds per hole. The board is a 4x8.
(game "Quendo" (players 4) (equipment {(mancalaBoard 4 8 store:None {(track "Track" "0,E,N,W,S2" loop:True)}) (piece "Seed" Each) (hand Each)}) (rules (start {(place "Seed1" (sites {0 1 2 3 4}) counts:{4}) (place "Seed2" (sites {5 6 7 15 23}) counts:{4}) (place "Seed3" (sites {31 30 29 28 27}) counts:{4}) (place "Seed4" (sites {26 25 24 16 8}) counts:{4})}) (play (if (!= 1 (count Pieces Mover)) (move Select (from (trackSite FirstSite from:(trackSite FirstSite if:(not (is Mover (who at:(to))))) if:(is Mover (who at:(to))))) (then (sow sowEffect:(if (and (!= (mover) (what at:(to))) (is Occupied (to))) (and (remove (to) count:(count at:(to))) (add (piece (id "Seed" Mover)) (to (to)) count:(count at:(to)))))))) (move (from (trackSite FirstSite from:(trackSite FirstSite if:(not (is Mover (who at:(to))))) if:(is Mover (who at:(to))))) (to (trackSite FirstSite from:(from) if:(is Enemy (who at:(to)))) (apply (and (remove (to) count:(count at:(to))) (add (piece (id "Seed" Mover)) (to (to)) count:(count at:(to))))))))) (end (forEach NonMover if:(no Pieces Player) (result Player Loss))))) 
4x7 board. Three counters in each hole in the outer row; before beginning each player rearranges these as they wish, with the following rules: The leftmost hole in the outer row must have the most counters; Each hole must have equal to or less than the number of the counters as the hole on its left; there can be a maximum of two holes with one counter in the inner row. Initial phase: Sowing occurs in an anti-clockwise direction, and when a counter lands in an occupied hole the sowing continues. When the final counter lands in an empty hole, the turn ends. If the empty hole is in the player's inner row, counters in the opponent's inner row opposite are captured, and if there are also counters in the opponent's outer row hole opposite, these are also taken. The initial phase ends for a player when they have one counter in each hole. After this, players can only move single counters into empty holes. The player who captures all of the opponent's counters wins.
(game "Quiela" (players 2) (equipment {(mancalaBoard 4 7 store:None {(track "TrackCCW1" "0,E,N1,W" loop:True P1) (track "TrackCCW2" "14,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "TrackCCW1")) (regions "Home" P2 (sites Track "TrackCCW2")) (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top))) (regions "Outer" P1 (sites Bottom)) (regions "Outer" P2 (sites Top)) (piece "Seed" Shared) (map "LeftMost" {(pair P1 0) (pair P2 27)}) (hand Each)}) (rules (start (set Count 3 to:(union (sites P1 "Outer") (sites P2 "Outer")))) phases:{(phase "Rearrangement" (play (or (move (from (sites Mover "Home") if:(is Occupied (from))) (to (difference (sites Mover) (from)))) (if (and {(all Sites (difference (sites Mover "Home") (mapEntry "LeftMost" Mover)) if:(> (count at:(mapEntry Mover)) (count at:(site)))) (all Sites (sites Mover "Home") if:(if (= (site) (if (is Mover P1) (ahead (site) W) (ahead (site) E))) True (<= (count at:(site)) (count at:(if (is Mover P1) (ahead (site) W) (ahead (site) E)))))) (>= 2 (count Sites in:(forEach (sites Mover "Inner") if:(= 1 (count at:(site))))))}) (move Pass)))) (nextPhase (all Passed) "InitialPhase")) (phase "InitialPhase" (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(is Occupied (from))) (then (sow "TrackCCW" owner:(mover) apply:(if (< 1 (count at:(to))) (moveAgain) (if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 7) (- (to) 7))) (and (fromTo (from (if (is Mover P1) (+ (to) 7) (- (to) 7))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 7) (- (to) 7)))) (if (is Occupied (if (is Mover P1) (+ (to) (* 7 2)) (- (to) (* 7 2)))) (fromTo (from (if (is Mover P1) (+ (to) (* 7 2)) (- (to) (* 7 2)))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) (* 7 2)) (- (to) (* 7 2)))))))))))))) (nextPhase Mover (all Sites (sites Mover "Home") if:(> 2 (count at:(site)))) "MainPhase")) (phase "MainPhase" (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(if (< 1 (count at:(from))) True (if (= 1 (count at:(from))) (is Empty (trackSite Move from:(from) "TrackCCW" steps:1))))) (then (sow "TrackCCW" owner:(mover) apply:(if (< 1 (count at:(to))) (moveAgain) (if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 7) (- (to) 7))) (and (fromTo (from (if (is Mover P1) (+ (to) 7) (- (to) 7))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 7) (- (to) 7)))) (if (is Occupied (if (is Mover P1) (+ (to) (* 7 2)) (- (to) (* 7 2)))) (fromTo (from (if (is Mover P1) (+ (to) (* 7 2)) (- (to) (* 7 2)))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) (* 7 2)) (- (to) (* 7 2)))))))))))))))} (end (forEach NonMover if:(all Sites (sites Player "Home") if:(= 0 (count at:(site)))) (result Player Loss))))) 
4x8 board. Two counters in each hole. Sowing proceeds in an anti-clockwise direction. The first move must begin from the second hole from the right in the player's outer row, and proceed as follows, and is played simultaneously by both players: sow the two counters from that first hole, capture the counters in the opponent's two opposite holes and sow them, starting in the rightmost hole in the outer row, capture from the opposite two holes on the opponent's side and sow them again from the same hole. When the final counter falls in an occupied hole, those counters are picked up and sowing continues. The opening move ends when the final counter falls in an empty hole. The main phase then begins. When the final counter falls into an occupied hole in the player's inner row and both of the opposite holes on the opponent's side of the board are occupied, the counters in the opposite holes are captured and sown beginning in the first hole that was sown into to begin the sowing that caused the capture. When the final counter falls into an occupied hole and a capture is not possible, the contents of the hole are picked up and sowing continues. When the final counter lands in an empty hole, the turn ends. Players cannot sow from a hole containing a single counter. The player who captures all of their opponent's counters wins.
(game "Ryakati" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "16,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (map "RightMostOuter" {(pair P1 7) (pair P2 24)}) (map "SecondHoleRightOuter" {(pair P1 6) (pair P2 25)}) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 2 to:(sites Board))) phases:{(phase "Opening1" (play (move Select (from (mapEntry "SecondHoleRightOuter" Mover)) (then (sow "Track" owner:(mover) apply:(and (fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (mapEntry "RightMostOuter" Mover)) count:2) (fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (mapEntry "RightMostOuter" Mover)) count:2)))))) (nextPhase Mover "Opening2")) (phase "Opening2" (play (move Select (from (mapEntry "RightMostOuter" Mover)) (then (sow count:4 "Track" owner:(mover) apply:(and (fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (mapEntry "RightMostOuter" Mover)) count:2) (fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (mapEntry "RightMostOuter" Mover)) count:2)) origin:True)))) (nextPhase Mover "Opening3")) (phase "Opening3" (play (move Select (from (if (is Prev Mover) (var "Replay") (mapEntry "RightMostOuter" Mover))) (then (sow count:(if (is Prev Mover) (count at:(last To)) 4) "Track" owner:(mover) apply:(if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to)))) origin:(not (is Prev Mover)))))) (nextPhase Mover (not (is Next Mover)) "Sowing")) (phase "Sowing" (play (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover "Home")) if:(> (count at:(from)) 1)) (then (sow "Track" owner:(mover) apply:(if (< 1 (count at:(to))) (if (and {(is In (to) (sites Mover "Inner")) (is Occupied (if (is Mover P1) (+ (to) 8) (- (to) 8))) (is Occupied (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))}) (and {(fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (last From)) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (sow (last From) count:(+ (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) "Track" owner:(mover))}) (and (moveAgain) (set Var "Replay" (to))))))))))} (end (forEach NonMover if:(all Sites (sites Player "Home") if:(= 0 (count at:(site)))) (result Player Loss))))) 
4x10-12 board (even numbers only). One counter in each hole, except for the third hole from the left of the inner row, which contains two, and the rightmost hole of the inner row, which is empty. Play must begin from the hole containing two counters. Sowing occurs in an anti-clockwise direction. When the final counter lands in an occupied hole. These are picked up and sowing continues. When the final counter falls in an empty hole, the contents of the hole in the opponent's inner row opposite this hole are captured; if there are also counters in the opponent's outer row, these are also captured, along with the contents of any other two holes on the opponent's side of the board. Single counters can be moved only when there are no holes with multiple counters and they may only be moved to an empty hole. The player who captures all of the opponent's counters wins. Each player has 10 holes by row.
(game "Spreta" (players 2) (equipment {(mancalaBoard 4 10 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "20,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (regions "Outer" P1 (sites Bottom)) (regions "Outer" P2 (sites Top)) (piece "Seed" Shared)}) (rules (start {(set Count 1 to:(union {(sites P1 "Outer") (sites P2 "Outer") (difference (sites P1 "Inner") (sites {12 19})) (difference (sites P2 "Inner") (sites {27 20}))})) (set Count 2 to:(sites {12 27}))}) phases:{(phase "Opening" (play (move Select (from (sites Mover) if:(= 2 (count at:(from)))) (then (sow "Track" owner:(mover))))) (nextPhase Mover "Playing")) (phase "Playing" (play (if (or (= 1 (var "ExtraCapture")) (= 2 (var "ExtraCapture"))) (move Remove (difference (sites Next "Home") (sites Empty)) count:(count at:(to)) (then (if (= 1 (var "ExtraCapture")) (and (moveAgain) (set Var "ExtraCapture" 2)) (set Var "ExtraCapture" 0)))) (priority {(move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover)) if:(< 1 (count at:(from)))) (then (sow "Track" owner:(mover) apply:(if (< 1 (count at:(to))) (moveAgain) (if (is In (to) (sites Mover "Inner")) (and {(if (> (count at:(if (is Mover P1) (+ (to) 10) (- (to) 10))) 0) (remove (if (is Mover P1) (+ (to) 10) (- (to) 10)) count:(count at:(if (is Mover P1) (+ (to) 10) (- (to) 10))))) (if (> (count at:(if (is Mover P1) (+ (to) (* 10 2)) (- (to) (* 10 2)))) 0) (remove (if (is Mover P1) (+ (to) (* 10 2)) (- (to) (* 10 2))) count:(count at:(if (is Mover P1) (+ (to) (* 10 2)) (- (to) (* 10 2)))))) (set Var "ExtraCapture" 1) (moveAgain)})))))) (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover)) if:(and (= 1 (count at:(from))) (= 0 (count at:(trackSite Move from:(from) steps:1))))) (then (sow "Track" owner:(mover) apply:(if (< 1 (count at:(to))) (moveAgain) (if (is In (to) (sites Mover "Inner")) (and {(if (> (count at:(if (is Mover P1) (+ (to) 10) (- (to) 10))) 0) (remove (if (is Mover P1) (+ (to) 10) (- (to) 10)) count:(count at:(if (is Mover P1) (+ (to) 10) (- (to) 10))))) (if (> (count at:(if (is Mover P1) (+ (to) (* 10 2)) (- (to) (* 10 2)))) 0) (remove (if (is Mover P1) (+ (to) (* 10 2)) (- (to) (* 10 2))) count:(count at:(if (is Mover P1) (+ (to) (* 10 2)) (- (to) (* 10 2)))))) (set Var "ExtraCapture" 1) (moveAgain)}))))))}))))} (end (if (all Sites (sites Next "Home") if:(= 0 (count at:(site)))) (result Mover Win))))) 
4x8=20 holes, with an even number per row. One counter in each hole, except the right-hand end row of the inner row. Sowing occurs in an anti-clockwise direction, only into an empty hole. When a counter lands in a hole in the inner row and the opponent's opposite inner row hole is empty, the contents of the opponent's opposite outer row hole are captured. The player who captures all of the opponent's pieces wins.
(game "Sute" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "16,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (piece "Seed" Shared)}) (rules (start (set Count 1 to:(difference (union (sites P1 "Home") (sites P2 "Home")) (union (intersection (sites Right) (sites Row 1)) (intersection (sites Left) (sites Row 2)))))) (play (move Select (from (sites Mover "Home") if:(and (> (count at:(from)) 0) (= 0 (count at:(trackSite Move from:(from) steps:1))))) (then (sow "Track" owner:(mover) apply:(if (and (= (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))) 0) (is In (to) (sites Mover "Inner"))) (remove (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))))))) (end (forEach NonMover if:(all Sites (sites Player "Home") if:(= 0 (count at:(site)))) (result Player Loss))))) 
4x8 board. May have one or two stores per player. Stores are located to the right hand side of the player's two rows, centered with respect to the player's two rows. If each player has two stores, the second store is located between the fourth and fifth holes of the player's rows; i.e., in the center of the board. One counter in each hole except the stores. Opening play: Player sows from any one of their holes, thus making a pair. They then take the counter in the next hole and sow it, making another pair. This continues until the last pair is made. When the last pair is made, the player sows this pair normally. Main phase: Sowing occurs in an anti-clockwise direction. When the final counter falls into an occupied hole, these are picked up and sowing continues. The turn ends when the final counter falls into an empty hole. When this empty hole is in the inner row, the counters in the opponent's hole opposite are captured. If the opponent's inner row hole are occupied, then any contents in the outer row opposite are also captured. Several rules apply to the stores: They are not used during the opening play; They may only hold one counter at a time; The counter in the store cannot be captured; It is the player's choice whether to include the store in sowing; they are considered to be in the player's inner row of holes for the purposes of sowing. The game is played on a 4x8 board.
(game "Tchela" (players 2) (equipment {(board (merge {(square 4) (shift 5 0 (square 4)) (shift 4 0.5 (square 1)) (shift 4 2.5 (square 1)) (shift -1 2.5 (square 1)) (shift 9 0.5 (square 1))}) {(track "TrackCCW1" {0 1 2 3 16 17 18 19 23 22 21 20 7 6 5 4} loop:True P1) (track "TrackCCW2" {8 9 10 11 24 25 26 27 31 30 29 28 15 14 13 12} loop:True P2) (track "TrackExtendedCCW1" {0 1 2 3 16 17 18 19 23 22 21 20 32 7 6 5 4} loop:True P1) (track "TrackExtendedCCW2" {8 9 10 11 33 24 25 26 27 31 30 29 28 15 14 13 12} loop:True P2)} use:Vertex) (piece "Seed" Shared) (regions "HomeNotExtented" P1 (sites Track "TrackCCW1")) (regions "HomeNotExtented" P2 (sites Track "TrackCCW2")) (regions "Home" P1 (sites Track "TrackExtendedCCW1")) (regions "Home" P2 (sites Track "TrackExtendedCCW2")) (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top))) (map {(pair P1 34) (pair P2 35)}) (map "ExtraStore" {(pair P1 32) (pair P2 33)})}) (rules (start (set Count 1 to:(difference (sites Board) (sites {32 33 34 35})))) phases:{(phase "Opening" (play (move Select (from (if (< (value Player Mover) 0) (sites Mover "HomeNotExtented") (sites {(trackSite Move from:(value Player Mover) "TrackCCW" steps:2)}))) (then (and (sow "TrackCCW" owner:(mover)) (set Value Mover (last To)))))) (nextPhase Mover (= 0 (count at:(trackSite Move from:(value Player Mover) "TrackCCW" steps:2))) "OpeningPair")) (phase "OpeningPair" (play (move Select (from (sites {(trackSite Move from:(value Player Mover) "TrackCCW" steps:1)})) (then (sow "TrackCCW" owner:(mover))))) (nextPhase Mover "Playing")) (phase "Playing" (play (or (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "HomeNotExtented")) if:(< 0 (count at:(from)))) (then (sow "TrackCCW" owner:(mover) apply:(if (> (count at:(to)) 1) (moveAgain) (if (and (is In (to) (sites Mover "Inner")) (> (count at:(if (is Mover P1) (+ (to) 4) (- (to) 4))) 0)) (and (fromTo (from (if (is Mover P1) (+ (to) 4) (- (to) 4))) (to (mapEntry Mover)) count:(count at:(if (is Mover P1) (+ (to) 4) (- (to) 4)))) (if (> (count at:(if (is Mover P1) (+ (to) 4) (- (to) 4))) 0) (fromTo (from (if (is Mover P1) (+ (to) (* 4 2)) (- (to) (* 4 2)))) (to (mapEntry Mover)) count:(count at:(if (is Mover P1) (+ (to) (* 4 2)) (- (to) (* 4 2)))))))))))) (do (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(< 0 (count at:(from)))) (then (sow "TrackExtendedCCW" owner:(mover) apply:(if (!= (to) (mapEntry "ExtraStore" Mover)) (if (> (count at:(to)) 1) (moveAgain) (if (and (is In (to) (sites Mover "Inner")) (> (count at:(if (is Mover P1) (+ (to) 4) (- (to) 4))) 0)) (and (fromTo (from (if (is Mover P1) (+ (to) 4) (- (to) 4))) (to (mapEntry Mover)) count:(count at:(if (is Mover P1) (+ (to) 4) (- (to) 4)))) (if (> (count at:(if (is Mover P1) (+ (to) 4) (- (to) 4))) 0) (fromTo (from (if (is Mover P1) (+ (to) (* 4 2)) (- (to) (* 4 2)))) (to (mapEntry Mover)) count:(count at:(if (is Mover P1) (+ (to) (* 4 2)) (- (to) (* 4 2))))))))))))) ifAfterwards:(<= (count at:(mapEntry "ExtraStore" Mover)) 1)))))} (end (if (no Moves Mover) (byScore {(score P1 (+ (count at:(mapEntry P1)) (count in:(sites P1 "Home")))) (score P2 (+ (count at:(mapEntry P2)) (count in:(sites P2 "Home"))))}))))) 
4x4, 8, 10, 16, or 22 board. Two counters in each hole. Sowing occurs in an anti-clockwise direction. When the final counter of a sowing lands in an occupied hole, the contents are picked up and sowing continues. When the final counter lands in an empty hole in the player's inner row, the contents of the opponent's hole in the inner row opposite it are captured, and if there are counters also in the corresponding outer row hole, these are also captured. The player may also capture from another hole from the opponent's side of the board of their choosing. The turn ends. If the final counter lands in an empty hole in the player's outer row, the turn ends. Play continues until one player captures all of the opponent's counters, thus winning. Each player has 4 holes on each row.
(game "Tshuba" (players 2) (equipment {(mancalaBoard 4 4 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "8,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 2 to:(union (sites P1 "Home") (sites P2 "Home")))) (play (if (= 1 (var "ExtraCapture")) (move Remove (difference (sites Next "Home") (sites Empty)) count:(count at:(to)) (then (set Var "ExtraCapture" 0))) (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover)) if:(< 0 (count at:(from)))) (then (sow "Track" owner:(mover) apply:(if (< 1 (count at:(to))) (moveAgain) (if (is In (to) (sites Mover "Inner")) (and {(if (> (count at:(if (is Mover P1) (+ (to) 4) (- (to) 4))) 0) (remove (if (is Mover P1) (+ (to) 4) (- (to) 4)) count:(count at:(if (is Mover P1) (+ (to) 4) (- (to) 4))))) (if (> (count at:(if (is Mover P1) (+ (to) (* 4 2)) (- (to) (* 4 2)))) 0) (remove (if (is Mover P1) (+ (to) (* 4 2)) (- (to) (* 4 2))) count:(count at:(if (is Mover P1) (+ (to) (* 4 2)) (- (to) (* 4 2)))))) (set Var "ExtraCapture" 1) (moveAgain)})))))))) (end (if (all Sites (sites Next "Home") if:(= 0 (count at:(site)))) (result Mover Win))))) 
4x6-21 board; 8 is most common, 12, 15, and 18 are also popular. Two counters in each hole in the players' outer rows. Before the game starts, players choose to make additional captures from one, two, or three holes. Sowing occurs in an anti-clockwise direction, only in the two rows belonging to the player. When the final counter lands in an occupied hole, these are picked up and sowing continues. When the final counter lands in an empty hole in the inner row, any counters in the opposite hole in the opponent's inner row are captured. If there also are counters in the opposite hole in the opponent's outer row, these are also captured, but only if there was first a capture from the inner row hole. The player then captures again, from the agreed-upon number of extra holes, chosen from any of the opponent's holes. Players cannot sow from a hole with a single counter unless there are no holes with multiple counters. Single counters can only be sown into an empty hole. Play continues until one player has captured all of the opponent's counters, thus winning the game. 3 extra captures. 8 Holes per row.
(game "Tsoro (Additional Capture)" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "16,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (piece "Seed" Shared)}) (rules (start (set Count 2 to:(union (sites Top) (sites Bottom)))) (play (if (< 0 (var)) (move Remove (forEach (sites Next) if:(< 0 (count at:(site)))) (then (and (if (< 1 (var)) (moveAgain)) (set Var (- (var) 1))))) (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(if (not (all Sites (forEach (sites Mover) if:(< 1 (count at:(site)))) if:(= 0 (count at:(site))))) (> (count at:(from)) 1) (and (= (count at:(from)) 1) (= 0 (count at:(trackSite Move from:(from) Mover steps:1)))))) (then (sow "Track" owner:(mover) apply:(if (= (count at:(to)) 1) (if (is In (to) (sites Mover "Inner")) (if (> (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))) 0) (and {(remove (if (is Mover P1) (+ (to) 8) (- (to) 8))) (if (> (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) 0) (remove (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2))))) (moveAgain) (set Var 3)}))) (moveAgain))))))) (end (forEach NonMover if:(all Sites (sites Player "Home") if:(= 0 (count at:(site)))) (result Player Loss))))) 
4x13-19 board. Two counters in every hole, except the leftmost in both of a player's rows, which are empty, and the second from the left in the inner row, which has one. Sowing occurs in an anti-clockwise direction. When the final counter lands in an occupied hole, these counters are picked up and sowing continues. Captures are made when the final counters lands in an empty hole in the inner row, capturing the contents of the opponent's opposite inner row hole, as well as the contents of the outer row hole only if there was a capture from the inner row hole. Captures from extra holes are also made, which are graduated based on the number of captures the player has made. On their first turn, players sow from the third hole from the left in the front row. This triggers a capture of the counters in the opposite holes in the opponent's inner and outer rows, plus the contents of any other five holes on the opponent's side of the board. In subsequent turns, sowing must occur from a hole which follows an empty hole according to the circuit of the holes. On their second capture, the player captures three extra holes. All other subsequent captures capture from two extra holes. Sowing a single counter cannot result in a capture. The player who captures all of their opponent's counters wins. Each row has 13 holes.
(game "Tsoro (Baia)" (players 2) (equipment {(mancalaBoard 4 13 store:None {(track "TrackCCW1" "0,E,N1,W" loop:True P1) (track "TrackCCW2" "26,E,N1,W" loop:True P2) (track "TrackCW1" "12,W,N1,E" loop:True P1) (track "TrackCW2" "39,E,S1,W" loop:True P2)}) (regions "Home" P1 (sites Track "TrackCCW1")) (regions "Home" P2 (sites Track "TrackCCW2")) (regions "Inner" P1 (difference (sites Track "TrackCCW1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "TrackCCW2") (sites Top))) (regions "Outer" P1 (sites Bottom)) (regions "Outer" P2 (sites Top)) (regions "FirstMove" P1 (difference (expand (intersection (difference (sites Track "TrackCCW1") (sites Bottom)) (sites Left)) steps:2 E) (expand (intersection (difference (sites Track "TrackCCW1") (sites Bottom)) (sites Left)) E))) (regions "FirstMove" P2 (difference (expand (intersection (difference (sites Track "TrackCCW2") (sites Top)) (sites Right)) steps:2 W) (expand (intersection (difference (sites Track "TrackCCW2") (sites Top)) (sites Right)) W))) (piece "Seed" Shared) (hand Each)}) (rules (start {(set Count 2 to:(difference (sites P1 "Outer") (sites Left))) (set Count 2 to:(difference (sites P2 "Outer") (sites Right))) (set Count 2 to:(difference (sites P1 "Inner") (expand (sites Left)))) (set Count 2 to:(difference (sites P2 "Inner") (expand (sites Right)))) (set Count 1 to:(difference (sites P1 "Inner") (union (sites Left) (difference (sites P1 "Inner") (expand (sites Left)))))) (set Count 1 to:(difference (sites P2 "Inner") (union (sites Right) (difference (sites P2 "Inner") (expand (sites Right))))))}) phases:{(phase "FirstTurn" (play (if (>= 0 (var "FreeCapture")) (move Select (from (sites Mover "FirstMove")) (then (sow "TrackCCW" owner:(mover) apply:(if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 13) (- (to) 13))) (and {(fromTo (from (if (is Mover P1) (+ (to) 13) (- (to) 13))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 13) (- (to) 13)))) (if (is Occupied (if (is Mover P1) (+ (to) (* 13 2)) (- (to) (* 13 2)))) (fromTo (from (if (is Mover P1) (+ (to) (* 13 2)) (- (to) (* 13 2)))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) (* 13 2)) (- (to) (* 13 2)))))) (set Value Mover (+ 1 (value Player Mover))) (set Var "FreeCapture" 5) (moveAgain)})))))) (move (from (sites Next "Home") if:(and (is Occupied (from)) (not (is In (from) (sites Next "FirstMove"))))) (to (handSite Mover)) count:(count at:(from)) (then (and (set Var "FreeCapture" (- (var "FreeCapture") 1)) (if (< 1 (var "FreeCapture")) (moveAgain))))))) (nextPhase Mover (not (is Next Mover)) "Main")) (phase "Main" (play (if (>= 0 (var "FreeCapture")) (or (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover "Home")) if:(and (< 1 (count at:(from))) (if (is Prev Mover) True (is Empty (trackSite Move from:(from) "TrackCW" steps:1))))) (then (sow "TrackCCW" owner:(mover) apply:(if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to))}) (if (is In (to) (sites Mover "Inner")) (if (is Occupied (if (is Mover P1) (+ (to) 13) (- (to) 13))) (and {(fromTo (from (if (is Mover P1) (+ (to) 13) (- (to) 13))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 13) (- (to) 13)))) (if (is Occupied (if (is Mover P1) (+ (to) (* 13 2)) (- (to) (* 13 2)))) (fromTo (from (if (is Mover P1) (+ (to) (* 13 2)) (- (to) (* 13 2)))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) (* 13 2)) (- (to) (* 13 2)))))) (set Value Mover (+ 1 (value Player Mover))) (if (= 0 (value Player Mover)) (set Var "FreeCapture" 3) (set Var "FreeCapture" 2)) (moveAgain)}))))))) (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover "Home")) if:(and (= 1 (count at:(from))) (if (is Prev Mover) True (is Empty (trackSite Move from:(from) "TrackCW" steps:1))))) (then (sow "TrackCCW" owner:(mover) apply:(if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to))})))))) (move (from (sites Next "Home") if:(and (is Occupied (from)) (not (is In (from) (sites Next "FirstMove"))))) (to (handSite Mover)) count:(count at:(from)) (then (and (set Var "FreeCapture" (- (var "FreeCapture") 1)) (if (< 1 (var "FreeCapture")) (moveAgain))))))))} (end (forEach NonMover if:(all Sites (sites Player) if:(= 0 (count at:(site)))) (result Player Loss))))) 
4x6-21 board; 8 is most common, 12, 15, and 18 are also popular. Two counters in each hole in the players' outer rows. Sowing occurs in an anti-clockwise direction, only in the two rows belonging to the player. When the final counter lands in an occupied hole, these are picked up and sowing continues. When the final counter lands in an empty hole in the inner row, any counters in the opposite hole in the opponent's inner row are captured. If there also are counters in the opposite hole in the opponent's outer row, these are also captured, but only if there was first a capture from the inner row hole. Captured counters are then sown on the player's own side of the board, starting with the hole following the one from which the capture was triggered. Players cannot sow from a hole with a single counter unless there are no holes with multiple counters. Single counters can only be sown into an empty hole. Play continues until one player has captured all of the opponent's counters, thus winning the game.  8 Holes per row.
(game "Tsoro (Reentered Captures)" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "16,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (piece "Seed" Shared)}) (rules (start (set Count 2 to:(union (sites Top) (sites Bottom)))) (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(if (not (all Sites (forEach (sites Mover) if:(< 1 (count at:(site)))) if:(= 0 (count at:(site))))) (> (count at:(from)) 1) (and (= (count at:(from)) 1) (= 0 (count at:(trackSite Move from:(from) Mover steps:1)))))) (then (sow "Track" owner:(mover) apply:(if (= (count at:(to)) 1) (if (is In (to) (sites Mover "Inner")) (if (> (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))) 0) (and {(fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (to)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (if (> (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) 0) (fromTo (from (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (to (to)) count:(count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))))) (sow (to) count:(+ (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) "Track" owner:(mover))}))) (moveAgain)))))) (end (forEach NonMover if:(all Sites (sites Player "Home") if:(= 0 (count at:(site)))) (result Player Loss))))) 
4x6-21 board; 8 is most common, 12, 15, and 18 are also popular. Two counters in each hole in the players' outer rows. Sowing occurs in an anti-clockwise direction, only in the two rows belonging to the player. When the final counter lands in an occupied hole, these are picked up and sowing continues. When the final counter lands in an empty hole in the inner row, any counters in the opposite hole in the opponent's inner row are captured. If there also are counters in the opposite hole in the opponent's outer row, these are also captured, but only if there was first a capture from the inner row hole. Players cannot sow from a hole with a single counter unless there are no holes with multiple counters. Single counters can only be sown into an empty hole. Play continues until one player has captured all of the opponent's counters, thus winning the game. 8 Holes per row.
(game "Tsoro" (players 2) (equipment {(mancalaBoard 4 8 store:None {(track "Track1" "0,E,N1,W" loop:True P1) (track "Track2" "16,E,N1,W" loop:True P2)}) (regions "Home" P1 (sites Track "Track1")) (regions "Home" P2 (sites Track "Track2")) (regions "Inner" P1 (difference (sites Track "Track1") (sites Bottom))) (regions "Inner" P2 (difference (sites Track "Track2") (sites Top))) (piece "Seed" Shared)}) (rules (start (set Count 2 to:(union (sites Top) (sites Bottom)))) (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(if (not (all Sites (forEach (sites Mover) if:(< 1 (count at:(site)))) if:(= 0 (count at:(site))))) (> (count at:(from)) 1) (and (= (count at:(from)) 1) (= 0 (count at:(trackSite Move from:(from) Mover steps:1)))))) (then (sow "Track" owner:(mover) apply:(if (= (count at:(to)) 1) (if (is In (to) (sites Mover "Inner")) (if (> (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))) 0) (and (remove (if (is Mover P1) (+ (to) 8) (- (to) 8))) (if (> (count at:(if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))) 0) (remove (if (is Mover P1) (+ (to) (* 8 2)) (- (to) (* 8 2)))))))) (moveAgain)))))) (end (forEach NonMover if:(all Sites (sites Player "Home") if:(= 0 (count at:(site)))) (result Player Loss))))) 
6x3 or 6 board. Two counters in each hole. Sowing occurs from one of the holes in the player's outermost row which contains counters, in either direction. Sowing moves in a boustrophedon path along the holes, moving from the last hole in the innermost row to the beginning of the outer row. When the final counter lands in an occupied hole, the contents of this hole are picked up and sowing continues. If this hole is in the player's inner row, the contents of the opponent's hole opposite it are captured, and these counters are also used along with the hole in which the last counter fell for the sowing to continue. If the opponent's inner row hole is empty, counters may be captured from their central row, and if both the inner and central rows are empty, captures may be made from the outer hole. Sowing ends when the final counter lands in an empty hole. When a player has only one counter on their side of the board, it may capture by moving from the central row directly to the inner row hole above it to make a capture (i.e., without following the normal track), and on the move prior to the capture, from the outer to the central row. Play continues until one player has captured all of the counters. 6 Holes per row.
(game "Katro" (players 2) (equipment {(mancalaBoard 6 6 store:None {(track "TrackCCW1" "0,E,N1,W,N1,E" loop:True P1) (track "TrackCW1" "5,W,N1,E,N1,W" loop:True P1) (track "TrackCW2" "18,E,N1,W,N1,E" loop:True P2) (track "TrackCCW2" "23,W,N1,E,N1,W" loop:True P2)}) (piece "Seed" Shared) (regions "Home" P1 (sites Track "TrackCCW1")) (regions "Home" P2 (sites Track "TrackCCW2")) (regions "Inner" P1 (sites Row 2)) (regions "Inner" P2 (sites Row 3)) (regions "Middle" P1 (sites Row 1)) (regions "Middle" P2 (sites Row 4)) (regions "Outer" P1 (sites Bottom)) (regions "Outer" P2 (sites Top))}) (rules (start (set Count 2 to:(sites Board))) (play (or {(if (or (= (value Player Mover) 1) (<= (value Player Mover) 0)) (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (if (!= 0 (count in:(sites Mover "Outer"))) (sites Mover "Outer") (if (!= 0 (count in:(sites Mover "Middle"))) (sites Mover "Middle") (sites Mover "Inner")))) if:(> (count at:(from)) 0)) (then (sow "TrackCCW" owner:(mover) apply:(if (> (count at:(to)) 1) (and {(if (<= (value Player Mover) 0) (set Value Mover 1)) (moveAgain) (if (is In (to) (sites Mover "Inner")) (if (!= 0 (count at:(if (is Mover P1) (+ (to) 6) (- (to) 6)))) (fromTo (from (if (is Mover P1) (+ (to) 6) (- (to) 6))) (to (to)) count:(count at:(if (is Mover P1) (+ (to) 6) (- (to) 6)))) (if (!= 0 (count at:(if (is Mover P1) (+ (to) (* 6 2)) (- (to) (* 6 2))))) (fromTo (from (if (is Mover P1) (+ (to) (* 6 2)) (- (to) (* 6 2)))) (to (to)) count:(count at:(if (is Mover P1) (+ (to) (* 6 2)) (- (to) (* 6 2))))) (if (!= 0 (count at:(if (is Mover P1) (+ (to) (* 6 3)) (- (to) (* 6 3))))) (fromTo (from (if (is Mover P1) (+ (to) (* 6 3)) (- (to) (* 6 3)))) (to (to)) count:(count at:(if (is Mover P1) (+ (to) (* 6 3)) (- (to) (* 6 3)))))))))}) (set Value Mover 0)))))) (if (or (= (value Player Mover) 2) (<= (value Player Mover) 0)) (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (if (!= 0 (count in:(sites Mover "Outer"))) (sites Mover "Outer") (if (!= 0 (count in:(sites Mover "Middle"))) (sites Mover "Middle") (sites Mover "Inner")))) if:(> (count at:(from)) 0)) (then (sow "TrackCW" owner:(mover) apply:(if (> (count at:(to)) 1) (and {(if (<= (value Player Mover) 0) (set Value Mover 2)) (moveAgain) (if (is In (to) (sites Mover "Inner")) (if (!= 0 (count at:(if (is Mover P1) (+ (to) 6) (- (to) 6)))) (fromTo (from (if (is Mover P1) (+ (to) 6) (- (to) 6))) (to (to)) count:(count at:(if (is Mover P1) (+ (to) 6) (- (to) 6)))) (if (!= 0 (count at:(if (is Mover P1) (+ (to) (* 6 2)) (- (to) (* 6 2))))) (fromTo (from (if (is Mover P1) (+ (to) (* 6 2)) (- (to) (* 6 2)))) (to (to)) count:(count at:(if (is Mover P1) (+ (to) (* 6 2)) (- (to) (* 6 2))))) (if (!= 0 (count at:(if (is Mover P1) (+ (to) (* 6 3)) (- (to) (* 6 3))))) (fromTo (from (if (is Mover P1) (+ (to) (* 6 3)) (- (to) (* 6 3)))) (to (to)) count:(count at:(if (is Mover P1) (+ (to) (* 6 3)) (- (to) (* 6 3)))))))))}) (set Value Mover 0)))))) (if (and (= (count in:(sites Mover "Home")) 1) (= (count in:(sites Mover "Outer")) 1)) (move (from (sites Mover "Outer") if:(> (count at:(from)) 0)) (to (if (is Mover P1) (ahead (from) N) (ahead (from) S))))) (if (and (= (count in:(sites Mover "Home")) 1) (= (count in:(sites Mover "Middle")) 1)) (move (from (sites Mover "Middle") if:(and (> (count at:(from)) 0) (< 1 (count in:(sites Column (column of:(from))))))) (to (if (is Mover P1) (ahead (from) N) (ahead (from) S))) (then (and (if (!= 0 (count at:(if (is Mover P1) (+ (last To) 6) (- (last To) 6)))) (fromTo (from (if (is Mover P1) (+ (last To) 6) (- (last To) 6))) (to (last To)) count:(count at:(if (is Mover P1) (+ (last To) 6) (- (last To) 6)))) (if (!= 0 (count at:(if (is Mover P1) (+ (last To) (* 6 2)) (- (last To) (* 6 2))))) (fromTo (from (if (is Mover P1) (+ (last To) (* 6 2)) (- (last To) (* 6 2)))) (to (last To)) count:(count at:(if (is Mover P1) (+ (last To) (* 6 2)) (- (last To) (* 6 2))))) (if (!= 0 (count at:(if (is Mover P1) (+ (last To) (* 6 3)) (- (last To) (* 6 3))))) (fromTo (from (if (is Mover P1) (+ (last To) (* 6 3)) (- (last To) (* 6 3)))) (to (last To)) count:(count at:(if (is Mover P1) (+ (last To) (* 6 3)) (- (last To) (* 6 3)))))))) (moveAgain)))))})) (end (forEach NonMover if:(all Sites (sites Player "Home") if:(= 0 (count at:(site)))) (result Player Loss))))) 
Two rows of twelve holes in the central part of the board, one hole on either end of this, two rows of two outside of these single holes on both sides of the board, and one final hole on either end of the board. Three counters in each hole. Sowing occurs only in the player's row; players use the inner single hole to their left; the outer single hole to the right. Sowing can occur in either direction. Captures are made when a counter falls into an empty hole. The counters in the opponent's opposite hole are captured. When the final counter of a sowing ends in a player's empty inner single holes, the counters in the opponent's inner single hole are captured. If it lands in a player's empty outer single hole, the counters in the opponent's outer single hole are captured. Single counters can be sown, but these cannot capture more than one of the opponent's counters. If the final counter falls into an occupied hole, the contents of this hole are picked up and sowing continues in the same direction. A player can sow such that they can make a capture from the hole in which the sowing began, but this cannot be done by sowing two or fewer counters. The player who has no counters remaining in their row loses. It is customary to play a series of round to determine the winner.
(game "Mbelele" (players 2) (equipment {(board (merge {(rectangle 2 12) (shift -1 0.5 (square 1)) (shift -3 0 (square 2)) (shift -4 0.5 (square 1)) (shift 12 0.5 (square 1)) (shift 13 0 (square 2)) (shift 15 0.5 (square 1))}) {(track "TrackCCW1" "25,26,24,0,E,31,32,35" loop:True P1) (track "TrackCCW2" "34,33,30,23,W,28,27,29" loop:True P2) (track "TrackCW1" "35,32,31,11,W,24,26,25" loop:True P1) (track "TrackCW2" "29,27,28,12,E,30,33,34" loop:True P2)} use:Vertex) (piece "Seed" Shared) (map "Opposite" {(pair 29 35) (pair 35 29) (pair 24 30) (pair 30 24) (pair 25 27) (pair 26 28) (pair 0 12) (pair 1 13) (pair 2 14) (pair 3 15) (pair 4 16) (pair 5 17) (pair 6 18) (pair 7 19) (pair 8 20) (pair 9 21) (pair 10 22) (pair 11 23) (pair 31 33) (pair 32 34) (pair 27 25) (pair 28 26) (pair 12 0) (pair 13 1) (pair 14 2) (pair 15 3) (pair 16 4) (pair 17 5) (pair 18 6) (pair 19 7) (pair 20 8) (pair 21 9) (pair 22 10) (pair 23 11) (pair 33 31) (pair 34 32)}) (regions P1 (union (sites Bottom) (sites {24 35}))) (regions P2 (union (sites Top) (sites {29 30})))}) (rules (start (set Count 3 to:(sites Board))) (play (or (if (!= 2 (var "NumCapture")) (or (if (!= (var "Direction") 2) (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover)) if:(and (if (is Prev Mover) True (= 1 (count at:(from)))) (is Occupied (from)))) (then (sow "TrackCCW" owner:(mover) apply:(if (= 1 (count at:(to))) (and {(if (is Occupied (mapEntry "Opposite" (to))) (remove (mapEntry "Opposite" (to)) count:1)) (set Var "Direction" 0) (set Var "NumCapture" 0)}) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 1) (set Var "NumCapture" 1)})))))) (if (!= (var "Direction") 1) (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover)) if:(and (if (is Prev Mover) True (= 1 (count at:(from)))) (is Occupied (from)))) (then (sow "TrackCW" owner:(mover) apply:(if (= 1 (count at:(to))) (and {(if (is Occupied (mapEntry "Opposite" (to))) (remove (mapEntry "Opposite" (to)) count:1)) (set Var "Direction" 0) (set Var "NumCapture" 0)}) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 2) (set Var "NumCapture" 1)})))))))) (if (!= 1 (var "NumCapture")) (or (if (!= (var "Direction") 2) (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover)) if:(and (if (is Prev Mover) True (< 1 (count at:(from)))) (is Occupied (from)))) (then (sow "TrackCCW" owner:(mover) apply:(if (= 1 (count at:(to))) (and {(if (is Occupied (mapEntry "Opposite" (to))) (remove (mapEntry "Opposite" (to)) count:(count at:(to)))) (set Var "Direction" 0) (set Var "NumCapture" 0)}) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 1) (set Var "NumCapture" 2)})))))) (if (!= (var "Direction") 1) (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover)) if:(and (if (is Prev Mover) True (< 1 (count at:(from)))) (is Occupied (from)))) (then (sow "TrackCW" owner:(mover) apply:(if (= 1 (count at:(to))) (and {(if (is Occupied (mapEntry "Opposite" (to))) (remove (mapEntry "Opposite" (to)) count:(count at:(to)))) (set Var "Direction" 0) (set Var "NumCapture" 1)}) (and {(moveAgain) (set Var "Replay" (to)) (set Var "Direction" 2) (set Var "NumCapture" 2)})))))))))) (end (forEach NonMover if:(all Sites (sites Player) if:(= 0 (count at:(site)))) (result Player Loss))))) 
Two rows of five holes arranged in a circle around four stores in the center. Each player has five holes on one half of the circle. Ten counters in each hole. Players sow from their holes, and can choose to sow any number of counters, but must leave at least one in the starting hole. Sowing occurs in an anti-clockwise direction. If sowing ends in a hole making its contents an odd number of counters, they are captured, but not more than nine. If the sowing ends and the last counter makes the contents of a hole an even number and the next hole has an odd number of counters, the contents of the odd hole are taken, but not more than nine. In both situations, if there is an unbroken sequence of holes with an odd number of counters, these are all taken, but not more than nine from each.
(game "Okwe (Achalla)" (players 2) (equipment {(board (add (concentric {10}) vertices:{{0.45 0.45} {-0.45 -0.45} {0.45 -0.45} {-0.45 0.45}}) (track "Track" {0 2 4 6 8 9 7 5 3 1} loop:True) use:Vertex) (regions P1 (sites {0 1 2 3 4})) (regions P2 (sites {5 6 7 8 9})) (map {(pair P1 11) (pair P2 10)}) (piece "Seed" Shared)}) (rules (start (set Count 10 to:(sites Track))) (play (forEach Site (forEach (sites Mover) if:(< 1 (count at:(site)))) (forEach Value min:2 max:(count at:(site)) (do (set Var (value)) next:(move Select (from (site)) (then (sow count:(var) if:True apply:(if (and (<= (count at:(to)) 9) (is Odd (count at:(to)))) (fromTo (from (to)) (to (mapEntry (mover))) count:(count at:(to))) (if (and (<= (count at:(trackSite Move from:(to) steps:1)) 9) (is Odd (count at:(trackSite Move from:(to) steps:1)))) (fromTo (from (trackSite Move from:(to) steps:1)) (to (mapEntry (mover))) count:(count at:(trackSite Move from:(to) steps:1))))) origin:True backtracking:(and (<= (count at:(to)) 9) (is Odd (count at:(to))))))))))) (end (if (and (no Moves P1) (no Moves P2)) (byScore {(score P1 (count at:(mapEntry P1))) (score P2 (count at:(mapEntry P2)))}))))) 
Played by two to five players. Each player has three heaps of counters, with twelve counters per heap. Sowing occurs in an anti-clockwise direction. When a player creates a heap containing three counters in an opponent's heap, a circle is drawn around the heap and the player captures the counters in it and every counter sown into it for the rest of the game. When there are no heaps left, the player with the most counters wins. Each hole contains initially 12 seeds. The game is played with 5 players.
(game "Pic" (players 5) (equipment {(board (concentric {(* 3 5)}) (track "Track" {0 1 3 5 7 9 11 13 14 12 10 8 6 4 2} loop:True) use:Vertex) (piece "Seed" Shared) (hand Each) (regions P1 (sites {0 1 3})) (regions P2 (sites {5 7 9})) (regions P3 (sites {11 13 14})) (regions P4 (sites {12 10 8})) (regions P5 (sites {6 4 2}))}) (rules (start (set Count 12 to:(sites Track))) (play (or {(move Select (from (sites Mover) if:(is Occupied (from))) (then (sow apply:(if (and (not (is In (to) (sites Mover))) (= 3 (count at:(to)))) (and (fromTo (from (to)) (to (handSite Mover)) count:3) (set State at:(to) (mover)))))))} (then (forEach Site (sites Board) (if (and (is Occupied (site)) (!= 0 (state at:(site)))) (and (fromTo (from (site)) (to (handSite (state at:(site)))) count:(count at:(site))) (set State at:(site) (state at:(site))))))))) (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) (byScore {(score P1 (count Cell at:(handSite P1))) (score P2 (count Cell at:(handSite P2))) (score P3 (count Cell at:(handSite P3))) (score P4 (count Cell at:(handSite P4))) (score P5 (count Cell at:(handSite P5)))}))))) 
Seven holes, arranged in a circle. Four counters in each hole. Sowing occurs in an anti-clockwise direction. When the final counter lands in a hole, the contents of the next hole are picked up and sowing continues with those counters. When the hole from which this new sowing would occur is empty, the counters in the next hole are captured and the turn ends. The next player begins to sow from the next available hole with counters after the last one played by the opponent. Play continues until no further captures can be made, and the player with the most counters wins.
(game "Sat Gol" (players 2) (equipment {(board (concentric {7}) (track "Track" {0 1 3 5 6 4 2} loop:True) use:Vertex) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 4 to:(sites Board))) (play (move Select (from (if (is Prev Mover) (sites {(trackSite Move from:(last To afterConsequence:True) steps:1)}) (if (= 0 (count Moves)) (sites Board) (sites {(var)}))) if:(> (count at:(from)) 0)) (then (sow apply:(if (!= 0 (count at:(trackSite Move from:(to) steps:1))) (moveAgain) (and (if (!= 0 (count at:(trackSite Move from:(to) steps:2))) (fromTo (from (trackSite Move from:(to) steps:2)) (to (handSite Mover)) count:(count at:(trackSite Move from:(to) steps:2)))) (if (!= 0 (count at:(trackSite Move from:(to) steps:3))) (set Var (trackSite Move from:(to) steps:3)) (if (!= 0 (count at:(trackSite Move from:(to) steps:4))) (set Var (trackSite Move from:(to) steps:4)) (if (!= 0 (count at:(trackSite Move from:(to) steps:5))) (set Var (trackSite Move from:(to) steps:5)) (if (!= 0 (count at:(trackSite Move from:(to) steps:6))) (set Var (trackSite Move from:(to) steps:6)) (set Pending))))))))))) (end (if (is Pending) (byScore {(score P1 (count Cell at:(handSite P1))) (score P2 (count Cell at:(handSite P2)))}))))) 
3x6 board. Each player owns the row closest to them and the half of the central row to their right. Play begins with three counters in each hole. During the first phase of the game, the players race each other (i.e., do not take turns) to be the first person to drop the last counter into an empty hole. Play moves from left to right in the row closest to the player, right to left in the central row, and left to right in the furthest row. Upon reaching the final hole in the opponent's row, play continues with the first hole in the player's own row. In the first phase, Players take counters from the leftmost hole in their row and sow them in the appropriate direction. When the final counter lands in a hole with counters, they are picked up and sowing continues until the last counter is dropped into an empty hole. Play continues in phase two in the same manner as before, but the players take turns and the player who "won" the first phase plays first. Players capture counters when placing the last counter of a sowing into one of their own holes which is empty. If the hole is on the left half of the board, any counters in the two holes of the opponent facing it are captured. If the last hole is on the right half of the board, any counters in the opponent's one hole facing it are captured. The player then continues to move using the last counter placed which effected the capture, and placing it in the next hole. This move can result in further captures (if the hole is empty), continuation of sowing (if there are counters in it), or the end of the turn (if hole is empty and there are no opponent's counters to be captured). Play continues until a player has no counters in their holes. The opponent then captures the remaining counters. Players then redistribute their counters, three in each hole, starting from the leftmost hole in their row in the direction of play. The player with fewer counters distributes all of their counters on the board, even if they cannot place three in the final hole of the counting. The player with more counters then places three counters in the same number of holes as the other player, taking any remaining as their winnings. Play continues in this fashion until one player captures all of the counters. 
(game "Abalala'e" (players 2) (equipment {(mancalaBoard 3 6 store:None {(track "Track" "0,E,N1,W5,N1,E" loop:True P1) (track "Track" "17,W,S1,E5,S1,W" loop:True P2)}) (regions "Home" P1 (union (sites Bottom) (sites {"D2" "E2" "F2"}))) (regions "Home" P2 (union (sites Top) (sites {"A2" "B2" "C2"}))) (regions "LeftPart" P1 (sites {"A1" "B1" "C1"})) (regions "LeftPart" P2 (sites {"D3" "E3" "F3"})) (regions "MiddleRow" (sites {"A2" "B2" "C2" "D2" "E2" "F2"})) (map "LeftHole" {(pair P1 0) (pair P2 17)}) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 3 to:(union (sites P1 "Home") (sites P2 "Home")))) (play (move Select (from (if (is Prev Mover) (if (is Pending) (sites Pending) (sites {(last To afterConsequence:True)})) (sites Mover "Home")) if:(> (count at:(from)) 0)) (then (sow count:(if (is Pending) 1 (count at:(last To))) "Track" owner:(mover) apply:(if (> (count at:(to)) 1) (moveAgain) (if (is In (to) (sites Mover "Home")) (if (is In (to) (sites "MiddleRow")) (if (> (count at:(if (is Mover P1) (+ (to) 6) (- (to) 6))) 0) (and {(fromTo (from (if (is Mover P1) (+ (to) 6) (- (to) 6))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 6) (- (to) 6)))) (moveAgain) (set Pending (to))})) (if (is In (to) (sites Mover "LeftPart")) (and {(if (> (count at:(if (is Mover P1) (+ (to) 6) (- (to) 6))) 0) (and {(fromTo (from (if (is Mover P1) (+ (to) 6) (- (to) 6))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 6) (- (to) 6)))) (moveAgain) (set Pending (to))})) (if (> (count at:(if (is Mover P1) (+ (to) (* 6 2)) (- (to) (* 6 2)))) 0) (and {(fromTo (from (if (is Mover P1) (+ (to) (* 6 2)) (- (to) (* 6 2)))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) (* 6 2)) (- (to) (* 6 2))))) (moveAgain) (set Pending (to))}))}) (if (> (count at:(if (is Mover P1) (+ (to) (* 6 2)) (- (to) (* 6 2)))) 0) (and {(fromTo (from (if (is Mover P1) (+ (to) (* 6 2)) (- (to) (* 6 2)))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) (* 6 2)) (- (to) (* 6 2))))) (moveAgain) (set Pending (to))})))))))))) (end (if (or {(all Sites (sites P1 "Home") if:(= 0 (count at:(site)))) (all Sites (sites P2 "Home") if:(= 0 (count at:(site))))}) (byScore {(score P1 (+ (count Cell at:(handSite P1)) (count in:(sites P1)))) (score P2 (+ (count Cell at:(handSite P2)) (count in:(sites P2))))}))))) 
3x6 board. Three counters per hole. Each player owns the row closest to them and the right half of the central row. Sowing occurs in the following direction: from left to right in the player's full row, right to left in the player's half of the central row, proceeding to the opponent's full row and sowing right to left, then left to right in the opponent's part of the central row, then proceeding back to the player's full row and proceeding as before. Sowing always begins from a player's own holes. When the last counter falls into an empty hole, the turn ends. If the last counter falls into an occupied hole, the contents of that hole are picked up and sowing continues. A hole is captured by dropping the last counter of a sowing into an opponent's hole which contains three counters, making it have four counters, and becomes a wegue. Captures cannot be made until after the original three counters placed in the holes at the beginning of the game have been moved. Once a wegue is created, the player cannot sow from it. When the final counter of a sowing lands in a wegue owned by the opponent, the player captures two counters from it. Play continues until all of the counters are captured or all of the counters are accumulated in wegue. A new round begins. Players then collect the counters in their captured holes. They count their takings by filling their holes with three counters each as in the beginning, and the player would own every hole they could fill with three counters. If the player has two counters remaining, they also gain another hole and the opponent surrenders their extra counter. At the end of play, if a player captures the opponent's single remaining hole as a wegue, the player captured three counters from it, leaving one for the opponent to continue to play. Play continues until one player cannot fill any holes.
(game "Gabata (Adowa)" (players 2) (equipment {(mancalaBoard 3 6 store:None (track "Track" "0,E,N1,W2,17,W,S1,E2" loop:True)) (piece "Seed" Shared) (hand Each) (regions P1 (union (sites Bottom) (intersection (sites Row 1) (expand (sites Right) steps:2)))) (regions P2 (union (sites Top) (intersection (sites Row 1) (expand (sites Left) steps:2)))) (map "LeftMost" {(pair P1 0) (pair P2 17)})}) (rules (start {(set Count 3 to:(sites Track)) (set RememberValue "OwnedP1" (union (sites Bottom) (intersection (sites Row 1) (expand (sites Right) steps:2)))) (set RememberValue "OwnedP2" (union (sites Top) (intersection (sites Row 1) (expand (sites Left) steps:2))))}) phases:{(phase "Sowing" (play (or {(move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (if (is Mover P1) (sites (values Remembered "OwnedP1")) (sites (values Remembered "OwnedP2")))) if:(and (< 0 (count at:(from))) (= 0 (state at:(from))))) (then (sow apply:(if (and {(= 0 (state at:(to))) (= 4 (count at:(to))) (is In (to) (if (is Mover P1) (sites (values Remembered "OwnedP2")) (sites (values Remembered "OwnedP1"))))}) (set State at:(to) (mover)) (if (< 1 (count at:(to))) (if (= 0 (state at:(to))) (and {(moveAgain) (set Var "Replay" (to))}) (if (!= (mover) (state at:(to))) (and {(fromTo (from (to)) (to (handSite Mover)) count:(min 2 (count at:(to)))) (set State at:(to) (state at:(to)))}))))))))} (then (if (all Sites (forEach (sites Board) if:(= 0 (state at:(site)))) if:(= 0 (count at:(site)))) (and {(forEach Site (forEach (sites Board) if:(= 1 (state at:(site)))) (fromTo (from (site)) (to (handSite P1)) count:(count at:(site)))) (forEach Site (forEach (sites Board) if:(= 2 (state at:(site)))) (fromTo (from (site)) (to (handSite P2)) count:(count at:(site)))) (forget Value "OwnedP1" All) (forget Value "OwnedP2" All)}))))) (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) {(if (>= 1 (count Cell at:(handSite P1))) (result P2 Win)) (if (>= 1 (count Cell at:(handSite P2))) (result P1 Win))})) (nextPhase (all Sites (sites Board) if:(= 0 (count at:(site)))) "BetweenRounds")) (phase "BetweenRounds" (play (if (<= 3 (count Cell at:(handSite Mover))) (move (from (handSite Mover)) (to (trackSite FirstSite from:(mapEntry "LeftMost" Mover) if:(is Empty (to)))) count:3 (then (and {(if (is Mover P1) (remember Value "OwnedP1" (last To)) (remember Value "OwnedP2" (last To))) (if (<= 3 (count Cell at:(handSite Mover))) (moveAgain) (if (= 2 (count Cell at:(handSite Mover))) (and {(fromTo (from (handSite Mover)) (to (trackSite FirstSite from:(mapEntry "LeftMost" Mover) if:(is Empty (to)))) count:2) (fromTo (from (handSite Next)) (to (trackSite FirstSite from:(mapEntry "LeftMost" Mover) if:(is Empty (to)))) count:1) (if (is Mover P1) (remember Value "OwnedP1" (trackSite FirstSite from:(mapEntry "LeftMost" Mover) if:(is Empty (to)))) (remember Value "OwnedP2" (trackSite FirstSite from:(mapEntry "LeftMost" Mover) if:(is Empty (to)))))})))}))))) (nextPhase (and (is Empty (handSite P1)) (is Empty (handSite P2))) "Sowing"))})) 
3x6 board. Play begins with three counters per hole. Each player owns the row closest to them and the right half of the central row. Sowing occurs in the following direction: from left to right in the player's full row, right to left in the player's half of the central row, proceeding to the opponent's full row and sowing right to left, then left to right in the opponent's part of the central row, then proceeding back to the player's full row and proceeding as before. Sowing always begins from a player's own holes. A player can not sow from their left hand hole in their main row unless it has more than three counters, unless there is no other option. When the last counter falls into an empty hole, the turn ends. If the last counter falls into an occupied hole, the contents of that hole are picked up and sowing continues. A hole is captured by dropping the last counter of a sowing into an opponent's hole which contains three counters, making it have four counters, and becomes a wegue. Captures cannot be made until after the original three counters placed in the holes at the beginning of the game have been moved. Once a wegue is created, the player cannot sow from it. When the final counter of a sowing lands in a wegue owned by the opponent, the player captures two counters from it. Play continues until all of the counters are captured or all of the counters are accumulated in wegue. A new round begins. Players then collect the counters in their captured holes. They count their takings by filling their holes with three counters each as in the beginning, and the player would own every hole they could fill with three counters. If the player has two counters remaining, they also gain another hole and the opponent surrenders their extra counter. At the end of play, if a player captures the opponent's single remaining hole as a wegue, the player captured three counters from it, leaving one for the opponent to continue to play. Play continues until one player cannot fill any holes.
(game "Gabata (Aksum)" (players 2) (equipment {(mancalaBoard 3 6 store:None (track "Track" "0,E,N1,W2,17,W,S1,E2" loop:True)) (piece "Seed" Shared) (hand Each) (regions P1 (union (sites Bottom) (intersection (sites Row 1) (expand (sites Right) steps:2)))) (regions P2 (union (sites Top) (intersection (sites Row 1) (expand (sites Left) steps:2)))) (map "LeftMost" {(pair P1 0) (pair P2 17)})}) (rules (start {(set Count 3 to:(sites Track)) (set RememberValue "OwnedP1" (union (sites Bottom) (intersection (sites Row 1) (expand (sites Right) steps:2)))) (set RememberValue "OwnedP2" (union (sites Top) (intersection (sites Row 1) (expand (sites Left) steps:2))))}) phases:{(phase "Sowing" (play (or {(move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (if (is Mover P1) (sites (values Remembered "OwnedP1")) (sites (values Remembered "OwnedP2")))) if:(and {(if (!= (from) (mapEntry "LeftMost" Mover)) True (if (is Prev Mover) True (or (< 3 (count at:(from))) (no Pieces All in:(forEach (difference (if (is Mover P1) (sites (values Remembered "OwnedP1")) (sites (values Remembered "OwnedP2"))) (mapEntry "LeftMost" Mover)) if:(= 0 (state at:(site)))))))) (< 0 (count at:(from))) (= 0 (state at:(from)))})) (then (sow apply:(if (and {(= 0 (state at:(to))) (= 4 (count at:(to))) (is In (to) (if (is Mover P1) (sites (values Remembered "OwnedP2")) (sites (values Remembered "OwnedP1"))))}) (set State at:(to) (mover)) (if (< 1 (count at:(to))) (if (= 0 (state at:(to))) (and {(moveAgain) (set Var "Replay" (to))}) (if (!= (mover) (state at:(to))) (and {(fromTo (from (to)) (to (handSite Mover)) count:(min 2 (count at:(to)))) (set State at:(to) (state at:(to)))}))))))))} (then (if (all Sites (forEach (sites Board) if:(= 0 (state at:(site)))) if:(= 0 (count at:(site)))) (and {(forEach Site (forEach (sites Board) if:(= 1 (state at:(site)))) (fromTo (from (site)) (to (handSite P1)) count:(count at:(site)))) (forEach Site (forEach (sites Board) if:(= 2 (state at:(site)))) (fromTo (from (site)) (to (handSite P2)) count:(count at:(site)))) (forget Value "OwnedP1" All) (forget Value "OwnedP2" All)}))))) (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) {(if (>= 1 (count Cell at:(handSite P1))) (result P2 Win)) (if (>= 1 (count Cell at:(handSite P2))) (result P1 Win))})) (nextPhase (all Sites (sites Board) if:(= 0 (count at:(site)))) "BetweenRounds")) (phase "BetweenRounds" (play (if (<= 3 (count Cell at:(handSite Mover))) (move (from (handSite Mover)) (to (trackSite FirstSite from:(mapEntry "LeftMost" Mover) if:(is Empty (to)))) count:3 (then (and {(if (is Mover P1) (remember Value "OwnedP1" (last To)) (remember Value "OwnedP2" (last To))) (if (<= 3 (count Cell at:(handSite Mover))) (moveAgain) (if (= 2 (count Cell at:(handSite Mover))) (and {(fromTo (from (handSite Mover)) (to (trackSite FirstSite from:(mapEntry "LeftMost" Mover) if:(is Empty (to)))) count:2) (fromTo (from (handSite Next)) (to (trackSite FirstSite from:(mapEntry "LeftMost" Mover) if:(is Empty (to)))) count:1) (if (is Mover P1) (remember Value "OwnedP1" (trackSite FirstSite from:(mapEntry "LeftMost" Mover) if:(is Empty (to)))) (remember Value "OwnedP2" (trackSite FirstSite from:(mapEntry "LeftMost" Mover) if:(is Empty (to)))))})))}))))) (nextPhase (and (is Empty (handSite P1)) (is Empty (handSite P2))) "Sowing"))})) 
3x6 board. Four counters per hole. Each player controls one row of holes and the half of the central row to their right. Sowing occurs from left ro right in the player's full row, right to left in their holes in the central row, then right to left in the opponent's full row, then left to right in the opponent's holes in the central row, at that point continuing into the player's full row again. When the final counter is sown into an occupied hole, the counters are picked up and sowing continues. When the final counter falls into an empty hole, the turn ends. At any point while the player sows, if a hole is made to contain four counters, these are captured, regardless of who the hole belongs to. When the final counter causes a capture, the turn ends. Play continues until a player has no counters in their holes. The opponent then captures the remaining counters. Players then redistribute their counters, four in each hole, starting from the leftmost hole in their row in the direction of play. The player with fewer counters distributes all of their counters on the board, even if they cannot place four in the final hole of the counting. The player with more counters then places four counters in the same number of holes as the other player, taking any remaining as their winnings. Play continues in this fashion until one player captures all of the counters.
(game "Rab'e" (players 2) (equipment {(mancalaBoard 3 6 store:None (track "Track" "0,E,N1,W2,17,W,S1,E2" loop:True)) (piece "Seed" Shared) (regions P1 (union (sites Bottom) (difference (expand (sites Right) steps:2) (sites Top)))) (regions P2 (union (sites Top) (difference (expand (sites Left) steps:2) (sites Bottom)))) (hand Each) (map "LeftMost" {(pair P1 0) (pair P2 17)}) (map "CorrespondingHoles" {(pair 0 17) (pair 1 16) (pair 2 15) (pair 3 14) (pair 4 13) (pair 5 12) (pair 11 6) (pair 10 7) (pair 9 8) (pair 8 9) (pair 7 10) (pair 6 11) (pair 12 5) (pair 13 4) (pair 14 3) (pair 15 2) (pair 16 1) (pair 17 0)})}) (rules (start (set Count 4 to:(sites Track))) phases:{(phase "Sowing" (play (or {(move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover)) if:(< 0 (count at:(from)))) (then (do (set Var "NumSowed" (count at:(last To))) next:(sow apply:(if (and (!= 4 (count at:(to))) (< 1 (count at:(to)))) (moveAgain))) (then (and (forEach Site (sites Track from:(last From) to:(trackSite Move from:(last From) "Track" steps:(var "NumSowed"))) (if (= 4 (count at:(site))) (fromTo (from (site)) (to (handSite Mover)) count:4))) (set Var "NumSowed" 0))))))} (then (if (or (all Sites (sites P1) if:(is Empty (site))) (all Sites (sites P2) if:(is Empty (site)))) (and {(forEach Site (sites P1) (fromTo (from (site)) (to (handSite P1)) count:(count at:(site)))) (forEach Site (sites P2) (fromTo (from (site)) (to (handSite P2)) count:(count at:(site)))) (if (<= (+ (count Cell at:(handSite P1)) (count in:(sites P1))) (+ (count Cell at:(handSite P2)) (count in:(sites P2)))) (set NextPlayer (player 1)) (set NextPlayer (player 2)))}))))) (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) {(if (= 0 (count Cell at:(handSite P1))) (result P2 Win)) (if (= 0 (count Cell at:(handSite P2))) (result P1 Win))})) (nextPhase (all Sites (sites Board) if:(= 0 (count at:(site)))) "BetweenRounds")) (phase "BetweenRounds" (play (if (<= 4 (count Cell at:(handSite Mover))) (move (from (handSite Mover)) (to (trackSite FirstSite from:(mapEntry "LeftMost" Mover) if:(is Empty (to)))) count:4 (then (if (<= 4 (count Cell at:(handSite Mover))) (moveAgain) (and (if (!= 0 (count Cell at:(handSite Mover))) (and (fromTo (from (handSite Mover)) (to (trackSite FirstSite from:(mapEntry "LeftMost" Mover) if:(is Empty (to)))) count:(count Cell at:(handSite Mover))) (fromTo (from (handSite Next)) (to (mapEntry "CorrespondingHoles" (trackSite FirstSite from:(mapEntry "LeftMost" Mover) if:(is Empty (to))))) count:(count Cell at:(handSite Next))))) (forEach Site (sites Mover) (if (is Occupied (site)) (fromTo (from (handSite Next)) (to (mapEntry "CorrespondingHoles" (site))) count:(count at:(site))))))))))) (nextPhase (= 0 (count Cell at:(handSite Mover))) "Sowing"))})) 
3x6 board, three counters per hole. Each player owns the row of holes closest to them, as well as the right half of the central row, with respect to their perspective. Sowing occurs from left to right in the player's complete row, right to left in the player's half of the central row, then continuing from right to left in the opponent's outer row, left to right in the opponent's holes in the central row, and then continuing as before into the player's outer row. Players sow from any of their holes, and when the final counter lands in an occupied hole, they pick up the contents and continue sowing. When the final counter falls into an empty hole, the turn ends. After the first turn, players may capture a hole when the final counter of a sowing falls into a hole containing three counters, increasing it to four. The counters in a captured hole cannot be sown. When a player drops their final counter into an occupied captured hole, two counters are captured from it. If the player captured counters from one of the holes that they had created, they begin sowing again from another of their holes, but if the capture was from a hole captured by the opponent, the turn ends. The leftmost holes in each player's row are special: a player may under no circumstance capture counters from this hole in their row, but may do so from the opponent's, gaining another turn when they do so. Play continues until all of the counters are captured or all of the counters are accumulated in captured holes. A new round begins. Players then collect the counters in their captured holes. They count their takings by filling their holes with three counters each as in the beginning, and the player would own every hole they could fill with three counters. If the player has two counters remaining, they also gain another hole and the opponent surrenders their extra counter. Play continues until one player cannot fill any holes.
(game "Selus (Massawa)" (players 2) (equipment {(mancalaBoard 3 6 store:None (track "Track" "0,E,N1,W2,17,W,S1,E2" loop:True)) (piece "Seed" Shared) (hand Each) (regions P1 (union (sites Bottom) (difference (expand (sites Right) steps:2) (sites Top)))) (regions P2 (union (sites Top) (difference (expand (sites Left) steps:2) (sites Bottom)))) (map "LeftMostHole" {(pair P1 0) (pair P2 17)})}) (rules (start {(set RememberValue "OwnedP1" (sites P1)) (set RememberValue "OwnedP2" (sites P2)) (set Count 3 to:(sites Track))}) phases:{(phase "Sowing" (play (or {(move Select (from (if (and (not (is Pending)) (is Prev Mover)) (sites {(last To afterConsequence:True)}) (if (is Mover P1) (sites (values Remembered "OwnedP1")) (sites (values Remembered "OwnedP2")))) if:(and (< 0 (count at:(from))) (= 0 (state at:(from))))) (then (sow apply:(if (< 1 (count at:(to))) (if (and (!= (mapEntry "LeftMostHole" Mover) (to)) (!= 0 (state at:(to)))) (and {(if (or (= (mover) (state at:(to))) (= (mapEntry "LeftMostHole" Next) (to))) (and (moveAgain) (set Pending))) (fromTo (from (to)) (to (handSite Mover)) count:2) (set State at:(to) (state at:(to)))}) (if (and {(< 2 (count Turns)) (= 0 (state at:(to))) (= 4 (count at:(to)))}) (set State at:(to) (mover)) (moveAgain)))))))} (then (if (all Sites (forEach (sites Board) if:(= 0 (state at:(site)))) if:(= 0 (count at:(site)))) (and {(forEach Site (forEach (sites Board) if:(= 1 (state at:(site)))) (fromTo (from (site)) (to (handSite P1)) count:(count at:(site)))) (forEach Site (forEach (sites Board) if:(= 2 (state at:(site)))) (fromTo (from (site)) (to (handSite P2)) count:(count at:(site)))) (forget Value "OwnedP1" All) (forget Value "OwnedP2" All)}))))) (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) {(if (> 3 (count Cell at:(handSite P1))) (result P2 Win)) (if (> 3 (count Cell at:(handSite P2))) (result P1 Win))})) (nextPhase (all Sites (sites Board) if:(= 0 (count at:(site)))) "BetweenRounds")) (phase "BetweenRounds" (play (if (<= 3 (count Cell at:(handSite Mover))) (move (from (handSite Mover)) (to (if (all Sites (sites Mover) if:(is Occupied (site))) (sites Board) (sites Mover)) if:(is Empty (to))) count:3 (then (if (is Mover P1) (remember Value "OwnedP1" (last To)) (remember Value "OwnedP2" (last To))))) (if (= 2 (count Cell at:(handSite Mover))) (move (from (handSite Mover)) (to (if (all Sites (sites Mover) if:(is Occupied (site))) (sites Board) (sites Mover)) if:(is Empty (to))) count:2 (then (and (fromTo (from (handSite Next)) (to (last To)) count:1) (if (is Mover P1) (remember Value "OwnedP1" (last To)) (remember Value "OwnedP2" (last To))))))))) (nextPhase (and (is Empty (handSite P1)) (is Empty (handSite P2))) "Sowing"))})) 
3x6 board. Three counters per hole. Each player owns the row of holes closest to them, as well as the right half of the central row, with respect to their perspective. Sowing occurs from left to right in the player's complete row, right to left in the player's half of the central row, then continuing from right to left in the opponent's outer row, left to right in the opponent's holes in the central row, and then continuing as before into the player's outer row. In the opening phase, players play simultaneously. When the final counter of a sowing falls into an occupied hole, the contents are picked up and sowing continues. Each player plays until their final counter falls into an empty hole; the first player to do so begins the main phase. In the main phase, players alternate turns, and picking up the counters and continuing to sow when the final counter lands in an occupied hole, and stopping when the final counter lands in an empty hole. There are some restrictions with regard to sowing. Each of the player's three leftmost holes cannot be sown from to begin a turn if they contain three counters or less, unless there are no other options for play, in which case sowing must occur from a hole with one counter, and if none are available, then it must begin from a hole with two counters, or three counters if that is the only option. Separately, if the player's other holes only contain two or three counters, the player must play from a hole containing two counters, and these must be the option closest to the opponent's holes. Players must also play from holes containing more than three counters when available. During sowing, a player may not drop a counter into any of the opponent's holes which contain three counters (except when making a nedf, see below), skipping over them and sowing in the next available holes. When the final counter of a sowing lands in a hole in the opponent's row containing three counters, this hole becomes a "nedf." Any counters falling into the nedf cannot be sown. Only one nedf can exist at one time. After the first nedf is made, any others can only be made by placing the final two counters of a sowing into holes which contain three counters, the penultimate hole becoming the new nedf. The player then continues their turn with the counters from the final hole. The hole after the nedf becomes the yazab tabaqi, or "guardian." While the yazab tabaqi contains exactly three counters, the opponent cannot create a new nedf. Play continues until one player has no counters to move, or concedes they can no longer make a nedf.
(game "Selus" (players 2) (equipment {(mancalaBoard 3 6 store:None (track "Track" "0,E,N1,W2,17,W,S1,E2" loop:True)) (piece "Seed" Shared) (hand Each) (regions "Home" P1 (union (intersection (sites Row 1) (expand (sites Right) steps:2)) (sites Bottom))) (regions "Home" P2 (union (intersection (sites Row 1) (expand (sites Left) steps:2)) (sites Top))) (regions "ThreeLeftMost" P1 (intersection (sites Bottom) (expand (sites Left) steps:2))) (regions "ThreeLeftMost" P2 (intersection (sites Top) (expand (sites Right) steps:2)))}) (rules (start (set Count 3 to:(sites Board))) (play (priority {(move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover)) if:(< 3 (count at:(site)))) (then (do (set Var "NumSowed" (count at:(last From))) next:(sow apply:(if (< 1 (count at:(to))) (if (and {(= 0 (state at:(to))) (= 4 (count at:(to))) (all Sites (sites Board) if:(!= (mover) (state at:(site)))) (is In (to) (sites Next))}) (set State at:(to) (mover)) (and (moveAgain) (set Var "Replay" (to))))) skipIf:(and (= 3 (count at:(to))) (is In (to) (sites Next))))))) (if (all Sites (intersection (sites Mover "Home") (sites Mover "ThreeLeftMost")) if:(or (= 2 (count at:(site))) (= 3 (count at:(site))))) (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover)) if:(= 2 (count at:(site)))) (then (do (set Var "NumSowed" (count at:(last From))) next:(sow apply:(if (< 1 (count at:(to))) (if (and {(= 0 (state at:(to))) (= 4 (count at:(to))) (all Sites (sites Board) if:(!= (mover) (state at:(site)))) (is In (to) (sites Next))}) (set State at:(to) (mover)) (and (moveAgain) (set Var "Replay" (to))))) skipIf:(and (= 3 (count at:(to))) (is In (to) (sites Next)))))))) (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover)) if:(and (is Occupied (from)) (if (is Prev Mover) True (if (is In (to) (sites Mover "ThreeLeftMost")) (< 3 (count at:(to))) True)))) (then (do (set Var "NumSowed" (count at:(last From))) next:(sow apply:(if (< 1 (count at:(to))) (if (and {(= 0 (state at:(to))) (= 4 (count at:(to))) (all Sites (sites Board) if:(!= (mover) (state at:(site)))) (is In (to) (sites Next))}) (set State at:(to) (mover)) (and (moveAgain) (set Var "Replay" (to))))) skipIf:(and (= 3 (count at:(to))) (is In (to) (sites Next))))))) (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover "ThreeLeftMost")) if:(and (= 1 (count at:(from))) (is Occupied (from)))) (then (do (set Var "NumSowed" (count at:(last From))) next:(sow apply:(if (< 1 (count at:(to))) (if (and {(= 0 (state at:(to))) (= 4 (count at:(to))) (all Sites (sites Board) if:(!= (mover) (state at:(site)))) (is In (to) (sites Next))}) (set State at:(to) (mover)) (and (moveAgain) (set Var "Replay" (to))))) skipIf:(and (= 3 (count at:(to))) (is In (to) (sites Next))))))) (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover "ThreeLeftMost")) if:(and (= 2 (count at:(from))) (is Occupied (from)))) (then (do (set Var "NumSowed" (count at:(last From))) next:(sow apply:(if (< 1 (count at:(to))) (if (and {(= 0 (state at:(to))) (= 4 (count at:(to))) (all Sites (sites Board) if:(!= (mover) (state at:(site)))) (is In (to) (sites Next))}) (set State at:(to) (mover)) (and (moveAgain) (set Var "Replay" (to))))) skipIf:(and (= 3 (count at:(to))) (is In (to) (sites Next))))))) (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover "ThreeLeftMost")) if:(and (= 3 (count at:(from))) (is Occupied (from)))) (then (do (set Var "NumSowed" (count at:(last From))) next:(sow apply:(if (< 1 (count at:(to))) (if (and {(= 0 (state at:(to))) (= 4 (count at:(to))) (all Sites (sites Board) if:(!= (mover) (state at:(site)))) (is In (to) (sites Next))}) (set State at:(to) (mover)) (and (moveAgain) (set Var "Replay" (to))))) skipIf:(and (= 3 (count at:(to))) (is In (to) (sites Next)))))))})) (end (if (no Moves Next) (result Mover Win))))) 
Three rows of four holes; the central two holes in the middle row are stores. Each player owns the hole in the central row to their left. Ten counters in each hole. Players sow from one of their holes, sowing first into the hole from which the counters were lifted, in an anti-clockwise direction. When the final counter lands in a hole containing two counters, these counters are captured. The player captures like this seven times. The eighth captures happens when the final counter falls into a hole containing one counter; the next capture from a hole containing three; the next from a hole containing five; then repeating the pattern of one, three, five for the rest of the game. The player who captures the most counters wins. The number of counters to have in the hole to capture in the initial captures before the sequence is 2. The number of initial captures before the sequence is 7.
(game "The Concentration Game" (players 2) (equipment {(mancalaBoard 3 4 store:None (track "Track" "0,E,N,W,S2" loop:True)) (piece "Seed" Shared) (regions P1 (union (sites {4}) (sites Bottom))) (regions P2 (union (sites {7}) (sites Top))) (map {(pair P1 5) (pair P2 6)})}) (rules (start {(set Count 10 to:(sites Outer)) (set RememberValue "NumToCaptureP1" 2) (set RememberValue "NumToCaptureP2" 2) (set RememberValue "NumCaptureTwoP1" 0) (set RememberValue "NumCaptureTwoP2" 0)}) (play (move Select (from (sites Mover) if:(< 1 (count at:(from)))) (then (sow if:(= (count at:(to)) (if (is In 2 (if (is Mover P1) (sites (values Remembered "NumToCaptureP1")) (sites (values Remembered "NumToCaptureP2")))) (+ 1 2) (if (is In 1 (if (is Mover P1) (sites (values Remembered "NumToCaptureP1")) (sites (values Remembered "NumToCaptureP2")))) 2 (if (is In 3 (if (is Mover P1) (sites (values Remembered "NumToCaptureP1")) (sites (values Remembered "NumToCaptureP2")))) 4 6)))) apply:(and (fromTo (from (to)) (to (mapEntry (mover))) count:(count at:(to))) (if (< (value Player Mover) 5) (set Value Mover (+ 1 (value Player Mover))) (if (is Mover P1) (and (forget Value "NumToCaptureP1" All) (if (is In 2 (if (is Mover P1) (sites (values Remembered "NumToCaptureP1")) (sites (values Remembered "NumToCaptureP2")))) (remember Value "NumToCaptureP1" 1) (if (is In 1 (if (is Mover P1) (sites (values Remembered "NumToCaptureP1")) (sites (values Remembered "NumToCaptureP2")))) (remember Value "NumToCaptureP1" 3) (if (is In 5 (if (is Mover P1) (sites (values Remembered "NumToCaptureP1")) (sites (values Remembered "NumToCaptureP2")))) (remember Value "NumToCaptureP1" 1) (remember Value "NumToCaptureP1" 5))))) (and (forget Value "NumToCaptureP2" All) (if (is In 2 (if (is Mover P1) (sites (values Remembered "NumToCaptureP1")) (sites (values Remembered "NumToCaptureP2")))) (remember Value "NumToCaptureP2" 1) (if (is In 1 (if (is Mover P1) (sites (values Remembered "NumToCaptureP1")) (sites (values Remembered "NumToCaptureP2")))) (remember Value "NumToCaptureP2" 3) (if (is In 5 (if (is Mover P1) (sites (values Remembered "NumToCaptureP1")) (sites (values Remembered "NumToCaptureP2")))) (remember Value "NumToCaptureP2" 1) (remember Value "NumToCaptureP2" 5)))))))) origin:True)))) (end (if (no Moves Next) (byScore {(score P1 (count at:(mapEntry P1))) (score P2 (count at:(mapEntry P2)))}))))) 
2x6 board with two stores. Four counters in each hole. Sowing occurs in an anti-clockwise direction from a hole in the player's row. If the final counter falls into a hole in the opponent's row containing two counters, making it contain three, they are captured. Any holes containing three counters in an unbroken line behind it in the opponent's row are also captured. A player cannot sow into a hole from which they sowed until it has been sown into by the opponent. Play continues until no more captures are possible, and the players win the counters they captured and the counters on their side of the board. A new round begins. The player with fewer counters fills up their holes from right to left with four counters. The opponent fills the same number of holes, and continues to play, holding any remaining counters for future rounds, if necessary. Play proceeds as before with the present number of holes in play. Play continues until one player cannot fill any holes.
(game "Adi" (players 2) (equipment {(mancalaBoard 2 6 {(track "TrackCCW" "1,E,N,W" loop:True) (track "TrackCW" "6,W,N,E" loop:True)}) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 FirstSite) (pair P2 LastSite)}) (piece "Seed" Shared) (map "RightMost" {(pair P1 6) (pair P2 7)}) (map "CorrespondingHoles" {(pair 1 12) (pair 2 11) (pair 3 10) (pair 4 9) (pair 5 8) (pair 6 7) (pair 7 6) (pair 8 5) (pair 9 4) (pair 10 3) (pair 11 2) (pair 12 1)})}) (rules (start {(set Count 4 to:(sites Track)) (set RememberValue "OwnedP1" (sites Bottom)) (set RememberValue "OwnedP2" (sites Top))}) phases:{(phase "Sowing" (play (or {(move Select (from (if (is Mover P1) (sites (values Remembered "OwnedP1")) (sites (values Remembered "OwnedP2"))) if:(and (if (is Mover P1) (not (is In (from) (values Remembered "P1SowFrom"))) (not (is In (from) (values Remembered "P2SowFrom")))) (< 0 (count at:(from))))) (then (and {(sow "TrackCCW" if:(and (is In (to) (sites Next)) (= (count at:(to)) 3)) apply:(fromTo (from (to)) (to (mapEntry (mover))) count:(count at:(to))) backtracking:True) (forEach Value (array (sites Track from:(last From) to:(trackSite Move from:(last From) "Track" steps:(min 12 (count at:(last From)))))) (if (is Mover P1) (if (is In (value) (values Remembered "P2SowFrom")) (forget Value "P2SowFrom" (value))) (if (is In (value) (values Remembered "P1SowFrom")) (forget Value "P1SowFrom" (value))))) (if (is Mover P1) (remember Value "P1SowFrom" (last From)) (remember Value "P2SowFrom" (last From)))})))} (then (if (not (can Move (or (move Select (from (sites (values Remembered "OwnedP1")) if:(and (not (is In (from) (values Remembered "P1SowFrom"))) (< 0 (count at:(from)))))) (move Select (from (sites (values Remembered "OwnedP2")) if:(and (not (is In (from) (values Remembered "P2SowFrom"))) (< 0 (count at:(from))))))))) (and {(forEach Site (sites P1) (if (< 0 (count at:(site))) (fromTo (from (site)) (to (mapEntry P1)) count:(count at:(site))))) (forEach Site (sites P2) (if (< 0 (count at:(site))) (fromTo (from (site)) (to (mapEntry P2)) count:(count at:(site))))) (forget Value "OwnedP1" All) (forget Value "OwnedP2" All) (forget Value "P1SowFrom" All) (forget Value "P2SowFrom" All) (if (>= (+ (count at:(mapEntry P2)) (count in:(sites P2))) (+ (count at:(mapEntry P1)) (count in:(sites P1)))) (set NextPlayer (player 1)) (set NextPlayer (player 2)))}))))) (end (if (all Sites (union (sites P1) (sites P2)) if:(= 0 (count at:(site)))) {(if (> 4 (count at:(mapEntry P1))) (result P2 Win)) (if (> 4 (count at:(mapEntry P2))) (result P1 Win))})) (nextPhase (all Sites (union (sites P1) (sites P2)) if:(= 0 (count at:(site)))) "BetweenRounds")) (phase "BetweenRounds" (play (if (<= 4 (count at:(mapEntry Mover))) (move (from (mapEntry Mover)) (to (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))) count:4 (then (and (if (is Mover P1) (remember Value "OwnedP1" (last To)) (remember Value "OwnedP2" (last To))) (if (<= 4 (count at:(mapEntry Mover))) (moveAgain) (forEach Site (sites Mover) (if (is Occupied (site)) (and (fromTo (from (mapEntry Next)) (to (mapEntry "CorrespondingHoles" (site))) count:(count at:(site))) (if (is Next P1) (remember Value "OwnedP1" (mapEntry "CorrespondingHoles" (site))) (remember Value "OwnedP2" (mapEntry "CorrespondingHoles" (site))))))))))))) (nextPhase (> 4 (count at:(mapEntry Mover))) "Sowing"))})) 
2x6 board with two stores. Four counters in each hole. Sowing occurs in an anti-clockwise direction. When the final counter lands in a hole containing one or two counters, thus making it contain two or three counters, these are captured. When this capture is made, other holes with two or three counters in them, in an uninterrupted sequence behind the hole from which the first capture was made, are captured. The player who captures the most counters wins.
(game "Adidada" (players 2) (equipment {(mancalaBoard 2 6 (track "Track" "1,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 FirstSite) (pair P2 LastSite)}) (piece "Seed" Shared)}) (rules (start (set Count 4 to:(sites Track))) (play (move Select (from (sites Mover) if:(< 0 (count at:(from)))) (then (sow if:(and (is In (to) (sites Next)) (or (= (count at:(to)) 2) (= (count at:(to)) 3))) apply:(fromTo (from (to)) (to (mapEntry (mover))) count:(count at:(to))) backtracking:True)))) (end (if (no Moves Mover) (byScore {(score P1 (+ (count Cell at:(mapEntry P1)) (count in:(sites P1)))) (score P2 (+ (count Cell at:(mapEntry P2)) (count in:(sites P2))))}))))) 
2x5 board. Ten counters in each hole. Sowing occurs in an anti-clockwise direction, sowing first into the hole from which the counters originally came. Opening phase: In the first ten turns, each player must sow from each of their five holes. Main phase: Captures are made when the last counter of a sowing falls into a hole preceding a hole containing one, three, or five counters. These counters are taken. Any subsequent holes also containing one, three, or five counters are captured, until a hole is reached that does not have one of these numbers of counters. The exception to this is in the first move when no captures are made. Sowing cannot begin from a hole with a single counter. A player wins when his opponent can no longer sow. However, if a player can no longer move, they can redistribute their captured beans into their holes, and if all five can be filled with ten, the game is a draw.
(game "Adjiboto" (players 2) (equipment {(mancalaBoard 2 5 store:None (track "Track" "0,E,N,W" loop:True)) (piece "Seed" Shared) (hand Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start (set Count 10 to:(sites Track))) phases:{(phase "Opening" (play (move Select (from (difference (sites Mover) (sites (if (is Mover P1) (values Remembered "SowedHolesP1") (values Remembered "SowedHolesP2")))) if:(< 1 (count at:(to)))) (then (and (sow origin:True) (if (is Mover P1) (remember Value "SowedHolesP1" (last From) unique:True) (remember Value "SowedHolesP2" (last From) unique:True)))))) (nextPhase Mover (< 8 (count Turns)))) (phase "Main" (play (move Select (from (sites Mover) if:(< 1 (count at:(to)))) (then (sow if:(or {(= 1 (count at:(trackSite Move from:(to) "Track" steps:1))) (= 3 (count at:(trackSite Move from:(to) "Track" steps:1))) (= 5 (count at:(trackSite Move from:(to) "Track" steps:1)))}) apply:(fromTo (from (trackSite Move from:(to) "Track" steps:1)) (to (handSite Mover)) count:(count at:(trackSite Move from:(to) "Track" steps:1))) origin:True forward:True)))) (end (if (no Moves Next) {(if (< (count Cell at:(handSite Next)) 50) (result Mover Win)) (if (>= (count Cell at:(handSite Next)) 50) (result Mover Draw))})))})) 
Played on a board with two rows of five holes with store holes on either side. To start, ten counters are placed in each hole except the stores. Play begins from any of a player's holes, and sowing proceeds in either direction, at the player's choice. The first seed is sown in the hole from which play started. When the last counter of a sowing falls into a hole, making the contents of that hole odd (but not more than nine), the counters are captured. The first capture must be of three counters, the second of one counter. The first capture must be of three counters, the second of one counter.
(game "Ako Okwe" (players 2) (equipment {(mancalaBoard 2 5 {(track "TrackCCW" "1,E,N,W" loop:True) (track "TrackCW" "6,E,S,W" loop:True)}) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 FirstSite) (pair P2 LastSite)}) (piece "Seed" Shared)}) (rules (start (set Count 10 to:(sites Track))) (play (or (move Select (from (sites Mover) if:(> (count at:(from)) 0)) (then (sow "TrackCW" if:(or {(and {(<= (count at:(to)) 9) (is Odd (count at:(to))) (>= (value Player Mover) 2)}) (and (= (value Player Mover) -1) (= (count at:(to)) 3)) (and (= (value Player Mover) 1) (= (count at:(to)) 1))}) apply:(fromTo (from (to)) (to (mapEntry (mover))) count:(count at:(to)) (then (and (if (= (value Player Mover) 1) (set Value Mover 2)) (if (= (value Player Mover) -1) (set Value Mover 1))))) origin:True))) (move Select (from (sites Mover) if:(> (count at:(from)) 0)) (then (sow "TrackCCW" if:(or {(and {(<= (count at:(to)) 9) (is Odd (count at:(to))) (>= (value Player Mover) 2)}) (and (= (value Player Mover) -1) (= (count at:(to)) 3)) (and (= (value Player Mover) 1) (= (count at:(to)) 1))}) apply:(fromTo (from (to)) (to (mapEntry (mover))) count:(count at:(to)) (then (and (if (= (value Player Mover) 1) (set Value Mover 2)) (if (= (value Player Mover) -1) (set Value Mover 1))))) origin:True))))) (end (if (no Moves Mover) (byScore {(score P1 (+ (count at:(mapEntry P1)) (count in:(sites P1)))) (score P2 (+ (count at:(mapEntry P2)) (count in:(sites P2))))}))))) 
2x6 board. Three counters in each hole. Sowing occurs from one of the holes in the player's row. If the final counter lands in an occupied hole, these counters are picked up and sowing continues. If the final counter lands in an empty hole in the player's own row, any counters in the opposite row hole are captured. A player wins when the opponent's row is empty.
(game "Altiev" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "0,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 3 to:(sites Track))) (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover)) if:(> (count at:(from)) 0)) (then (sow apply:(if (> (count at:(to)) 1) (moveAgain) (if (is In (to) (sites Mover)) (fromTo (from (if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6))) (to (handSite Mover)) count:(count at:(if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6)))))))))) (end {(if (all Sites (sites P1) if:(= 0 (count at:(site)))) (result P2 Win)) (if (all Sites (sites P2) if:(= 0 (count at:(site)))) (result P1 Win))}))) 
2x12, 15, 18, 21, or 24 board. Two counters per hole. Typically played by a team of players, who consult each other about the moves to be made. Sowing occurs most commonly in an anti-clockwise direction, but can be played clockwise if the players agree. Play begins with one player picking up the counters in one of the holes in their row and sowing them, then picking up the counters in the hole following the one in which the last counter was sown, and continuing to sow in this way until there is a pattern of holes with three counters alternating with empty holes. The players then decide who gets to play first. Players sow counters from a hole in their row in the agreed-upon direction. When the final counter lands in an occupied hole, these counters are picked up and sowing continues. When the last counter falls into an empty hole, the sowing ends. If the sowing ends in the player's own row, any counters in the opponent's hole opposite are captured. Once both players are reduced to only single counters in their holes, when a player reaches the end of their row with a counter, it is captured instead of continuing to sow it to the opponent's rows. The player who is the last in possession of counters wins. Each player has 12 holes and sow anti-clockwise.
(game "Andada" (players 2) (equipment {(mancalaBoard 2 12 store:None (track "Track" "0,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 2 to:(sites Track))) phases:{(phase "Opening" (play (move Select (from (if (is Prev Mover) (sites {(trackSite Move from:(last To afterConsequence:True) "Track" steps:1)}) (sites Mover)) if:(> (count at:(from)) 0)) (then (sow (then (if (is Occupied (trackSite Move from:(last To afterConsequence:True) "Track" steps:1)) (moveAgain))))))) (nextPhase (is Mover P2) "Playing")) (phase "Playing" (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover)) if:(> (count at:(from)) 0)) (then (sow apply:(if (= 1 (count at:(to))) (if (all Sites (sites Board) if:(<= (count at:(site)) 1)) (if (is In (trackSite Move from:(to) "Track" steps:1) (sites Next)) (fromTo (from (to)) (to (handSite Mover)) count:(count at:(to)))) (if (and (is Occupied (if (is Mover P1) (+ (to) 12) (- (to) 12))) (is In (to) (sites Mover))) (fromTo (from (if (is Mover P1) (+ (to) 12) (- (to) 12))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 12) (- (to) 12)))))) (moveAgain)))))) (end (forEach Player if:(all Sites (sites Player) if:(= 0 (count at:(site)))) (result Player Loss))))})) 
2x6 board. Four counters per hole. Players sow in a clockwise direction from their left three holes or anti-clockwise from their right three holes. When the final counter of a sowing falls into a hole in the opponent's row or in the leftmost or rightmost hole of the player's own row, which contains three counters, making it now contain four, this hole is marked and counters cannot be sown from this hole. Sowing cannot occur from a hole with a single counter into a hole containing three in the opponent's row, but is allowed when the hole containing three is in the player's own row. A player cannot sow a lone counter that was sown into their row by the opponent on the previous turn back into the hole from which it was just moved. If a player is unable to sow from their row, the opponent may continue to play until the player is able to move. Play continues until all of the counters are in marked holes. The player with the most counters in their marked holes wins.
(game "Andot" (players 2) (equipment {(mancalaBoard 2 6 store:None {(track "TrackCCW" "0,E,N,W" loop:True) (track "TrackCW" "5,W,N,E" loop:True)}) (regions "Home" P1 (sites Bottom)) (regions "Home" P2 (sites Top)) (regions "LeftThree" P1 (expand (intersection (sites Bottom) (sites Left)) steps:2 E)) (regions "LeftThree" P2 (expand (intersection (sites Top) (sites Right)) steps:2 W)) (regions "RightThree" P1 (expand (intersection (sites Bottom) (sites Right)) steps:2 W)) (regions "RightThree" P2 (expand (intersection (sites Top) (sites Left)) steps:2 E)) (regions "ExtremeHoles" P1 (intersection (union (sites Left) (sites Right)) (sites Bottom))) (regions "ExtremeHoles" P2 (intersection (union (sites Left) (sites Right)) (sites Top))) (piece "Seed" Shared)}) (rules (start (set Count 4 to:(sites Board))) (play (or (move Select (from (sites Mover "LeftThree") if:(and (or (and (= (count at:(from)) 1) (and (!= (from) (trackSite Move from:(last From) "TrackCCW" steps:1)) (if (is In (trackSite Move from:(from) "TrackCW" steps:1) (sites Next "Home")) (!= (count at:(trackSite Move from:(from) "TrackCW" steps:1)) 3) True))) (> (count at:(from)) 1)) (= 0 (state at:(from))))) (then (sow "TrackCW" apply:(if (and (= (count at:(to)) 4) (is In (to) (union (sites Mover "ExtremeHoles") (sites Next "Home")))) (set State at:(to) (mover)))))) (move Select (from (sites Mover "RightThree") if:(and (or (and (= (count at:(from)) 1) (and (!= (from) (trackSite Move from:(last From) "TrackCW" steps:1)) (if (is In (trackSite Move from:(from) "TrackCCW" steps:1) (sites Next "Home")) (!= (count at:(trackSite Move from:(from) "TrackCCW" steps:1)) 3) True))) (> (count at:(from)) 1)) (= 0 (state at:(from))))) (then (sow "TrackCCW" apply:(if (and (= (count at:(to)) 4) (is In (to) (union (sites Mover "ExtremeHoles") (sites Next "Home")))) (set State at:(to) (mover)))))))) (end (if (= 0 (count in:(forEach (sites Board) if:(= 0 (state at:(site)))))) (byScore {(score P1 (count in:(forEach (sites Board) if:(= (id P1) (state at:(site)))))) (score P2 (count in:(forEach (sites Board) if:(= (id P2) (state at:(site))))))}))))) 
Play begins with each hole (except the large holes on the ends) holding 3 counters (usually seeds or stones), though 2 or 5 are also acceptable. A player picks up all of the counters in one of the holes on their side, depositing one in each consecutive hole in a counterclockwise manner. If the last counter is placed in a hole with one less than the original starting number of counters (thus making the number of counters equal to the starting number), the player "makes a fish" (ára ot-tjin) and captures the pieces in that hole. Sowing cannot begin from.a hole containing a single counter. Play continues until one player cannot play, at which point their opponent captures the remaining counters on the board. The player with the most captured counters wins. If both players have only single counters in their holes, they must play again. The game starts with 3 counters.
(game "Aw-li On-nam Ot-tjin" (players 2) (equipment {(mancalaBoard 2 9 (track "Track" "1,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 FirstSite) (pair P2 LastSite)}) (piece "Seed" Shared)}) (rules (start (set Count 3 to:(sites Track))) (play (move Select (from (sites Mover) if:(> (count at:(from)) 1)) (then (sow if:(= (count at:(to)) 3) apply:(fromTo (from (to)) (to (mapEntry (mover))) count:(count at:(to))))))) (end (if (no Moves Mover) {(if (no Moves Next) (result Mover Draw)) (if (is Mover P1) (byScore {(score P1 (count at:(mapEntry P1))) (score P2 (+ {(count at:(mapEntry P1)) (count in:(sites P1)) (count in:(sites P2))}))})) (if (is Mover P2) (byScore {(score P1 (+ {(count at:(mapEntry P2)) (count in:(sites P2)) (count in:(sites P1))})) (score P2 (count at:(mapEntry P2)))}))})))) 
2x6 board. Play begins with four counters in each hole. A player picks up the contents of any of their holes and sowing them in an anti-clockwise direction, picking up the contents of the last hole in which his counters fall, and continuing sowing. This continues until the last counter falls in an empty hole. Then it is the other player's turn. A hole is captured when the last ball is dropped into an opponent's hole containing three counters, making it four. A player cannot then take from one of these holes that they have captured. Therefore, the player cannot begin a turn from their own captured hole nor can they continue sowing from it. If the last counter of a sowing falls into an opponent's captured hole, nothing happens on the first instance, but every time after that, one of those counters are removed from the board and placed in the store, and the sowing ends. Ownership of a hole continues even if it becomes empty. When a player cannot move (i.e., there are no counters in their holes except any that are in captured holes), the opponent continues to move until the player is able to move. Play continues until all counters are either placed in the store or in captured holes and thus cannot be moved. Players then count their pieces by placing four in each hole, and the player who has more than their original number takes ownership of one of the opponent's holes for every four counters more than the original number that have been taken. If no player took four more than the original, the player with three extra gets the hole, if each player has two extra the weaker player is given the two extra counters. Play then begins again as before. The game ends when one player owns all of the counters, and thus all of the holes.
(game "Awagagae" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "0,E,N,W" loop:True)) (piece "Seed" Shared) (hand Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(set RememberValue "OwnedP1" (sites Bottom)) (set RememberValue "OwnedP2" (sites Top)) (set Count 4 to:(sites Track))}) phases:{(phase "Sowing" (play (or {(move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (if (is Mover P1) (sites (values Remembered "OwnedP1")) (sites (values Remembered "OwnedP2")))) if:(and (if (is Mover P1) (not (is In (from) (values Remembered "CapturedP2"))) (not (is In (from) (values Remembered "CapturedP1")))) (< 0 (count at:(from))))) (then (sow "Track" apply:(if (not (if (= (mover) P1) (is In (to) (values Remembered "CapturedP1")) (is In (to) (values Remembered "CapturedP2")))) (if (and (is In (to) (sites Next)) (= (count at:(to)) 4)) (if (is Mover P1) (remember Value "CapturedP1" (to)) (remember Value "CapturedP2" (to))) (if (if (= (mover) P1) (is In (to) (values Remembered "CapturedP2")) (is In (to) (values Remembered "CapturedP1"))) (fromTo (from (to)) (to (handSite Next)) count:1) (if (> (count at:(to)) 1) (moveAgain))))))))} (then (if (no Pieces in:(forEach (sites Board) if:(and (not (is In (site) (values Remembered "CapturedP1"))) (not (is In (site) (values Remembered "CapturedP2")))))) (and {(forEach Site (sites Board) (if (and (is In (site) (values Remembered "CapturedP1")) (is Occupied (site))) (fromTo (from (site)) (to (handSite P1)) count:(count at:(site))))) (forEach Site (sites Board) (if (and (is In (site) (values Remembered "CapturedP2")) (is Occupied (site))) (fromTo (from (site)) (to (handSite P2)) count:(count at:(site))))) (forget Value "OwnedP1" All) (forget Value "OwnedP2" All) (forget Value "CapturedP1" All) (forget Value "CapturedP2" All)}))))) (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) {(if (= 0 (count Cell at:(handSite P1))) (result P2 Win)) (if (= 0 (count Cell at:(handSite P2))) (result P1 Win))})) (nextPhase (all Sites (sites Board) if:(= 0 (count at:(site)))) "BetweenRounds")) (phase "BetweenRounds" (play (if (<= 4 (count Cell at:(handSite Mover))) (move (from (handSite Mover)) (to (if (all Sites (sites Mover) if:(is Occupied (site))) (sites Next) (sites Mover)) if:(is Empty (to))) count:4 (then (and (if (is Mover P1) (remember Value "OwnedP1" (last To)) (remember Value "OwnedP2" (last To))) (if (and (> 4 (count Cell at:(handSite P1))) (> 4 (count Cell at:(handSite P2)))) (and {(fromTo (from Cell (handSite P1)) (to (sites Empty)) count:(count Cell at:(handSite P1))) (fromTo (from Cell (handSite P2)) (to (sites Empty)) count:(count Cell at:(handSite P2))) (if (= 3 (count Cell at:(handSite P1))) (remember Value "OwnedP1" (regionSite (sites Empty) index:0)) (remember Value "OwnedP2" (regionSite (sites Empty) index:0)))}))))))) (nextPhase (and (is Empty (handSite P1)) (is Empty (handSite P2))) "Sowing"))})) 
2x6 board. Four counters in each hole. Sowing occurs in an anti-clockwise direction. The hole from which sowing begins must remain empty throughout the player's turn. Captures are made when the last counter of a sowing fall into the opponent's row in a hole containing one or two counters (thus making two or three), capturing all of the counters in that hole. A continuous series of holes holding two or three counters behind it are also captured, provided the player's sowing caused them to contain this number. If a player has no counters in their holes, the opponent must play to place seeds in their row, if possible. The game ends when players have holes with only empty and single counters. The player who captured the most counters wins. 
(game "Awari" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "0,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 4 to:(sites Track))) (play (do (move Select (from (sites Mover) if:(< 0 (count at:(from)))) (then (sow if:(and (is In (to) (sites Next)) (or (= (count at:(to)) 2) (= (count at:(to)) 3))) apply:(fromTo (from (to)) (to (handSite Mover)) count:(count at:(to))) includeSelf:False backtracking:True))) ifAfterwards:(< 0 (count in:(sites Next))))) (end (if (all Sites (sites Track) if:(<= (count at:(site)) 1)) (byScore {(score P1 (count Cell at:(handSite P1))) (score P2 (count Cell at:(handSite P2)))}))))) 
2x20 board. Opening arrangement: Each player has this opening arrangement (number of counters in each hole, starting from the leftmost hole): 5-5-5-5-5-5-5-1-1-5-2-1-0-0-0-0-0-0-0-0. Opening phase: Players remove the counters in their final four holes with counters and conceals them from the opponent. Players take the counters from any of their holes and sow them in an anti-clockwise direction. When sowing, the first counter is dropped into the hole from which it just came, unless it is a single counter. If the last counter lands in the opponent's row and this hole contains one or three, counters, these are taken and added to the concealed store. Also, if the hole from which a capture was made is preceded by an unbroken sequence of holes with one or three counters, these are also taken. In place of a move, a player may add all of the counters from the concealed store, sowing from the leftmost hole in their row. If the sowing reaches the rightmost hole in this row, sowing may continue from the leftmost hole or may continue into the opponent's row. If the player continues into the opponent's row, subsequent holes after the one in which the final counter was dropped are captured if they contain one or three counters, in an unbroken sequence.
(game "Azigo" (players 2) (equipment {(mancalaBoard 2 20 store:None {(track "Track" "0,E,N,W" loop:True) (track "TrackSpecialHome1" "0,E" loop:True P1) (track "TrackSpecialHome2" "39,W" loop:True P2)}) (piece "Seed" Shared) (hand Each) (map "LeftMost" {(pair P1 0) (pair P2 39)}) (regions "OpeningRegion" P1 (sites {8 9 10 11})) (regions "OpeningRegion" P2 (sites {28 29 30 31})) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(set Count 5 to:(sites {0 1 2 3 4 5 6 9 39 38 37 36 35 34 33 30})) (set Count 1 to:(sites {7 8 11 32 31 28})) (set Count 2 to:(sites {10 29}))}) phases:{(phase "Opening" (play (move (from (sites Mover "OpeningRegion") if:(is Occupied (from))) (to (handSite Mover)) count:(count at:(from)))) (nextPhase Mover (all Sites (sites Mover "OpeningRegion") if:(is Empty (site))) "Sowing")) (phase "Sowing" (play (or (move Select (from (sites Mover) if:(is Occupied (from))) (then (sow "Track" apply:(if (and (is In (to) (sites Next)) (or (= 2 (count at:(to))) (= 4 (count at:(to))))) (fromTo (from (to)) (to (handSite Mover)) count:(count at:(to)))) origin:(< 1 (count at:(from))) backtracking:True))) (if (is Occupied Cell (handSite Mover)) (or (do (set Var "NumToSow" (count Cell at:(handSite Mover))) next:(move (from (handSite Mover)) (to (mapEntry "LeftMost" Mover)) count:(count Cell at:(handSite Mover)) (then (and (sow count:(var "NumToSow") "Track" if:(and (is In (to) (sites Next)) (or (= 2 (count at:(to))) (= 4 (count at:(to))))) apply:(if (and (is In (to) (sites Next)) (or (= 2 (count at:(to))) (= 4 (count at:(to))))) (fromTo (from (to)) (to (handSite Mover)) count:(count at:(to)))) origin:True forward:True) (set Var "NumToSow" 0))))) (do (set Var "NumToSow" (count Cell at:(handSite Mover))) next:(move (from (handSite Mover)) (to (mapEntry "LeftMost" Mover)) count:(count Cell at:(handSite Mover)) (then (and (sow count:(var "NumToSow") "TrackSpecialHome" owner:(mover) origin:True) (set Var "NumToSow" 0))))))))))} (end (if (no Moves Mover) (byScore {(score P1 (+ (count Cell at:(handSite P1)) (count in:(sites P1)))) (score P2 (+ (count Cell at:(handSite P2)) (count in:(sites P2))))}))))) 
2x6 board. Each player has 36 counters which they arrange however they like in their holes. Play begins from any hole in a player's row. Sowing occurs in an anti-clockwise direction. When the last counter falls makes an odd number of counters in the final hole of the sowing, these are picked up and sowing continues. If the last hole is made to be even, these are captured, as well as the contents of the opposite hole. If the previous hole is also even, those counters and those in the opposite hole are also taken, continuing until there is an odd or empty hole. If the final counter falls into an empty hole, play ends. The round ends when one player is unable to move. A new round begins. The player with the smaller number of counters distributes them as they like in their holes. The opponent then copies this arrangement, keeping the surplus of counters. Play continues as before. Rounds are played until one player has no remaining counters.
(game "Baqura" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "0,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (piece "Seed" Shared) (hand Each)}) (rules (start {(set Count 36 at:(handSite P1)) (set Count 36 at:(handSite P2))}) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Mover)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Sowing")) (phase "Sowing" (play (if (not (all Sites (sites Mover) if:(= 0 (count at:(site))))) (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover)) if:(> (count at:(from)) 0)) (then (sow if:(> (count at:(to)) 1) apply:(if (and (> (count at:(to)) 1) (is Odd (count at:(to)))) (moveAgain) (and (if (> (count at:(if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6))) 0) (fromTo (from (if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6))) (to (handSite Mover)) count:(count at:(if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6))))) (fromTo (from (to)) (to (handSite Mover)) count:(count at:(to))))) backtracking:(and {(is In (to) (sites Mover)) (> (count at:(to)) 1) (is Even (count at:(to)))})))) (move Pass (then (and (forEach Site (sites Next) (if (is Occupied (site)) (fromTo (from (site)) (to (handSite Next)) count:(count at:(site))))) (if (< (+ (count Cell at:(handSite P1)) (count in:(sites P1))) (+ (count Cell at:(handSite P2)) (count in:(sites P2)))) (set NextPlayer (player 1)) (set NextPlayer (player 2)))))))) (nextPhase (was Pass) "PlacementLosingPlayer")) (phase "PlacementLosingPlayer" (play (move (from (handSite Mover)) (to (sites Mover)) (then (if (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) (forEach Site (sites Mover) (if (is Occupied (site)) (fromTo (from Cell (handSite Next)) (to (if (is In (site) (sites Bottom)) (+ (site) 6) (- (site) 6))) count:(count at:(site))))) (moveAgain))))) (nextPhase (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Sowing"))} (end (forEach Player if:(= 0 (+ (count Cell at:(handSite Player)) (count in:(sites Player)))) (result Player Loss))))) 
2x4 board with two stores on either end, the store on a player's right belonging to them. Four counters per hole, five in each store. Players sow in the direction of their choosing from one of the holes in their row, not from the stores, on each turn, sowing also into the stores. If the next hole has counters, these are picked up and sowing continues with these counters. When this next hole is empty, the counters in the next hole after that are captured and the turn ends. If there are a series of alternating empty holes and holes with counters, the counters in these holes are captured until two empty or full holes are reached. When the point of the game is reached that play cannot continue, the players claim the counters in their holes, and a new game begins. The players refill their holes, beginning with their store, which receives five counters, and four in each other. Holes are only filled with exactly four counters, any extra are set aside. If a player cannot fill any of their holes with counters, these holes are eliminated from play. Play continues in this way until one player captures all of the counters or the other player cannot fill any holes.
(game "Bay Khom" (players 2) (equipment {(mancalaBoard 2 4 {(track "TrackCW" "0,5,E,9,4,W" loop:True) (track "TrackCCW" "0,1,E,9,8,W" loop:True)}) (piece "Seed" Shared) (map {(pair P1 LastSite) (pair P2 FirstSite)}) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (hand Each)}) (rules (start {(set Count 4 to:(union (sites P1) (sites P2))) (set Count 5 at:(mapEntry 1)) (set Count 5 at:(mapEntry 2)) (set RememberValue "OwnedP1" (sites Bottom)) (set RememberValue "OwnedP2" (sites Top))}) phases:{(phase "Sowing" (play (or (if (or (<= (var "Direction") 0) (= (var "Direction") 1)) (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (if (is Mover P1) (sites (values Remembered "OwnedP1")) (sites (values Remembered "OwnedP2")))) if:(is Occupied (from))) (then (sow "TrackCW" apply:(if (is Occupied (trackSite Move from:(to) "TrackCW" steps:1)) (and (moveAgain) (set Var "Direction" 1)) (and (if (is Occupied (trackSite Move from:(to) "TrackCW" steps:2)) (and (fromTo (from (trackSite Move from:(to) "TrackCW" steps:2)) (to (mapEntry Mover)) count:(count at:(trackSite Move from:(to) "TrackCW" steps:2))) (if (and (is Empty (trackSite Move from:(to) "TrackCW" steps:3)) (is Occupied (trackSite Move from:(to) "TrackCW" steps:4))) (and (fromTo (from (trackSite Move from:(to) "TrackCW" steps:4)) (to (mapEntry Mover)) count:(count at:(trackSite Move from:(to) "TrackCW" steps:4))) (if (and (is Empty (trackSite Move from:(to) "TrackCW" steps:5)) (is Occupied (trackSite Move from:(to) "TrackCW" steps:6))) (and (fromTo (from (trackSite Move from:(to) "TrackCW" steps:6)) (to (mapEntry Mover)) count:(count at:(trackSite Move from:(to) "TrackCW" steps:6))) (if (and (is Empty (trackSite Move from:(to) "TrackCW" steps:7)) (is Occupied (trackSite Move from:(to) "TrackCW" steps:8))) (fromTo (from (trackSite Move from:(to) "TrackCW" steps:8)) (to (mapEntry Mover)) count:(count at:(trackSite Move from:(to) "TrackCW" steps:8)))))))))) (set Var "Direction" 0))))))) (if (or (<= (var "Direction") 0) (= (var "Direction") 2)) (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (if (is Mover P1) (sites (values Remembered "OwnedP1")) (sites (values Remembered "OwnedP2")))) if:(is Occupied (from))) (then (sow "TrackCCW" apply:(if (is Occupied (trackSite Move from:(to) "TrackCCW" steps:1)) (and (moveAgain) (set Var "Direction" 2)) (and (if (is Occupied (trackSite Move from:(to) "TrackCCW" steps:2)) (and (fromTo (from (trackSite Move from:(to) "TrackCCW" steps:2)) (to (mapEntry Mover)) count:(count at:(trackSite Move from:(to) "TrackCCW" steps:2))) (if (and (is Empty (trackSite Move from:(to) "TrackCCW" steps:3)) (is Occupied (trackSite Move from:(to) "TrackCCW" steps:4))) (and (fromTo (from (trackSite Move from:(to) "TrackCCW" steps:4)) (to (mapEntry Mover)) count:(count at:(trackSite Move from:(to) "TrackCCW" steps:4))) (if (and (is Empty (trackSite Move from:(to) "TrackCCW" steps:5)) (is Occupied (trackSite Move from:(to) "TrackCCW" steps:6))) (and (fromTo (from (trackSite Move from:(to) "TrackCCW" steps:6)) (to (mapEntry Mover)) count:(count at:(trackSite Move from:(to) "TrackCCW" steps:6))) (if (and (is Empty (trackSite Move from:(to) "TrackCCW" steps:7)) (is Occupied (trackSite Move from:(to) "TrackCCW" steps:8))) (fromTo (from (trackSite Move from:(to) "TrackCCW" steps:8)) (to (mapEntry Mover)) count:(count at:(trackSite Move from:(to) "TrackCCW" steps:8)))))))))) (set Var "Direction" 0))))))) (then (if (all Sites (union (sites (values Remembered "OwnedP1")) (sites (values Remembered "OwnedP2"))) if:(is Empty (site))) (and {(forEach Site (sites P1) (fromTo (from (site)) (to (handSite P1)) count:(count at:(site)))) (if (is Occupied (mapEntry P1)) (fromTo (from (mapEntry P1)) (to (handSite P1)) count:(count at:(mapEntry P1)))) (forEach Site (sites P2) (fromTo (from (site)) (to (handSite P2)) count:(count at:(site)))) (if (is Occupied (mapEntry P2)) (fromTo (from (mapEntry P2)) (to (handSite P2)) count:(count at:(mapEntry P2)))) (forget Value "OwnedP1" All) (forget Value "OwnedP2" All)}))))) (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) {(if (> 9 (count Cell at:(handSite P1))) (result P2 Win)) (if (> 9 (count Cell at:(handSite P2))) (result P1 Win))})) (nextPhase (all Sites (sites Board) if:(= 0 (count at:(site)))) "BetweenRounds")) (phase "BetweenRounds" (play (if (is Empty (mapEntry Mover)) (move (from (handSite Mover)) (to (mapEntry Mover)) count:5) (if (<= 4 (count Cell at:(handSite Mover))) (move (from (handSite Mover)) (to (sites Mover) if:(is Empty (to))) count:4 (then (if (is Mover P1) (remember Value "OwnedP1" (last To)) (remember Value "OwnedP2" (last To)))))))) (nextPhase (all Passed) "Sowing"))})) 
2x4 board. Six counters per hole. Sowing occurs in a clockwise direction from the left half of a player's row, and anti-clockwise when played from the player's right half of the row. The first seed of sowing is placed in the hole from which the sowing began. When the final counter of a sowing falls into an occupied hole, and it now contains an even number of counters, these are captured, provided the contents of that hole have already been moved. Should the following hole also contain an even number of counters, these are also captured, as well as the next one, until there is a hole with an odd number of counters. If a player cannot move, they must pass until the opponent plays in such a way that they may play. If neither player is able to move, they both capture the counters in their rows. Players then count their counters by placing them six per hole. The player who has more counters than necessary to fill their holes places them aside for use in successive rounds. The player who is unable to fill a hole with six counters leaves it empty, also placing the extra counters aside for later use. This hole is not to be sown into. The player chooses which hole to leave empty. Subsequent rounds continue until one player cannot fill a hole with six counters.  The board has 4 columns.
(game "Bechi" (players 2) (equipment {(mancalaBoard 2 4 store:None {(track "TrackCW" "3,W,N,E" loop:True) (track "TrackCCW" "0,E,N,W" loop:True)}) (regions "Home" P1 (sites Bottom)) (regions "Home" P2 (sites Top)) (regions "LeftSide" P1 (intersection (expand (sites Left) steps:1) (sites Bottom))) (regions "LeftSide" P2 (intersection (expand (sites Right) steps:1) (sites Top))) (regions "RightSide" P1 (intersection (expand (sites Right) steps:1) (sites Bottom))) (regions "RightSide" P2 (intersection (expand (sites Left) steps:1) (sites Top))) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 6 to:(sites Track))) phases:{(phase "Sowing" (play (if (can Move (or {(move Select (from (sites Mover "LeftSide") if:(> (count at:(from)) 1)) (then (and (remember Value "HolesSowed" (last To)) (sow "TrackCW" apply:(if (and (is In (to) (values Remembered "HolesSowed")) (is Even (count at:(to)))) (fromTo (from (to)) (to (handSite Mover)) count:(count at:(to)) (then (if (is Even (count at:(trackSite Move from:(last From) "TrackCW" steps:1))) (and (fromTo (from (trackSite Move from:(last From) "TrackCW" steps:1)) (to (handSite Mover)) count:(count at:(trackSite Move from:(last From) "TrackCW" steps:1))) (if (is Even (count at:(trackSite Move from:(last From) "TrackCW" steps:2))) (and (fromTo (from (trackSite Move from:(last From) "TrackCW" steps:2)) (to (handSite Mover)) count:(count at:(trackSite Move from:(last From) "TrackCW" steps:2))) (if (is Even (count at:(trackSite Move from:(last From) "TrackCW" steps:3))) (and (fromTo (from (trackSite Move from:(last From) "TrackCW" steps:3)) (to (handSite Mover)) count:(count at:(trackSite Move from:(last From) "TrackCW" steps:3))) (if (is Even (count at:(trackSite Move from:(last From) "TrackCW" steps:4))) (and (fromTo (from (trackSite Move from:(last From) "TrackCW" steps:4)) (to (handSite Mover)) count:(count at:(trackSite Move from:(last From) "TrackCW" steps:4))) (if (is Even (count at:(trackSite Move from:(last From) "TrackCW" steps:5))) (and (fromTo (from (trackSite Move from:(last From) "TrackCW" steps:5)) (to (handSite Mover)) count:(count at:(trackSite Move from:(last From) "TrackCW" steps:5))) (if (is Even (count at:(trackSite Move from:(last From) "TrackCW" steps:6))) (fromTo (from (trackSite Move from:(last From) "TrackCW" steps:6)) (to (handSite Mover)) count:(count at:(trackSite Move from:(last From) "TrackCW" steps:6))))))))))))))))) origin:True)))) (move Select (from (sites Mover "RightSide") if:(> (count at:(from)) 1)) (then (and (remember Value "HolesSowed" (last To)) (sow "TrackCCW" apply:(if (and (is In (to) (values Remembered "HolesSowed")) (is Even (count at:(to)))) (fromTo (from (to)) (to (handSite Mover)) count:(count at:(to)) (then (if (is Even (count at:(trackSite Move from:(last From) "TrackCCW" steps:1))) (and (fromTo (from (trackSite Move from:(last From) "TrackCCW" steps:1)) (to (handSite Mover)) count:(count at:(trackSite Move from:(last From) "TrackCCW" steps:1))) (if (is Even (count at:(trackSite Move from:(last From) "TrackCCW" steps:2))) (and (fromTo (from (trackSite Move from:(last From) "TrackCCW" steps:2)) (to (handSite Mover)) count:(count at:(trackSite Move from:(last From) "TrackCCW" steps:2))) (if (is Even (count at:(trackSite Move from:(last From) "TrackCCW" steps:3))) (and (fromTo (from (trackSite Move from:(last From) "TrackCCW" steps:3)) (to (handSite Mover)) count:(count at:(trackSite Move from:(last From) "TrackCCW" steps:3))) (if (is Even (count at:(trackSite Move from:(last From) "TrackCCW" steps:4))) (and (fromTo (from (trackSite Move from:(last From) "TrackCCW" steps:4)) (to (handSite Mover)) count:(count at:(trackSite Move from:(last From) "TrackCCW" steps:4))) (if (is Even (count at:(trackSite Move from:(last From) "TrackCCW" steps:5))) (and (fromTo (from (trackSite Move from:(last From) "TrackCCW" steps:5)) (to (handSite Mover)) count:(count at:(trackSite Move from:(last From) "TrackCCW" steps:5))) (if (is Even (count at:(trackSite Move from:(last From) "TrackCCW" steps:6))) (fromTo (from (trackSite Move from:(last From) "TrackCCW" steps:6)) (to (handSite Mover)) count:(count at:(trackSite Move from:(last From) "TrackCCW" steps:6))))))))))))))))) origin:True))))})) (or {(move Select (from (sites Mover "LeftSide") if:(> (count at:(from)) 1)) (then (and (remember Value "HolesSowed" (last To)) (sow "TrackCW" apply:(if (and (is In (to) (values Remembered "HolesSowed")) (is Even (count at:(to)))) (fromTo (from (to)) (to (handSite Mover)) count:(count at:(to)) (then (if (is Even (count at:(trackSite Move from:(last From) "TrackCW" steps:1))) (and (fromTo (from (trackSite Move from:(last From) "TrackCW" steps:1)) (to (handSite Mover)) count:(count at:(trackSite Move from:(last From) "TrackCW" steps:1))) (if (is Even (count at:(trackSite Move from:(last From) "TrackCW" steps:2))) (and (fromTo (from (trackSite Move from:(last From) "TrackCW" steps:2)) (to (handSite Mover)) count:(count at:(trackSite Move from:(last From) "TrackCW" steps:2))) (if (is Even (count at:(trackSite Move from:(last From) "TrackCW" steps:3))) (and (fromTo (from (trackSite Move from:(last From) "TrackCW" steps:3)) (to (handSite Mover)) count:(count at:(trackSite Move from:(last From) "TrackCW" steps:3))) (if (is Even (count at:(trackSite Move from:(last From) "TrackCW" steps:4))) (and (fromTo (from (trackSite Move from:(last From) "TrackCW" steps:4)) (to (handSite Mover)) count:(count at:(trackSite Move from:(last From) "TrackCW" steps:4))) (if (is Even (count at:(trackSite Move from:(last From) "TrackCW" steps:5))) (and (fromTo (from (trackSite Move from:(last From) "TrackCW" steps:5)) (to (handSite Mover)) count:(count at:(trackSite Move from:(last From) "TrackCW" steps:5))) (if (is Even (count at:(trackSite Move from:(last From) "TrackCW" steps:6))) (fromTo (from (trackSite Move from:(last From) "TrackCW" steps:6)) (to (handSite Mover)) count:(count at:(trackSite Move from:(last From) "TrackCW" steps:6))))))))))))))))) origin:True)))) (move Select (from (sites Mover "RightSide") if:(> (count at:(from)) 1)) (then (and (remember Value "HolesSowed" (last To)) (sow "TrackCCW" apply:(if (and (is In (to) (values Remembered "HolesSowed")) (is Even (count at:(to)))) (fromTo (from (to)) (to (handSite Mover)) count:(count at:(to)) (then (if (is Even (count at:(trackSite Move from:(last From) "TrackCCW" steps:1))) (and (fromTo (from (trackSite Move from:(last From) "TrackCCW" steps:1)) (to (handSite Mover)) count:(count at:(trackSite Move from:(last From) "TrackCCW" steps:1))) (if (is Even (count at:(trackSite Move from:(last From) "TrackCCW" steps:2))) (and (fromTo (from (trackSite Move from:(last From) "TrackCCW" steps:2)) (to (handSite Mover)) count:(count at:(trackSite Move from:(last From) "TrackCCW" steps:2))) (if (is Even (count at:(trackSite Move from:(last From) "TrackCCW" steps:3))) (and (fromTo (from (trackSite Move from:(last From) "TrackCCW" steps:3)) (to (handSite Mover)) count:(count at:(trackSite Move from:(last From) "TrackCCW" steps:3))) (if (is Even (count at:(trackSite Move from:(last From) "TrackCCW" steps:4))) (and (fromTo (from (trackSite Move from:(last From) "TrackCCW" steps:4)) (to (handSite Mover)) count:(count at:(trackSite Move from:(last From) "TrackCCW" steps:4))) (if (is Even (count at:(trackSite Move from:(last From) "TrackCCW" steps:5))) (and (fromTo (from (trackSite Move from:(last From) "TrackCCW" steps:5)) (to (handSite Mover)) count:(count at:(trackSite Move from:(last From) "TrackCCW" steps:5))) (if (is Even (count at:(trackSite Move from:(last From) "TrackCCW" steps:6))) (fromTo (from (trackSite Move from:(last From) "TrackCCW" steps:6)) (to (handSite Mover)) count:(count at:(trackSite Move from:(last From) "TrackCCW" steps:6))))))))))))))))) origin:True))))}) (move Pass (then (if (all Passed) (and {(forEach Site (sites P1 "Home") (if (is Occupied (site)) (fromTo (from (site)) (to (handSite P1)) count:(count at:(site))))) (forEach Site (sites P2 "Home") (if (is Occupied (site)) (fromTo (from (site)) (to (handSite P2)) count:(count at:(site))))) (forget Value "HolesSowed" All)})))))) (end (if (all Passed) {(if (> 6 (count Cell at:(handSite P1))) (result P2 Win)) (if (> 6 (count Cell at:(handSite P2))) (result P1 Win))})) (nextPhase (all Passed) "BetweenRounds")) (phase "BetweenRounds" (play (if (<= 6 (count Cell at:(handSite Mover))) (move (from (handSite Mover)) (to (intersection (sites Empty) (sites Mover "Home"))) count:6))) (nextPhase (all Passed) "Sowing"))})) 
Play begins with four counters in each hole. Players move by picking up all of the counters in any of the holes in their row and sowing them anti-clockwise. If the next hole after the one in which the final counter is dropped contains counters, these are picked up and sowing continues. If the next hole after the one in which the last counter was sown is empty, the counters in the hole after this one are taken and the turn is over. If that hole is empty, none are taken. When all of the holes in one row are empty, the player whose row still contains counters captures these counters. A new game begins. Each player fills as many of the holes in their row with four counters. The player which cannot fill all of their holes with four counters removes from play all of the holes that cannot be filled, and sets aside the extra counters. They play another round with the same rules as before, but without the eliminated hole(s). The game ends when one player must close all of the holes in their row, thus being unable to play.
(game "Bosh" (players 2) (equipment {(mancalaBoard 2 5 store:None (track "Track" "0,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (piece "Seed" Shared) (hand Each)}) (rules (start {(set Count 4 to:(sites Track)) (set RememberValue "OwnedP1" (sites Bottom)) (set RememberValue "OwnedP2" (sites Top))}) phases:{(phase "Sowing" (play (or {(move Select (from (if (is Prev Mover) (sites {(trackSite Move from:(last To afterConsequence:True) steps:1)}) (if (is Mover P1) (sites (values Remembered "OwnedP1")) (sites (values Remembered "OwnedP2")))) if:(> (count at:(from)) 0)) (then (sow apply:(if (and (= (count at:(trackSite Move from:(to) steps:1)) 0) (> (count at:(trackSite Move from:(to) steps:2)) 0)) (fromTo (from (trackSite Move from:(to) steps:2)) (to (handSite Mover)) count:(count at:(trackSite Move from:(to) steps:2))) (if (> (count at:(trackSite Move from:(to) steps:1)) 0) (moveAgain))) skipIf:(not (is In (to) (union (values Remembered "OwnedP1") (values Remembered "OwnedP2")))))))} (then (if (or (no Pieces All in:(sites P1)) (no Pieces All in:(sites P2))) (and (forEach Site (sites P1) (fromTo (from (site)) (to (handSite P1)) count:(count at:(site)))) (forEach Site (sites P2) (fromTo (from (site)) (to (handSite P2)) count:(count at:(site))))))))) (nextPhase (all Sites (sites Board) if:(= 0 (count at:(site)))) "BetweenRounds")) (phase "BetweenRounds" (play (if (<= 4 (count Cell at:(handSite Mover))) (move (from (handSite Mover)) (to (intersection (sites Empty) (sites Mover))) count:4) (move Pass (then (forEach Site (if (is Mover P1) (sites (values Remembered "OwnedP1")) (sites (values Remembered "OwnedP2"))) (if (is Empty (site)) (if (is Mover P1) (forget Value "OwnedP1" (site)) (forget Value "OwnedP2" (site))))))))) (end (if (all Passed) {(if (if (= 1 P1) (= 0 (size Array (values Remembered "OwnedP1"))) (= 0 (size Array (values Remembered "OwnedP2")))) (result P2 Win)) (if (if (= 2 P1) (= 0 (size Array (values Remembered "OwnedP1"))) (= 0 (size Array (values Remembered "OwnedP2")))) (result P1 Win))})) (nextPhase (all Passed) "Sowing"))})) 
2x4 board, rendered as holes in the sand. Six counters per hole. A player picks up all of the counters in one of the holes in their row and sows them in an anti-clockwise direction. When the final counter lands in an empty hole, the contents of the following hole are picked up and the sowing continues. When the final counter lands in a hole in the opponent's row causing it to contain six counters, these counters are captured. Play continues until one player has no counters in their holes, and the opponent wins.
(game "Boukerourou" (players 2) (equipment {(mancalaBoard 2 4 store:None (track "Track" "0,E,N,W" loop:True)) (piece "Seed" Shared) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start (set Count 6 to:(sites Track))) (play (move Select (from (if (is Prev Mover) (sites {(trackSite Move from:(last To afterConsequence:True) "Track" steps:1)}) (sites Mover)) if:(> (count at:(from)) 0)) (then (sow apply:(if (and (= 1 (count at:(to))) (is Occupied (trackSite Move from:(to) "Track" steps:1))) (moveAgain) (if (and (is In (to) (sites Next)) (= 6 (count at:(to)))) (remove (to)))))))) (end (forEach Player if:(all Sites (sites Player) if:(= 0 (count at:(site)))) (result Player Loss))))) 
2x4 board. Six counters in each hole. At the beginning of the game, each player chooses one hole to be their sowing hole, from which each move on their turn must begin. The players agree on a direction of play, which is maintained throughout the game. Players alternate turns sowing from their sowing hole. The players may choose to sow one-by-one, two-by-two, three-by-three, four-by-four, and so forth, into the following holes. When the final counter lands in a hole causing it to contain two, four, six, or eight counters, the contents of that hole are captured. If the preceding hole also contains two, four, six, or eight counters, these are also captured, proceeding until there is a no longer a hole with two, four, six, or eight counters. If at the end of a turn a player sowed into the opponent's row and any of the opponent's holes contain two, four, six, or eight counters, providing the player sowed into them, the opponent captures these counters. In a players own row, if either player sows into a hole with an odd number of counters, making it an even number of counters, the player who owns that row captures the counters. If a player's sowing hole is empty at the beginning of their turn, they pass. Play continues until all of the counters are captured, or there is only one left on the board. The single counter is captured by the player in whose row it is located. A new round begins. Players fill up as many holes as they can with six counters. If a player cannot, they fill as many as they can with six counters, and place the remainder in a hole, either between two with six counters or after them, and erases any empty holes. Play continues as before. When one player has erased all of their holes, the opponent wins. The game is played counter clockwise.
(game "Buqruru" (players 2) (equipment {(mancalaBoard 2 4 store:None (track "Track" "0,E,N,W" loop:True)) (piece "Seed" Shared) (hand Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(set Count 6 to:(sites Track)) (set RememberValue "Playable" (sites Board))}) phases:{(phase "SelectingHole" (play (move Select (from (sites Mover) if:(is In (from) (sites (values Remembered "Playable")))) (then (set Value Mover (last To))))) (nextPhase Mover "Sowing")) (phase "Sowing" (play (if (is Occupied (value Player Mover)) (or {(move Select (from (value Player Mover) if:(is In (from) (sites (values Remembered "Playable")))) (then (sow numPerHole:1 sowEffect:(if (and (is In (to) (sites Next)) (or {(= 1 (count at:(to))) (= 3 (count at:(to))) (= 5 (count at:(to))) (= 7 (count at:(to)))})) (fromTo (from (to)) (to (handSite Mover)) count:(count at:(to)))) apply:(if (or {(= 2 (count at:(to))) (= 4 (count at:(to))) (= 6 (count at:(to))) (= 8 (count at:(to)))}) (fromTo (from (to)) (to (handSite Mover)) count:(count at:(to)))) skipIf:(not (is In (to) (sites (values Remembered "Playable")))) backtracking:True))) (if (= 0 (% (count at:(value Player Mover)) 2)) (move Select (from (value Player Mover)) (then (sow numPerHole:2 sowEffect:(if (and (is In (to) (sites Next)) (or {(= 0 (count at:(to))) (= 2 (count at:(to))) (= 4 (count at:(to))) (= 6 (count at:(to)))})) (fromTo (from (to)) (to (handSite Mover)) count:(count at:(to)))) apply:(if (or {(= 2 (count at:(to))) (= 4 (count at:(to))) (= 6 (count at:(to))) (= 8 (count at:(to)))}) (fromTo (from (to)) (to (handSite Mover)) count:(count at:(to)))) skipIf:(not (is In (to) (sites (values Remembered "Playable")))) backtracking:True)))) (if (= 0 (% (count at:(value Player Mover)) 3)) (move Select (from (value Player Mover)) (then (sow numPerHole:3 sowEffect:(if (and (is In (to) (sites Next)) (or {(= 1 (count at:(to))) (= 3 (count at:(to))) (= 5 (count at:(to)))})) (fromTo (from (to)) (to (handSite Mover)) count:(count at:(to)))) apply:(if (or {(= 2 (count at:(to))) (= 4 (count at:(to))) (= 6 (count at:(to))) (= 8 (count at:(to)))}) (fromTo (from (to)) (to (handSite Mover)) count:(count at:(to)))) skipIf:(not (is In (to) (sites (values Remembered "Playable")))) backtracking:True)))) (if (= 0 (% (count at:(value Player Mover)) 4)) (move Select (from (value Player Mover)) (then (sow numPerHole:4 sowEffect:(if (and (is In (to) (sites Next)) (or {(= 0 (count at:(to))) (= 2 (count at:(to))) (= 4 (count at:(to)))})) (fromTo (from (to)) (to (handSite Mover)) count:(count at:(to)))) apply:(if (or {(= 2 (count at:(to))) (= 4 (count at:(to))) (= 6 (count at:(to))) (= 8 (count at:(to)))}) (fromTo (from (to)) (to (handSite Mover)) count:(count at:(to)))) skipIf:(not (is In (to) (sites (values Remembered "Playable")))) backtracking:True))))}) (then (if (> 2 (count in:(union (sites Top) (sites Bottom)))) (and {(forEach Site (sites P1) (if (is Occupied (site)) (fromTo (from (site)) (to (handSite P1)) count:(count at:(site))))) (forEach Site (sites P2) (if (is Occupied (site)) (fromTo (from (site)) (to (handSite P2)) count:(count at:(site))))) (forget Value "Playable" All)}))))) (end {(if (and (= 0 (count at:(value Player P1))) (= 0 (count at:(value Player P2)))) (result Mover Draw)) (if (> 2 (count in:(union (sites Top) (sites Bottom)))) {(if (= 0 (count Cell at:(handSite P1))) (result P2 Win)) (if (= 0 (count Cell at:(handSite P2))) (result P1 Win))})}) (nextPhase (> 2 (count in:(union (sites Top) (sites Bottom)))) "BetweenRounds")) (phase "BetweenRounds" (play (if (not (all Sites (sites Mover) if:(is Occupied (site)))) (if (<= 6 (count at:(handSite Mover))) (move (from (handSite Mover)) (to (sites Mover)) count:6 (then (remember Value "Playable" (last To)))) (move (from (handSite Mover)) (to (sites Mover)) count:(count at:(handSite Mover)) (then (remember Value "Playable" (last To))))))) (nextPhase (all Passed) "SelectingHole"))})) 
2x5 board with one store on either end. The store to the right of the player belongs to the player. Play begins with five counters in each regular hole, with one larger stone in each store, but one is slightly smaller than the other. Game can be played with two or four players. With four players, two players control the larger stones, but cannot move the regular counters. Players throw out a finger (index, little, or thumb) to determine who plays first. Index beats thumb, thumb beats little finger, little finger beats index. This happens at the start of each round. Counters are taken from any of the holes in the player's row, sowing them in either direction, including the stores. When the last counter of a sowing is dropped in a hole, sowing continues by picking up the counters in the next hole and continuing to sow in that direction. If the hole following the last seed of a sowing is empty, the counters in the hole following this empty hole are captured. If there is an empty hole following the captured hole, and then an occupied hole immediately after it, the counters in the occupied hole are also captured, and so forth until there are two occupied or two empty holes in a row. Moves may not begin from stores. Both stores are sown into normally by both players. Stores are considered to be empty, except when its large stone remains in it, then the large stone only can be sown or captured and not any other counters that may have accumulated there. Large stones can be sown in any order a player chooses during a sowing. If a player has no counters in their holes, they may opt to place one counter in each of their holes, taking counters from their store and continue play (called huelshe). If they opt not to, the opponent takes all the remaining stones on the board. If one of the large stones remains in its original store, the player cannot opt out. If the player doesn't have enough stones for all of the holes, they may choose which holes in their row to place the counters, but they must form a continuous sequence of holes with counters. When the round ends, players must buy back their large stones if they no longer have them, at a price determined in the beginning of the game (usually seven for the larger stone and six for the smaller). Players then attempt to refill their holes with the original number of counters. The player that has fewer than the original number of counters must borrow counters from the opponent. Debt accumulates over subsequent rounds. When the debt reaches five, the player must sell one of their holes to the opponent. The selling player can choose which holes to sell. The seller then receives five counters to either repay debt or fill holes as long as debt does not exceed four.  Each row has 5 holes. The price of the largest stone is 7.
(game "Ceelkoqyuqkoqiji" (players 2) (equipment {(mancalaBoard 2 5 largeStack:True {(track "TrackCCW" "0,1,E,11,10,W" loop:True) (track "TrackCW" "0,6,E,11,5,W" loop:True)}) (piece "Seed" Shared) (piece "Ball" P1) (piece "Ball" P2) (hand Each size:2) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 LastSite) (pair P2 FirstSite)}) (regions "EndHoles" (sites {0 (+ 1 (* 2 5))}))}) (rules (start {(place Stack "Seed" (union (sites Bottom) (sites Top)) count:5) (place Stack "Ball1" (mapEntry P1)) (place Stack "Ball2" (mapEntry P2)) (set RememberValue "OwnedP1" (sites Bottom)) (set RememberValue "OwnedP2" (sites Top))}) phases:{(phase "Sowing" (play (or {(if (!= (var "Direction") 2) (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (if (is Mover P1) (sites (values Remembered "OwnedP1")) (sites (values Remembered "OwnedP2")))) if:(!= 0 (size Stack at:(from)))) (then (and {(forEach Value min:1 max:(size Stack at:(last From)) (fromTo (from (last From) level:(- (size Stack at:(last From)) (value))) (to (trackSite Move from:(last From) "TrackCCW" steps:(value))) stack:True)) (if (or (is In (trackSite Move from:(last From) "TrackCCW" steps:(+ 1 (size Stack at:(last From)))) (sites "EndHoles")) (>= (size Stack at:(last From)) (* 2 5))) (set Var "Direction" 0) (if (!= 0 (size Stack at:(trackSite Move from:(last From) "TrackCCW" steps:(+ 1 (size Stack at:(last From)))))) (and {(set Var "Direction" 1) (moveAgain) (set Var "Replay" (trackSite Move from:(last From) "TrackCCW" steps:(+ 1 (size Stack at:(last From)))))}) (and (set Var "Direction" 0) (if (is Occupied (trackSite Move from:(last From) "TrackCCW" steps:(+ 2 (size Stack at:(last From))))) (forEach Level (trackSite Move from:(last From) "TrackCCW" steps:(+ 2 (size Stack at:(last From)))) FromTop (if (= (id "Seed" Shared) (what at:(trackSite Move from:(last From) "TrackCCW" steps:(+ 2 (size Stack at:(last From)))) level:(level))) (fromTo (from (trackSite Move from:(last From) "TrackCCW" steps:(+ 2 (size Stack at:(last From)))) level:(level)) (to (handSite Mover))) (fromTo (from (trackSite Move from:(last From) "TrackCCW" steps:(+ 2 (size Stack at:(last From)))) level:(level)) (to (handSite Mover 1)))))))))})))) (if (!= (var "Direction") 1) (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (if (is Mover P1) (sites (values Remembered "OwnedP1")) (sites (values Remembered "OwnedP2")))) if:(!= 0 (size Stack at:(from)))) (then (and (forEach Value min:1 max:(size Stack at:(last From)) (fromTo (from (last From) level:(- (size Stack at:(last From)) (value))) (to (trackSite Move from:(last From) "TrackCW" steps:(value))) stack:True)) (if (or (is In (trackSite Move from:(last From) "TrackCW" steps:(+ 1 (size Stack at:(last From)))) (sites "EndHoles")) (>= (size Stack at:(last From)) (* 5 2))) (set Var "Direction" 0) (if (!= 0 (size Stack at:(trackSite Move from:(last From) "TrackCW" steps:(+ 1 (size Stack at:(last From)))))) (and {(set Var "Direction" 2) (moveAgain) (set Var "Replay" (trackSite Move from:(last From) "TrackCW" steps:(+ 1 (size Stack at:(last From)))))}) (and (set Var "Direction" 0) (if (is Occupied (trackSite Move from:(last From) "TrackCW" steps:(+ 2 (size Stack at:(last From))))) (forEach Level (trackSite Move from:(last From) "TrackCW" steps:(+ 2 (size Stack at:(last From)))) FromTop (if (= (id "Seed" Shared) (what at:(trackSite Move from:(last From) "TrackCW" steps:(+ 2 (size Stack at:(last From)))) level:(level))) (fromTo (from (trackSite Move from:(last From) "TrackCW" steps:(+ 2 (size Stack at:(last From)))) level:(level)) (to (handSite Mover))) (fromTo (from (trackSite Move from:(last From) "TrackCW" steps:(+ 2 (size Stack at:(last From)))) level:(level)) (to (handSite Mover 1)))))))))))))} (then (if (= 2 (count Cell in:(sites {(handSite P1 1) (handSite P2 1)}))) (and {(forEach Site (intersection (sites (values Remembered "OwnedP1")) (sites (values Remembered "OwnedP2"))) (if (is Occupied (site)) (and (forEach Level (site) FromTop (if (>= (level) (/ (size Stack at:(site)) 2)) (fromTo (from (site) level:(level)) (to (handSite P1)) stack:True))) (forEach Level (site) FromTop (if (< (level) (/ (size Stack at:(site)) 2)) (fromTo (from (site) level:(level)) (to (handSite P2)) stack:True)))))) (forEach Site (union (difference (sites (values Remembered "OwnedP1")) (sites (values Remembered "OwnedP2"))) (sites {(mapEntry P1)})) (if (is Occupied (site)) (forEach Level (site) FromTop (fromTo (from (site) level:(level)) (to (handSite P1)) stack:True)))) (forEach Site (union (difference (sites (values Remembered "OwnedP2")) (sites (values Remembered "OwnedP1"))) (sites {(mapEntry P2)})) (if (is Occupied (site)) (forEach Level (site) FromTop (fromTo (from (site) level:(level)) (to (handSite P2)) stack:True)))) (forget Value "OwnedP1" All) (forget Value "OwnedP2" All)}) (and (if (and (if (= 1 P1) (no Pieces All in:(sites (values Remembered "OwnedP1"))) (no Pieces All in:(sites (values Remembered "OwnedP2")))) (>= (size Stack Cell at:(handSite P1)) (if (= 1 P1) (count Sites in:(sites (values Remembered "OwnedP1"))) (count Sites in:(sites (values Remembered "OwnedP2")))))) (forEach Value min:1 max:(if (= 1 P1) (count Sites in:(sites (values Remembered "OwnedP1"))) (count Sites in:(sites (values Remembered "OwnedP2")))) (fromTo (from Cell (handSite P1) level:(- (size Stack Cell at:(handSite P1)) (value))) (to (regionSite (sites (values Remembered "OwnedP1")) index:(- (value) 1))) stack:True))) (if (and (if (= 1 P2) (no Pieces All in:(sites (values Remembered "OwnedP1"))) (no Pieces All in:(sites (values Remembered "OwnedP2")))) (>= (size Stack Cell at:(handSite P2)) (if (= 1 P2) (count Sites in:(sites (values Remembered "OwnedP1"))) (count Sites in:(sites (values Remembered "OwnedP2")))))) (forEach Value min:1 max:(if (= 1 P2) (count Sites in:(sites (values Remembered "OwnedP1"))) (count Sites in:(sites (values Remembered "OwnedP2")))) (fromTo (from Cell (handSite P2) level:(- (size Stack Cell at:(handSite P2)) (value))) (to (regionSite (sites (values Remembered "OwnedP2")) index:(- (value) 1))) stack:True)))))))) (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) {(if (>= 4 (size Stack Cell at:(handSite P1))) (result P2 Win)) (if (>= 4 (size Stack Cell at:(handSite P2))) (result P1 Win))})) (nextPhase (all Sites (sites Board) if:(= 0 (count at:(site)))) "BetweenRounds")) (phase "BetweenRounds" (play (if (<= 5 (size Stack Cell at:(handSite Mover))) (move Select (from Cell (handSite Mover)) (to (trackSite FirstSite "TrackCCW" from:(mapEntry Mover) if:(and (not (is In (to) (sites "EndHoles"))) (is Empty (to))))) (then (and {(forEach Value min:1 max:5 (fromTo (from Cell (last From) level:(- (size Stack Cell at:(last From)) (value))) (to (last To)) stack:True)) (if (is Mover P1) (remember Value "OwnedP1" (last To)) (remember Value "OwnedP2" (last To))) (if (<= (* 2 5) (count Cell at:(handSite Mover))) (moveAgain) (if (or (= 8 (count Cell at:(handSite Mover))) (= 9 (count Cell at:(handSite Mover)))) (and {(forEach Value min:1 max:(- (count Cell at:(handSite Mover)) 5) (fromTo (from Cell (handSite Mover) level:(- (- (size Stack Cell at:(handSite Mover)) 5) (value))) (to (trackSite FirstSite "TrackCCW" from:(trackSite FirstSite "TrackCCW" from:(mapEntry Mover) if:(and (not (is In (to) (sites "EndHoles"))) (is Empty (to)))) if:(and {(not (is In (to) (sites "EndHoles"))) (is Empty (to)) (!= (trackSite FirstSite "TrackCCW" from:(mapEntry Mover) if:(and (not (is In (to) (sites "EndHoles"))) (is Empty (to)))) (to))}))) stack:True)) (forEach Value min:1 max:(- 5 (- (count Cell at:(handSite Mover)) 5)) (fromTo (from Cell (handSite Next) level:(- (size Stack Cell at:(handSite Next)) (value))) (to (trackSite FirstSite "TrackCCW" from:(trackSite FirstSite "TrackCCW" from:(mapEntry Mover) if:(and (not (is In (to) (sites "EndHoles"))) (is Empty (to)))) if:(and {(not (is In (to) (sites "EndHoles"))) (is Empty (to)) (!= (trackSite FirstSite "TrackCCW" from:(mapEntry Mover) if:(and (not (is In (to) (sites "EndHoles"))) (is Empty (to)))) (to))}))) stack:True)) (if (is Mover P1) (remember Value "OwnedP1" (trackSite FirstSite "TrackCCW" from:(trackSite FirstSite "TrackCCW" from:(mapEntry Mover) if:(and (not (is In (to) (sites "EndHoles"))) (is Empty (to)))) if:(and {(not (is In (to) (sites "EndHoles"))) (is Empty (to)) (!= (trackSite FirstSite "TrackCCW" from:(mapEntry Mover) if:(and (not (is In (to) (sites "EndHoles"))) (is Empty (to)))) (to))}))) (remember Value "OwnedP2" (trackSite FirstSite "TrackCCW" from:(trackSite FirstSite "TrackCCW" from:(mapEntry Mover) if:(and (not (is In (to) (sites "EndHoles"))) (is Empty (to)))) if:(and {(not (is In (to) (sites "EndHoles"))) (is Empty (to)) (!= (trackSite FirstSite "TrackCCW" from:(mapEntry Mover) if:(and (not (is In (to) (sites "EndHoles"))) (is Empty (to)))) (to))})))) (if (is Mover P2) (remember Value "OwnedP1" (trackSite FirstSite "TrackCCW" from:(trackSite FirstSite "TrackCCW" from:(mapEntry Mover) if:(and (not (is In (to) (sites "EndHoles"))) (is Empty (to)))) if:(and {(not (is In (to) (sites "EndHoles"))) (is Empty (to)) (!= (trackSite FirstSite "TrackCCW" from:(mapEntry Mover) if:(and (not (is In (to) (sites "EndHoles"))) (is Empty (to)))) (to))}))) (remember Value "OwnedP2" (trackSite FirstSite "TrackCCW" from:(trackSite FirstSite "TrackCCW" from:(mapEntry Mover) if:(and (not (is In (to) (sites "EndHoles"))) (is Empty (to)))) if:(and {(not (is In (to) (sites "EndHoles"))) (is Empty (to)) (!= (trackSite FirstSite "TrackCCW" from:(mapEntry Mover) if:(and (not (is In (to) (sites "EndHoles"))) (is Empty (to)))) (to))}))))})))}))) (then (if (and (is Empty Cell (handSite P1)) (is Empty Cell (handSite P2))) (and (if (= (size Stack Cell at:(handSite P1 1)) 2) (and (fromTo (from Cell (handSite P1 1) level:1) (to (mapEntry P1)) stack:True) (fromTo (from Cell (handSite P1 1) level:0) (to (mapEntry P2)) stack:True)) (if (= (size Stack Cell at:(handSite P2 1)) 2) (and (fromTo (from Cell (handSite P2 1) level:1) (to (mapEntry P1)) stack:True) (fromTo (from Cell (handSite P2 1) level:0) (to (mapEntry P2)) stack:True)) (and (fromTo (from Cell (handSite P1 1) level:0) (to (mapEntry P1)) stack:True) (fromTo (from Cell (handSite P2 1) level:0) (to (mapEntry P2)) stack:True)))) (if (< 50 (value Random (range 1 100))) (set NextPlayer (player 1)) (set NextPlayer (player 2)))))))) (nextPhase (and (is Empty Cell (handSite P1)) (is Empty Cell (handSite P2))) "Sowing"))})) 
2x7 board with two stores. Seven counters in each hole. Players move from one of the holes in their row, sowing in a clockwise direction, and including the player's store, which is to the left, but not the opponent's store. If the final counter of a sowing lands in an occupied hole (not a store), sowing continues. If it lands into an empty hole, the turn is over. If the empty hole is in the player's own row, the contents of the hole opposite in the opponent's row are captured and placed in the store. The person who captures the most counters wins.
(game "Chongka'" (players 2) (equipment {(mancalaBoard 2 7 {(track "Track1" "7,W,WNW,ENE,E" loop:True P1) (track "Track2" "7,W,N,E,ESE" loop:True P2)}) (piece "Seed" Shared) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 FirstSite) (pair P2 LastSite)})}) (rules (start (set Count 7 to:(union (sites P1) (sites P2)))) (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover)) if:(> (count at:(from)) 0)) (then (sow "Track" owner:(mover) apply:(if (and {(> (count at:(to)) 1) (is In (to) (union (sites P1) (sites P2)))}) (moveAgain) (if (and (is In (to) (sites Mover)) (> (count at:(if (is Mover P1) (+ (to) 7) (- (to) 7))) 0)) (fromTo (from (if (is Mover P1) (+ (to) 7) (- (to) 7))) (to (mapEntry Mover)) count:(count at:(if (is Mover P1) (+ (to) 7) (- (to) 7)))))))))) (end (if (and (no Moves Mover) (no Moves Next)) (byScore {(score P1 (count at:(mapEntry P1))) (score P2 (count at:(mapEntry P2)))}))))) 
2x7 board, with two stores. Seven counters per hole. The first player may choose the direction of sowing, which must be maintained throughout the game. Sowing includes the player's store, which is the store following the last hole in the player's row, according to the direction of sowing. When the final counter of a sowing falls into an occupied hole, the counters in that hole are picked up and sowing continues. When the final counter of a sowing falls into an empty hole, that counter is captured along with any counters in the hole in the row opposite it. When the final counter falls into the player's store, the turn ends. The player who first captures half of the counters wins.  Sowing occurs in CCW.
(game "Chonka" (players 2) (equipment {(mancalaBoard 2 7 {(track "Track1" "1,E,ENE,WNW,W" loop:True P1) (track "Track2" "1,E,N,W,WSW" loop:True P2)}) (piece "Seed" Shared) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 LastSite) (pair P2 FirstSite)})}) (rules (start (set Count 7 to:(union (sites P1) (sites P2)))) (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover)) if:(> (count at:(from)) 0)) (then (sow apply:(if (!= (to) (mapEntry Mover)) (if (> (count at:(to)) 1) (moveAgain) (and (fromTo (from (if (is In (to) (sites Bottom)) (+ (to) 7) (- (to) 7))) (to (mapEntry Mover)) count:(count at:(if (is In (to) (sites Bottom)) (+ (to) 7) (- (to) 7)))) (fromTo (from (to)) (to (mapEntry Mover)) count:(count at:(to)))))))))) (end (if (<= (/ (* 7 (- (count Sites in:(sites Board)) 2)) 2) (count at:(mapEntry Mover))) (result Mover Win))))) 
2x7 board, with two stores. Seven counters in each hole. Players sow from any hole on their side of the board, in a clockwise direction, and sow into the store on their left, but not the one on the right. When the final counter of a sowing lands in an occupied hole that is not the store, the player picks up these counters and continues sowing. When then final counter lands in an empty hole, the turn ends. When the final counter lands in the store, the turn ends. Play continues until all of the counters are in the stores, and the player with the most counters in their store wins.
(game "Chungcajon" (players 2) (equipment {(mancalaBoard 2 7 {(track "Track1" "7,W,WNW,ENE,E" loop:True P1) (track "Track2" "8,E,ESE,WSW,W" loop:True P2)}) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 FirstSite) (pair P2 LastSite)}) (piece "Seed" Shared)}) (rules (start (set Count 7 to:(union (sites P1) (sites P2)))) (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover)) if:(> (count at:(from)) 0)) (then (sow "Track" owner:(mover) if:(and (> (count at:(to)) 1) (!= (to) (mapEntry Mover))) apply:(moveAgain))))) (end (if (all Sites (union (sites P1) (sites P2)) if:(= 0 (count at:(site)))) (byScore {(score P1 (count at:(mapEntry P1))) (score P2 (count at:(mapEntry P2)))}))))) 
Two rows of ten holes Four counters in each hole First play must be from the rightmost hole. The player has to open the game with one of the four rightmost holes.
(game "Dabuda" (players 2) (equipment {(mancalaBoard 2 10 store:None (track "Track" "0,E,N,W" loop:True)) (regions "Home" P1 (sites Bottom)) (regions "Home" P2 (sites Top)) (regions "RightMost" P1 (sites {6 7 8 9})) (regions "RightMost" P2 (sites {10 11 12 13})) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 4 to:(sites Track))) phases:{(phase "Rightmost" (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "RightMost")) if:(> (count at:(from)) 0)) (then (sow apply:(if (and {(is In (to) (sites Mover "Home")) (= (count at:(to)) 1) (> (count at:(if (is Mover P1) (+ (to) 10) (- (to) 10))) 0)}) (and (fromTo (from (if (is Mover P1) (+ (to) 10) (- (to) 10))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 10) (- (to) 10)))) (fromTo (from (to)) (to (handSite Mover)) count:1)) (if (> (count at:(to)) 1) (moveAgain))))))) (nextPhase (= (count Turns) 2) "HomePhase")) (phase "HomePhase" (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(> (count at:(from)) 0)) (then (sow apply:(if (and {(is In (to) (sites Mover "Home")) (= (count at:(to)) 1) (> (count at:(if (is Mover P1) (+ (to) 10) (- (to) 10))) 0)}) (and (fromTo (from (if (is Mover P1) (+ (to) 10) (- (to) 10))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 10) (- (to) 10)))) (fromTo (from (to)) (to (handSite Mover)) count:1)) (if (> (count at:(to)) 1) (moveAgain))))))))} (end (if (no Moves Mover) (byScore {(score P1 (+ (count Cell at:(handSite P1)) (count in:(sites P1 "Home")))) (score P2 (+ (count Cell at:(handSite P2)) (count in:(sites P2 "Home"))))}))))) 
2x7 board with two stores. Four counters in each hole. Sowing occurs in either a clockwise or anti-clockwise direction; the first player chooses the direction and all subsequent moves are made in that direction. Players sow beginning from holes their row. If the final counter falls into an empty hole, the contents of the opposite hole in the other row are captured. If the last counter falls into a hole with counters, these are picked up and sowing continues. Throughout the game, singletons cannot be moved if a player has a hole with multiple counters, and a singleton in the front hole cannot be moved if there are other singletons in the player's row. The round ends when one player's holes are empty. A second round begins with the winner of the first round placing four counters in each of their holes, leaving any surplus in the store. The loser of round one places four counters in as many consecutive holes on their side of the board as possible, and any remaining counters in the next hole. If this hole contains one, it is called puta, if two, naga, if three, wala. Holes with no counters are excluded from play for this round. If the loser has a puta hole, the opponent removes three counters from their hole opposite; if a naga, the opponent removes two from the opposite hole, if a wala, the opponent removes one. The removed counters go into their store. Puta and naga holes are marked with a piece of paper or straw in them. Empty holes are excluded from play in this round. The losing player begins the round, moving in the direction of the excluded holes, and played in the same way as the first round. The player with empty holes begins play in the direction of the empty hole. Counters cannot be sown or captured from puta or naga holes. Play continues as before, but when the final counter falls into a puta or naga hole, the contents of the opposite hole in the other row are captured. When one player has fewer than twelve counters at the beginning of a round, they may arrange them differently at the beginning. They may put one or two counters in one end hole and not more than four in the other end hole, and one or two counters in the intermediate holes, leaving some empty and, thus, excluded. The opponent then puts four counters in each of their holes. There are no puta, naga, or wala holes in this round. The player with more counters plays as before, but the one with less has captures that are determined by the number of counters placed in the first end hole. If there were two in the end hole, the player captures when dropping the final counter into a hole to make it three; or when it makes two if there was one counter in the first end hole. Otherwise, the player does not sow in holes with one or two counters. Play continues until one player cannot sow at the beginning of a round.
(game "Daramuti" (players 2) (equipment {(mancalaBoard 2 7 {(track "TrackCCW" "1,E,N,W" loop:True) (track "TrackCW" "7,W,N,E" loop:True)}) (piece "Seed" Shared) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 FirstSite) (pair P2 LastSite)})}) (rules (start {(set Count 4 to:(sites Track)) (set RememberValue "Playable" (union (sites Top) (sites Bottom)))}) phases:{(phase "StartingMove" (play (or (move Select (from (sites Mover) if:(and (is Occupied (from)) (is In (from) (sites (values Remembered "Playable"))))) (then (and (sow "TrackCCW" apply:(if (= 1 (count at:(to))) (if (is Occupied (if (is In (to) (sites Bottom)) (+ (to) 7) (- (to) 7))) (fromTo (from (if (is In (to) (sites Bottom)) (+ (to) 7) (- (to) 7))) (to (mapEntry Mover)) count:(count at:(if (is In (to) (sites Bottom)) (+ (to) 7) (- (to) 7))))) (and (moveAgain) (set Var "Replay" (to)))) skipIf:(not (is In (to) (sites (values Remembered "Playable"))))) (set Var "Direction" 1)))) (move Select (from (sites Mover) if:(and (is Occupied (from)) (is In (from) (sites (values Remembered "Playable"))))) (then (and (sow "TrackCW" apply:(if (= 1 (count at:(to))) (if (is Occupied (if (is In (to) (sites Bottom)) (+ (to) 7) (- (to) 7))) (fromTo (from (if (is In (to) (sites Bottom)) (+ (to) 7) (- (to) 7))) (to (mapEntry Mover)) count:(count at:(if (is In (to) (sites Bottom)) (+ (to) 7) (- (to) 7))))) (and (moveAgain) (set Var "Replay" (to)))) skipIf:(not (is In (to) (sites (values Remembered "Playable"))))) (set Var "Direction" 2)))))) (nextPhase "Sowing")) (phase "Sowing" (play (if (= 1 (var "Direction")) (move Select (from (if (and (not (is Pending)) (is Prev Mover)) (sites {(var "Replay")}) (sites Mover)) if:(and {(is Occupied (from)) (is In (from) (sites (values Remembered "Playable"))) (not (is In (from) (sites (values Remembered "Blocked")))) (if (not (all Sites (forEach (sites Mover) if:(is In (site) (sites (values Remembered "Playable")))) if:(>= 1 (count at:(site))))) (< 1 (count at:(from))))})) (then (sow "TrackCCW" apply:(if (= 1 (count at:(to))) (if (is Occupied (if (is In (to) (sites Bottom)) (+ (to) 7) (- (to) 7))) (fromTo (from (if (is In (to) (sites Bottom)) (+ (to) 7) (- (to) 7))) (to (mapEntry Mover)) count:(count at:(if (is In (to) (sites Bottom)) (+ (to) 7) (- (to) 7))))) (and (moveAgain) (set Var "Replay" (to)))) skipIf:(not (is In (to) (sites (values Remembered "Playable"))))))) (move Select (from (if (and (not (is Pending)) (is Prev Mover)) (sites {(var "Replay")}) (sites Mover)) if:(and {(is Occupied (from)) (is In (from) (sites (values Remembered "Playable"))) (not (is In (from) (sites (values Remembered "Blocked")))) (if (not (all Sites (forEach (sites Mover) if:(is In (site) (sites (values Remembered "Playable")))) if:(>= 1 (count at:(site))))) (< 1 (count at:(from))))})) (then (sow "TrackCW" apply:(if (= 1 (count at:(to))) (if (is Occupied (if (is In (to) (sites Bottom)) (+ (to) 7) (- (to) 7))) (fromTo (from (if (is In (to) (sites Bottom)) (+ (to) 7) (- (to) 7))) (to (mapEntry Mover)) count:(count at:(if (is In (to) (sites Bottom)) (+ (to) 7) (- (to) 7))))) (and (moveAgain) (set Var "Replay" (to)))) skipIf:(not (is In (to) (sites (values Remembered "Playable"))))))) (then (if (no Moves Next) (and {(forEach Site (sites P1) (if (is Occupied (site)) (fromTo (from (site)) (to (mapEntry P1)) count:(count at:(site))))) (forEach Site (sites P2) (if (is Occupied (site)) (fromTo (from (site)) (to (mapEntry P2)) count:(count at:(site))))) (forget Value "Playable" All) (forget Value "Blocked" All) (if (< (+ (count at:(mapEntry P1)) (count in:(sites P1))) (+ (count at:(mapEntry P2)) (count in:(sites P2)))) (and (set NextPlayer (player 2)) (set Var "Winner" 2)) (and (set NextPlayer (player 1)) (set Var "Winner" 1)))}))))) (end (if (no Moves Next) {(if (> 2 (count at:(mapEntry P1))) (result P2 Win)) (if (> 2 (count at:(mapEntry P2))) (result P1 Win))})) (nextPhase (no Moves Next) "BetweenRounds")) (phase "BetweenRounds" (play (if (and (not (is Prev Mover)) (!= (mover) (var "Winner"))) (or (move (from (mapEntry Mover)) (to (if (is Mover P1) (intersection (sites Bottom) (expand (sites Right))) (intersection (sites Top) (expand (sites Left)))) if:(is Empty (to))) count:(min 4 (count at:(mapEntry Mover))) (then (and {(remember Value "Playable" (last To)) (if (> 4 (count at:(last To))) (and (fromTo (from (if (is In (to) (sites Bottom)) (+ (to) 7) (- (to) 7))) (to (mapEntry Next)) count:(- 4 (count at:(last To)))) (remember Value "Blocked" (last To)))) (moveAgain) (if (= 0 (count at:(mapEntry Mover))) (set Pending)) (set Var "Direction" 2)}))) (move (from (mapEntry Mover)) (to (if (is Mover P1) (intersection (sites Bottom) (expand (sites Left))) (intersection (sites Top) (expand (sites Right)))) if:(is Empty (to))) count:(min 4 (count at:(mapEntry Mover))) (then (and {(remember Value "Playable" (last To)) (if (> 4 (count at:(last To))) (and (fromTo (from (if (is In (to) (sites Bottom)) (+ (to) 7) (- (to) 7))) (to (mapEntry Next)) count:(- 4 (count at:(last To)))) (remember Value "Blocked" (last To)))) (moveAgain) (if (= 0 (count at:(mapEntry Mover))) (set Pending)) (set Var "Direction" 1)})))) (if (!= (mover) (var "Winner")) (move (from (mapEntry Mover)) (to (if (= (var "Direction") 1) (trackSite Move from:(last To) "TrackCCW" steps:1) (trackSite Move from:(last To) "TrackCW" steps:1)) if:(is Empty (to))) count:(min 4 (count at:(mapEntry Mover))) (then (and {(remember Value "Playable" (last To)) (moveAgain) (if (= 0 (count at:(mapEntry Mover))) (set Pending))}))) (move (from (mapEntry Mover)) (to (sites Mover) if:(is Empty (to))) count:4 (then (and (remember Value "Playable" (last To)) (if (not (all Sites (sites Mover) if:(is Occupied (site)))) (moveAgain)))))))) (nextPhase (and (!= (var "Winner") (mover)) (= 0 (count at:(mapEntry Mover)))) "Sowing"))})) 
2x6 board with store holes at either end. The game begins with six counters in each hole. Each player owns one row of holes. At the beginning of the turn, a player picks up all of the counters from their side of the board and sows them, one each, into consecutive holes in a counterclockwise pattern. If the last counter lands in a hole that contains 2, 4, or 6 (after sowing), then the player captures the counters in that hole. If the player captures counters in a hole, then they may also capture counters in the previous hole, if it also has 2,4, or 6, continuing until reaching a hole without 2, 4, or 6. Play continues until one player cannot play on their turn, at which point the other player receives all of the remaining counters. The player with the most captured counters wins.
(game "Das Bohnenspiel" (players 2) (equipment {(mancalaBoard 2 6 (track "Track" "1,E,N,W" loop:True)) (regions "Home" P1 (sites Bottom)) (regions "Home" P2 (sites Top)) (map {(pair P1 FirstSite) (pair P2 LastSite)}) (piece "Seed" Shared)}) (rules (start (set Count 6 to:(sites Track))) (play (move Select (from (sites Mover) if:(> (count at:(from)) 0)) (then (sow if:(is In (count at:(to)) (sites {2 4 6})) apply:(fromTo (from (to)) (to (mapEntry (mover))) count:(count at:(to))) backtracking:True)))) (end (if (no Moves Mover) (byScore {(score P1 (+ (count at:(mapEntry P1)) (count in:(sites P1)))) (score P2 (+ (count at:(mapEntry P2)) (count in:(sites P2))))}))))) 
Two rows of six holes encircling a larger hole in the center. Two counters in each hole, except the center hole. Players move by removing the counters from one of the holes in their row and sowing them in an anti-clockwise direction. If the final counter of the sowing falls into an occupied hole, these counters are picked up and sowing continues. When the final counter falls into an empty hole, the turn ends. If the final counter falls into a hole already containing two others, the player takes these counters and covers the hole. The three counters are sown beginning with the following hole. When sowing, if a player reaches a covered hole in their row, they skip it and continue sowing with the next available hole. If the player reaches a covered hole in the opponent's row, the counter that would fall into it is instead deposited into the central hole. If this is the final counter, the turn ends. It is possible to sow a single counter. The player who can no longer sow from their row loses.
(game "Deka" (players 2) (equipment {(board (merge {(rectangle 1 5) (rectangle 3 1) (shift 0 2 (rectangle 1 5)) (shift 4 0 (rectangle 3 1)) (shift 2 1 (square 1))}) (track "Track" "0,E,N,W,S1" loop:True) use:Vertex) (regions P1 (sites {0 1 2 3 4 11})) (regions P2 (sites {5 6 7 8 9 10})) (piece "Seed" Shared)}) (rules (start (set Count 2 to:(difference (sites Board) 12))) (play (or {(move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover)) if:(is Occupied (from))) (then (sow apply:(if (not (and (is In (to) (sites Next)) (= (next) (state at:(to))))) (if (= 3 (count at:(to))) (and {(fromTo (from (to)) (to (trackSite Move from:(to) steps:1)) count:3) (sow (trackSite Move from:(to) steps:1) count:3 skipIf:(and (is In (to) (sites Mover)) (= 1 (state at:(to))))) (set State at:(to) 1)}) (if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to)))))) skipIf:(and (is In (to) (sites Mover)) (= (mover) (state at:(to)))))))} (then (forEach Site (if (is Mover P1) (sites P2) (sites P1)) (if (= 1 (state at:(site))) (and (fromTo (from (site)) (to (centrePoint)) count:(count at:(site))) (set State at:(site) 1))))))) (end (forEach Player if:(no Moves Player) (result Player Loss))))) 
2x5 board. Five counters per hole. Sowing can happen in either direction. When the last counter falls into a hole, sowing continues if there are counters in the following holes; these are picked up and sowing continues from there. When the hole after the end of a sowing is empty, the counters in the next hole following it are captured. If a pattern of alternating empty and occupied holes continues after this, the counters in the occupied holes are captured, until there are two occupied or two empty holes in a row. The player who captures the most counters wins.
(game "Dongjintian" (players 2) (equipment {(mancalaBoard 2 5 store:None {(track "TrackCCW" "0,E,N,W" loop:True) (track "TrackCW" "4,W,N,E" loop:True)}) (piece "Seed" Shared) (hand Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start (set Count 5 to:(sites Track))) (play (or (if (or (>= 0 (var "Direction")) (= (var "Direction") 1)) (move Select (from (if (is Prev Mover) (sites {(trackSite Move from:(last To afterConsequence:True) "TrackCCW" steps:1)}) (sites Mover)) if:(is Occupied (from))) (then (sow "TrackCCW" apply:(if (is Occupied (trackSite Move from:(to) "TrackCCW" steps:1)) (and (moveAgain) (set Var "Direction" 1)) (if (and (is Empty (trackSite Move from:(to) "TrackCCW" steps:1)) (is Occupied (trackSite Move from:(to) "TrackCCW" steps:2))) (and (and (fromTo (from (trackSite Move from:(to) "TrackCCW" steps:2)) (to (handSite Mover)) count:(count at:(trackSite Move from:(to) "TrackCCW" steps:2))) (if (and (is Empty (trackSite Move from:(to) "TrackCCW" steps:3)) (is Occupied (trackSite Move from:(to) "TrackCCW" steps:4))) (and (fromTo (from (trackSite Move from:(to) "TrackCCW" steps:4)) (to (handSite Mover)) count:(count at:(trackSite Move from:(to) "TrackCCW" steps:4))) (if (and (is Empty (trackSite Move from:(to) "TrackCCW" steps:5)) (is Occupied (trackSite Move from:(to) "TrackCCW" steps:6))) (and (fromTo (from (trackSite Move from:(to) "TrackCCW" steps:6)) (to (handSite Mover)) count:(count at:(trackSite Move from:(to) "TrackCCW" steps:6))) (if (and (is Empty (trackSite Move from:(to) "TrackCCW" steps:7)) (is Occupied (trackSite Move from:(to) "TrackCCW" steps:8))) (fromTo (from (trackSite Move from:(to) "TrackCCW" steps:8)) (to (handSite Mover)) count:(count at:(trackSite Move from:(to) "TrackCCW" steps:8))))))))) (set Var "Direction" 0)))))))) (if (or (>= 0 (var "Direction")) (= (var "Direction") 2)) (move Select (from (if (is Prev Mover) (sites {(trackSite Move from:(last To afterConsequence:True) "TrackCW" steps:1)}) (sites Mover)) if:(is Occupied (from))) (then (sow "TrackCW" apply:(if (is Occupied (trackSite Move from:(to) "TrackCW" steps:1)) (and (moveAgain) (set Var "Direction" 2)) (if (and (is Empty (trackSite Move from:(to) "TrackCW" steps:1)) (is Occupied (trackSite Move from:(to) "TrackCW" steps:2))) (and (and (fromTo (from (trackSite Move from:(to) "TrackCW" steps:2)) (to (handSite Mover)) count:(count at:(trackSite Move from:(to) "TrackCW" steps:2))) (if (and (is Empty (trackSite Move from:(to) "TrackCW" steps:3)) (is Occupied (trackSite Move from:(to) "TrackCW" steps:4))) (and (fromTo (from (trackSite Move from:(to) "TrackCW" steps:4)) (to (handSite Mover)) count:(count at:(trackSite Move from:(to) "TrackCW" steps:4))) (if (and (is Empty (trackSite Move from:(to) "TrackCW" steps:5)) (is Occupied (trackSite Move from:(to) "TrackCW" steps:6))) (and (fromTo (from (trackSite Move from:(to) "TrackCW" steps:6)) (to (handSite Mover)) count:(count at:(trackSite Move from:(to) "TrackCW" steps:6))) (if (and (is Empty (trackSite Move from:(to) "TrackCW" steps:7)) (is Occupied (trackSite Move from:(to) "TrackCW" steps:8))) (fromTo (from (trackSite Move from:(to) "TrackCW" steps:8)) (to (handSite Mover)) count:(count at:(trackSite Move from:(to) "TrackCW" steps:8))))))))) (set Var "Direction" 0)))))))))) (end (if (<= (count Pieces All in:(sites Board)) 1) (byScore {(score P1 (count Cell at:(handSite P1))) (score P2 (count Cell at:(handSite P2)))}))))) 
2x6 board with two stores. Four counters in each hole. Sowing occurs in an anti-clockwise direction. When the final counter lands in an occupied hole the counters are picked up and sowing continues, unless the hole contained three counters, causing it to contain four, in which case the counters are captured. An unbroken sequence of holes with four counters in them behind the hole from which the first capture was made are also captured. In addition, any holes which were sown into during the course of the turn which now contain four counters are captured by the owner of the row. Play continues until there are only eight counters left. The first player to make a capture with these eight counters captures them all. The player with the most counters wins.
(game "Duene" (players 2) (equipment {(mancalaBoard 2 6 (track "Track" "1,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 FirstSite) (pair P2 LastSite)}) (piece "Seed" Shared)}) (rules (start (set Count 4 to:(sites Track))) phases:{(phase "Playing" (play (move Select (from (if (is Prev Mover) (sites {(var "To")}) (sites Mover)) if:(< 0 (count at:(from)))) (then (do (and (set Var "From" (last From)) (sow apply:(and (set Var "To" (to)) (if (= (count at:(to)) 4) (fromTo (from (to)) (to (mapEntry (mover))) count:(count at:(to))) (if (> (count at:(to)) 1) (moveAgain)))) backtracking:(= (count at:(to)) 4))) next:(and {(pass) (forEach Site (forEach (sites Track from:(var "From") to:(var "To")) if:(and (is In (site) (sites P1)) (= 4 (count at:(site))))) (fromTo (from (site)) (to (mapEntry P1)) count:(count at:(site)))) (forEach Site (forEach (sites Track from:(var "From") to:(var "To")) if:(and (is In (site) (sites P2)) (= 4 (count at:(site))))) (fromTo (from (site)) (to (mapEntry P2)) count:(count at:(site))))}))))) (nextPhase (<= (count in:(sites Track)) 8) "EndGame")) (phase "EndGame" (play (move Select (from (if (is Prev Mover) (sites {(var "To")}) (sites Mover)) if:(< 0 (count at:(from)))) (then (sow apply:(if (= (count at:(to)) 4) (forEach Site (sites Track) (if (< 0 (count at:(site))) (fromTo (from (site)) (to (mapEntry (mover))) count:(count at:(site))))) (if (> (count at:(to)) 1) (moveAgain))))))))} (end (if (all Sites (sites Track) if:(= 0 (count at:(site)))) (byScore {(score P1 (+ (count at:(mapEntry P1)) (count in:(sites P1)))) (score P2 (+ (count at:(mapEntry P2)) (count in:(sites P2))))}))))) 
2x40-50 board. Each team controls one row. Play begins with each hole containing four counters (usually seeds or pebbles). A player picks up the counters in a hole in his team's row and sows them in a counterclockwise fashion, one in each consecutive hole. If the last counter is deposited into a hole containing counter, those counters are picked up and the player continues sowing. The turn continues in this fashion until the last counter falls into an empty hole. If this empty hole is on the player's side, the counters in the opposite hole in the other team's row are captured. The counter also causing the capture is taken. Play continues until one team cannot move, and the remaining counters are captured by the other team. The team with the most seeds wins. Each row has 40 holes.
(game "En Gehe" (players 2) (equipment {(mancalaBoard 2 40 store:None (track "Track" "0,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 4 to:(sites Track))) (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover)) if:(> (count at:(from)) 0)) (then (sow apply:(if (> (count at:(to)) 1) (moveAgain) (if (and (is In (to) (sites Mover)) (> (count at:(if (is Mover P1) (+ (to) 40) (- (to) 40))) 0)) (and (fromTo (from (if (is Mover P1) (+ (to) 40) (- (to) 40))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 40) (- (to) 40)))) (fromTo (from (to)) (to (handSite Mover)) count:(count at:(to)))))))))) (end (if (no Moves Mover) (byScore {(score P1 (+ (count Cell at:(handSite P1)) (count in:(sites P1)))) (score P2 (+ (count Cell at:(handSite P2)) (count in:(sites P2))))}))))) 
2x6 board with two store holes on either end. Play begins with four counters in each row. For the opening move, a player may take all of the counters in one hole and add them to the next hole. Play continues with players sowing from any one of the holes in their row in an anti-clockwise direction. If a sowing reaches the hole from which the sowing began, this hole is skipped. If the final counter falls in a hole containing three counters, thus making it contain four counters, these are captured. An unbroken sequence of holes containing four counters moving backwards from the final hole are also captured. Single counters cannot be sown. If a player cannot move, the opponent must sow in a way that allows them to play on the next turn. Play continues until one player has no counters on their side of the board. The player with the most captured counters wins.
(game "English Wari (St. Lucia)" (players 2) (equipment {(mancalaBoard 2 6 (track "Track" "1,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 FirstSite) (pair P2 LastSite)}) (piece "Seed" Shared)}) (rules (start (set Count 4 to:(sites Track))) phases:{(phase "Init" (play (move Select (from (sites Mover)) (then (fromTo (from (last To)) (to (trackSite Move from:(last To) steps:1)) count:(count at:(last To)))))) (nextPhase (= (next) 1) "Sowing")) (phase "Sowing" (play (do (move Select (from (sites Mover) if:(> (count at:(from)) 1)) (then (sow if:(= (count at:(to)) 4) apply:(fromTo (from (to)) (to (mapEntry (mover))) count:(count at:(to))) includeSelf:False backtracking:True))) ifAfterwards:(if (is Mover P1) (not (and {(< (count at:7) 2) (< (count at:8) 2) (< (count at:9) 2) (< (count at:10) 2) (< (count at:11) 2) (< (count at:12) 2)})) (not (and {(< (count at:1) 2) (< (count at:2) 2) (< (count at:3) 2) (< (count at:4) 2) (< (count at:5) 2) (< (count at:6) 2)}))))))} (end (if (no Moves Mover) (byScore {(score P1 (+ (count at:(mapEntry P1)) (count in:(sites P1)))) (score P2 (+ (count at:(mapEntry P2)) (count in:(sites P2))))}))))) 
2x6 board, with a storage hole on either end. The game starts with four counters in each hole. A player picks up all of the counters in one of the holes in their row and sows them one-by-one in a counterclockwise direction in consecutive holes from the hole the pieces originated. The starting hole is always left empty, even if a player sows in a complete circuit of the board, the original house is skipped and sowing continues in the next hole after it. When the final counter of a sowing lands in a hole with three counters, the owner of that hole captures the counters. If an opponent's holes are all empty, the other player must make a move placing counters in the opponent's row. If not possible, the player captures all the counters in their row. The player who has captured the most counters wins. If the game continues in a repeating loop, the players can agree to end the game and capture the counters remaining in their row. 
(game "Enindji" (players 2) (equipment {(mancalaBoard 2 6 (track "Track" "1,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 FirstSite) (pair P2 LastSite)}) (piece "Seed" Shared)}) (rules (start (set Count 4 to:(sites Track))) (play (if (is Proposed "End") (or (move Vote "End") (move Vote "No")) (or (if (is Cycle) (move Propose "End")) (do (move Select (from (sites Mover) if:(< 0 (count at:(from)))) (then (sow if:(= (count at:(to)) 4) apply:(fromTo (from (to)) (to (if (is In (to) (sites P1)) (mapEntry 1) (mapEntry 2))) count:(count at:(to))) includeSelf:False))) ifAfterwards:(< 0 (count in:(sites Next))))))) (end (if (and (no Moves Mover) (no Moves Next)) (byScore {(score P1 (+ (count at:(mapEntry P1)) (count in:(sites P1)))) (score P2 (+ (count at:(mapEntry P2)) (count in:(sites P2))))}))))) 
2x6 board, with stores on either end. The store to a player's left belongs to them. Four counters in each hole. Players sow in an anti-clockwise direction from any hole in their row. When the final counter lands in a hole in the opponent's row, causing it to contain two or four counters, these are captured and put in the store. The player also captures the contents of any adjacent holes in the opponent's row if they also contain two or four counters. Play continues until one player has no counters in their row, their opponent capturing the remaining counters. A new round begins. Players fill up their holes with four counters, beginning from the left. Any excess counters are placed in that player's store; the final hole of the player with fewer counters may contain fewer than four counters. Any empty holes are out of play. Play continues as before. The game repeats in this fashion until one player has no counters remaining, their opponent is the winner.
(game "Erherhe" (players 2) (equipment {(mancalaBoard 2 6 (track "Track" "1,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 FirstSite) (pair P2 LastSite)}) (map "LeftMost" {(pair P1 1) (pair P2 12)}) (piece "Seed" Shared)}) (rules (start {(set Count 4 to:(sites Track)) (set RememberValue "Playable" (union (sites Top) (sites Bottom)))}) phases:{(phase "Sowing" (play (or {(move Select (from (sites Mover) if:(and (is Occupied (from)) (is In (from) (sites (values Remembered "Playable"))))) (then (sow apply:(if (and (is In (to) (sites Next)) (or (= 2 (count at:(to))) (= 4 (count at:(to))))) (and {(fromTo (from (to)) (to (mapEntry Mover)) count:(count at:(to))) (if (!= (to) (ahead (to) W)) (if (or (= 2 (count at:(ahead (to) W))) (= 4 (count at:(ahead (to) W)))) (fromTo (from (ahead (to) W)) (to (mapEntry Mover)) count:(count at:(ahead (to) W))))) (if (!= (to) (ahead (to) E)) (if (or (= 2 (count at:(ahead (to) E))) (= 4 (count at:(ahead (to) E)))) (fromTo (from (ahead (to) E)) (to (mapEntry Mover)) count:(count at:(ahead (to) E)))))})) skipIf:(not (is In (to) (sites (values Remembered "Playable")))))))} (then (if (or (all Sites (sites Bottom) if:(= 0 (count at:(site)))) (all Sites (sites Top) if:(= 0 (count at:(site))))) (and {(forEach Site (sites P1) (fromTo (from (site)) (to (mapEntry P1)) count:(count at:(site)))) (forEach Site (sites P2) (fromTo (from (site)) (to (mapEntry P2)) count:(count at:(site)))) (forget Value "Playable" All)}))))) (end (if (all Sites (union (sites Top) (sites Bottom)) if:(= 0 (count at:(site)))) {(if (= 0 (count at:(mapEntry P1))) (result P2 Win)) (if (= 0 (count at:(mapEntry P2))) (result P1 Win))})) (nextPhase (all Sites (union (sites Top) (sites Bottom)) if:(= 0 (count at:(site)))) "BetweenRounds")) (phase "BetweenRounds" (play (if (not (all Sites (sites Mover) if:(is Occupied (site)))) (if (<= 4 (count at:(mapEntry Mover))) (move (from (mapEntry Mover)) (to (trackSite FirstSite from:(mapEntry "LeftMost" Mover) if:(is Empty (to)))) count:4 (then (remember Value "Playable" (last To)))) (move (from (mapEntry Mover)) (to (trackSite FirstSite from:(mapEntry "LeftMost" Mover) if:(is Empty (to)))) count:(count at:(mapEntry Mover)) (then (remember Value "Playable" (last To))))))) (nextPhase (all Passed) "Sowing"))})) 
The board has two rows of six play pits with a larger scoring pit on either end. Play begins with four seeds in each hole, with one or two seeds moved to make the initial position fair, i.e. two perfect players will draw. Each player controls the row nearest them. Play consists of choosing one of the player's non-empty play pits, removing the pieces from it, and sowing the pieces one per pit consecutively in a counterclockwise pattern including the player's own scoring pit but not the opponent's. If the last piece is placed in a player's empty pit, that piece and any opposite are captured and put in the player's scoring pit. If the last seed falls in the scoring pit, the player gets another turn. When one player has no pieces in any of their play pits, the game ends. The other player captures all of the other pieces, and the player with the most scored pieces wins. FairKalah board 1
(game "FairKalah" (players 2) (equipment {(mancalaBoard 2 6 (track "Track" "0,ESE,E,ENE,WNW,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 LastSite) (pair P2 FirstSite)}) (piece "Seed" Shared)}) (rules (start {(set Count 4 at:1) (set Count 4 at:2) (set Count 5 at:3) (set Count 4 at:4) (set Count 3 at:5) (set Count 4 at:6) (set Count 0 at:13) (set Count 4 at:12) (set Count 4 at:11) (set Count 4 at:10) (set Count 4 at:9) (set Count 4 at:8) (set Count 4 at:7) (set Count 0 at:0)}) (play (move Select (from (sites Mover) if:(> (count at:(from)) 0)) (then (sow apply:(if (= (to) (mapEntry (mover))) (moveAgain) (if (and {(is In (to) (sites Mover)) (= (count at:(to)) 1) (>= (count at:(if (is Mover P1) (+ (to) 6) (- (to) 6))) 0)}) (and (fromTo (from (to)) (to (mapEntry (mover))) count:(count at:(to))) (fromTo (from (if (is Mover P1) (+ (to) 6) (- (to) 6))) (to (mapEntry (mover))) count:(count at:(if (is Mover P1) (+ (to) 6) (- (to) 6))))))) skipIf:(= (to) (mapEntry (next))))))) (end (if (or (= (count in:(sites Bottom)) 0) (= (count in:(sites Top)) 0)) (byScore {(score P1 (+ (count at:(mapEntry P1)) (count in:(sites P1)))) (score P2 (+ (count at:(mapEntry P2)) (count in:(sites P2))))}))))) 
2x6 board, divided in half and joined in the center with a single row of two holes. From the left, Five, five, three, three, five, and five counters in each hole of the double-row holes, four counters in the single row holes. Each player owns the row closest to them, but neither player controls the holes in the single row. Sowing begins from one of the holes in the player's row, and continues in an anti-clockwise direction. If the final counter lands in an occupied hole, these counters are picked up and sowing continues, unless the hole is in the single row, in which case the turn comes to an end. When the final counter falls in an empty hole in the player's row, the contents of the hole in the opponent's row adjacent to it are captured, along with the final counter of the sowing. However, if the hole from which the capture would be made contained three counters, these plus the final counter of the sowing are divided between the last hole of the sowing and the hole from which the capture would be made, i.e. two counters per each hole. The player then owns both of these holes, but cannot sow from them. The player also chooses at this point one of the holes in the single row to own, but the player still cannot begin sowing from it. Play continues until one player cannot play, and the players collect all of the counters from the holes they own. If one or both holes in the single row have not been claimed, the counters remain in them for the next round. The next round begins with the losing player filling as many holes in their row as possible, beginning from their left, according to the original starting number. After as many holes as possible are filled to the original capacity, the remaining are placed in the next hole, or in an empty central hole. The opponent matches the arrangement in their own holes that are opposite the ones the other player can fill. If the losing player has fewer than five counters, they place one in each hole, starting from their left, and the opponent matches this arrangement. Play continues like this until one player has no more counters.
(game "Fergen Gobale" (players 2) (equipment {(board (merge {(rectangle 2 3) (shift 5 0 (rectangle 2 3)) (shift 3 0.5 (rectangle 1 2))}) {(track "Track" "0,E,12,13,6,E,N,W,13,12,5,W" loop:True) (track "TrackFill" "0,E,6,E,N,W,5,W" loop:True)} use:Vertex) (piece "Seed" Shared) (regions "Home" P1 (sites Bottom)) (regions "Home" P2 (sites Top)) (regions "Central" (sites Centre)) (hand Each) (map "LeftMost" {(pair P1 0) (pair P2 11)}) (map "CorrespondingHoles" {(pair 0 11) (pair 1 10) (pair 2 9) (pair 6 5) (pair 7 4) (pair 8 3) (pair 5 6) (pair 4 7) (pair 3 8) (pair 9 2) (pair 10 1) (pair 11 0)}) (map "InitialCount" {(pair 0 5) (pair 1 5) (pair 2 3) (pair 6 3) (pair 7 5) (pair 8 5) (pair 3 5) (pair 4 5) (pair 5 3) (pair 9 3) (pair 10 5) (pair 11 5)})}) (rules (start {(set Count 5 to:(sites {"A1" "B1" "A2" "B2" "G2" "H2" "G1" "H1" "H2"})) (set Count 4 to:(sites {"D1" "E1"})) (set Count 3 to:(sites {"C1" "F1" "C2" "F2"})) (set RememberValue "Playable" (sites Board))}) phases:{(phase "Sowing" (play (if (is Pending) (move Select (from (sites "Central") if:(= 0 (state at:(from)))) (then (set State at:(last To) (mover)))) (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover "Home")) if:(and {(= 0 (state at:(from))) (is In (from) (sites (values Remembered "Playable"))) (is Occupied (from))})) (then (sow "Track" apply:(if (< 1 (count at:(to))) (if (and (= 0 (state at:(to))) (not (is In (to) (sites "Central")))) (and (moveAgain) (set Var "Replay" (to)))) (if (is In (to) (sites Mover "Home")) (if (= 3 (count at:(if (is Mover P1) (+ (to) 3) (- (to) 3)))) (and {(fromTo (from (if (is Mover P1) (+ (to) 3) (- (to) 3))) (to (to)) count:1) (set State at:(to) (mover)) (set State at:(if (is Mover P1) (+ (to) 3) (- (to) 3)) (mover)) (moveAgain) (set Pending)}) (and (fromTo (from (to)) (to (handSite Mover)) count:1) (if (is Occupied (if (is Mover P1) (+ (to) 3) (- (to) 3))) (fromTo (from (if (is Mover P1) (+ (to) 3) (- (to) 3))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 3) (- (to) 3))))))))) skipIf:(and (not (is In (to) (sites "Central"))) (not (is In (to) (sites (values Remembered "Playable")))))))) (then (if (or (all Sites (sites P1 "Home") if:(or (is Empty (site)) (!= 0 (state at:(site))))) (all Sites (sites P2 "Home") if:(or (is Empty (site)) (!= 0 (state at:(site)))))) (and {(forEach Site (sites Board) (if (or (and (= 0 (state at:(site))) (is In (site) (sites P1 "Home"))) (= (state at:(site)) 1)) (fromTo (from (site)) (to (handSite P1)) count:(count at:(site))) (if (or (and (= 0 (state at:(site))) (is In (site) (sites P2 "Home"))) (= (state at:(site)) 2)) (fromTo (from (site)) (to (handSite P2)) count:(count at:(site)))))) (if (< (+ (count Cell at:(handSite P1)) (count in:(forEach (sites Board) if:(or (and (= 0 (state at:(site))) (is In (site) (sites P1 "Home"))) (= (state at:(site)) P1))))) (+ (count Cell at:(handSite P2)) (count in:(forEach (sites Board) if:(or (and (= 0 (state at:(site))) (is In (site) (sites P2 "Home"))) (= (state at:(site)) P2)))))) (set NextPlayer (player 1)) (set NextPlayer (player 2))) (if (or (> 5 (+ (count Cell at:(handSite P1)) (count in:(forEach (sites Board) if:(or (and (= 0 (state at:(site))) (is In (site) (sites P1 "Home"))) (= (state at:(site)) P1)))))) (> 5 (+ (count Cell at:(handSite P2)) (count in:(forEach (sites Board) if:(or (and (= 0 (state at:(site))) (is In (site) (sites P2 "Home"))) (= (state at:(site)) P2))))))) (set Var "PlaceOne" 1)) (forget Value "Playable" All)}))))) (end (if (or (all Sites (sites P1 "Home") if:(or (is Empty (site)) (!= 0 (state at:(site))))) (all Sites (sites P2 "Home") if:(or (is Empty (site)) (!= 0 (state at:(site)))))) {(if (= 0 (count Cell at:(handSite P1))) (result P2 Win)) (if (= 0 (count Cell at:(handSite P2))) (result P1 Win))})) (nextPhase (or (all Sites (sites P1 "Home") if:(or (is Empty (site)) (!= 0 (state at:(site))))) (all Sites (sites P2 "Home") if:(or (is Empty (site)) (!= 0 (state at:(site)))))) "BetweenRounds")) (phase "BetweenRounds" (play (if (= 1 (var "PlaceOne")) (move (from (handSite Mover)) (to (trackSite FirstSite "TrackFill" from:(mapEntry "LeftMost" Mover) if:(is Empty (to)))) count:1 (then (and (remember Value "Playable" (last To)) (if (is Occupied (handSite Mover)) (moveAgain))))) (if (<= (mapEntry "InitialCount" (trackSite FirstSite "TrackFill" from:(mapEntry "LeftMost" Mover) if:(is Empty (to)))) (count Cell at:(handSite Mover))) (move (from (handSite Mover)) (to (trackSite FirstSite "TrackFill" from:(mapEntry "LeftMost" Mover) if:(is Empty (to)))) count:(mapEntry "InitialCount" (trackSite FirstSite "TrackFill" from:(mapEntry "LeftMost" Mover) if:(is Empty (to)))) (then (and (remember Value "Playable" (last To)) (if (is Occupied (handSite Mover)) (moveAgain))))) (if (all Sites (sites Mover "Home") if:(is Occupied (site))) (move (from (handSite Mover)) (to (if (is Empty 12) 12 13)) count:(count Cell at:(handSite Mover))) (move (from (handSite Mover)) (to (trackSite FirstSite "TrackFill" from:(mapEntry "LeftMost" Mover) if:(is Empty (to)))) count:(count Cell at:(handSite Mover)) (then (remember Value "Playable" (last To)))))) (then (if (is Empty (handSite Mover)) (and (forEach Site (sites Mover "Home") (if (is Occupied (site)) (and (remember Value "Playable" (mapEntry "CorrespondingHoles" (site))) (fromTo (from (handSite Next)) (to (mapEntry "CorrespondingHoles" (site))) count:(count at:(site)))))) (set Var "PlaceOne" 0)))))) (nextPhase (is Empty (handSite Mover)) "Sowing"))})) 
2x6 board. Four counters in each hole. A player picks up all of the counters in one of the holes in their row and sows them one-by-one in a clockwise direction in consecutive holes from the hole the pieces originated. The starting hole is always left empty, even if a player sows in a complete circuit of the board, the original house is skipped and sowing continues in the next hole after it. When the final counter falls into an occupied hole, these are picked up and sowing continues. When the final counter of a sowing lands in an empty hole in the player's own row, the contents of the hole in the opponent's row opposite it are captured. If the opponent's holes are all empty, the other player must make a move placing counters in the opponent's row. If not possible, the player captures all the counters in their row. The player who has captured the most counters wins. If the game continues in a repeating loop, the players can agree to end the game and capture the counters remaining in their row. 
(game "Foji" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "5,W,N,E" loop:True)) (piece "Seed" Shared) (hand Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start (set Count 4 to:(sites Track))) (play (if (is Proposed "End") (or (move Vote "End") (move Vote "No")) (or (if (is Cycle) (move Propose "End")) (if (is Prev Mover) (move Select (from (sites {(last To afterConsequence:True)})) (then (sow apply:(if (< 1 (count at:(to))) (moveAgain) (if (is In (to) (sites Mover)) (if (is Occupied (if (is Mover P1) (+ (to) 6) (- (to) 6))) (fromTo (from (if (is Mover P1) (+ (to) 6) (- (to) 6))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 6) (- (to) 6))))))) includeSelf:False))) (do (move Select (from (sites Mover) if:(is Occupied (from))) (then (sow apply:(if (< 1 (count at:(to))) (moveAgain) (if (is In (to) (sites Mover)) (if (is Occupied (if (is Mover P1) (+ (to) 6) (- (to) 6))) (fromTo (from (if (is Mover P1) (+ (to) 6) (- (to) 6))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 6) (- (to) 6))))))) includeSelf:False))) ifAfterwards:(if (is Mover P1) (< 0 (count in:(sites P2))) (< 0 (count in:(sites P1))))))))) (end (if (or (no Moves Mover) (is Decided "End")) (byScore {(score P1 (+ (count Cell at:(handSite P1)) (count in:(sites P1)))) (score P2 (+ (count Cell at:(handSite P2)) (count in:(sites P2))))}))))) 
2x6 board, with a storage hole on either end. The game starts with four counters in each hole. A player picks up all of the counters in one of the holes in their row and sows them one-by-one in a counterclockwise direction in consecutive holes from the hole the pieces originated. The starting hole is always left empty, even if a player sows in a complete circuit of the board, the original house is skipped and sowing continues in the next hole after it. Players capture counters when the final counter is sown in the player's own row and the hole containing it has two or three counters (counting the counter just dropped into it). If the hole before it also has two or three counters, these are also captured and so on until reaching a hole without two or three counters or one not belonging to the player. If an opponent's holes are all empty, the other player must make a move placing counters in the opponent's row. If not possible, the player captures all the counters in their row. The player who has captured the most counters wins. If the game continues in a repeating loop, the players can agree to end the game and capture the counters remaining in their row. 
(game "Fondji" (players 2) (equipment {(mancalaBoard 2 6 (track "Track" "1,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 FirstSite) (pair P2 LastSite)}) (piece "Seed" Shared)}) (rules (start (set Count 4 to:(sites Track))) (play (if (is Proposed "End") (or (move Vote "End") (move Vote "No")) (or (if (is Cycle) (move Propose "End")) (do (move Select (from (sites Mover) if:(< 0 (count at:(from)))) (then (sow if:(and (is In (to) (sites Next)) (or (= (count at:(to)) 2) (= (count at:(to)) 3))) apply:(fromTo (from (to)) (to (mapEntry (mover))) count:(count at:(to))) includeSelf:False backtracking:True))) ifAfterwards:(< 0 (count in:(sites Next))))))) (end (if (or (no Moves Mover) (is Decided "End")) (byScore {(score P1 (+ (count at:(mapEntry P1)) (count in:(sites P1)))) (score P2 (+ (count at:(mapEntry P2)) (count in:(sites P2))))}))))) 
2x6 board. Play begins with four counters in each hole. Moves begin from any hole in the player's row and sowing proceeds in an anti-clockwise direction. If the final counter of a sowing lands in an occupied hole, these counters are lifted and sowing continues. If the final counter lands in an empty hole, any counters in the opposite hole are taken and the turn ends. Play continues until one player cannot move. When this happens, the other player captures the remaining counters and the game ends. The player with the most counters wins.
(game "French Wari" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "0,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 4 to:(sites Track))) (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover)) if:(> (count at:(from)) 0)) (then (sow apply:(if (> (count at:(to)) 1) (moveAgain) (if (> (count at:(if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6))) 0) (fromTo (from (if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6))) (to (handSite Mover)) count:(count at:(if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6)))))))))) (end (if (no Moves Mover) (byScore {(score P1 (+ (count Cell at:(handSite P1)) (count in:(sites P1)))) (score P2 (+ (count Cell at:(handSite P2)) (count in:(sites P2))))}))))) 
2x6 board. Three counters in each hole. Sowing occurs in an anti-clockwise direction. When the final counter falls into an occupied hole, the player picks up the counters in the next hole and continues sowing from it. If that next hole is empty, the turn ends. If the final counter falls into an empty hole, the contents of the following hole are captured. Play continues until one player can no longer play because there are no counters left on their side. The opponent then takes the remainder of the counters on the board. For the next round, each player counts out the counters they captured, placing three each of the holes in their row. For every three in excess of the amount required to fill all of the holes in a row, the player claims one hole from the opponent's row. Play continues in this fashion until one player captures all of the holes on the board.
(game "Gabata (Adegrat)" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "0,E,N,W" loop:True)) (piece "Seed" Shared) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (hand Each) (map "LeftMost" {(pair P1 0) (pair P2 11)})}) (rules (start {(set Count 3 to:(sites Track)) (set RememberValue "OwnedP1" (sites Bottom)) (set RememberValue "OwnedP2" (sites Top))}) phases:{(phase "Sowing" (play (or {(move Select (from (if (is Prev Mover) (sites {(trackSite Move from:(last To afterConsequence:True) steps:1)}) (if (is Mover P1) (sites (values Remembered "OwnedP1")) (sites (values Remembered "OwnedP2")))) if:(> (count at:(from)) 0)) (then (sow apply:(if (> (count at:(to)) 1) (if (>= (count at:(trackSite Move from:(to) steps:1)) 1) (moveAgain)) (if (>= (count at:(trackSite Move from:(to) steps:1)) 1) (fromTo (from (trackSite Move from:(to) steps:1)) (to (handSite Mover)) count:(count at:(trackSite Move from:(to) steps:1))))))))} (then (if (or (all Sites (sites P1) if:(= 0 (count at:(site)))) (all Sites (sites P2) if:(= 0 (count at:(site))))) (and {(if (all Sites (sites P1) if:(= 0 (count at:(site)))) (forEach Site (sites Board) (if (< 0 (count at:(site))) (fromTo (from (site)) (to (handSite P2)) count:(count at:(site))))) (forEach Site (sites Board) (if (< 0 (count at:(site))) (fromTo (from (site)) (to (handSite P1)) count:(count at:(site)))))) (forget Value "OwnedP1" All) (forget Value "OwnedP2" All)}))))) (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) {(if (> 3 (count Cell at:(handSite P1))) (result P2 Win)) (if (> 3 (count Cell at:(handSite P2))) (result P1 Win))})) (nextPhase (all Sites (sites Board) if:(= 0 (count at:(site)))) "BetweenRounds")) (phase "BetweenRounds" (play (if (<= 3 (count Cell at:(handSite Mover))) (move (from (handSite Mover)) (to (trackSite FirstSite from:(mapEntry "LeftMost" Mover) if:(is Empty (to)))) count:3 (then (if (is Mover P1) (remember Value "OwnedP1" (last To)) (remember Value "OwnedP2" (last To))))))) (nextPhase (all Passed) "Sowing"))})) 
2x6 board. Three counters in each hole. The players begin the game simultaneously sowing first from their rightmost hole, racing to be the first one to drop the last counter of a sowing into an empty hole. This player then begins the next phase where they alternate play. Sowing occurs in an anti-clockwise direction. When the final counter falls into an occupied hole, the contents of this hole are picked up and sowing continues. When the final counter lands into an empty hole in the row belonging to the player, the counters in the opposite hole belonging to the opponent are captured, and the counter that triggered the capture is moved to the following hole. This could trigger the further capture of more of the opponent's counters if the hole in which the counter is placed was empty and the opponent's opposite hole contains counters. If the hole is occupied, sowing continues. If the hole is empty and the opposite hole is unoccupied or it is one of the opponent's holes, sowing ends. When one player can no longer play because the holes on their side are empty, the opponent captures the remaining counters on the board. A new round begins. The losing player places three counters in each hole, beginning on the rightmost hole. If the player has remaining counters but cannot fill their holes with three, they must distribute the remainder to fill as many of the remaining holes as possible with at least one counter. The winning player from the previous round then matches this starting configuration, keeping any surplus for use in future rounds. Play continues until one player has one or zero counters, the opponent being the winner.
(game "Gabata (Ansaba)" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "0,E,N,W" loop:True)) (piece "Seed" Shared) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (hand Each) (map "LeftMost" {(pair P1 0) (pair P2 11)}) (map "CorrespondingHoles" {(pair 0 11) (pair 1 10) (pair 2 9) (pair 3 8) (pair 4 7) (pair 5 6) (pair 6 5) (pair 7 4) (pair 8 3) (pair 9 2) (pair 10 1) (pair 11 0)})}) (rules (start (set Count 3 to:(sites Track))) phases:{(phase "Sowing" (play (or {(move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover)) if:(> (count at:(from)) 0)) (then (sow apply:(if (> (count at:(to)) 1) (moveAgain) (if (is In (to) (sites Mover)) (if (!= 0 (count at:(if (is Mover P1) (+ (to) 6) (- (to) 6)))) (and (fromTo (from (if (is Mover P1) (+ (to) 6) (- (to) 6))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 6) (- (to) 6)))) (moveAgain))))))))} (then (if (or (all Sites (sites P1) if:(= 0 (count at:(site)))) (all Sites (sites P2) if:(= 0 (count at:(site))))) (if (all Sites (sites P1) if:(= 0 (count at:(site)))) (and (forEach Site (sites Board) (if (< 0 (count at:(site))) (fromTo (from (site)) (to (handSite P2)) count:(count at:(site))))) (if (>= (count Cell at:(handSite P1)) (+ (count Cell at:(handSite P2)) (count in:(sites Board)))) (set NextPlayer (player 2)) (set NextPlayer (player 1)))) (and (forEach Site (sites Board) (if (< 0 (count at:(site))) (fromTo (from (site)) (to (handSite P1)) count:(count at:(site))))) (if (>= (count Cell at:(handSite P2)) (+ (count Cell at:(handSite P1)) (count in:(sites Board)))) (set NextPlayer (player 1)) (set NextPlayer (player 2))))))))) (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) {(if (> 2 (count Cell at:(handSite P1))) (result P2 Win)) (if (> 2 (count Cell at:(handSite P2))) (result P1 Win))})) (nextPhase (all Sites (sites Board) if:(= 0 (count at:(site)))) "BetweenRounds")) (phase "BetweenRounds" (play (if (<= 3 (count Cell at:(handSite Mover))) (move (from (handSite Mover)) (to (trackSite FirstSite from:(mapEntry "LeftMost" Mover) if:(is Empty (to)))) count:3) (move (from (handSite Mover)) (to (trackSite FirstSite from:(mapEntry "LeftMost" Mover) if:(is Empty (to)))) count:1) (then (if (!= 0 (count Cell at:(handSite Mover))) (moveAgain) (forEach Site (sites Mover) (if (is Occupied (site)) (fromTo (from (handSite Next)) (to (mapEntry "CorrespondingHoles" (site))) count:(count at:(site))))))))) (nextPhase (or (is Empty (handSite P1)) (is Empty (handSite P2))) "Sowing"))})) 
2x6 board. Four counters per hole. Each player takes their first turn from their leftmost hole. Sowing occurs in an anti-clockwise direction. If the final counter falls into an occupied hole, these are picked up and sowing continues. If the final counter falls into an empty hole, the turn ends. At any time during the sowing, if a hole is made to contain four counters, the owner of the hole in which the four counters are located captures them, unless it is the final hole of the sowing, in which case the player who is sowing captures them. The captures happen immediately. If a player does not capture when they should have, and a subsequent sowing causes this hole to contain five counters, it becomes a Jen. Players can no longer capture from a Jen in the same manner as before. Captures are made from it when the final counter of a sowing lands in it, in which case the final counter and one counter from the Jen are captured by the player who is sowing. Play continues until a player can no longer move because there are no counters in their row, and the opponent captures the remaining counters. Players then count their pieces by placing four in each hole, and the player who has more than their original number takes ownership of one of the opponent's holes for every four counters more than the original number that have been taken. If no player took four more than the original, the player with three extra gets the hole, if each player has two extra the weaker player is given the two extra counters. Play then begins again as before. The game ends when one player owns all of the counters, and thus all of the holes.
(game "Gabata (Ghinda)" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "0,E,N,W" loop:True)) (piece "Seed" Shared) (hand Each) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map "LeftMost" {(pair P1 0) (pair P2 11)})}) (rules (start {(set RememberValue "OwnedP1" (sites Bottom)) (set RememberValue "OwnedP2" (sites Top)) (set Count 4 to:(sites Track "Track"))}) phases:{(phase "Sowing" (play (or {(move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (if (= 1 (value Player Mover)) (if (is Mover P1) (sites (values Remembered "OwnedP1")) (sites (values Remembered "OwnedP2"))) (sites {(mapEntry "LeftMost" Mover)}))) if:(is Occupied (from))) (then (and (do (set Var "NumSowed" (count at:(last To))) next:(sow apply:(if (< 1 (count at:(to))) (if (= 4 (count at:(to))) (fromTo (from (to)) (to (handSite Mover)) count:4) (and (moveAgain) (set Var "Replay" (to)))))) (then (and (forEach Site (sites Track from:(last From) to:(trackSite Move from:(last From) "Track" steps:(- (var "NumSowed") 1))) (if (= 4 (count at:(site))) (fromTo (from (site)) (to (if (is In (site) (sites (values Remembered "OwnedP1"))) (handSite P1) (handSite P2))) count:4))) (set Var "NumSowed" 0)))) (if (!= 1 (value Player Mover)) (set Value Mover 1)))))} (then (if (or (all Sites (sites (values Remembered "OwnedP1")) if:(= 0 (count at:(site)))) (all Sites (sites (values Remembered "OwnedP2")) if:(= 0 (count at:(site))))) (and {(if (all Sites (sites (values Remembered "OwnedP2")) if:(= 0 (count at:(site)))) (forEach Site (sites Board) (fromTo (from (site)) (to (handSite P1)) count:(count at:(site)))) (forEach Site (sites Board) (fromTo (from (site)) (to (handSite P2)) count:(count at:(site))))) (forget Value "OwnedP1" All) (forget Value "OwnedP2" All)}))))) (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) {(if (= 0 (count Cell at:(handSite P1))) (result P2 Win)) (if (= 0 (count Cell at:(handSite P2))) (result P1 Win))})) (nextPhase (all Sites (sites Board) if:(= 0 (count at:(site)))) "BetweenRounds")) (phase "BetweenRounds" (play (if (<= 4 (count Cell at:(handSite Mover))) (move (from (handSite Mover)) (to (trackSite FirstSite "Track" from:(mapEntry "LeftMost" Mover) if:(is Empty (to)))) count:4 (then (and {(if (is Mover P1) (remember Value "OwnedP1" (last To)) (remember Value "OwnedP2" (last To))) (if (<= 4 (count Cell at:(handSite Mover))) (moveAgain) (if (= 3 (count Cell at:(handSite Mover))) (and {(fromTo (from (handSite Mover)) (to (trackSite FirstSite "Track" from:(mapEntry "LeftMost" Mover) if:(is Empty (to)))) count:3) (fromTo (from (handSite Next)) (to (trackSite FirstSite "Track" from:(mapEntry "LeftMost" Mover) if:(is Empty (to)))) count:1) (if (is Mover P1) (remember Value "OwnedP1" (trackSite FirstSite "Track" from:(mapEntry "LeftMost" Mover) if:(is Empty (to)))) (remember Value "OwnedP2" (trackSite FirstSite "Track" from:(mapEntry "LeftMost" Mover) if:(is Empty (to)))))}) (if (= 2 (count Cell at:(handSite Mover))) (and {(fromTo (from (handSite Mover)) (to (trackSite FirstSite "Track" from:(mapEntry "LeftMost" Mover) if:(is Empty (to)))) count:2) (fromTo (from (handSite Next)) (to (trackSite FirstSite "Track" from:(mapEntry "LeftMost" Mover) if:(is Empty (to)))) count:2) (if (< 50 (value Random (range 1 100))) (remember Value "OwnedP1" (trackSite FirstSite "Track" from:(mapEntry "LeftMost" Mover) if:(is Empty (to)))) (remember Value "OwnedP2" (trackSite FirstSite "Track" from:(mapEntry "LeftMost" Mover) if:(is Empty (to)))))}))))}))))) (nextPhase (and (is Empty (handSite P1)) (is Empty (handSite P2))) "Sowing"))})) 
2x6 board. Four counters in each hole. Play begins with a stylised move. One player takes the four counters in their leftmost hole and places them into the next hole, moving in an anti-clockwise direction. They then take the four counters in the next hole, and place them in the following holes. This continues until the entire board has an alternation pattern of a hole with eight counters followed by one with zero counters. The player then sows beginning from the final hole with eight counters they created. When the final counter of a sowing lands in a hole with counters, the player picks up these counters and sowing continues. When the final counter falls into an empty hole, the turn ends. At any time during the sowing a hole is made to contain four counters, they are captured by the player who is sowing, except when it is the final hole of a sowing, in which case they are picked up and sowing continues. If a player cannot play, they must pass their turn and may resume play when they are next able. When all of the counters have been captured, the player who captured the most counters wins.
(game "Gabata (Oromo)" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "0,E,N,W" loop:True)) (piece "Seed" Shared) (hand Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start (set Count 4 to:(sites Track))) phases:{(phase "Opening1" (play (move Select (from (if (is Prev Mover) (var "Replay") 0)) (then (sow numPerHole:4 apply:(and (moveAgain) (if (is Occupied (trackSite Move from:(to) "Track" steps:1)) (set Var "Replay" (trackSite Move from:(to) "Track" steps:1)) (set Var "Replay" -1))))))) (nextPhase (= -1 (var "Replay")) "Opening2")) (phase "Opening2" (play (move Select (from (if (and (is Prev Mover) (!= -1 (var "Replay"))) (var "Replay") 6)) (then (do (set Var "NumSowed" (count at:(last To))) next:(sow apply:(if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to))))) (then (and (forEach Site (sites Track from:(last From) to:(trackSite Move from:(last From) "Track" steps:(- (var "NumSowed") 1))) (if (= 4 (count at:(site))) (fromTo (from (site)) (to (handSite Mover)) count:4))) (set Var "NumSowed" 0))))))) (nextPhase (not (is Next Prev)) "Sowing")) (phase "Sowing" (play (move Select (from (if (and (is Prev Mover) (!= -1 (var "Replay"))) (sites {(var "Replay")}) (sites Mover)) if:(is Occupied (from))) (then (do (set Var "NumSowed" (count at:(last To))) next:(sow apply:(if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to))))) (then (and (forEach Site (sites Track from:(last From) to:(trackSite Move from:(last From) "Track" steps:(- (var "NumSowed") 1))) (if (= 4 (count at:(site))) (fromTo (from (site)) (to (handSite Mover)) count:4))) (set Var "NumSowed" 0))))))))} (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) (byScore {(score P1 (count Cell at:(handSite P1))) (score P2 (count Cell at:(handSite P2)))}))))) 
2x6 board. Four counters in each hole. Players draw lots to see who goes first. Players pick up the counters in any of the holes in their row and sow them in an anti-clockwise direction. If the last counter falls into a hole that is occupied, the player picks up the contents of this hole and continues to sow. When the last counter falls into an empty hole, the play ends. Capturing occurs when the last counter falls into a hole on the opponent's side of the board containing three counters, increasing it to four. This hole then belongs to the player who captured it. A player cannot pick up counters from this hole, and the opponent can only do so if the last counter of their sowing falls there, in which case the opponent takes one counter from it, along with the final counter. The captured hole remains in the ownership of the person who captured it. If it remains empty and the opponent drops their last counter into this hole, the last counter is removed. If a player cannot move, they pass, but the opponent may continue to make moves. The player could then resume play if the opponent's moves create a possibility for a move. Play ends when there are no more counters available to move. Each player owns the counters in their captured holes or which they have removed from the board. A second round is played, each player placing four counters into each hole starting from the rightmost hole in their row. The player with more counters gains a hole from their opponent for every four extra balls they've captured. If an opponent has three extra after counting in such a way, they also gain a hole, but not if there are one or two extra. Play continues in several rounds like this until one player takes all the counters. Each row has 6 holes.
(game "Gabata (Shoa I)" (players 2) (equipment {(mancalaBoard 2 6 store:None {(track "TrackCCW" "0,E,N,W" loop:True) (track "TrackCW" "5,W,N,E" loop:True)}) (piece "Seed" Shared) (hand Each) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map "RightMost" {(pair P1 5) (pair P2 6)})}) (rules (start {(set RememberValue "OwnedP1" (sites Bottom)) (set RememberValue "OwnedP2" (sites Top)) (set Count 4 to:(sites Track))}) phases:{(phase "Sowing" (play (or {(move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (if (is Mover P1) (sites (values Remembered "OwnedP1")) (sites (values Remembered "OwnedP2")))) if:(and (< 0 (count at:(from))) (= 0 (state at:(from))))) (then (sow "TrackCCW" apply:(if (and (= 0 (state at:(to))) (= 4 (count at:(to)))) (set State at:(to) (mover)) (if (< 1 (count at:(to))) (if (= 0 (state at:(to))) (and (moveAgain) (set Var "Replay" (to))) (if (!= (mover) (state at:(to))) (and (fromTo (from (to)) (to (handSite Mover)) count:(min 2 (count at:(to)))) (set State at:(to) (state at:(to)))))))))))} (then (if (all Sites (forEach (sites Board) if:(= 0 (state at:(site)))) if:(= 0 (count at:(site)))) (and {(forEach Site (forEach (sites Board) if:(= 1 (state at:(site)))) (fromTo (from (site)) (to (handSite P1)) count:(count at:(site)))) (forEach Site (forEach (sites Board) if:(= 2 (state at:(site)))) (fromTo (from (site)) (to (handSite P2)) count:(count at:(site)))) (forget Value "OwnedP1" All) (forget Value "OwnedP2" All) (set Var "Round" (+ 1 (var "Round")))}))))) (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) {(if (>= 1 (count Cell at:(handSite P1))) (result P2 Win)) (if (>= 1 (count Cell at:(handSite P2))) (result P1 Win))})) (nextPhase (all Sites (sites Board) if:(= 0 (count at:(site)))) "BetweenRounds")) (phase "BetweenRounds" (play (if (<= 4 (count Cell at:(handSite Mover))) (move (from (handSite Mover)) (to (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))) count:4 (then (and {(if (is Mover P1) (remember Value "OwnedP1" (last To)) (remember Value "OwnedP2" (last To))) (if (<= 4 (count Cell at:(handSite Mover))) (moveAgain) (if (= 3 (count Cell at:(handSite Mover))) (and {(fromTo (from (handSite Mover)) (to (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))) count:3) (fromTo (from (handSite Next)) (to (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))) count:1) (if (is Mover P1) (remember Value "OwnedP1" (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))) (remember Value "OwnedP2" (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))))}) (if (= 2 (count Cell at:(handSite Mover))) (and {(fromTo (from (handSite Mover)) (to (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))) count:2) (fromTo (from (handSite Next)) (to (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))) count:2) (if (< 50 (value Random (range 1 100))) (remember Value "OwnedP1" (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))) (remember Value "OwnedP2" (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))))}))))}))) (then (if (and (is Empty (handSite P1)) (is Empty (handSite P2))) (and (if (is Even (var "Round")) (set NextPlayer (player 2)) (set NextPlayer (player 1))) (set Pending)))))) (nextPhase (and (is Empty (handSite P1)) (is Empty (handSite P2))) "Sowing"))})) 
2x6 board. Four counters in each hole. The game begins with a stylised move. One player takes one counter from their rightmost hole, and holds in in their hand. They then take one counter from the next hole, moving in an anti-clockwise direction, and place it in the next hole. They then take a counter from the next hole after that, and placing it in the next hole, continuing until there is an alternating pattern of a hole with five counters followed by a hole with three counters. The original hole from which the first counter was taken will have four counters. The player will then place the first counter taken into the next hole in the opponent's row, causing it to hold four counters. This creates a weg, a hole captured by that player, which is involved in capturing (see below). Players alternate making this first move in subsequent rounds. The next phase begins once this stylised move is completed. Sowing occurs in an anti-clockwise direction. If the final counter of a sowing falls into a hole containing counters, these are picked up and sowing continues. A player's turn ends when the final counter falls into an empty hole. When the final counter of a sowing falls into a hole containing three counters, it creates a weg, and the turn ends. Players cannot sow from a weg they've captured. A player may capture counters from an opponent's weg when the final counter of a sowing falls into the opponent's weg on the player's turn. The final counter and one counter in the weg are captured. The player may then take the counters from any of their holes and sow from there. If a player cannot play, they must pass their turn, but may play again if this becomes possible in a subsequent turn. Play ends when there are no possible moves left on the board. Players then capture the counters in their wegs. A new round begins. The players fill as many of their holes with four counters as they are able. The player with more counters will capture as many holes from the opponent in which they can place four or more counters. If the player has three remaining counters after holes are filled with four, the opponent would cede their one remaining counter to the opponent to make four and the player captures one further hole. If there are two remaining, the players draw lots to determine which player owns the remaining hole. The player who played second in the previous round begins the new round with the same stylized move, and play continues as before after that. Play continues until one player owns no holes; the opponent wins.
(game "Gabata (Shoa and Adegrat)" (players 2) (equipment {(mancalaBoard 2 6 store:None {(track "TrackCCW" "0,E,N,W" loop:True) (track "TrackCW" "5,W,N,E" loop:True)}) (piece "Seed" Shared) (hand Each) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map "RightMost" {(pair P1 5) (pair P2 6)})}) (rules (start {(set RememberValue "OwnedP1" (sites Bottom)) (set RememberValue "OwnedP2" (sites Top)) (set Count 4 to:(sites Track))}) phases:{(phase "Opening" (play (if (is Mover P1) (move Select (from (if (and (not (is Pending)) (is Prev Mover)) (sites {(trackSite Move from:(last From) "TrackCCW" steps:2)}) (sites {10}))) (then (sow count:1 "TrackCCW" apply:(if (not (is In (trackSite Move from:(from) "TrackCCW" steps:2) (intersection (sites Bottom) (sites Right)))) (moveAgain) (set State at:11 (mover)))))) (move Select (from (if (and (not (is Pending)) (is Prev Mover)) (sites {(trackSite Move from:(last From) "TrackCCW" steps:2)}) (sites {1}))) (then (sow count:1 "TrackCCW" apply:(if (not (is In (trackSite Move from:(from) "TrackCCW" steps:2) (intersection (sites Top) (sites Left)))) (moveAgain) (set State at:0 (mover)))))))) (nextPhase (if (is Mover P1) (is In (trackSite Move from:(last From) "TrackCCW" steps:2) (intersection (sites Bottom) (sites Right))) (is In (trackSite Move from:(last From) "TrackCCW" steps:2) (intersection (sites Top) (sites Left)))) "Sowing")) (phase "Sowing" (play (or {(move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (if (is Mover P1) (sites (values Remembered "OwnedP1")) (sites (values Remembered "OwnedP2")))) if:(and (< 0 (count at:(from))) (= 0 (state at:(from))))) (then (sow "TrackCCW" apply:(if (and (= 0 (state at:(to))) (= 4 (count at:(to)))) (set State at:(to) (mover)) (if (< 1 (count at:(to))) (if (= 0 (state at:(to))) (and (moveAgain) (set Var "Replay" (to))) (if (!= (mover) (state at:(to))) (and (fromTo (from (to)) (to (handSite Mover)) count:(min 2 (count at:(to)))) (set State at:(to) (state at:(to)))))))))))} (then (if (all Sites (forEach (sites Board) if:(= 0 (state at:(site)))) if:(= 0 (count at:(site)))) (and {(forEach Site (forEach (sites Board) if:(= 1 (state at:(site)))) (fromTo (from (site)) (to (handSite P1)) count:(count at:(site)))) (forEach Site (forEach (sites Board) if:(= 2 (state at:(site)))) (fromTo (from (site)) (to (handSite P2)) count:(count at:(site)))) (forget Value "OwnedP1" All) (forget Value "OwnedP2" All) (set Var "Round" (+ 1 (var "Round")))}))))) (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) {(if (>= 1 (count Cell at:(handSite P1))) (result P2 Win)) (if (>= 1 (count Cell at:(handSite P2))) (result P1 Win))})) (nextPhase (all Sites (sites Board) if:(= 0 (count at:(site)))) "BetweenRounds")) (phase "BetweenRounds" (play (if (<= 4 (count Cell at:(handSite Mover))) (move (from (handSite Mover)) (to (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))) count:4 (then (and {(if (is Mover P1) (remember Value "OwnedP1" (last To)) (remember Value "OwnedP2" (last To))) (if (<= 4 (count Cell at:(handSite Mover))) (moveAgain) (if (= 3 (count Cell at:(handSite Mover))) (and {(fromTo (from (handSite Mover)) (to (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))) count:3) (fromTo (from (handSite Next)) (to (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))) count:1) (if (is Mover P1) (remember Value "OwnedP1" (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))) (remember Value "OwnedP2" (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))))}) (if (= 2 (count Cell at:(handSite Mover))) (and {(fromTo (from (handSite Mover)) (to (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))) count:2) (fromTo (from (handSite Next)) (to (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))) count:2) (if (< 50 (value Random (range 1 100))) (remember Value "OwnedP1" (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))) (remember Value "OwnedP2" (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))))}))))}))) (then (if (and (is Empty (handSite P1)) (is Empty (handSite P2))) (and (if (is Even (var "Round")) (set NextPlayer (player 2)) (set NextPlayer (player 1))) (set Pending)))))) (nextPhase (and (is Empty (handSite P1)) (is Empty (handSite P2))) "Opening"))})) 
2x6 board. Three counters in each hole. Play begins with a stylized move. One player takes all of the counters from their leftmost hole, and proceeding in an anti-clockwise direction, takes all of the counters from the holes in their row. They then begin sowing these counters into the opponent's row, proceeding around the board in an anti-clockwise direction. When the final counter lands in an occupied hole, these counters are picked up and sowing continues. When the final counter lands in an empty hole, the turn ends. The main phase of the game begins, in which sowing continues in the same manner, but the player may begin their turn from any hole in their row. At the end of sowing, any holes containing four counters are captured by the owner of the row in which the hole is located, unless it is the hole in which the final counter fell, in which case the player captures them and the turn ends. If at the end of the game there are not sufficient counters to cause a hole to contain four, the players decide how the counters are allocated, and a new round begins. The players fill as many of their holes with four counters as they are able. The player with more counters will capture as many holes from the opponent in which they can place three or counters. If the player has two remaining counters after holes are filled with three, the opponent would cede their one remaining counter to the player to make three and the player captures one further hole. The player who played second in the previous round begins the new round with the same stylized move, and play continues as before after that. Play continues until one player owns no holes; the opponent wins.
(game "Gabata (Wuqro)" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "0,E,N,W" loop:True)) (piece "Seed" Shared) (hand Each) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map "LeftMost" {(pair P1 0) (pair P2 11)})}) (rules (start {(set RememberValue "OwnedP1" (sites Bottom)) (set RememberValue "OwnedP2" (sites Top)) (set Count 3 to:(sites Track))}) phases:{(phase "Opening" (play (if (is Prev Mover) (move Select (from (var "Replay")) (then (sow apply:(if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to))) (set Var "Round" (+ 1 (var "Round"))))))) (move (from 0) (to 11) count:(count at:(to)) (then (and {(forEach Site (sites Mover) (if (is Occupied (site)) (fromTo (from (site)) (to 11) count:(count at:(site))))) (moveAgain) (set Var "Replay" 11)}))))) (nextPhase (not (is Next Mover)) "Sowing")) (phase "Sowing" (play (or {(move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (if (is Mover P1) (sites (values Remembered "OwnedP1")) (sites (values Remembered "OwnedP2")))) if:(is Occupied (from))) (then (do (set Var "NumSowed" (count at:(last To))) next:(sow apply:(if (< 1 (count at:(to))) (if (= 4 (count at:(to))) (fromTo (from (to)) (to (handSite Mover)) count:4) (and (moveAgain) (set Var "Replay" (to)))))) (then (and (forEach Site (sites Track from:(last From) to:(trackSite Move from:(last From) "Track" steps:(- (var "NumSowed") 1))) (if (= 4 (count at:(site))) (fromTo (from (site)) (to (handSite Mover)) count:4))) (set Var "NumSowed" 0))))))} (then (if (= 4 (count in:(sites Board))) (and {(forEach Site (sites Board) (fromTo (from (site)) (to (handSite Mover)) count:(count at:(site)))) (forget Value "OwnedP1" All) (forget Value "OwnedP2" All) (set Var "Round" (+ 1 (var "Round")))}) (if (all Sites (sites Board) if:(= 0 (count at:(site)))) (and {(forget Value "OwnedP1" All) (forget Value "OwnedP2" All) (set Var "Round" (+ 1 (var "Round")))})))))) (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) {(if (> 2 (count Cell at:(handSite P1))) (result P2 Win)) (if (> 2 (count Cell at:(handSite P2))) (result P1 Win))})) (nextPhase (all Sites (sites Board) if:(= 0 (count at:(site)))) "BetweenRounds")) (phase "BetweenRounds" (play (if (<= 3 (count Cell at:(handSite Mover))) (move (from (handSite Mover)) (to (trackSite FirstSite "Track" from:(mapEntry "LeftMost" Mover) if:(is Empty (to)))) count:3 (then (and {(if (is Mover P1) (remember Value "OwnedP1" (last To)) (remember Value "OwnedP2" (last To))) (if (<= 3 (count Cell at:(handSite Mover))) (moveAgain) (if (= 2 (count Cell at:(handSite Mover))) (and {(fromTo (from (handSite Mover)) (to (trackSite FirstSite "Track" from:(mapEntry "LeftMost" Mover) if:(is Empty (to)))) count:2) (fromTo (from (handSite Next)) (to (trackSite FirstSite "Track" from:(mapEntry "LeftMost" Mover) if:(is Empty (to)))) count:1) (if (is Mover P1) (remember Value "OwnedP1" (trackSite FirstSite "Track" from:(mapEntry "LeftMost" Mover) if:(is Empty (to)))) (remember Value "OwnedP2" (trackSite FirstSite "Track" from:(mapEntry "LeftMost" Mover) if:(is Empty (to)))))})))}))) (then (if (and (is Empty (handSite P1)) (is Empty (handSite P2))) (and (if (is Even (var "Round")) (set NextPlayer (player 2)) (set NextPlayer (player 1))) (set Pending)))))) (nextPhase (and (is Empty (handSite P1)) (is Empty (handSite P2))) "Opening"))})) 
2x6 board with two stores. Seven counters in each hole. Play moves in an anti-clockwise direction and players sow into the store on their right hand side. A move may begin from any of the player's holes except their store. If the last counter falls into the store, they can sow again from any of the holes in their row. If it lands in a hole with counters in it, these are picked up and sowing continues. If the last counter falls into an empty hole the move ends, but if the hole is in the player's own row, any counters in the hole opposite it are captured and placed in the store. When no more moves can be made, a new round begins and each player fills as many holes as they can by putting seven in each. Surplus counters are placed in the store. Any unfilled holes are excluded from play. Play continues until one player cannot fill a hole with seven counters, and the opponent wins.
(game "Galatjang" (players 2) (equipment {(mancalaBoard 2 6 {(track "Track1" "1,E,ENE,WNW,W" loop:True P1) (track "Track2" "12,W,WSW,ESE,E" loop:True P2)}) (piece "Seed" Shared) (regions "Home" P1 (sites Bottom)) (regions "Home" P2 (sites Top)) (map {(pair P1 LastSite) (pair P2 FirstSite)})}) (rules (start {(set Count 7 to:(union (sites Bottom) (sites Top))) (forEach Value min:1 max:12 (set RememberValue (value)))}) phases:{(phase "Round" (play (move Select (from (if (and (not (is Pending)) (is Prev Mover)) (sites {(last To afterConsequence:True)}) (forEach (sites Mover "Home") if:(is In (site) (values Remembered)))) if:(> (count at:(from)) 0)) (then (sow "Track" owner:(mover) apply:(if (= (to) (mapEntry Mover)) (and (moveAgain) (set Pending)) (if (> (count at:(to)) 1) (moveAgain) (if (and (is In (to) (sites Mover "Home")) (> (count at:(if (is Mover P1) (+ (to) 6) (- (to) 6))) 0)) (fromTo (from (if (is Mover P1) (+ (to) 6) (- (to) 6))) (to (mapEntry Mover)) count:(count at:(if (is Mover P1) (+ (to) 6) (- (to) 6))))))) (then (if (all Sites (forEach (difference (union (sites Bottom) (sites Top)) (sites Empty)) if:(is In (site) (values Remembered))) if:(= 0 (count at:(site)))) (and (forEach Site (difference (sites P1 "Home") (sites Empty)) (fromTo (from (site)) (to (mapEntry P1)) count:(count at:(site)))) (forEach Site (difference (sites P2 "Home") (sites Empty)) (fromTo (from (site)) (to (mapEntry P2)) count:(count at:(site))))))))))) (nextPhase (all Sites (forEach (difference (union (sites Bottom) (sites Top)) (sites Empty)) if:(is In (site) (values Remembered))) if:(= 0 (count at:(site)))) "BetweenRound")) (phase "BetweenRound" (play (if (>= (count at:(mapEntry Mover)) 7) (move (from (mapEntry Mover)) (to (intersection (sites Empty) (sites Mover "Home"))) count:7) (then (if (or (and (> 7 (count at:(mapEntry P2))) (= 42 (count in:(sites Bottom)))) (and (> 7 (count at:(mapEntry P1))) (= 42 (count in:(sites Top))))) (and (forget Value All) (forEach Site (sites Board) (if (= 7 (count at:(site))) (remember Value (site))))))))) (nextPhase (or (and (> 7 (count at:(mapEntry P2))) (= 42 (count in:(sites Bottom)))) (and (> 7 (count at:(mapEntry P1))) (= 42 (count in:(sites Top))))) "Round"))} (end (if (> 7 (count in:(difference (sites Board) (mapEntry Mover)))) (result Mover Win))))) 
2x6 board. Four counters in each hole. Sowing occurs in an anti-clockwise direction. When the final counter of a sowing lands in an empty hole on the player's own row, the contents of the opponent's opposite hole are captured only if it contains one counter. If the final counter lands in an occupied hole, the contents of it are picked up and sowing continues. If the final counter lands in a hole in the opponent's row, causing it to contain four counters, the hole becomes a qasamo, and it can no longer be sown from. Play continues until all of the counters are captured or are in a qasamo. The player with the most counters captured and in all qasamo belonging to them wins.
(game "Gamacha (Nobility)" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "0,E,N,W" loop:True)) (piece "Seed" Shared) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (hand Each)}) (rules (start (set Count 4 to:(sites Track))) (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover)) if:(and (< 0 (count at:(from))) (= 0 (state at:(from))))) (then (sow apply:(if (and (is In (to) (sites Mover)) (= 1 (count at:(to)))) (if (= 1 (count at:(if (is Mover P1) (+ (to) 6) (- (to) 6)))) (fromTo (from (if (is Mover P1) (+ (to) 6) (- (to) 6))) (to (handSite Mover)) count:1)) (if (< 1 (count at:(to))) (and (moveAgain) (if (and {(is In (to) (sites Next)) (= 0 (state at:(to))) (= 4 (count at:(to)))}) (set State at:(to) (mover)))))))))) (end (if (all Sites (forEach (sites Board) if:(= 0 (state at:(site)))) if:(= 0 (count at:(site)))) (byScore {(score P1 (+ (count Cell at:(handSite P1)) (count in:(forEach (sites Board) if:(= (id P1) (state at:(site))))))) (score P2 (+ (count Cell at:(handSite P2)) (count in:(forEach (sites Board) if:(= (id P2) (state at:(site)))))))}))))) 
2x12 board. The board begins with the following pattern of counters in the holes, beginning from the bottom left row and proceeding in an anti-clockwise direction: 0-0-4-0-4-0-4-0-4-0-4-0-4-0-4-0-4-0-4-0-4-0-4-0. One player starts with an additional four counters in their left hand hole. The player with fewer counters on their first move places the counters from their seventh hole into the opponent's opposite hole. Sowing occurs in an anti-clockwise direction, and may only happen when the final counter lands either in an empty hole in the player's own row or in any hole in the opponent's row. When the final counter lands in an empty hole in the player's own row, the contents of the opposite hole in the opponent's row are captured. When the final counter lands in an occupied hole in the opponent's row, these counters are picked up and sowing continues. The final counter of this sowing is allowed to fall into an occupied hole in the player's own row, and these are picked up and sowing continues. Sowing ends when the final counter lands in an empty hole. The game ends when one player has no counters on their side of the board, and the opponent wins.
(game "Gamacha" (players 2) (equipment {(mancalaBoard 2 12 store:None (track "Track" "0,E,N,W" loop:True)) (piece "Seed" Shared) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (hand Each)}) (rules (start (set Count 4 to:(sites {"C1" "E1" "G1" "I1" "K1" "L2" "J2" "H2" "F2" "D2" "B2"}))) phases:{(phase "Opening" (play (move (from 6) (to 18) count:4)) (nextPhase "Sowing")) (phase "Sowing" (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover)) if:(if (is Prev Mover) True (and (> (count at:(from)) 0) (if (is In (trackSite Move from:(from) steps:(count at:(from))) (sites Next)) True (is Empty (trackSite Move from:(from) steps:(count at:(from)))))))) (then (sow apply:(if (and (is In (to) (sites Mover)) (<= (count at:(to)) 1)) (if (!= 0 (count at:(if (is Mover P1) (+ (to) 12) (- (to) 12)))) (fromTo (from (if (is Mover P1) (+ (to) 12) (- (to) 12))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 12) (- (to) 12))))) (if (> (count at:(to)) 1) (moveAgain))))))))} (end (forEach Player if:(all Sites (sites Player) if:(= 0 (count at:(site)))) (result Player Loss))))) 
2x4 board with two stores on the ends. Six counters in each hole. Instead of owning the row of holes closest to them, players own the holes on the left half of the board. Play begins from any of the player's holes, sowing in either direction. When the last counter is sown, making the hole contain two or four counters, these are captured. If the adjacent holes also contain two or four counters, these are also captured. If the last counter falls into a hole, making it contain a number other than two or four, and adjacent holes contain two or four, the counters from only one of these adjacent holes may be captured. Play ends when each player is reduced to one counter. A second round begins with each player placing six counters in as many of their holes as they can, returning surplus to the store. Play continues as before. Rounds are played until one player loses all their counters.
(game "Gifia" (players 2) (equipment {(mancalaBoard 2 4 {(track "TrackCCW" "1,E,N,W" loop:True) (track "TrackCW" "4,W,N,E" loop:True)}) (regions P1 (difference (expand (sites Left) steps:2) (sites Left))) (regions P2 (difference (expand (sites Right) steps:2) (sites Right))) (map {(pair P1 FirstSite) (pair P2 LastSite)}) (piece "Seed" Shared)}) (rules (start (set Count 6 to:(sites Track))) phases:{(phase "Sowing" (play (if (is Prev Mover) (or (move (from (ahead (last To afterConsequence:True) W)) (to (mapEntry Mover)) count:(count at:(ahead (last To afterConsequence:True) W))) (move (from (ahead (last To afterConsequence:True) E)) (to (mapEntry Mover)) count:(count at:(ahead (last To afterConsequence:True) E)))) (or (move Select (from (sites Mover) if:(is Occupied (from))) (then (sow "TrackCCW" apply:(if (or (= 2 (count at:(to))) (= 4 (count at:(to)))) (and {(fromTo (from (to)) (to (mapEntry Mover)) count:(count at:(to))) (if (!= (to) (ahead (to) W)) (if (or (= 2 (count at:(ahead (to) W))) (= 4 (count at:(ahead (to) W)))) (fromTo (from (ahead (to) W)) (to (mapEntry Mover)) count:(count at:(ahead (to) W))))) (if (!= (to) (ahead (to) E)) (if (or (= 2 (count at:(ahead (to) E))) (= 4 (count at:(ahead (to) E)))) (fromTo (from (ahead (to) E)) (to (mapEntry Mover)) count:(count at:(ahead (to) E)))))}) (if (and (if (!= (to) (ahead (to) W)) (if (or (= 2 (count at:(ahead (to) W))) (= 4 (count at:(ahead (to) W)))) False)) (if (!= (to) (ahead (to) E)) (if (or (= 2 (count at:(ahead (to) E))) (= 4 (count at:(ahead (to) E)))) False))) (moveAgain)))))) (move Select (from (sites Mover) if:(is Occupied (from))) (then (sow "TrackCW" apply:(if (or (= 2 (count at:(to))) (= 4 (count at:(to)))) (and {(fromTo (from (to)) (to (mapEntry Mover)) count:(count at:(to))) (if (!= (to) (ahead (to) W)) (if (or (= 2 (count at:(ahead (to) W))) (= 4 (count at:(ahead (to) W)))) (fromTo (from (ahead (to) W)) (to (mapEntry Mover)) count:(count at:(ahead (to) W))))) (if (!= (to) (ahead (to) E)) (if (or (= 2 (count at:(ahead (to) E))) (= 4 (count at:(ahead (to) E)))) (fromTo (from (ahead (to) E)) (to (mapEntry Mover)) count:(count at:(ahead (to) E)))))}) (if (and (if (!= (to) (ahead (to) W)) (if (or (= 2 (count at:(ahead (to) W))) (= 4 (count at:(ahead (to) W)))) False)) (if (!= (to) (ahead (to) E)) (if (or (= 2 (count at:(ahead (to) E))) (= 4 (count at:(ahead (to) E)))) False))) (moveAgain))))))) (then (if (and (>= 1 (count Pieces All in:(sites P1))) (>= 1 (count Pieces All in:(sites P2)))) (and (forEach Site (sites P1) (fromTo (from (site)) (to (mapEntry P1)) count:(count at:(site)))) (forEach Site (sites P2) (fromTo (from (site)) (to (mapEntry P2)) count:(count at:(site))))))))) (end (if (no Pieces All in:(union (sites Top) (sites Bottom))) {(if (> 6 (count at:(mapEntry P1))) (result P2 Win)) (if (> 6 (count at:(mapEntry P2))) (result P1 Win))})) (nextPhase (no Pieces All in:(union (sites Top) (sites Bottom))) "BetweenRounds")) (phase "BetweenRounds" (play (if (not (all Sites (sites Mover) if:(is Occupied (site)))) (if (<= 6 (count at:(mapEntry Mover))) (move (from (mapEntry Mover)) (to (sites Mover) if:(is Empty (to))) count:6)))) (nextPhase (all Passed) "Sowing"))})) 
Play begins with six counters in each hole. Sowing is anti-clockwise. If the last counter of a sowing lands in the player's own hole making it even, the counters are captured. If the contents of the hole before it is also even, these are also taken, continuing until an odd or empty hole is reached. If the last counter makes a hole odd, the turn ends. If a player has no counters in their holes at the end of the turn, the opponent must play so that the player can play on the next turn. Play ends when neither player is able to move; the last player who was able to move takes the remaining counters and the player with the most counters captured wins.
(game "Halusa" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "0,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 6 to:(sites Track))) (play (do (move Select (from (sites Mover) if:(> (count at:(from)) 0)) (then (sow if:(and (is In (to) (sites Mover)) (is Even (count at:(to)))) apply:(fromTo (from (to)) (to (handSite Mover)) count:(count at:(to))) backtracking:True))) ifAfterwards:(> (count in:(sites Next)) 0))) (end (if (no Moves Mover) (byScore {(score P1 (+ (count Cell at:(handSite P1)) (count in:(sites P1)))) (score P2 (+ (count Cell at:(handSite P2)) (count in:(sites P2))))}))))) 
2x6-12 board, six is the most common. Four counters in each hole. A player moves by picking up the contents of one of their holes and sowing them in an anti-clockwise direction. If the final counter lands in an occupied hole, the contents of this hole are picked up and sowing continues. If the final counter falls into an empty hole, the turn ends. If the final counter falls into a hole containing three counters, making it four after the sowing, then these counters are captured and the turn ends. If at any time during sowing a player drops a counter into a hole to make it contain four, these are captured. If a player cannot move because there are no counters in their holes, they pass. When eight counters are left, the player to first capture a group of four also takes the remaining four counters on the board. Each player has 6 holes.
(game "Hoyito" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "0,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 4 to:(sites Track))) (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover)) if:(> (count at:(from)) 0)) (then (sow apply:(if (= (count at:(to)) 4) (if (<= (count in:(sites Board)) 8) (forEach Site (sites Board) (if (> (count at:(site)) 0) (fromTo (from (site)) (to (handSite Mover)) count:(count at:(site))))) (fromTo (from (to)) (to (handSite Mover)) count:(count at:(to)))) (if (< (count at:(to)) 1) (moveAgain))))))) (end (if (no Moves Mover) (byScore {(score P1 (count Cell at:(handSite P1))) (score P2 (count Cell at:(handSite P2)))}))))) 
2x6 board. Four counters in each hole. Sowing proceeds in an anti-clockwise direction. When the final counter of a sowing lands in an occupied hole, the contents are picked up and sowing continues. When the final counter falls in an empty hole, the turn ends. If the empty hole is in the player's row, any counters in the opponent's opposite hole are captured. If a player cannot play, they pass their turn until they are able. The player who captures all of the counters wins. Players then count their pieces by placing four in each hole, and the player who has more than their original number takes ownership of one of the opponent's holes for every four counters more than the original number that have been taken. If no player took four more than the original, the player with three extra gets the hole, if each player has two extra they draw lots to see who gets an extra hole. Play then begins again as before. Play continues until one player owns all of the holes.
(game "Hufesay" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "0,E,N,W" loop:True)) (regions "Home" P1 (sites Bottom)) (regions "Home" P2 (sites Top)) (piece "Seed" Shared) (hand Each) (map "LeftMost" {(pair P1 0) (pair P2 11)})}) (rules (start {(set Count 4 to:(sites Track)) (set RememberValue "OwnedP1" (sites Bottom)) (set RememberValue "OwnedP2" (sites Top))}) phases:{(phase "Sowing" (play (or {(move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (if (is Mover P1) (sites (values Remembered "OwnedP1")) (sites (values Remembered "OwnedP2")))) if:(is Occupied (from))) (then (sow apply:(if (> (count at:(to)) 1) (moveAgain) (if (and (is In (to) (sites Mover)) (> (count at:(if (is Mover P1) (+ (to) 6) (- (to) 6))) 0)) (fromTo (from (if (is Mover P1) (+ (to) 6) (- (to) 6))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 6) (- (to) 6)))))))))} (then (if (or (all Sites (sites P1) if:(= 0 (count at:(site)))) (all Sites (sites P2) if:(= 0 (count at:(site))))) (and {(forEach Site (sites (values Remembered "OwnedP1")) (if (is Occupied (site)) (fromTo (from (site)) (to (handSite P1)) count:(count at:(site))))) (forEach Site (sites (values Remembered "OwnedP2")) (if (is Occupied (site)) (fromTo (from (site)) (to (handSite P2)) count:(count at:(site))))) (forget Value "OwnedP1" All) (forget Value "OwnedP2" All) (if (>= (+ (count Cell at:(handSite P1)) (count in:(sites P1))) (+ (count Cell at:(handSite P2)) (count in:(sites P2)))) (set NextPlayer (player 1)) (set NextPlayer (player 2)))}))))) (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) {(if (> 4 (count Cell at:(handSite P1))) (result P2 Win)) (if (> 4 (count Cell at:(handSite P2))) (result P1 Win))})) (nextPhase (all Sites (sites Board) if:(= 0 (count at:(site)))) "BetweenRounds")) (phase "BetweenRounds" (play (if (<= 4 (count Cell at:(handSite Mover))) (move (from (handSite Mover)) (to (trackSite FirstSite from:(mapEntry "LeftMost" Mover) if:(is Empty (to)))) count:4 (then (and {(if (is Mover P1) (remember Value "OwnedP1" (last To)) (remember Value "OwnedP2" (last To))) (if (<= 4 (count Cell at:(handSite Mover))) (moveAgain) (if (= 3 (count Cell at:(handSite Mover))) (and {(fromTo (from (handSite Mover)) (to (trackSite FirstSite from:(mapEntry "LeftMost" Mover) if:(is Empty (to)))) count:3) (fromTo (from (handSite Next)) (to (trackSite FirstSite from:(mapEntry "LeftMost" Mover) if:(is Empty (to)))) count:1) (if (is Mover P1) (remember Value "OwnedP1" (trackSite FirstSite from:(mapEntry "LeftMost" Mover) if:(is Empty (to)))) (remember Value "OwnedP2" (trackSite FirstSite from:(mapEntry "LeftMost" Mover) if:(is Empty (to)))))}) (fromTo (from (handSite Mover)) (to (handSite Next)) count:(count Cell at:(handSite Mover)))))}))))) (nextPhase (and (is Empty (handSite P1)) (is Empty (handSite P2))) "Sowing"))})) 
2x5 board, the right-most hole is the store. Four counters in each hole. Sowing in an anti-clockwise direction, including the store. Play begins by each player placing the counters in their fourth hole into their store. Moves may begin from any of a player's holes except the store. If the last counter of a sowing drops into a hole making it contain two or three counters, these are taken and placed in the store. As soon as a player has at least thirteen counters in their store, they are picked up and sown, omitting each player's store and takes any counters in the opponent's holes which now contain two or three counters. Each player performs this move only once. The player who captures the most counters wins.
(game "I Pere" (players 2) (equipment {(mancalaBoard 2 5 store:None (track "Track" "0,E,N,W" loop:True)) (piece "Seed" Shared) (hand Each) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 4) (pair P2 5)}) (map "Fourth" {(pair P1 3) (pair P2 6)})}) (rules (start (set Count 4 to:(sites Track))) phases:{(phase "Opening" (play (move (from (mapEntry "Fourth" Mover)) (to (mapEntry Mover)) count:4)) (nextPhase Mover "Sowing")) (phase "Sowing" (play (if (and (<= 13 (count at:(mapEntry Mover))) (!= 1 (value Player Mover))) (or {(move Select (from (mapEntry Mover)) (then (and (sow skipIf:(or (= (to) (mapEntry P1)) (= (to) (mapEntry P2)))) (set Value Mover 1))))} (then (forEach Site (difference (sites Next) (mapEntry Next)) (if (or (= 2 (count at:(site))) (= 3 (count at:(site)))) (fromTo (from (site)) (to (mapEntry Mover)) count:(count at:(site))))))) (move Select (from (difference (sites Mover) (mapEntry Mover)) if:(is Occupied (from))) (then (sow apply:(if (or (= 2 (count at:(to))) (= 3 (count at:(to)))) (fromTo (from (to)) (to (mapEntry Mover)) count:(count at:(to))))))))))} (end (if (no Moves Next) (byScore {(score P1 (count at:(mapEntry P1))) (score P2 (count at:(mapEntry P2)))}))))) 
2x3-7 board. Four counters in each hole. Players sow counters from their side of the board in an anti-clockwise direction. When the final counter of a sowing lands in a hole containing one or two counters, making it now contain two or three, these are captured. Any adjacent holes with two or three counters are also captured. Single counters cannot be sown. When a player only has single counters in holes in their row, they pass. The player who captures the most counters wins. Each row has 3 holes.
(game "I" (players 2) (equipment {(mancalaBoard 2 3 store:None (track "Track" "0,E,N,W" loop:True)) (piece "Seed" Shared) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (hand Each)}) (rules (start (set Count 4 to:(sites Track))) (play (move Select (from (sites Mover) if:(> (count at:(from)) 1)) (then (sow apply:(if (or (= 2 (count at:(to))) (= 3 (count at:(to)))) (and {(fromTo (from (to)) (to (handSite Mover)) count:(count at:(to))) (if (!= (to) (ahead (to) E)) (if (or (= 2 (count at:(ahead (to) E))) (= 3 (count at:(ahead (to) E)))) (fromTo (from (ahead (to) E)) (to (handSite Mover)) count:(count at:(ahead (to) E))))) (if (!= (to) (ahead (to) W)) (if (or (= 2 (count at:(ahead (to) W))) (= 3 (count at:(ahead (to) W)))) (fromTo (from (ahead (to) W)) (to (handSite Mover)) count:(count at:(ahead (to) W)))))})))))) (end (if (and (no Moves P1) (no Moves P2)) (byScore {(score P1 (count Cell at:(handSite P1))) (score P2 (count Cell at:(handSite P2)))}))))) 
2x12 board. Starting position, from the left hand hole, for each player: 0-3-3-0-3-3-0-3-3-0-3-3 In the opening play, one player must sow two counters from the second hole from their right. The opponent then makes the same play from their row, or from the fourth hole from their right. When the final counter lands in an occupied hole, these are picked up and sowing continues. A player's turn ends when the final counter falls into an empty hole. Players may now begin their move from any hole in their row, but only if it ends in an empty hole in their row or if it enters the opponent's row. If the final counter lands in an occupied hole in the opponent's row, these are picked up and sowing continues. If the final counter lands in an occupied hole in the player's row, the contents of the hole in the opponent's hole opposite it are captured. Sowing ends when a capture is made or when a counter falls into an empty hole.
(game "Intotoi" (players 2) (equipment {(mancalaBoard 2 12 store:None (track "Track" "0,E,N,W" loop:True)) (piece "Seed" Shared) (hand Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start (set Count 3 to:(sites {1 2 4 5 7 8 10 11 22 21 19 18 16 15 13 12}))) phases:{(phase "Opening1" (play (move Select (from 10) (then (sow count:2)))) (nextPhase "Opening2")) (phase "Opening2" (play (if (is Prev Mover) (move Select (from (sites {(last To afterConsequence:True)}) if:(> (count at:(from)) 0)) (then (sow apply:(if (!= 1 (count at:(to))) (moveAgain))))) (move Select (from (sites {13 15}) if:(> (count at:(from)) 0)) (then (sow count:2 apply:(if (!= 1 (count at:(to))) (moveAgain))))))) (nextPhase (not (is Next Mover)) "Play")) (phase "Play" (play (move Select (from (sites From (do (move Select (from (sites Mover) if:(> (count at:(from)) 0)) (then (sow))) ifAfterwards:(or (and (= 1 (count at:(last To afterConsequence:True))) (is In (last To afterConsequence:True) (sites Mover))) (is In (last To afterConsequence:True) (sites Next))))) if:(> (count at:(from)) 0)) (then (sow apply:(if (= 1 (count at:(to))) (if (and (is Occupied (if (is Mover P1) (+ (to) 12) (- (to) 12))) (is In (to) (sites Mover))) (fromTo (from (if (is Mover P1) (+ (to) 12) (- (to) 12))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 12) (- (to) 12))))) (moveAgain)))))) (nextPhase Mover (is Next Mover) "Replay")) (phase "Replay" (play (move Select (from (sites {(last To afterConsequence:True)}) if:(> (count at:(from)) 0)) (then (sow apply:(if (= 1 (count at:(to))) (if (and (is Occupied (if (is Mover P1) (+ (to) 12) (- (to) 12))) (is In (to) (sites Mover))) (fromTo (from (if (is Mover P1) (+ (to) 12) (- (to) 12))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 12) (- (to) 12))))) (moveAgain)))))) (nextPhase Mover (not (is Next Mover)) "Play"))} (end (if (no Moves Mover) (byScore {(score P1 (+ (count Cell at:(handSite P1)) (count in:(sites P1)))) (score P2 (+ (count Cell at:(handSite P2)) (count in:(sites P2))))}))))) 
2x8 board. Four counters in each hole. Play begins with both players placing all of the counters in the rightmost three holes in their row into the rightmost hole. Counters are sown in an anti-clockwise fashion, but they can be sown clockwise only if it leads to a capture. Counters are captured when the final counter is sown into a hole opposite a hole containing one or three counters, and those are take. If the hole opposite the next hole also contains one or three, these are also taken, continuing until a hole with any other number of counters is reached. Instead of taking counters from one of their holes, a player may sow any or all of the counters they have captured, beginning from the leftmost hole. The same rules for sowing apply. The game ends when one player has no counters in their holes.
(game "Iyogh" (players 2) (equipment {(mancalaBoard 2 8 store:None {(track "TrackCCW" "0,E,N,W" loop:True) (track "TrackCW" "7,W,N,E" loop:True)}) (piece "Seed" Shared) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (hand Each) (map "LeftMost" {(pair P1 0) (pair P2 15)}) (map "RightMost" {(pair P1 7) (pair P2 8)}) (regions "RightMost" P1 (sites {5 6})) (regions "RightMost" P2 (sites {9 10}))}) (rules (start (set Count 4 to:(sites Track))) phases:{(phase "Opening" (play (move (from (sites Mover "RightMost") if:(is Occupied (from))) (to (mapEntry "RightMost" Mover)) count:(count at:(from)))) (nextPhase Mover (all Sites (sites Mover "RightMost") if:(is Empty (site))) "Sowing")) (phase "Sowing" (play (or {(if (is Occupied Cell (handSite Mover)) (forEach Value min:1 max:(count Cell at:(handSite Mover)) (do (set Var "NumToSow" (value)) next:(move (from Cell (handSite Mover)) (to (mapEntry "LeftMost" Mover)) count:(value) (then (and (sow count:(var "NumToSow") "TrackCCW" if:(or (= 1 (count at:(if (is In (to) (sites Bottom)) (+ (to) 8) (- (to) 8)))) (= 3 (count at:(if (is In (to) (sites Bottom)) (+ (to) 8) (- (to) 8))))) apply:(if (or (= 1 (count at:(if (is In (to) (sites Bottom)) (+ (to) 8) (- (to) 8)))) (= 3 (count at:(if (is In (to) (sites Bottom)) (+ (to) 8) (- (to) 8))))) (fromTo (from (if (is In (to) (sites Bottom)) (+ (to) 8) (- (to) 8))) (to (handSite Mover)) count:(count at:(if (is In (to) (sites Bottom)) (+ (to) 8) (- (to) 8))))) forward:True) (set Var "NumToSow" 0))))))) (if (is Occupied Cell (handSite Mover)) (forEach Value min:1 max:(count Cell at:(handSite Mover)) (do (set Var "NumToSow" (value)) next:(move (from Cell (handSite Mover) if:(or (= 1 (count at:(if (is In (trackSite Move from:(mapEntry "LeftMost" Mover) "TrackCW" steps:(value)) (sites Bottom)) (+ (trackSite Move from:(mapEntry "LeftMost" Mover) "TrackCW" steps:(value)) 8) (- (trackSite Move from:(mapEntry "LeftMost" Mover) "TrackCW" steps:(value)) 8)))) (= 3 (count at:(if (is In (trackSite Move from:(mapEntry "LeftMost" Mover) "TrackCW" steps:(value)) (sites Bottom)) (+ (trackSite Move from:(mapEntry "LeftMost" Mover) "TrackCW" steps:(value)) 8) (- (trackSite Move from:(mapEntry "LeftMost" Mover) "TrackCW" steps:(value)) 8)))))) (to (mapEntry "LeftMost" Mover)) count:(value) (then (and (sow count:(var "NumToSow") "TrackCW" if:(or (= 1 (count at:(if (is In (to) (sites Bottom)) (+ (to) 8) (- (to) 8)))) (= 3 (count at:(if (is In (to) (sites Bottom)) (+ (to) 8) (- (to) 8))))) apply:(if (or (= 1 (count at:(if (is In (to) (sites Bottom)) (+ (to) 8) (- (to) 8)))) (= 3 (count at:(if (is In (to) (sites Bottom)) (+ (to) 8) (- (to) 8))))) (fromTo (from (if (is In (to) (sites Bottom)) (+ (to) 8) (- (to) 8))) (to (handSite Mover)) count:(count at:(if (is In (to) (sites Bottom)) (+ (to) 8) (- (to) 8))))) forward:True) (set Var "NumToSow" 0))))))) (move Select (from (sites Mover) if:(< 0 (count at:(from)))) (then (sow "TrackCCW" if:(or (= 1 (count at:(if (is In (to) (sites Bottom)) (+ (to) 8) (- (to) 8)))) (= 3 (count at:(if (is In (to) (sites Bottom)) (+ (to) 8) (- (to) 8))))) apply:(if (or (= 1 (count at:(if (is In (to) (sites Bottom)) (+ (to) 8) (- (to) 8)))) (= 3 (count at:(if (is In (to) (sites Bottom)) (+ (to) 8) (- (to) 8))))) (fromTo (from (if (is In (to) (sites Bottom)) (+ (to) 8) (- (to) 8))) (to (handSite Mover)) count:(count at:(if (is In (to) (sites Bottom)) (+ (to) 8) (- (to) 8))))) forward:True))) (move Select (from (sites Mover) if:(and (< 0 (count at:(from))) (or (= 1 (count at:(if (is In (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) (sites Bottom)) (+ (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) 8) (- (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) 8)))) (= 3 (count at:(if (is In (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) (sites Bottom)) (+ (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) 8) (- (trackSite Move from:(from) "TrackCW" steps:(count at:(from))) 8))))))) (then (sow "TrackCW" if:(or (= 1 (count at:(if (is In (to) (sites Bottom)) (+ (to) 8) (- (to) 8)))) (= 3 (count at:(if (is In (to) (sites Bottom)) (+ (to) 8) (- (to) 8))))) apply:(if (or (= 1 (count at:(if (is In (to) (sites Bottom)) (+ (to) 8) (- (to) 8)))) (= 3 (count at:(if (is In (to) (sites Bottom)) (+ (to) 8) (- (to) 8))))) (fromTo (from (if (is In (to) (sites Bottom)) (+ (to) 8) (- (to) 8))) (to (handSite Mover)) count:(count at:(if (is In (to) (sites Bottom)) (+ (to) 8) (- (to) 8))))) forward:True)))})))} (end (forEach Player if:(all Sites (sites Player) if:(= 0 (count at:(site)))) (result Player Loss))))) 
2x6 board. Four counters in each hole. Sowing proceeds in an anti-clockwise direction. When the final counter of a sowing lands in an occupied hole, the counters are picked up and sowing continues. When the final counter lands in an occupied hole in the player's own row causing it to contain four counters, these are captured and the turn ends. If the final counter falls into an empty hole, the turn ends. If at any point in the sowing a hole in the player's own row is made to contain four counters, they are taken. When there are only eight counters left on the board, the first player to make four counters in a hole captures all the remaining counters. At the end of the game, players place their captured counters four by four into the remaining holes. Players may thus capture holes from the opponent's row, one for every four counters placed in a hole. They may capture from these holes in the next round. Play continues until one player owns no holes.
(game "J'erin" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "0,E,N,W" loop:True)) (piece "Seed" Shared) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (hand Each)}) (rules (start {(set Count 4 to:(sites Track)) (set RememberValue "OwnedP1" (sites Bottom)) (set RememberValue "OwnedP2" (sites Top))}) phases:{(phase "Sowing" (play (or {(move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (if (is Mover P1) (sites (values Remembered "OwnedP1")) (sites (values Remembered "OwnedP2")))) if:(< 0 (count at:(from)))) (then (do (set Var "NumSowed" (count at:(last To))) next:(if (and (>= 8 (count Pieces All in:(sites Board))) (not (all Sites (sites Track from:(trackSite Move from:(last From) "Track" steps:1) to:(trackSite Move from:(last From) "Track" steps:(var "NumSowed"))) if:(!= 3 (count at:(site)))))) (forEach Site (sites Board) (if (is Occupied (site)) (fromTo (from (site)) (to Cell (handSite Mover)) count:(count at:(site))))) (sow apply:(if (if (= 4 (count at:(to))) (not (is In (to) (if (is Mover P1) (sites (values Remembered "OwnedP1")) (sites (values Remembered "OwnedP2"))))) (!= 0 (count at:(to)))) (moveAgain))) (then (and (forEach Site (intersection (if (is Mover P1) (sites (values Remembered "OwnedP1")) (sites (values Remembered "OwnedP2"))) (sites Track from:(last From) to:(trackSite Move from:(last From) "Track" steps:(var "NumSowed")))) (if (= 4 (count at:(site))) (fromTo (from (site)) (to (handSite Mover)) count:4))) (set Var "NumSowed" 0)))))))} (then (if (all Sites (sites Board) if:(= 0 (count at:(site)))) (and (forget Value "OwnedP1" All) (forget Value "OwnedP2" All)))))) (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) {(if (> 4 (count Cell at:(handSite P1))) (result P2 Win)) (if (> 4 (count Cell at:(handSite P2))) (result P1 Win))})) (nextPhase (all Sites (sites Board) if:(= 0 (count at:(site)))) "BetweenRounds")) (phase "BetweenRounds" (play (if (<= 4 (count Cell at:(handSite Mover))) (if (not (all Sites (sites Mover) if:(is Occupied (site)))) (move (from (handSite Mover)) (to (sites Mover) if:(is Empty (to))) count:4 (then (if (is Mover P1) (remember Value "OwnedP1" (last To)) (remember Value "OwnedP2" (last To))))) (move (from (handSite Mover)) (to (sites Board) if:(is Empty (to))) count:4 (then (if (is Mover P1) (remember Value "OwnedP1" (last To)) (remember Value "OwnedP2" (last To)))))))) (nextPhase (and (> 4 (count Cell at:(handSite P1))) (> 4 (count Cell at:(handSite P2)))) "Sowing"))})) 
2x6 board, which two stores. Four counters in each hole. Sowing proceeds in an anti-clockwise direction. When the final counter of a sowing falls in to an occupied hole, these counters are picked up and sowing continues. When the final hole lands in an empty hole, if the hole is in the player's row, the contents of the opponent's opposite hole are captured. If the empty hole is in the opponent's row, the turn ends. A player must play so that the opponent is able to play on their next turn, if possible. The player who captures the most counters wins. 
(game "J'odu" (players 2) (equipment {(mancalaBoard 2 6 (track "Track" "1,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 FirstSite) (pair P2 LastSite)}) (piece "Seed" Shared)}) (rules (start (set Count 4 to:(sites Track))) (play (do (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover)) if:(< 0 (count at:(from)))) (then (sow apply:(if (> (count at:(to)) 1) (moveAgain) (if (is In (to) (sites Mover)) (fromTo (from (if (is Mover P1) (+ (to) 6) (- (to) 6))) (to (mapEntry (mover))) count:(count at:(if (is Mover P1) (+ (to) 6) (- (to) 6))))))))) ifAfterwards:(< 0 (count in:(if (is Mover P1) (sites P2) (sites P1)))))) (end (if (no Moves Mover) (byScore {(score P1 (+ (count at:(mapEntry P1)) (count in:(sites P1)))) (score P2 (+ (count at:(mapEntry P2)) (count in:(sites P2))))}))))) 
2x6 board. Four counters in each hole. In the opening phase, the player takes all of the counters in their rightmost hole and places them in the opponent's opposite hole. The player then takes the contents of the next hole, placing all of them into the hole following it, until the entire board has alternating holes with eight and zero counters. When the final hole is made with eight counters, these are picked up and the player sows as normal in an anti-clockwise direction. When the final counter falls into an occupied hole, the counters are picked up and sowing continues. When the final counter falls into an empty hole, the player captures the counters in the opposite hole. If a player cannot play, they must pass their turn until there are counters available for them to play. Play continues until there is one piece or fewer on the board, the player to whom the row in which the single piece is located captures it. A second round is played, each player placing four counters into each hole starting from the rightmost hole in their row. The player with more counters gains a hole from their opponent for every four extra balls they've captured. If an opponent has three extra after counting in such a way, they also gain a hole, and if each player has two remaining counters ownership is determined by chance. Play continues in several rounds like this until one player takes all the counters. 
(game "Jimafesosh" (players 2) (equipment {(mancalaBoard 2 6 store:None {(track "TrackCCW" "0,E,N,W" loop:True) (track "TrackCW" "5,W,N,E" loop:True)}) (piece "Seed" Shared) (hand Each) (map "RightMost" {(pair P1 5) (pair P2 6)}) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(set RememberValue "OwnedP1" (sites Bottom)) (set RememberValue "OwnedP2" (sites Top)) (set Count 4 to:(sites Track "TrackCCW"))}) phases:{(phase "Opening1" (play (move Select (from (if (is Prev Mover) (var "Replay") 5)) (then (sow numPerHole:4 "TrackCCW" apply:(and (moveAgain) (if (is Occupied (trackSite Move from:(to) "Track" steps:1)) (set Var "Replay" (trackSite Move from:(to) "Track" steps:1)) (set Var "Replay" -1))))))) (nextPhase (= -1 (var "Replay")) "Opening2")) (phase "Opening2" (play (move Select (from (if (and (is Prev Mover) (!= -1 (var "Replay"))) (var "Replay") 4)) (then (sow "TrackCCW" apply:(if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to))) (if (is Occupied (if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6))) (fromTo (from (if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6))) (to (handSite Mover)) count:(count at:(if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6)))))))))) (nextPhase (not (is Next Prev)) "Sowing")) (phase "Sowing" (play (or {(move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (if (is Mover P1) (sites (values Remembered "OwnedP1")) (sites (values Remembered "OwnedP2")))) if:(is Occupied (from))) (then (sow "TrackCCW" apply:(if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to))) (if (is Occupied (if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6))) (fromTo (from (if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6))) (to (handSite Mover)) count:(count at:(if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6)))))))))} (then (if (>= 1 (count Pieces All in:(sites Board))) (and {(forEach Site (sites P1) (fromTo (from (site)) (to (handSite P1)) count:(count at:(site)))) (forEach Site (sites P2) (fromTo (from (site)) (to (handSite P2)) count:(count at:(site)))) (forget Value "OwnedP1" All) (forget Value "OwnedP2" All)}))))) (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) {(if (= 0 (count Cell at:(handSite P1))) (result P2 Win)) (if (= 0 (count Cell at:(handSite P2))) (result P1 Win))})) (nextPhase (all Sites (sites Board) if:(= 0 (count at:(site)))) "BetweenRounds")) (phase "BetweenRounds" (play (if (<= 4 (count Cell at:(handSite Mover))) (move (from (handSite Mover)) (to (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))) count:4 (then (and {(if (is Mover P1) (remember Value "OwnedP1" (last To)) (remember Value "OwnedP2" (last To))) (if (= 3 (count Cell at:(handSite Mover))) (and {(fromTo (from (handSite Mover)) (to (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))) count:3) (fromTo (from (handSite Next)) (to (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))) count:1) (if (is Mover P1) (remember Value "OwnedP1" (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))) (remember Value "OwnedP2" (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))))}) (if (= 2 (count Cell at:(handSite Mover))) (and {(fromTo (from (handSite Mover)) (to (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))) count:2) (fromTo (from (handSite Next)) (to (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))) count:2) (if (< 50 (value Random (range 1 100))) (remember Value "OwnedP1" (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))) (remember Value "OwnedP2" (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))))})))}))))) (nextPhase (and (is Empty (handSite P1)) (is Empty (handSite P2))) "Sowing"))})) 
The board has two rows of six holes with a larger hole on either end. Play begins with four seeds in each hole. Each player controls the row nearest them. Seeds are sown consecutively in a counterclockwise pattern including the player's own larger hole but not the opponent's. If the last seed is placed in an opponent's empty hole, that seed and any opposite are captured and put in the player's larger hole. If the last seed falls in the larger hole, the player gets another turn. When one player has no seeds in any of their holes, the game ends. The other player captures all of the other seeds, and the player with the most captured seeds wins.
(game "Kalah" (players 2) (equipment {(mancalaBoard 2 6 (track "Track" "0,ESE,E,ENE,WNW,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 LastSite) (pair P2 FirstSite)}) (piece "Seed" Shared)}) (rules (start (set Count 4 to:(union (sites P1) (sites P2)))) (play (move Select (from (sites Mover) if:(> (count at:(from)) 0)) (then (sow apply:(if (= (to) (mapEntry (mover))) (moveAgain) (if (and {(is In (to) (sites Mover)) (= (count at:(to)) 1) (> (count at:(if (is Mover P1) (+ (to) 6) (- (to) 6))) 0)}) (and (fromTo (from (to)) (to (mapEntry (mover))) count:(count at:(to))) (fromTo (from (if (is Mover P1) (+ (to) 6) (- (to) 6))) (to (mapEntry (mover))) count:(count at:(if (is Mover P1) (+ (to) 6) (- (to) 6))))))) skipIf:(= (to) (mapEntry (next))))))) (end (if (no Moves Mover) (byScore {(score P1 (+ (count at:(mapEntry P1)) (count in:(sites P1)))) (score P2 (+ (count at:(mapEntry P2)) (count in:(sites P2))))}))))) 
Two rows of seven holes. Twelve counters in each hole, except in the central hole of each row, one of which has one counter and the other is empty. Players do not own a row of holes, rather each player owns the six holes on one side of the central holes. Sowing occurs in an anti-clockwise direction. Neither player may begin sowing from the central holes. When sowing ends, if the next hole after the hole in which the final counter was placed is occupied, these counters are picked up and sown. If this hole is empty, the counters in the hole opposite it are captured. Play continues until all of the counters have been captured. The player who captures the most pieces wins.
(game "Kanji Guti" (players 2) (equipment {(mancalaBoard 2 7 store:None (track "Track" "0,E,N,W" loop:True)) (piece "Seed" Shared) (hand Each) (regions "Home" P1 (expand (sites Left) steps:2)) (regions "Home" P2 (expand (sites Right) steps:2))}) (rules (start {(set Count 1 at:(coord "D1")) (set Count 12 to:(difference (sites Track) (sites Centre)))}) (play (move Select (from (if (is Prev Mover) (sites {(trackSite Move from:(last To afterConsequence:True) steps:1)}) (sites Mover)) if:(< 0 (count at:(from)))) (then (sow apply:(if (> (count at:(trackSite Move from:(to) steps:1)) 0) (moveAgain) (if (> (count at:(if (is In (trackSite Move from:(to) steps:1) (sites Bottom)) (+ (trackSite Move from:(to) steps:1) 7) (- (trackSite Move from:(to) steps:1) 7))) 0) (fromTo (from (if (is In (trackSite Move from:(to) steps:1) (sites Bottom)) (+ (trackSite Move from:(to) steps:1) 7) (- (trackSite Move from:(to) steps:1) 7))) (to (handSite Mover)) count:(count at:(if (is In (trackSite Move from:(to) steps:1) (sites Bottom)) (+ (trackSite Move from:(to) steps:1) 7) (- (trackSite Move from:(to) steps:1) 7)))))))))) (end (if (= 0 (count in:(sites Track))) (byScore {(score P1 (count Cell at:(handSite P1))) (score P2 (count Cell at:(handSite P2)))}))))) 
2x3 board. Eight counters in each pile. A player takes the counters from any of the piles and sows them anti-clockwise, beginning with the pile from which the counters were taken. Any piles that now contain 2, 4, or 6 counters are captured. The player who captures the most counters wins. 
(game "Kapana Bona" (players 2) (equipment {(mancalaBoard 2 3 store:None (track "Track" "0,E,N,W" loop:True)) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 8 to:(sites Track))) (play (move Select (from (sites Board) if:(> (count at:(from)) 0)) (then (sow origin:True (then (forEach Site (sites Board) (if (or {(= (count at:(site)) 2) (= (count at:(site)) 4) (= (count at:(site)) 6)}) (fromTo (from (site)) (to (handSite Mover)) count:(count at:(site)))))))))) (end (if (= 0 (count Sites in:(forEach (sites Board) if:(< 1 (count at:(site)))))) (byScore {(score P1 (count Cell at:(handSite P1))) (score P2 (count Cell at:(handSite P2)))}))))) 
Play begins with seven counters in each hole. Players begin by picking up the counters in one of their holes and sowing them anti-clockwise. If the final counter lands in an opponent's hole or the rightmost hole belonging to the player sowing, having dropped counters in the opponent's holes making them contain two, four, or six counters, the contents of those holes are captured. The player who has the most counters at the end of the game wins.
(game "Kara" (players 2) (equipment {(mancalaBoard 2 3 (track "Track" "1,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 FirstSite) (pair P2 LastSite)}) (map "RightHole" {(pair P1 3) (pair P2 4)}) (piece "Seed" Shared)}) (rules (start (set Count 7 to:(sites Track))) (play (move Select (from (sites Mover) if:(> (count at:(from)) 0)) (then (sow if:(and (is In (count at:(to)) (sites {2 4 6})) (is In (to) (union (sites Next) (sites {(mapEntry "RightHole" (mover))})))) apply:(fromTo (from (to)) (to (mapEntry (mover))) count:(count at:(to))))))) (end (if (no Moves Mover) (byScore {(score P1 (+ (count at:(mapEntry P1)) (count in:(sites P1)))) (score P2 (+ (count at:(mapEntry P2)) (count in:(sites P2))))}))))) 
2x6 board, one store on either end. Four counters in each hole. Sowing occurs in an anti-clockwise direction and begins in the player's row. When the final counter lands in an occupied hole which is not followed by an empty hole, the contents are picked up and sowing continues. If the final counter falls in an occupied hole followed by an empty hole, or if it falls into an empty hole, the turn ends. Sowing always skips the hole from which the sowing began if it goes all the way around the board. When the final counter falls into an occupied hole in the opponent's row containing three counters, these are captured and the turn ends. Any holes in the opponent's row containing four counters in an unbroken consecutive sequence behind this hole are also captured. Single counters can only be sowed when the next hole is empty. Play continues until one player can no longer play. The player who has captured the most counters wins.
(game "Kay" (players 2) (equipment {(mancalaBoard 2 6 (track "Track" "1,E,N,W" loop:True)) (piece "Seed" Shared) (regions "Home" P1 (sites Bottom)) (regions "Home" P2 (sites Top)) (map {(pair P1 FirstSite) (pair P2 LastSite)})}) (rules (start (set Count 4 to:(sites Track))) (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover)) if:(or (< 1 (count at:(from))) (and (= 1 (count at:(from))) (is Empty (trackSite Move from:(from) "Track" steps:1))))) (then (sow if:True apply:(if (= 4 (count at:(to))) (fromTo (from (to)) (to (mapEntry Mover)) count:(count at:(to))) (if (< 1 (count at:(to))) (if (is Occupied (trackSite Move from:(to) "Track" steps:1)) (moveAgain)))) includeSelf:False backtracking:(= 4 (count at:(to))))))) (end (if (no Moves Next) (byScore {(score P1 (count at:(mapEntry P1))) (score P2 (count at:(mapEntry P2)))}))))) 
2x2, 3, 4, or 6 board. Each hole contains a number of counters equal to the total number of holes in the board. Sowing begins from any hole in the player's row, and proceeds anti-clockwise. Counters are captured when the final counter lands in an occupied hole, making it contain 2, 4, 6, or 8 counters. When all of the counters have been captured, a second game begins. Each player fills their holes with the same number of counters as the beginning of the previous game. The player who has extra counters holds these in reserve. The other player will have either empty holes or one without the requisite number to fill the hole. Sowing cannot begin and captures cannot be made from these holes until the contents of these holes reaches the required number of counters to fill them. The second player in the first game now becomes the first player. Play continues with subsequent games until one player captures all the counters. Evidence Map Each player has 2 holes.
(game "Khrour" (players 2) (equipment {(mancalaBoard 2 2 store:None (track "Track" "0,E,N,W" loop:True)) (piece "Seed" Shared) (hand Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(set Count 4 to:(sites Track)) (set RememberValue "Playable" (union (sites Top) (sites Bottom)))}) phases:{(phase "Sowing" (play (or {(move Select (from (sites Mover) if:(and (is Occupied (from)) (is In (from) (sites (values Remembered "Playable"))))) (then (sow apply:(if (and (or {(= 2 (count at:(to))) (= 4 (count at:(to))) (= 6 (count at:(to))) (= 8 (count at:(to)))}) (is In (to) (sites (values Remembered "Playable")))) (fromTo (from (to)) (to (handSite Mover)) count:(count at:(to)))))))} (then (if (all Sites (union (sites Top) (sites Bottom)) if:(= 0 (count at:(site)))) (forget Value "Playable" All) (forEach Site (difference (sites Board) (sites (values Remembered "Playable"))) (if (<= 4 (count at:(site))) (remember Value "Playable" (site)))))))) (end (if (all Sites (union (sites Top) (sites Bottom)) if:(= 0 (count at:(site)))) {(if (= 0 (count Cell at:(handSite P1))) (result P2 Win)) (if (= 0 (count Cell at:(handSite P2))) (result P1 Win))})) (nextPhase (all Sites (union (sites Top) (sites Bottom)) if:(= 0 (count at:(site)))) "BetweenRounds")) (phase "BetweenRounds" (play (if (not (all Sites (sites Mover) if:(is Occupied (site)))) (if (<= 4 (count Cell at:(handSite Mover))) (move (from (handSite Mover)) (to (sites Mover) if:(is Empty (to))) count:4 (then (remember Value "Playable" (last To)))) (move (from (handSite Mover)) (to (sites Mover) if:(is Empty (to))) count:(count Cell at:(handSite Mover)))))) (nextPhase (all Passed) "Sowing"))})) 
2x5 board. Five counters in each hole. Players take turns sowing in an anti-clockwise direction. When the final counter lands in a hole, the player picks up the contents of the next hole following this one, and continues sowing. If the player cannot pick up any counters from this hole, the players captures any counters from the hole after the empty hole, and the turn ends. Whenever any holes in the player's row contain four counters, they are captured by the player. Play continues until all of the counters have been captured. A new round begins. The players count their captured counters. If the difference between the two players' captured counters is greater than five, for each multiple of five in the difference a hole on the player with fewer counters' side is eliminated from play, and the excess counters that equal a multiple of five are placed aside for use in further rounds if necessary. When the difference is less than five, and when dealing with the remaining pieces after the multiples of five are dealt with, The following scenarios apply. When one player has one counter and the other has four, the player with one will give their stone to the one with four, but the player who has one counter will receive one counter from the hole from which sowing begins at the beginning of each player's turn. When one player has two counters and the other has three, the player with two gives these counters to the other player. With these five, the player creates a "bha" from one of holes in their row. The bha must be either the leftmost or rightmost hole. Every counter dropped into this hole during the course of play is captured by the owner of the hole. At the end of the round, the player who created the bha must return the number of counters given to them at the beginning of the round back to the other player. The holes which remain in play are then filled with five counters each from each player's captured counters and play continues as before. until one player captures all of the counters. 
(game "Khutka Boia" (players 2) (equipment {(mancalaBoard 2 5 store:None (track "Track" "0,E,N,W" loop:True)) (piece "Seed" Shared) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (hand Each)}) (rules (start {(set Count 5 to:(sites Track)) (set RememberValue "Playable" (union (sites Top) (sites Bottom)))}) phases:{(phase "Sowing" (play (or {(or {(move Select (from (if (is Prev Mover) (sites {(trackSite Move from:(last To afterConsequence:True) "Track" steps:1)}) (sites Mover)) if:(and (is Occupied (from)) (is In (from) (sites (values Remembered "Playable"))))) (then (do (if (= 1 (value Player Next)) (fromTo (from (last From)) (to (handSite Mover)) count:1)) next:(sow (last From) apply:(if (is Occupied (trackSite Move from:(to) "Track" steps:1)) (moveAgain) (if (is Occupied (trackSite Move from:(to) "Track" steps:2)) (fromTo (from (trackSite Move from:(to) "Track" steps:2)) (to (handSite Mover)) count:(count at:(trackSite Move from:(to) "Track" steps:2))))) skipIf:(not (is In (to) (sites (values Remembered "Playable"))))))))} (then (and {(forEach Player (forEach Site (sites Player) (if (= 4 (count at:(site))) (fromTo (from (site)) (to (handSite Player)) count:4)))) (forEach Site (sites P1) (if (and (is Occupied (site)) (= 1 (state at:(site)))) (and (fromTo (from (site)) (to (handSite Player)) count:(count at:(site))) (set State at:(site) 1)))) (forEach Site (sites P2) (if (and (is Occupied (site)) (= 2 (state at:(site)))) (and (fromTo (from (site)) (to (handSite Player)) count:(count at:(site))) (set State at:(site) 2))))})))} (then (if (= 1 (count Pieces All in:(union (sites Top) (sites Bottom)))) (and {(forEach Site (sites P1) (fromTo (from (site)) (to (handSite P1)) count:(count at:(site)))) (forEach Site (sites P2) (fromTo (from (site)) (to (handSite P2)) count:(count at:(site)))) (forEach Site (sites Board) (if (!= 0 (state at:(site))) (set State at:(site) 0))) (set Value P1 0) (set Value P2 0) (forget Value "Playable" All)}))))) (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) {(if (= 0 (count Cell at:(handSite P1))) (result P2 Win)) (if (= 0 (count Cell at:(handSite P2))) (result P1 Win))})) (nextPhase (all Sites (sites Board) if:(= 0 (count at:(site)))) "BetweenRounds")) (phase "BetweenRounds" (play (if (not (all Sites (sites Mover) if:(is Occupied (site)))) (if (<= 5 (count Cell at:(handSite Mover))) (move (from (handSite Mover)) (to (sites Mover) if:(is Empty (to))) count:5 (then (remember Value "Playable" (last To))))))) (nextPhase (all Passed) "DecisionForNextRound")) (phase "DecisionForNextRound" (play (if (> 5 (abs (- (count Cell at:(handSite P1)) (count Cell at:(handSite P2))))) (do (if (= 1 (count Cell at:(handSite P1))) (and (set Value P1 1) (fromTo (from (handSite P1)) (to (handSite P2)) count:1)) (if (= 1 (count Cell at:(handSite P2))) (and (set Value P2 1) (fromTo (from (handSite P2)) (to (handSite P1)) count:1)) (if (= 2 (count Cell at:(handSite P2))) (set Var "Bha" 1) (if (= 2 (count Cell at:(handSite P1))) (set Var "Bha" 2))))) next:(if (= (var "Bha") P1) (move Select (from (intersection (union (sites Left) (sites Right)) (sites P1))) (then (and (set State at:(last To) 1) (set Var "Bha" 0)))) (if (= (var "Bha") P2) (move Select (from (intersection (union (sites Left) (sites Right)) (sites P2))) (then (and (set State at:(last To) 2) (set Var "Bha" 0)))) (move Pass)))) (move Pass))) (nextPhase "Sowing"))})) 
2x5-10 holes (six is the most common), two stores on either end six counters in each hole. Play begins from any hole in a player's row, and counters can be sown in either direction. If sowing fails to reach a hole in the opponent's row, the player makes a second move from a loaded hole in the opposite direction, continuing to do so until they can sow in the opponent's row. If the last counter is sown in a loaded hole, the contents are lifted and sowing continues in the opposite direction. Play continues like this until the last counter lands in an empty hole. If the empty hole is in the opponent's row, play ends. If it lands in an empty hole in the player's row, the counters in the opponent's hole opposite it are placed in the store. If the next hole in the direction of sowing in the player's row is empty, the counters in the opponent's hole opposite that hole are also placed in the store. Single counters cannot be sown. Play continues until both players have only single counters in holes or all of the counters have been captured. These are then collected and placed in the store. If each player has the same number of counters, the game is a draw. If the number of counters is unequal, the player with fewer counters arranges them in their row however they wish. The opponent then matches this arrangement, placing any extras in the store. If the player has fewer than half of the original number of counters, the board is decreased in size by one hole. If less than a quarter, it is decreased by two holes, and if less than one eight, decreased by three holes. If in subsequent rounds a player regains more than one half/one quarter/one eighth of the original total, the board size is increased appropriately. Play continues until one player has all the counters. Each player has 6 holes.
(game "Kiuthi" (players 2) (equipment {(mancalaBoard 2 6 {(track "TrackCCW" "1,E,N,W" loop:True) (track "TrackCW" "6,W,N,E" loop:True)}) (piece "Seed" Shared) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 FirstSite) (pair P2 LastSite)})}) (rules (start {(set Count 6 to:(sites Track)) (set RememberValue "Playable" (union (sites Top) (sites Bottom)))}) phases:{(phase "Sowing" (play (or (if (!= 2 (var "Direction")) (move Select (from (if (is Prev Mover) (if (= 1 (var "ReachOpponent")) (sites {(var "Replay")}) (sites Mover)) (sites Mover)) if:(and (< 1 (count at:(from))) (is In (from) (sites (values Remembered "Playable"))))) (then (if (!= 1 (var "OppositeDirection")) (sow "TrackCCW" apply:(if (!= 1 (var "ReachOpponent")) (if (is In (to) (sites Next)) (if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "ReachOpponent" 1) (if (= 1 (var "OppositeDirection")) (set Var "OppositeDirection" 0) (set Var "OppositeDirection" 1)) (set Var "Direction" 1)}) (and (set Var "ReachOpponent" 0) (set Var "Direction" 0))) (moveAgain)) (if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (if (= 1 (var "OppositeDirection")) (set Var "OppositeDirection" 0) (set Var "OppositeDirection" 1)) (set Var "Direction" 1)}) (and {(set Var "ReachOpponent" 0) (set Var "OppositeDirection" 0) (set Var "Direction" 0) (if (is In (to) (sites Mover)) (if (is Occupied (if (is Mover P1) (+ (to) 6) (- (to) 6))) (and (fromTo (from (if (is Mover P1) (+ (to) 6) (- (to) 6))) (to (mapEntry Mover)) count:(count at:(if (is Mover P1) (+ (to) 6) (- (to) 6)))) (if (and (is Empty (trackSite Move from:(to) "TrackCCW" steps:1)) (is In (trackSite Move from:(to) "TrackCCW" steps:1) (sites Mover))) (if (is Occupied (if (is Mover P1) (+ (trackSite Move from:(to) "TrackCCW" steps:1) 6) (- (trackSite Move from:(to) "TrackCCW" steps:1) 6))) (fromTo (from (if (is Mover P1) (+ (trackSite Move from:(to) "TrackCCW" steps:1) 6) (- (trackSite Move from:(to) "TrackCCW" steps:1) 6))) (to (mapEntry Mover)) count:(count at:(if (is Mover P1) (+ (trackSite Move from:(to) "TrackCCW" steps:1) 6) (- (trackSite Move from:(to) "TrackCCW" steps:1) 6)))))))))}))) skipIf:(not (is In (to) (sites (values Remembered "Playable"))))) (sow "TrackCW" apply:(if (!= 1 (var "ReachOpponent")) (if (is In (to) (sites Next)) (if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "ReachOpponent" 1) (if (= 1 (var "OppositeDirection")) (set Var "OppositeDirection" 0) (set Var "OppositeDirection" 1)) (set Var "Direction" 1)}) (and (set Var "ReachOpponent" 0) (set Var "Direction" 0))) (moveAgain)) (if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (if (= 1 (var "OppositeDirection")) (set Var "OppositeDirection" 0) (set Var "OppositeDirection" 1)) (set Var "Direction" 1)}) (and {(set Var "ReachOpponent" 0) (set Var "OppositeDirection" 0) (set Var "Direction" 0) (if (is In (to) (sites Mover)) (if (is Occupied (if (is Mover P1) (+ (to) 6) (- (to) 6))) (and (fromTo (from (if (is Mover P1) (+ (to) 6) (- (to) 6))) (to (mapEntry Mover)) count:(count at:(if (is Mover P1) (+ (to) 6) (- (to) 6)))) (if (and (is Empty (trackSite Move from:(to) "TrackCW" steps:1)) (is In (trackSite Move from:(to) "TrackCW" steps:1) (sites Mover))) (if (is Occupied (if (is Mover P1) (+ (trackSite Move from:(to) "TrackCW" steps:1) 6) (- (trackSite Move from:(to) "TrackCW" steps:1) 6))) (fromTo (from (if (is Mover P1) (+ (trackSite Move from:(to) "TrackCW" steps:1) 6) (- (trackSite Move from:(to) "TrackCW" steps:1) 6))) (to (mapEntry Mover)) count:(count at:(if (is Mover P1) (+ (trackSite Move from:(to) "TrackCW" steps:1) 6) (- (trackSite Move from:(to) "TrackCW" steps:1) 6)))))))))}))) skipIf:(not (is In (to) (sites (values Remembered "Playable"))))))))) (if (!= 1 (var "Direction")) (move Select (from (if (is Prev Mover) (if (= 1 (var "ReachOpponent")) (sites {(var "Replay")}) (sites Mover)) (sites Mover)) if:(and (< 1 (count at:(from))) (is In (from) (sites (values Remembered "Playable"))))) (then (if (!= 1 (var "OppositeDirection")) (sow "TrackCW" apply:(if (!= 1 (var "ReachOpponent")) (if (is In (to) (sites Next)) (if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "ReachOpponent" 1) (if (= 1 (var "OppositeDirection")) (set Var "OppositeDirection" 0) (set Var "OppositeDirection" 1)) (set Var "Direction" 2)}) (and (set Var "ReachOpponent" 0) (set Var "Direction" 0))) (moveAgain)) (if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (if (= 1 (var "OppositeDirection")) (set Var "OppositeDirection" 0) (set Var "OppositeDirection" 1)) (set Var "Direction" 2)}) (and {(set Var "ReachOpponent" 0) (set Var "OppositeDirection" 0) (set Var "Direction" 0) (if (is In (to) (sites Mover)) (if (is Occupied (if (is Mover P1) (+ (to) 6) (- (to) 6))) (and (fromTo (from (if (is Mover P1) (+ (to) 6) (- (to) 6))) (to (mapEntry Mover)) count:(count at:(if (is Mover P1) (+ (to) 6) (- (to) 6)))) (if (and (is Empty (trackSite Move from:(to) "TrackCW" steps:1)) (is In (trackSite Move from:(to) "TrackCW" steps:1) (sites Mover))) (if (is Occupied (if (is Mover P1) (+ (trackSite Move from:(to) "TrackCW" steps:1) 6) (- (trackSite Move from:(to) "TrackCW" steps:1) 6))) (fromTo (from (if (is Mover P1) (+ (trackSite Move from:(to) "TrackCW" steps:1) 6) (- (trackSite Move from:(to) "TrackCW" steps:1) 6))) (to (mapEntry Mover)) count:(count at:(if (is Mover P1) (+ (trackSite Move from:(to) "TrackCW" steps:1) 6) (- (trackSite Move from:(to) "TrackCW" steps:1) 6)))))))))}))) skipIf:(not (is In (to) (sites (values Remembered "Playable"))))) (sow "TrackCCW" apply:(if (!= 1 (var "ReachOpponent")) (if (is In (to) (sites Next)) (if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "ReachOpponent" 1) (if (= 1 (var "OppositeDirection")) (set Var "OppositeDirection" 0) (set Var "OppositeDirection" 1)) (set Var "Direction" 2)}) (and (set Var "ReachOpponent" 0) (set Var "Direction" 0))) (moveAgain)) (if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (if (= 1 (var "OppositeDirection")) (set Var "OppositeDirection" 0) (set Var "OppositeDirection" 1)) (set Var "Direction" 2)}) (and {(set Var "ReachOpponent" 0) (set Var "OppositeDirection" 0) (set Var "Direction" 0) (if (is In (to) (sites Mover)) (if (is Occupied (if (is Mover P1) (+ (to) 6) (- (to) 6))) (and (fromTo (from (if (is Mover P1) (+ (to) 6) (- (to) 6))) (to (mapEntry Mover)) count:(count at:(if (is Mover P1) (+ (to) 6) (- (to) 6)))) (if (and (is Empty (trackSite Move from:(to) "TrackCCW" steps:1)) (is In (trackSite Move from:(to) "TrackCCW" steps:1) (sites Mover))) (if (is Occupied (if (is Mover P1) (+ (trackSite Move from:(to) "TrackCCW" steps:1) 6) (- (trackSite Move from:(to) "TrackCCW" steps:1) 6))) (fromTo (from (if (is Mover P1) (+ (trackSite Move from:(to) "TrackCCW" steps:1) 6) (- (trackSite Move from:(to) "TrackCCW" steps:1) 6))) (to (mapEntry Mover)) count:(count at:(if (is Mover P1) (+ (trackSite Move from:(to) "TrackCCW" steps:1) 6) (- (trackSite Move from:(to) "TrackCCW" steps:1) 6)))))))))}))) skipIf:(not (is In (to) (sites (values Remembered "Playable"))))))))) (then (if (all Sites (union (sites Top) (sites Bottom)) if:(>= 1 (count at:(site)))) (and {(forEach Site (sites P1) (fromTo (from (site)) (to (mapEntry P1)) count:(count at:(site)))) (forEach Site (sites P2) (fromTo (from (site)) (to (mapEntry P2)) count:(count at:(site)))) (forget Value "Playable" All) (if (< (+ (count at:(mapEntry P1)) (count in:(sites P1))) (+ (count at:(mapEntry P2)) (count in:(sites P2)))) (and (set NextPlayer (player 1)) (if (< (+ (count at:(mapEntry P1)) (count in:(sites P1))) (/ (* 6 (count Sites in:(union (sites Top) (sites Bottom)))) 8)) (forEach Site (difference (union (sites Top) (sites Bottom)) (expand (sites Right) steps:3)) (remember Value "Playable" (site))) (if (< (+ (count at:(mapEntry P1)) (count in:(sites P1))) (/ (* 6 (count Sites in:(union (sites Top) (sites Bottom)))) 4)) (forEach Site (difference (union (sites Top) (sites Bottom)) (expand (sites Right) steps:2)) (remember Value "Playable" (site))) (if (< (+ (count at:(mapEntry P1)) (count in:(sites P1))) (/ (* 6 (count Sites in:(union (sites Top) (sites Bottom)))) 2)) (forEach Site (difference (union (sites Top) (sites Bottom)) (expand (sites Right))) (remember Value "Playable" (site))) (forEach Site (union (sites Top) (sites Bottom)) (remember Value "Playable" (site))))))) (and (set NextPlayer (player 2)) (if (< (+ (count at:(mapEntry P2)) (count in:(sites P2))) (/ (* 6 (count Sites in:(union (sites Top) (sites Bottom)))) 8)) (forEach Site (difference (union (sites Top) (sites Bottom)) (expand (sites Right) steps:3)) (remember Value "Playable" (site))) (if (< (+ (count at:(mapEntry P2)) (count in:(sites P2))) (/ (* 6 (count Sites in:(union (sites Top) (sites Bottom)))) 4)) (forEach Site (difference (union (sites Top) (sites Bottom)) (expand (sites Right) steps:2)) (remember Value "Playable" (site))) (if (< (+ (count at:(mapEntry P2)) (count in:(sites P2))) (/ (* 6 (count Sites in:(union (sites Top) (sites Bottom)))) 2)) (forEach Site (difference (union (sites Top) (sites Bottom)) (expand (sites Right))) (remember Value "Playable" (site))) (forEach Site (union (sites Top) (sites Bottom)) (remember Value "Playable" (site))))))))}))))) (end (if (no Pieces All in:(union (sites Top) (sites Bottom))) {(if (= 0 (count at:(mapEntry P1))) (result P2 Win)) (if (= 0 (count at:(mapEntry P2))) (result P1 Win)) (if (= (count at:(mapEntry P1)) (count at:(mapEntry P2))) (result Mover Draw))})) (nextPhase (no Pieces All in:(union (sites Top) (sites Bottom))) "BetweenRounds")) (phase "BetweenRounds" (play (if (is Occupied (mapEntry Mover)) (forEach Value min:1 max:(count at:(mapEntry Mover)) (move (from (mapEntry Mover)) (to (sites Mover) if:(is In (to) (sites (values Remembered "Playable")))) count:(value))) (then (if (is Occupied (mapEntry Mover)) (moveAgain) (forEach Site (sites Mover) (if (is Occupied (site)) (fromTo (from (mapEntry Next)) (to (if (is Mover P1) (+ (site) 6) (- (site) 6))) count:(count at:(site))))))))) (nextPhase (is Empty (mapEntry Mover)) "Sowing"))})) 
2x6 board. Four counters per hole. Each player's rightmost hole is their "hogon," from which they cannot sow, except they must when it reaches fourteen counters. Sowing occurs in an anti-clockwise direction. Sowing from a hole with a single counter is forbidden. When the older player has only single counters in their regular holes, they pass. When the younger player has only single counters in their regular holes, they sow from their hogon. When a player must sow from their hogon and the opponent's holes only contain single counters, the player picks these up and sows them along with the contents of the hogon. When one player only has single counters in their row, the opponent wins.  Each row has 6 holes. Each hole has initially 4 seeds.
(game "Koro" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "0,E,N,W" loop:True)) (piece "Seed" Shared) (hand Each) (map "Hogon" {(pair P1 5) (pair P2 6)}) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start (set Count 4 to:(sites Track))) (play (if (<= 14 (count at:(mapEntry "Hogon" Mover))) (move Select (from (mapEntry "Hogon" Mover)) (then (sow))) (if (all Sites (difference (sites Mover) (mapEntry "Hogon" Mover)) if:(>= 1 (count at:(site)))) (if (is Mover P1) (move Pass) (do (if (all Sites (difference (sites Next) (mapEntry "Hogon" Next)) if:(>= 1 (count at:(site)))) (forEach Site (difference (sites Next) (mapEntry "Hogon" Next)) (if (is Occupied (site)) (fromTo (from (site)) (to (mapEntry "Hogon" Mover)))))) next:(move Select (from (mapEntry "Hogon" Mover) if:(< 1 (count at:(from)))) (then (sow))))) (move Select (from (difference (sites Mover) (mapEntry "Hogon" Mover)) if:(< 1 (count at:(from)))) (then (sow)))))) (end (forEach Player if:(all Sites (sites Player) if:(>= 1 (count at:(site)))) (result Player Loss))))) 
2x7 board with two stores. Four counters in each hole. Sowing occurs in either a clockwise or anti-clockwise direction; the first player chooses the direction and all subsequent moves are made in that direction. The first turn of each player must occur from one of the player's end holes. Players sow beginning from holes in their row. In the course of sowing, a player cannot sow into a hole containing three counters; if one is encountered, it is skipped and the counter is sowed into the next hole without three. If the final counter falls into a hole containing three counters, the contents of the hole are captured and the contents of the next hole are picked up and sowing continues. However, if the hole fitting these conditions is an end hole, it is treated as a puta or naga hole as described below. Otherwise, if the last counter falls into a hole with counters, these are picked up and sowing continues, or if it falls into an empty hole or one treated as a naga or puta hole, the turn ends. Throughout the game, single counters cannot be moved if a player has a hole with multiple counters, and a single counter in the front hole cannot be moved if there are other single counters in the player's row. The round ends when one player's holes are empty. A second round begins with the winner of the first round placing four counters in each of their holes, leaving any surplus in the store. The loser of round one places four counters in as many consecutive holes on their side of the board as possible, and any remaining counters in the next hole. If this hole contains one, it is called puta, if two, naga, if three, wala. Holes with no counters are excluded from play for this round. If the loser has a puta hole, the opponent removes three counters from their hole opposite; if a naga, the opponent removes two from the opposite hole, if a wala, the opponent removes one. The removed counters go into their store. Puta and naga holes are marked with a piece of paper or straw in them. Empty holes are excluded from play in this round. The losing player begins the round, moving in the direction of the excluded holes, and played in the same way as the first round. The player with empty holes begins play in the direction of the empty hole. Counters cannot be captured or sowed from puta or naga holes. Play continues as before. When one player has fewer than twelve counters at the beginning of a round, they may arrange them differently at the beginning. They may put one or two counters in one end hole and not more than four in the other end hole, and one or two counters in the intermediate holes, leaving some empty and, thus, excluded. The opponent then puts four counters in each of their holes. There are no puta, naga, or wala holes in this round. The player with more counters plays as before, but the one with less has captures that are determined by the number of counters placed in the first end hole. If there were two in the end hole, the player captures when dropping the final counter into a hole to make it three; or when it makes two if there was one counter in the first end hole. Otherwise, the player does not sow in holes with one or two counters. Play continues until one player cannot sow at the beginning of a round.
(game "Kotu Baendum" (players 2) (equipment {(mancalaBoard 2 7 {(track "TrackCCW" "1,E,N,W" loop:True) (track "TrackCW" "7,W,N,E" loop:True)}) (piece "Seed" Shared) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 FirstSite) (pair P2 LastSite)})}) (rules (start {(set Count 4 to:(sites Track)) (set RememberValue "Playable" (union (sites Top) (sites Bottom)))}) phases:{(phase "StartingMove" P1 (play (or (move Select (from (intersection (sites Mover) (expand (sites Corners))) if:(and (is Occupied (from)) (is In (from) (sites (values Remembered "Playable"))))) (then (and (sow "TrackCCW" apply:(if (= 4 (count at:(to))) (and (if (is In (to) (expand (sites Corners))) (set Var "Blocked" (to)) (if (!= 0 (count at:(trackSite Move from:(to) "TrackCCW" steps:1))) (and (moveAgain) (set Var "Replay" (trackSite Move from:(to) "TrackCCW" steps:1))))) (fromTo (from (to)) (to (mapEntry Mover)) count:4)) (if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to))))) skipIf:(or (not (is In (to) (sites (values Remembered "Playable")))) (and (= 3 (count at:(to))) (!= 1 (value))))) (set Var "Direction" 1)))) (move Select (from (intersection (sites Mover) (expand (sites Corners))) if:(and (is Occupied (from)) (is In (from) (sites (values Remembered "Playable"))))) (then (and (sow "TrackCW" apply:(if (= 4 (count at:(to))) (and (if (is In (to) (expand (sites Corners))) (set Var "Blocked" (to)) (if (!= 0 (count at:(trackSite Move from:(to) "TrackCW" steps:1))) (and (moveAgain) (set Var "Replay" (trackSite Move from:(to) "TrackCW" steps:1))))) (fromTo (from (to)) (to (mapEntry Mover)) count:4)) (if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to))))) skipIf:(or (not (is In (to) (sites (values Remembered "Playable")))) (and (= 3 (count at:(to))) (!= 1 (value))))) (set Var "Direction" 2)))))) (nextPhase Mover "Sowing")) (phase "StartingMove" P2 (play (if (= 1 (var "Direction")) (move Select (from (intersection (sites Mover) (expand (sites Corners))) if:(and (is Occupied (from)) (is In (from) (sites (values Remembered "Playable"))))) (then (sow "TrackCCW" apply:(if (= 4 (count at:(to))) (and (if (is In (to) (expand (sites Corners))) (set Var "Blocked" (to)) (if (!= 0 (count at:(trackSite Move from:(to) "TrackCCW" steps:1))) (and (moveAgain) (set Var "Replay" (trackSite Move from:(to) "TrackCCW" steps:1))))) (fromTo (from (to)) (to (mapEntry Mover)) count:4)) (if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to))))) skipIf:(or (not (is In (to) (sites (values Remembered "Playable")))) (and (= 3 (count at:(to))) (!= 1 (value))))))) (move Select (from (intersection (sites Mover) (expand (sites Corners))) if:(and (is Occupied (from)) (is In (from) (sites (values Remembered "Playable"))))) (then (sow "TrackCW" apply:(if (= 4 (count at:(to))) (and (if (is In (to) (expand (sites Corners))) (set Var "Blocked" (to)) (if (!= 0 (count at:(trackSite Move from:(to) "TrackCW" steps:1))) (and (moveAgain) (set Var "Replay" (trackSite Move from:(to) "TrackCW" steps:1))))) (fromTo (from (to)) (to (mapEntry Mover)) count:4)) (if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to))))) skipIf:(or (not (is In (to) (sites (values Remembered "Playable")))) (and (= 3 (count at:(to))) (!= 1 (value))))))))) (nextPhase Mover "Sowing")) (phase "Sowing" (play (if (= 1 (var "Direction")) (move Select (from (if (and (not (is Pending)) (is Prev Mover)) (sites {(var "Replay")}) (sites Mover)) if:(and {(is Occupied (from)) (is In (from) (sites (values Remembered "Playable"))) (not (is In (from) (sites (values Remembered "Blocked")))) (if (not (all Sites (forEach (sites Mover) if:(is In (site) (sites (values Remembered "Playable")))) if:(>= 1 (count at:(site))))) (< 1 (count at:(from))))})) (then (sow "TrackCCW" apply:(if (= 4 (count at:(to))) (and (if (is In (to) (expand (sites Corners))) (set Var "Blocked" (to)) (if (!= 0 (count at:(trackSite Move from:(to) "TrackCCW" steps:1))) (and (moveAgain) (set Var "Replay" (trackSite Move from:(to) "TrackCCW" steps:1))))) (if (not (is In (to) (sites (values Remembered "Blocked")))) (fromTo (from (to)) (to (mapEntry Mover)) count:4))) (if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to))))) skipIf:(or (not (is In (to) (sites (values Remembered "Playable")))) (and (= 3 (count at:(to))) (!= 1 (value))))))) (move Select (from (if (and (not (is Pending)) (is Prev Mover)) (sites {(var "Replay")}) (sites Mover)) if:(and {(is Occupied (from)) (is In (from) (sites (values Remembered "Playable"))) (not (is In (from) (sites (values Remembered "Blocked")))) (if (not (all Sites (forEach (sites Mover) if:(is In (site) (sites (values Remembered "Playable")))) if:(>= 1 (count at:(site))))) (< 1 (count at:(from))))})) (then (sow "TrackCW" apply:(if (= 4 (count at:(to))) (and (if (is In (to) (expand (sites Corners))) (set Var "Blocked" (to)) (if (!= 0 (count at:(trackSite Move from:(to) "TrackCW" steps:1))) (and (moveAgain) (set Var "Replay" (trackSite Move from:(to) "TrackCW" steps:1))))) (if (not (is In (to) (sites (values Remembered "Blocked")))) (fromTo (from (to)) (to (mapEntry Mover)) count:4))) (if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to))))) skipIf:(or (not (is In (to) (sites (values Remembered "Playable")))) (and (= 3 (count at:(to))) (!= 1 (value))))))) (then (if (no Moves Next) (and {(forEach Site (sites P1) (if (is Occupied (site)) (fromTo (from (site)) (to (mapEntry P1)) count:(count at:(site))))) (forEach Site (sites P2) (if (is Occupied (site)) (fromTo (from (site)) (to (mapEntry P2)) count:(count at:(site))))) (forget Value "Playable" All) (forget Value "Blocked" All) (if (< (+ (count at:(mapEntry P1)) (count in:(sites P1))) (+ (count at:(mapEntry P2)) (count in:(sites P2)))) (and (set NextPlayer (player 2)) (set Var "Winner" 2)) (and (set NextPlayer (player 1)) (set Var "Winner" 1)))}))))) (end (if (no Moves Next) {(if (> 2 (count at:(mapEntry P1))) (result P2 Win)) (if (> 2 (count at:(mapEntry P2))) (result P1 Win))})) (nextPhase (no Moves Next) "BetweenRounds")) (phase "BetweenRounds" (play (if (and (not (is Prev Mover)) (!= (mover) (var "Winner"))) (or (move (from (mapEntry Mover)) (to (if (is Mover P1) (intersection (sites Bottom) (expand (sites Right))) (intersection (sites Top) (expand (sites Left)))) if:(is Empty (to))) count:(min 4 (count at:(mapEntry Mover))) (then (and {(remember Value "Playable" (last To)) (if (> 4 (count at:(last To))) (and (fromTo (from (if (is Mover P1) (+ (to) 7) (- (to) 7))) (to (mapEntry Next)) count:(- 4 (count at:(last To)))) (remember Value "Blocked" (last To)))) (moveAgain) (if (= 0 (count at:(mapEntry Mover))) (set Pending)) (set Var "Direction" 2)}))) (move (from (mapEntry Mover)) (to (if (is Mover P1) (intersection (sites Bottom) (expand (sites Left))) (intersection (sites Top) (expand (sites Right)))) if:(is Empty (to))) count:(min 4 (count at:(mapEntry Mover))) (then (and {(remember Value "Playable" (last To)) (if (> 4 (count at:(last To))) (and (fromTo (from (if (is Mover P1) (+ (to) 7) (- (to) 7))) (to (mapEntry Next)) count:(- 4 (count at:(last To)))) (remember Value "Blocked" (last To)))) (moveAgain) (if (= 0 (count at:(mapEntry Mover))) (set Pending)) (set Var "Direction" 1)})))) (if (!= (mover) (var "Winner")) (move (from (mapEntry Mover)) (to (if (= (var "Direction") 1) (trackSite Move from:(last To) "TrackCCW" steps:1) (trackSite Move from:(last To) "TrackCW" steps:1)) if:(is Empty (to))) count:(min 4 (count at:(mapEntry Mover))) (then (and {(remember Value "Playable" (last To)) (moveAgain) (if (= 0 (count at:(mapEntry Mover))) (set Pending))}))) (move (from (mapEntry Mover)) (to (sites Mover) if:(is Empty (to))) count:4 (then (and (remember Value "Playable" (last To)) (if (not (all Sites (sites Mover) if:(is Occupied (site)))) (moveAgain)))))))) (nextPhase (and (!= (var "Winner") (mover)) (= 0 (count at:(mapEntry Mover)))) "Sowing"))})) 
Two rows of six holes with stores on either end. Four counters in each hole. Players sow in an anti-clockwise direction. When the last counter falls into a hole, and it now contains two or three counters, these are captured. The game is played with 2 players.
(game "Kpo" (players 2) (equipment {(mancalaBoard 2 6 (track "Track" "1,E,N,W" loop:True)) (piece "Seed" Shared) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 FirstSite) (pair P2 LastSite)})}) (rules (start (set Count 4 to:(sites Track))) (play (move Select (from (sites Mover) if:(> (count at:(from)) 0)) (then (sow apply:(if (or (= (count at:(to)) 2) (= (count at:(to)) 3)) (fromTo (from (to)) (to (mapEntry Mover)) count:(count at:(to)))))))) (end (if (no Moves Next) (byScore {(score P1 (+ (count in:(sites P1)) (count at:(mapEntry P1)))) (score P2 (+ (count in:(sites P2)) (count at:(mapEntry P2))))}))))) 
2x7 board. Seven counters in each hole. Sowing occurs in an anti-clockwise direction. When the final counter falls into an occupied hole, the contents of that hole are picked up and sowing continues. If the final counter falls into a hole containing one or three counters, the player captures those counters, plus any counters in the hole in the opposite row, as well as the contents of any holes in an unbroken sequence following the one in which the final counter which also contain two or four counters.When the final counter falls into an empty hole, the turn ends. Play continues until all of the pieces are captured. The player who captured the most counters wins.
(game "La'b Akila" (players 2) (equipment {(mancalaBoard 2 7 store:None (track "TrackCCW" "0,E,N,W" loop:True)) (piece "Seed" Shared) (hand Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start (set Count 7 to:(sites Track))) (play (move Select (from (sites Mover) if:(is Occupied (from))) (then (sow if:True apply:(if (or (= 2 (count at:(to))) (= 4 (count at:(to)))) (and (fromTo (from (to)) (to (handSite Mover)) count:(count at:(to))) (if (!= 0 (count at:(if (is In (to) (sites Bottom)) (+ (to) 7) (- (to) 7)))) (fromTo (from (if (is In (to) (sites Bottom)) (+ (to) 7) (- (to) 7))) (to (handSite Mover)) count:(count at:(if (is In (to) (sites Bottom)) (+ (to) 7) (- (to) 7))))))) backtracking:(or (= 2 (count at:(to))) (= 4 (count at:(to)))))))) (end (if (>= 1 (count Pieces All in:(sites Board))) (byScore {(score P1 (+ (count in:(sites Mover)) (count Cell at:(handSite P1)))) (score P2 (+ (count in:(sites Mover)) (count Cell at:(handSite P2))))}))))) 
2x6 board. Four counters in each hole. The first player takes three counters from each of their holes, and sows them beginning in the opponent's first hole. Sowing proceeds in an anti-clockwise direction, and when the final counter lands in an occupied hole, these are picked up and sowing continues. While sowing, if a hole is made to contain four counters, these are captured by the player. When the final counter falls into an empty hole, the turn ends, unless the player was able to make a capture during the sowing, in which case they may play again. A player with no counters on their side must pass, and may continue playing when there are counters in their holes again. Play continues until all the counters are captured, and the player with the most counters wins. A second round is played, each player placing four counters into each hole starting from the rightmost hole in their row. The player with more counters gains a hole from their opponent for every four extra balls they've captured. If an opponent has three extra after counting in such a way, they also gain a hole, but not if there are one or two extra. Play continues in several rounds like this until one player captures all the holes. 
(game "Lam Waladach" (players 2) (equipment {(mancalaBoard 2 6 store:None {(track "TrackCCW" "0,E,N,W" loop:True) (track "TrackCW" "5,W,N,E" loop:True)}) (piece "Seed" Shared) (hand Each) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map "RightMost" {(pair P1 5) (pair P2 6)})}) (rules (start {(set Count 4 to:(sites Track)) (set RememberValue "OwnedP1" (sites Bottom)) (set RememberValue "OwnedP2" (sites Top))}) phases:{(phase "Opening" (play (move Select (from 11) (then (and (forEach Site (sites Mover) (fromTo (from (site)) (to 11) count:3)) (sow count:18 "TrackCCW" apply:(if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to)))) origin:True))))) (nextPhase "Sowing")) (phase "Sowing" (play (or {(move Select (from (if (and (not (is Pending)) (is Prev Mover)) (sites {(var "Replay")}) (if (is Mover P1) (sites (values Remembered "OwnedP1")) (sites (values Remembered "OwnedP2")))) if:(> (count at:(from)) 0)) (then (do (set Var "NumSowed" (count at:(last To))) next:(sow "TrackCCW" apply:(if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to))))) (then (and (forEach Site (sites Track from:(last From) to:(trackSite Move from:(last From) "Track" steps:(var "NumSowed"))) (if (= 4 (count at:(site))) (and (fromTo (from (site)) (to (handSite Mover)) count:4) (and (moveAgain) (set Pending))))) (set Var "NumSowed" 0))))))} (then (if (all Sites (sites Board) if:(= 0 (count at:(site)))) (and (forget Value "OwnedP1" All) (forget Value "OwnedP2" All)))))) (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) {(if (> 3 (count Cell at:(handSite P1))) (result P2 Win)) (if (> 3 (count Cell at:(handSite P2))) (result P1 Win))})) (nextPhase (all Sites (sites Board) if:(= 0 (count at:(site)))) "BetweenRounds")) (phase "BetweenRounds" (play (if (<= 3 (count Cell at:(handSite Mover))) (move (from (handSite Mover)) (to (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))) count:(if (>= (count Cell at:(handSite Mover)) 4) 4 3) (then (if (is Mover P1) (remember Value "OwnedP1" (last To)) (remember Value "OwnedP2" (last To))))))) (nextPhase (all Passed) "Sowing"))})) 
2x6 board. Four counters in each hole. Play begins with a stylized move. One player takes one counter from their rightmost hole, and holds it in their hand. They then take one counter from the next hole, moving in an anti-clockwise direction, and place it in the next hole. They then take a counter from the next hole after that, and placing it in the next hole, continuing until there is an alternating pattern of a hole with five counters followed by a hole with three counters. Upon reaching the original hole, one counter is dropping in it, and then one counter in the following hole, thus capturing the counters in this hole. Players then alternate turns, sowing in an anti-clockwise direction. When the final counter of a sowing lands in an occupied hole, these counters are picked up and the sowing continues. During sowing, the contents of any hole made to contain four counters are captured by the player in whose row the hole is located, except when this is the final counter of a sowing, in which case the player who is sowing captures these counters. When the sowing ends in an empty hole, the turn ends. Play continues until one player cannot move, and the other player captures the remaining counters. A second round is played, each player placing four counters into each hole starting from the rightmost hole in their row. The player with more counters gains a hole from their opponent for every four extra balls they've captured. If an opponent has three extra after counting in such a way, they also gain a hole, but not if there are one or two extra. Play continues in several rounds like this until one player captures all the holes. 
(game "Lamosh" (players 2) (equipment {(mancalaBoard 2 6 store:None {(track "TrackCCW" "0,E,N,W" loop:True) (track "TrackCW" "5,W,N,E" loop:True)}) (piece "Seed" Shared) (hand Each) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map "RightMost" {(pair P1 5) (pair P2 6)})}) (rules (start {(set Count 4 to:(sites Track)) (set RememberValue "OwnedP1" (sites Bottom)) (set RememberValue "OwnedP2" (sites Top))}) phases:{(phase "Opening1" (play (move (from (if (is Prev Mover) (var "Replay") 11)) (to (trackSite Move from:(from) "Track" steps:1)) (then (if (!= (trackSite Move from:(last To) "Track" steps:1) 11) (and (moveAgain) (set Var "Replay" (trackSite Move from:(last To) "Track" steps:1))) (fromTo (from 11) (to (handSite Mover)) count:(count at:11)))))) (nextPhase (not (is Next Mover)) "Sowing")) (phase "Sowing" (play (or {(move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (if (is Mover P1) (sites (values Remembered "OwnedP1")) (sites (values Remembered "OwnedP2")))) if:(is Occupied (from))) (then (do (set Var "NumSowed" (count at:(last To))) next:(sow "TrackCCW" apply:(if (= 4 (count at:(to))) (fromTo (from (to)) (to (handSite Mover)) count:4) (if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to)))))) (then (and (forEach Site (sites Track from:(last From) to:(trackSite Move from:(last From) "Track" steps:(- (var "NumSowed") 1))) (if (= 4 (count at:(site))) (fromTo (from (site)) (to (if (is In (to) (sites (values Remembered "OwnedP1"))) (handSite P1) (handSite P2))) count:4))) (set Var "NumSowed" 0))))))} (then (if (and (not (is Next Mover)) (or (all Sites (sites (values Remembered "OwnedP1")) if:(is Empty (site))) (all Sites (sites (values Remembered "OwnedP2")) if:(is Empty (site))))) (and {(if (no Moves P1) (forEach Site (sites Board) (if (is Occupied (site)) (fromTo (from (site)) (to (handSite P1)) count:(count at:(site))))) (forEach Site (sites Board) (if (is Occupied (site)) (fromTo (from (site)) (to (handSite P2)) count:(count at:(site)))))) (forget Value "OwnedP1" All) (forget Value "OwnedP2" All)}))))) (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) {(if (> 3 (count Cell at:(handSite P1))) (result P2 Win)) (if (> 3 (count Cell at:(handSite P2))) (result P1 Win))})) (nextPhase (all Sites (sites Board) if:(= 0 (count at:(site)))) "BetweenRounds")) (phase "BetweenRounds" (play (if (<= 3 (count Cell at:(handSite Mover))) (move (from (handSite Mover)) (to (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))) count:(if (>= (count Cell at:(handSite Mover)) 4) 4 3) (then (if (is Mover P1) (remember Value "OwnedP1" (last To)) (remember Value "OwnedP2" (last To))))))) (nextPhase (all Passed) "Sowing"))})) 
2x5 board. Five counters per hole. Each player has a larger stone, which they place in any hole on their side of the board. Sowing proceeds in either direction, the first player chooses which and all sowing for the rest of the game proceeds in that direction. Players may sow from any hole on the board. If the last counter falls into a hole with counters, the counters in the next hole are picked up and sowing continues, and if this hole is empty, the counters in the hole following the empty hole are captured. If there is an unbroken sequence of alternating empty and occupied holes, the counters in the occupied holes are captured until there are two empty or two occupied holes. If the final counter falls into an empty hole the turn ends. Also, if a large stone is dropped into an occupied hole during sowing, the contents of that hole are captured by the owner of the large stone, even if it is not the current player. If a player captures the other player's large stone, it is kept by the capturing player in subsequent rounds until it is captured. The game ends when one player's holes are empty, the opponent claiming the remainder of the counters. The players then attempt to fill all of the holes on their side of the board with either five counters or the large stone. Both large stones must be used to fill holes. Any holes that cannot be filled with five counters or a large stone are left empty, but may be sown into and played from as normal. Play continues in this fashion until one player cannot fill any holes. 
(game "Laomuzhu" (players 2) (equipment {(mancalaBoard 2 5 store:None largeStack:True {(track "TrackCCW" "0,E,N,W" loop:True) (track "TrackCW" "4,W,N,E" loop:True)}) (piece "Seed" Shared) (piece "Ball" P1) (piece "Ball" P2) (hand Each size:2) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 0) (pair P2 9)})}) (rules (start {(place Stack "Seed" (union (sites Bottom) (sites Top)) count:5) (place Stack "Ball1" (handSite P1 1)) (place Stack "Ball2" (handSite P2 1))}) phases:{(phase "Placement" (play (if (is Occupied Cell (handSite Mover 1)) (move (from Cell (handSite Mover 1) level:(topLevel Cell at:(handSite Mover 1))) (to (sites Mover)) stack:True))) (nextPhase Mover (is Empty Cell (handSite Mover 1)) "Sowing")) (phase "Sowing" (play (or {(if (!= (var "Direction") 2) (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover)) if:(!= 0 (size Stack at:(from)))) (then (and {(forEach Value min:1 max:(size Stack at:(last From)) (if (= (id "Seed" Shared) (what at:(last From) level:(- (size Stack at:(last From)) (value)))) (fromTo (from (last From) level:(- (size Stack at:(last From)) (value))) (to (trackSite Move from:(last From) "TrackCCW" steps:(value))) stack:True) (and (if (and (is Occupied (trackSite Move from:(last From) "TrackCCW" steps:(value))) (!= (trackSite Move from:(last From) "TrackCCW" steps:(value)) (last From))) (if (= (who at:(last From) level:(- (size Stack at:(last From)) (value))) P1) (forEach Level (trackSite Move from:(last From) "TrackCCW" steps:(value)) FromTop (if (= (id "Seed" Shared) (what at:(trackSite Move from:(last From) "TrackCCW" steps:(value)) level:(level))) (fromTo (from (trackSite Move from:(last From) "TrackCCW" steps:(value)) level:(level)) (to (handSite P1))) (fromTo (from (trackSite Move from:(last From) "TrackCCW" steps:(value)) level:(level)) (to (handSite P1 1))))) (forEach Level (trackSite Move from:(last From) "TrackCCW" steps:(value)) FromTop (if (= (id "Seed" Shared) (what at:(trackSite Move from:(last From) "TrackCCW" steps:(value)) level:(level))) (fromTo (from (trackSite Move from:(last From) "TrackCCW" steps:(value)) level:(level)) (to (handSite P2))) (fromTo (from (trackSite Move from:(last From) "TrackCCW" steps:(value)) level:(level)) (to (handSite P2 1))))))) (fromTo (from (last From) level:(- (size Stack at:(last From)) (value))) (to (trackSite Move from:(last From) "TrackCCW" steps:(value))) stack:True)))) (if (< (var "Direction") 1) (set Var "Direction" 1)) (if (< (size Stack at:(last From)) 8) (if (!= 0 (size Stack at:(trackSite Move from:(last From) "TrackCCW" steps:(+ 1 (size Stack at:(last From)))))) (and (moveAgain) (set Var "Replay" (trackSite Move from:(last From) "TrackCCW" steps:(+ 1 (size Stack at:(last From)))))) (if (is Occupied (trackSite Move from:(last From) "TrackCCW" steps:(+ 2 (size Stack at:(last From))))) (forEach Level (trackSite Move from:(last From) "TrackCCW" steps:(+ 2 (size Stack at:(last From)))) FromTop (if (= (id "Seed" Shared) (what at:(trackSite Move from:(last From) "TrackCCW" steps:(+ 2 (size Stack at:(last From)))) level:(level))) (fromTo (from (trackSite Move from:(last From) "TrackCCW" steps:(+ 2 (size Stack at:(last From)))) level:(level)) (to (handSite Mover))) (fromTo (from (trackSite Move from:(last From) "TrackCCW" steps:(+ 2 (size Stack at:(last From)))) level:(level)) (to (handSite Mover 1))))))))})))) (if (!= (var "Direction") 1) (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover)) if:(!= 0 (size Stack at:(from)))) (then (and {(forEach Value min:1 max:(size Stack at:(last From)) (if (= (id "Seed" Shared) (what at:(last From) level:(- (size Stack at:(last From)) (value)))) (fromTo (from (last From) level:(- (size Stack at:(last From)) (value))) (to (trackSite Move from:(last From) "TrackCW" steps:(value))) stack:True) (and (if (and (is Occupied (trackSite Move from:(last From) "TrackCW" steps:(value))) (!= (trackSite Move from:(last From) "TrackCW" steps:(value)) (last From))) (if (= (who at:(last From) level:(- (size Stack at:(last From)) (value))) P1) (forEach Level (trackSite Move from:(last From) "TrackCW" steps:(value)) FromTop (if (= (id "Seed" Shared) (what at:(trackSite Move from:(last From) "TrackCW" steps:(value)) level:(level))) (fromTo (from (trackSite Move from:(last From) "TrackCW" steps:(value)) level:(level)) (to (handSite P1))) (fromTo (from (trackSite Move from:(last From) "TrackCW" steps:(value)) level:(level)) (to (handSite P1 1))))) (forEach Level (trackSite Move from:(last From) "TrackCW" steps:(value)) FromTop (if (= (id "Seed" Shared) (what at:(trackSite Move from:(last From) "TrackCW" steps:(value)) level:(level))) (fromTo (from (trackSite Move from:(last From) "TrackCW" steps:(value)) level:(level)) (to (handSite P2))) (fromTo (from (trackSite Move from:(last From) "TrackCW" steps:(value)) level:(level)) (to (handSite P2 1))))))) (fromTo (from (last From) level:(- (size Stack at:(last From)) (value))) (to (trackSite Move from:(last From) "TrackCW" steps:(value))) stack:True)))) (if (< (var "Direction") 1) (set Var "Direction" 2)) (if (< (size Stack at:(last From)) 8) (if (!= 0 (size Stack at:(trackSite Move from:(last From) "TrackCW" steps:(+ 1 (size Stack at:(last From)))))) (and (moveAgain) (set Var "Replay" (trackSite Move from:(last From) "TrackCW" steps:(+ 1 (size Stack at:(last From)))))) (if (is Occupied (trackSite Move from:(last From) "TrackCW" steps:(+ 2 (size Stack at:(last From))))) (forEach Level (trackSite Move from:(last From) "TrackCW" steps:(+ 2 (size Stack at:(last From)))) FromTop (if (= (id "Seed" Shared) (what at:(trackSite Move from:(last From) "TrackCW" steps:(+ 2 (size Stack at:(last From)))) level:(level))) (fromTo (from (trackSite Move from:(last From) "TrackCW" steps:(+ 2 (size Stack at:(last From)))) level:(level)) (to (handSite Mover))) (fromTo (from (trackSite Move from:(last From) "TrackCW" steps:(+ 2 (size Stack at:(last From)))) level:(level)) (to (handSite Mover 1))))))))}))))} (then (if (all Sites (sites P1) if:(= 0 (count at:(site)))) (forEach Site (sites Board) (if (is Occupied (site)) (forEach Level (site) FromTop (if (= (id "Seed" Shared) (what at:(site) level:(level))) (fromTo (from (site) level:(level)) (to (handSite P1)) stack:True) (fromTo (from (site) level:(level)) (to (handSite P1 1)) stack:True))))) (if (all Sites (sites P2) if:(= 0 (count at:(site)))) (forEach Site (sites Board) (if (is Occupied (site)) (forEach Level (site) FromTop (if (= (id "Seed" Shared) (what at:(site) level:(level))) (fromTo (from (site) level:(level)) (to (handSite P2)) stack:True) (fromTo (from (site) level:(level)) (to (handSite P2 1)) stack:True)))))))))) (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) {(if (and (> 5 (size Stack Cell at:(handSite P1))) (= 0 (size Stack Cell at:(handSite P1 1)))) (result P2 Win)) (if (and (> 5 (size Stack Cell at:(handSite P2))) (= 0 (size Stack Cell at:(handSite P2 1)))) (result P1 Win))})) (nextPhase (all Sites (sites Board) if:(= 0 (count at:(site)))) "BetweenRounds")) (phase "BetweenRounds" (play (or (if (<= 5 (size Stack Cell at:(handSite Mover))) (move Select (from Cell (handSite Mover)) (to (trackSite FirstSite "TrackCCW" from:(mapEntry Mover) if:(is Empty (to)))) (then (forEach Value min:1 max:5 (fromTo (from Cell (last From) level:(- (size Stack Cell at:(last From)) (value))) (to (last To)) stack:True))))) (if (!= 0 (size Stack Cell at:(handSite Mover 1))) (move Select (from Cell (handSite Mover 1)) (to (sites Mover)) (then (fromTo (from Cell (last From) level:(topLevel Cell at:(last From))) (to (last To)) stack:True)))))) (nextPhase (all Passed) "Sowing"))})) 
2x6 board. Five counters in each hole. Play begins from any hole in a player's row and sown anti-clockwise. When the final counter falls into an occupied hole, the counters in that hole are picked up and sowing continues. If the final counter falls into an empty hole, the turn ends; if this hole is in the player's own row, the contents of the opponent's hole are captured if they contain one, two, four, or more counters. If it contains three counters, one of the opponent's counters is taken and placed into the hole where sowing ended, so that each now has two counters. These holes cannot be sown from for the rest of the game and are owned by the player whose turn created them. Players cannot change their move mid-turn and counting of counters is forbidden. Play ends when one player can no longer play. The opponent then takes all of the counters in their own row, and each player takes the counters that have accumulated in their captured holes. A new game begins. The player with the fewest counters arranges them in their holes, distributing them as equally as possible. The opponent then mirrors this arrangement in their holes, placing aside any extras for use in subsequent games. If the player is reduced to four counters or less, these are arranged one to a hole and any empty holes are not used for the game (by either player). The player who captures all the counters wins.
(game "Leyla Gobale (Gabradarre)" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "TrackCCW" "0,E,N,W" loop:True)) (piece "Seed" Shared) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (hand Each) (map "CorrespondingHoles" {(pair 0 11) (pair 1 10) (pair 2 9) (pair 3 8) (pair 4 7) (pair 5 6) (pair 6 5) (pair 7 4) (pair 8 3) (pair 9 2) (pair 10 1) (pair 11 0)})}) (rules (start {(set RememberValue "Playable" (union (sites Top) (sites Bottom))) (set Count 5 to:(sites Track))}) phases:{(phase "Sowing" (play (or {(move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover)) if:(and {(is Occupied (from)) (= 0 (state at:(from))) (is In (from) (sites (values Remembered "Playable")))})) (then (sow apply:(if (< 1 (count at:(to))) (if (= 0 (state at:(to))) (and (moveAgain) (set Var "Replay" (to)))) (if (is In (to) (sites Mover)) (if (!= 3 (count at:(if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6)))) (if (!= 0 (count at:(if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6)))) (fromTo (from (if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6))) (to (handSite Mover)) count:(count at:(if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6))))) (and {(fromTo (from (if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6))) (to (to)) count:1) (set State at:(to) (mover)) (set State at:(if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6)) (mover))})))))))} (then (if (and (not (is Next Mover)) (or (all Sites (sites P1) if:(or (not (is In (site) (sites (values Remembered "Playable")))) (or (!= 0 (state at:(site))) (is Empty (site))))) (all Sites (sites P2) if:(or (not (is In (site) (sites (values Remembered "Playable")))) (or (!= 0 (state at:(site))) (is Empty (site))))))) (and {(forEach Site (sites P1) (if (= 0 (state at:(site))) (fromTo (from (site)) (to (handSite P1)) count:(count at:(site))))) (forEach Site (sites P2) (if (= 0 (state at:(site))) (fromTo (from (site)) (to (handSite P2)) count:(count at:(site))))) (forEach Site (sites Board) (if (= (state at:(site)) P1) (fromTo (from (site)) (to (handSite P1)) count:(count at:(site))) (if (= (state at:(site)) P2) (fromTo (from (site)) (to (handSite P2)) count:(count at:(site)))))) (if (< (+ {(count Cell at:(handSite P1)) (count in:(forEach (sites Board) if:(= (state at:(site)) P1))) (count in:(forEach (sites P1) if:(= (state at:(site)) 0)))}) (+ {(count Cell at:(handSite P2)) (count in:(forEach (sites Board) if:(= (state at:(site)) P2))) (count in:(forEach (sites P2) if:(= (state at:(site)) 0)))})) (set NextPlayer (player 1)) (set NextPlayer (player 2))) (forget Value "Playable" All)}))))) (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) {(if (= 0 (count Cell at:(handSite P1))) (result P2 Win)) (if (= 0 (count Cell at:(handSite P2))) (result P1 Win))})) (nextPhase (all Sites (sites Board) if:(= 0 (count at:(site)))) "BetweenRounds")) (phase "BetweenRounds" (play (move (from (handSite Mover)) (to (forEach (sites Mover) if:(= (count at:(site)) (min (results from:(sites Mover) to:(sites Mover) (count at:(to))))))) count:1 (then (and (remember Value "Playable" (last To) unique:True) (if (< 0 (count Cell at:(handSite Mover))) (moveAgain) (forEach Site (sites Mover) (if (is Occupied (site)) (fromTo (from (handSite Next)) (to (mapEntry "CorrespondingHoles" (site))) count:(count at:(site)))))))))) (nextPhase (or (is Empty (handSite P1)) (is Empty (handSite P2))) "Sowing"))})) 
2x6, 8, or 12 holes. Four counters in each hole. Play begins from a player's righthand hole and counters are sown clockwise. After this, a player may begin sowing from any hole in their row. When the final counter falls into an occupied hole, the counters in that hole are picked up and sowing continues. If the final counter falls into an empty hole, the turn ends; if this hole is in the player's own row, the contents of the opponent's hole are captured if they contain one, two, four, or more counters. If it contains three counters, one of the opponent's counters is taken and placed into the hole where sowing ended, so that each now has two counters. These holes cannot be sown from for the rest of the game and are owned by the player whose turn created them. Play ends when one player can no longer play. The opponent then takes all of the counters in their own row, and each player takes the counters that have accumulated in their captured holes. The player with the most counters wins. Each player has 6 holes.
(game "Leyla Gobale (Somaliland)" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "5,W,N,E" loop:True)) (piece "Seed" Shared) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (hand Each)}) (rules (start (set Count 4 to:(sites Track))) (play (or {(move Select (from (if (= 0 (count Moves)) (sites {5}) (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover))) if:(and (is Occupied (from)) (= 0 (state at:(from))))) (then (sow apply:(if (< 1 (count at:(to))) (if (= 0 (state at:(to))) (and (moveAgain) (set Var "Replay" (to)))) (if (is In (to) (sites Mover)) (if (!= 3 (count at:(if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6)))) (if (!= 0 (count at:(if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6)))) (fromTo (from (if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6))) (to (handSite Mover)) count:(count at:(if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6))))) (and {(fromTo (from (if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6))) (to (to)) count:1) (set State at:(to) (mover)) (set State at:(if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6)) (mover))})))))))} (then (if (and (not (is Next Mover)) (or (all Sites (sites P1) if:(or (!= 0 (state at:(site))) (is Empty (site)))) (all Sites (sites P2) if:(or (!= 0 (state at:(site))) (is Empty (site)))))) (and {(forEach Site (sites P1) (if (= 0 (state at:(site))) (fromTo (from (site)) (to (handSite P1)) count:(count at:(site))))) (forEach Site (sites P2) (if (= 0 (state at:(site))) (fromTo (from (site)) (to (handSite P2)) count:(count at:(site))))) (forEach Site (sites Board) (if (= (state at:(site)) P1) (fromTo (from (site)) (to (handSite P1)) count:(count at:(site))) (if (= (state at:(site)) P2) (fromTo (from (site)) (to (handSite P2)) count:(count at:(site))))))}))))) (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) (byScore {(score P1 (count Cell at:(handSite P1))) (score P2 (count Cell at:(handSite P2)))}))))) 
2x6 board. Four counters in each hole. Sowing occurs in a clockwise direction. When the final counter of a sowing lands in an occupied hole, the contents of the hole are picked up and sowing continues. If this occupied hole is in the opponent's row and is made to contain four with the final counter, this hole and the one opposite it are captured, the counters remaining in the holes. Players may not sow from these holes. If on a subsequent turn the final counter of a sowing falls into an opponent's captured hole, one counter from the hole is captured, as well as the final counter of the sowing, and the turn ends. When the final counter of a sowing lands in an empty hole, the turn ends. Play continues until one of the players can no longer move, the opponent taking any remaining counters in free holes on their side of the board and each player taking the counters in their captured holes. A new round begins. Players attempt to fill their holes with four counters each. If a player has two extra counters, they may loan them to the other player, to be repaid when they can in a subsequent round. If a player has one extra counter, it is surrendered to the opponent. The player with more counter would only fill as many hole as the opponent is able to fill, retaining their extra counters for future rounds. Play continues until one player cannot fill any holes.
(game "Leyla" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "5,W,N,E" loop:True)) (piece "Seed" Shared) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (hand Each)}) (rules (start (set Count 4 to:(sites Track))) phases:{(phase "Sowing" (play (or {(move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover)) if:(and (is Occupied (from)) (= 0 (state at:(from))))) (then (sow apply:(if (!= 0 (state at:(to))) (if (= (next) (state at:(to))) (and (fromTo (from (to)) (to (handSite Mover)) count:(min 2 (count at:(to)))) (set State at:(to) (next)))) (if (and (is In (to) (sites Next)) (= 4 (count at:(to)))) (and (set State at:(to) (mover)) (set State at:(if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6)) (mover))) (if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to)))))))))} (then (if (and (not (is Next Mover)) (or (all Sites (sites P1) if:(or (!= 0 (state at:(site))) (is Empty (site)))) (all Sites (sites P2) if:(or (!= 0 (state at:(site))) (is Empty (site)))))) (and {(forEach Site (sites P1) (if (= 0 (state at:(site))) (fromTo (from (site)) (to (handSite P1)) count:(count at:(site))))) (forEach Site (sites P2) (if (= 0 (state at:(site))) (fromTo (from (site)) (to (handSite P2)) count:(count at:(site))))) (forEach Site (sites Board) (if (= (state at:(site)) P1) (and (fromTo (from (site)) (to (handSite P1)) count:(count at:(site))) (set State at:(site) 0)) (if (= (state at:(site)) P2) (and (fromTo (from (site)) (to (handSite P2)) count:(count at:(site))) (set State at:(site) 0)))))}))))) (end (if (no Pieces All in:(sites Board)) {(if (> 3 (count Cell at:(handSite P1))) (result P2 Win)) (if (> 3 (count Cell at:(handSite P2))) (result P1 Win))})) (nextPhase (no Pieces All in:(sites Board)) "BetweenRounds")) (phase "BetweenRounds" (play (if (<= 4 (count Cell at:(handSite Mover))) (move (from (handSite Mover)) (to (sites Mover) if:(is Empty (to))) count:4 (then (if (= 1 (count Cell at:(handSite Mover))) (fromTo (from (handSite Mover)) (to (handSite Next)) count:1) (if (= 2 (count Cell at:(handSite Mover))) (fromTo (from (handSite Next)) (to (handSite Mover)) count:2) (if (= 3 (count Cell at:(handSite Mover))) (fromTo (from (handSite Next)) (to (handSite Mover)) count:1)))))))) (nextPhase (and (= (count Sites in:(forEach (sites P1) if:(is Occupied (site)))) (count Sites in:(forEach (sites P2) if:(is Occupied (site))))) (or (is Empty (handSite P1)) (is Empty (handSite P2)))) "Sowing"))})) 
2x6 board. 72 counters are distributed unevenly into the holes with the only rule that corresponding holes on either side of the board must contain counters. The opponent moves first, but may flip the board around if they prefer that arrangement, sacrificing the first move. Counters are sowed in an anti-clockwise direction from a hole in the player's row. If the last counter falls into a hole making it odd, these are picked up and sowing continues. If it lands in a hole making it even, these counters are captured as are the ones in the opposite hole. If the previous hole also has an even number, these and the ones in the opposite hole are captured. If the last counter falls into an empty hole, the turn ends. If a player has no counters in their holes, the opponent must give them one counter, to be placed in the leftmost hole and played from there. Play ends when the board is cleared of counters. Each player counts the number of counters they captured. The player with more counters is given a score equal to the difference in the number of counters. Another round begins again exactly as before. The game is won when a player accumulates sixty points.
(game "Li'b al-'Aqil" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "0,E,N,W" loop:True)) (piece "Seed" Shared) (hand Each) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map "LeftMost" {(pair P1 0) (pair P2 11)})}) (rules (start (place "Seed" (handSite P1) count:72)) phases:{(phase "Opening1" (play (or {(if (is Occupied Cell (handSite P1)) (forEach Value min:1 max:(count Cell at:(handSite P1)) (move (from (handSite P1)) (to (sites Board)) count:(value))) (forEach Site (sites Board) (if (is Occupied (site)) (move (from (site)) (to (sites Board) if:(!= (to) (from)))))) (then (moveAgain))) (if (and (is Empty (handSite P1)) (all Sites (sites Bottom) if:(if (is Empty (site)) (is Empty (+ (site) 6)) (is Occupied (+ (site) 6))))) (move Pass))})) (nextPhase (was Pass) "Opening2")) (phase "Opening2" (play (or (move Pass (then (moveAgain))) (move Swap Players P1 P2) (then (set Pending)))) (nextPhase "Sowing")) (phase "Sowing" (play (if (and (not (is Prev Mover)) (all Sites (sites Next) if:(= 0 (count at:(site))))) (move (from (sites Mover) if:(is Occupied (from))) (to (mapEntry "LeftMost" Next))) (move Select (from (if (and (not (is Pending)) (is Prev Mover)) (sites {(var "Replay")}) (sites Mover)) if:(is Occupied (from))) (then (sow if:True apply:(if (is Odd (count at:(to))) (and (moveAgain) (set Var "Replay" (to))) (and (fromTo (from (to)) (to (handSite Mover)) count:(count at:(to))) (if (is Occupied (if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6))) (fromTo (from (if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6))) (to (handSite Mover)) count:(count at:(if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6))))))) backtracking:(and (is Occupied (to)) (is Even (count at:(to))))))) (then (if (all Sites (sites Board) if:(= 0 (count at:(site)))) (and (if (< (count Cell at:(handSite P1)) (count Cell at:(handSite P2))) (addScore P2 (- (count Cell at:(handSite P2)) (count Cell at:(handSite P1)))) (addScore P1 (- (count Cell at:(handSite P1)) (count Cell at:(handSite P2))))) (if (is Occupied Cell (handSite P2)) (fromTo (from (handSite P2)) (to (handSite P1)) count:(count Cell at:(handSite P2))))))))) (nextPhase (all Sites (sites Board) if:(= 0 (count at:(site)))) "Opening1"))} (end (forEach Player if:(<= 60 (score Player)) (result Player Win))))) 
2x6 board. 72 counters are distributed unevenly into the holes by one player in both rows, placing at least four in each hole. The opponent moves first, but may flip the board around if they prefer that arrangement. Each move must begin from the rightmost hole in a player's row or the next closest hole to it from which it is possible to move. Counters are sowed in an anti-clockwise direction. If the last counter falls into a hole making it odd, these are picked up and sowing continues. If it lands in a hole making it even, these counters are captured as are the ones in the opposite hole. If the previous hole also has an even number, these and the ones in the opposite hole are captured. If the last counter falls into an empty hole, the turn ends. If a player has no counters in their holes, the opponent must give them one counter, to be placed in the leftmost hole and played from there. Play ends when the board is cleared of counters. Each player counts the number of counters they captured. The player with more counters is given a score equal to the difference in the number of counters. Another round begins as before, with the loser distributing the counters and the winner playing first.. The game is won when a player accumulates sixty points.
(game "Li'b al-Ghashim" (players 2) (equipment {(mancalaBoard 2 6 store:None {(track "TrackCCW" "0,E,N,W" loop:True) (track "TrackCW" "5,W,N,E" loop:True)}) (piece "Seed" Shared) (hand Each) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map "RightMost" {(pair P1 5) (pair P2 6)})}) (rules (start (place "Seed" (handSite P1) count:72)) phases:{(phase "Opening1" (play (or {(if (is Occupied Cell (handSite P1)) (forEach Value min:1 max:(count Cell at:(handSite P1)) (move (from (handSite P1)) (to (sites Board)) count:(value))) (forEach Site (sites Board) (if (is Occupied (site)) (move (from (site)) (to (sites Board) if:(!= (to) (from)))))) (then (moveAgain))) (if (and (is Empty (handSite P1)) (all Sites (sites Board) if:(<= 4 (count at:(site))))) (move Pass))})) (nextPhase (was Pass) "Opening2")) (phase "Opening2" (play (or (move Pass (then (and (set Pending) (moveAgain)))) (move Swap Players P1 P2 (then (and (set NextPlayer (player 1)) (set Pending)))))) (nextPhase "Sowing")) (phase "Sowing" (play (if (and (not (is Prev Mover)) (all Sites (sites Next) if:(= 0 (count at:(site))))) (move (from (sites Mover) if:(is Occupied (from))) (to (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(and (is In (to) (sites Mover)) (is Occupied (to)))))) (move Select (from (if (and (not (is Pending)) (is Prev Mover)) (sites {(var "Replay")}) (sites Mover)) if:(is Occupied (from))) (then (sow "TrackCCW" if:True apply:(if (is Odd (count at:(to))) (and (moveAgain) (set Var "Replay" (to))) (and (fromTo (from (to)) (to (handSite Mover)) count:(count at:(to))) (if (is Occupied (if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6))) (fromTo (from (if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6))) (to (handSite Mover)) count:(count at:(if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6))))))) backtracking:(and (is Occupied (to)) (is Even (count at:(to))))))) (then (if (= 1 (count in:(sites Board))) (and {(if (< (count Cell at:(handSite P1)) (count Cell at:(handSite P2))) (addScore P2 (- (count Cell at:(handSite P2)) (count Cell at:(handSite P1)))) (addScore P1 (- (count Cell at:(handSite P1)) (count Cell at:(handSite P2))))) (if (is Occupied Cell (handSite P2)) (fromTo (from (handSite P2)) (to (handSite P1)) count:(count Cell at:(handSite P2)))) (forEach Site (sites Board) (if (is Occupied (site)) (fromTo (from (site)) (to Cell (handSite P1)) count:(count at:(site)))))}))))) (nextPhase (= 1 (count in:(sites Board))) "Opening1"))} (end (forEach Player if:(<= 60 (score Player)) (result Player Win))))) 
2x6 board, with a store hole on either end. Four counters in each hole. Each player owns the six holes, three holes in each row, to their right. Sowing occurs in an anti-clockwise direction, and only in the holes belonging to the player. Play begins with a stylized opening move. The first player takes the counters from the holes in each of the row of holes closest to them, and places them in the central row of their holes in the further row. The counters from the hole next in the direction of sowing are then sown. The counters from the central hole in the further of the player's rows are then sown. When this is completed, the player takes the counters from the holes in the row closest to them, and holds them until the opponent performs the same sequence of moves on their side of the board. At this point, each player places the counters they are holding into any hole on the opponent's side of the board which contains more than one counter. Players then alternate turns sowing pieces around their holes of the board. Sowing always skips the hole from which sowing began. When the final counter of a sowing causes a hole to contain four counters, these counters are placed on any hole on the opponent's side of the board that contains more than one counter. When a player has only single seeds in their holes, and the opponent is about to place counters in the player's holes, the opponent moves one of the player's counters into another hole containing one counter, thus making two, and places the counters from the opponent's side are placed there. The player who is able to place all of their counters on the opponent's side of the board wins. The opening rules of the variant Lontu Holo.
(game "Lontu-Holo" (players 2) (equipment {(mancalaBoard 2 6 {(track "TrackCCW1" {1 2 3 9 8 7} loop:True P1) (track "TrackCCW2" {4 5 6 12 11 10} loop:True P2)}) (regions "Home" P1 (sites Track "TrackCCW1")) (regions "Home" P2 (sites Track "TrackCCW2")) (regions "TwoHolesClosestNotCentre" P1 (sites {1 3})) (regions "TwoHolesClosestNotCentre" P2 (sites {10 12})) (regions "TwoHolesFurtherNotCentre" P1 (sites {7 9})) (regions "TwoHolesFurtherNotCentre" P2 (sites {4 6})) (regions "LeftMostHoles" P1 (intersection (expand (sites Left)) (sites Track "TrackCCW1"))) (regions "LeftMostHoles" P2 (intersection (expand (sites Right)) (sites Track "TrackCCW2"))) (regions "RightMostHoles" P1 (intersection (sites Centre) (sites Track "TrackCCW1"))) (regions "RightMostHoles" P2 (intersection (sites Centre) (sites Track "TrackCCW2"))) (regions "ClosestRow" P1 (intersection (sites Bottom) (sites Track "TrackCCW1"))) (regions "ClosestRow" P2 (intersection (sites Top) (sites Track "TrackCCW2"))) (map "CentreFurtherRow" {(pair P1 8) (pair P2 5)}) (map "CentreClosestRow" {(pair P1 2) (pair P2 11)}) (map "RightFurtherRow" {(pair P1 9) (pair P2 4)}) (map "RightClosestRow" {(pair P1 3) (pair P2 10)}) (map "LeftFurtherRow" {(pair P1 7) (pair P2 6)}) (map "LeftClosestRow" {(pair P1 1) (pair P2 12)}) (piece "Seed" Shared) (map "Store" {(pair P1 FirstSite) (pair P2 LastSite)})}) (rules (start (set Count 4 to:(union (sites Bottom) (sites Top)))) phases:{(phase "Opening1" (play (move (from (sites Mover "TwoHolesClosestNotCentre") if:(is Occupied (from))) (to (mapEntry "CentreFurtherRow" Mover)) count:(count at:(from)))) (nextPhase Mover (all Sites (sites Mover "TwoHolesClosestNotCentre") if:(is Empty (site))) "Opening2")) (phase "Opening2" (play (move Select (from (trackSite Move from:(mapEntry "CentreFurtherRow" Mover) "TrackCCW" steps:1)) (then (sow "TrackCCW" owner:(mover))))) (nextPhase Mover "Opening3")) (phase "Opening3" (play (move Select (from (mapEntry "CentreFurtherRow" Mover)) (then (sow "TrackCCW" owner:(mover))))) (nextPhase Mover "Opening4")) (phase "Opening4" (play (move (from (sites Mover "ClosestRow") if:(is Occupied (from))) (to (mapEntry "Store" Mover)) count:(count at:(from)))) (nextPhase Mover (all Sites (sites Mover "ClosestRow") if:(is Empty (site))) "Opening5")) (phase "Opening5" (play (move (from (mapEntry "Store" Mover)) (to (sites Mover "Home") if:(< 1 (count at:(to)))) count:1)) (nextPhase Mover (is Empty (mapEntry "Store" Mover)) "Sowing")) (phase "Sowing" (play (if (is Prev Mover) (if (all Sites (sites Next "Home") if:(= 1 (count at:(site)))) (move (from (sites Next "Home")) (to (sites Next "Home") if:(!= (from) (to))) count:1 (then (moveAgain))) (move (from (var "Replay")) (to (sites Next "Home") if:(< 1 (count at:(to)))) count:1 (then (if (is Occupied (last From)) (moveAgain))))) (move Select (from (sites Mover "Home") if:(is Occupied (from))) (then (sow "TrackCCW" owner:(mover) apply:(if (= 4 (count at:(to))) (and (moveAgain) (set Var "Replay" (to))))))))) (end (if (all Sites (sites Mover "Home") if:(is Empty (site))) (result Mover Win))))})) 
2x7 board. Four counters per hole. The first player takes all of the counters from one of their holes. If they take from the central hole, they can be placed in any other hole on the board. If they are from any other hole, they can be placed in any hole except the opposite hole on the opponent's side. Once both players have made this initial move, the main phase of the game begins. Players alternate turns taking counters from one of the holes on their side of the board and sowing them. Groups of four counters are always sown. Play can occur in a clockwise or anti-clockwise direction. Players sow four counters at a time; that is, placing four counters in each hole. When the final four counters land in an empty hole in the player's row, any counters in the opponent's opposite hole are captured, and the player may sow again from another hole. Play continues until all of the counters have been captured, and the player with the most counters wins.
(game "Luuth" (players 2) (equipment {(mancalaBoard 2 7 store:None {(track "TrackCCW" "0,E,N,W" loop:True) (track "TrackCW" "6,W,N,E" loop:True)}) (piece "Seed" Shared) (hand Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start (set Count 4 to:(sites Track))) phases:{(phase "Opening" (play (move (from (sites Mover)) (to (if (is In (from) (sites Centre)) (difference (sites Board) (from)) (difference (sites Board) (sites {(from) (if (is Mover P1) (+ (from) 7) (- (from) 7))})))) count:(count at:(from)))) (nextPhase Mover "Sowing")) (phase "Sowing" (play (or (move Select (from (sites Mover) if:(is Occupied (from))) (then (sow numPerHole:4 "TrackCCW" apply:(if (and (is In (to) (sites Mover)) (= 4 (count at:(to)))) (and (moveAgain) (if (is Occupied (if (is Mover P1) (+ (to) 7) (- (to) 7))) (fromTo (from (if (is Mover P1) (+ (to) 7) (- (to) 7))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 7) (- (to) 7)))))))))) (move Select (from (sites Mover) if:(is Occupied (from))) (then (sow numPerHole:4 "TrackCW" apply:(if (and (is In (to) (sites Mover)) (= 4 (count at:(to)))) (and (moveAgain) (if (is Occupied (if (is Mover P1) (+ (to) 7) (- (to) 7))) (fromTo (from (if (is Mover P1) (+ (to) 7) (- (to) 7))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 7) (- (to) 7)))))))))))))} (end (if (= 4 (count Pieces All in:(sites Board))) (byScore {(score P1 (+ (count in:(sites Mover)) (count Cell at:(handSite P1)))) (score P2 (+ (count in:(sites Mover)) (count Cell at:(handSite P2))))}))))) 
2x6-9 holes with a store on either end. Play starts with same number of counters in each hole as number of holes in the row (6 counters if 6 holes in a row, etc). Store on either end. A player's store is the store to their left. Stores are included when sowing. Play begins from any hole belonging to the player. Counters are sowed clockwise: if the final counter lands in an empty hole, in player's own row, they take the counters in the opposite hole and place them in the store. If play ends in the store, they can then take counters from any of their holes and sow again. if play ends in an empty hole in the opponent's row, play ends. If play ends in a hole with counters, those are collected and sowing continues. A round ends when there are no counters left in a player's row. The opponent then takes all remaining counters and adds them to their store. Next round begins with each player taking the counters from their store and placing the same number of counters in the holes as when the game began, starting from right to left. Surplus counters are placed in the store. Unfilled holes are excluded from play in this round. Play continues as before. Play continues with as many rounds as needed until one player does not have enough counters to fill a single hole. Each player has 6 holes.
(game "Main Chongkak" (players 2) (equipment {(mancalaBoard 2 6 (track "Track" "0,ENE,E,ESE,WSW,W" loop:True)) (piece "Seed" Shared) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 FirstSite) (pair P2 LastSite)}) (map "RightMost" {(pair P1 6) (pair P2 (+ 6 1))})}) (rules (start {(set RememberValue "Playable" (union (sites Top) (sites Bottom))) (set Count 6 to:(union (sites Bottom) (sites Top)))}) phases:{(phase "Sowing" (play (or {(move Select (from (if (and (not (is Pending)) (is Prev Mover)) (sites {(var "Replay")}) (sites Mover)) if:(and (is Occupied (from)) (is In (from) (sites (values Remembered "Playable"))))) (then (sow apply:(if (and (is In (to) (sites Mover)) (= 1 (count at:(to)))) (if (is Occupied (if (is Mover P1) (+ (to) 6) (- (to) 6))) (fromTo (from (if (is Mover P1) (+ (to) 6) (- (to) 6))) (to (mapEntry Mover)) count:(count at:(if (is Mover P1) (+ (to) 6) (- (to) 6))))) (if (= (to) (mapEntry Mover)) (and (set Pending) (moveAgain)) (if (and (< 1 (count at:(to))) (!= (to) (mapEntry Next))) (and (moveAgain) (set Var "Replay" (to)))))) skipIf:(and {(not (is In (to) (sites (values Remembered "Playable")))) (!= (to) (mapEntry P1)) (!= (to) (mapEntry P2))}))))} (then (if (or (all Sites (sites Bottom) if:(= 0 (count at:(site)))) (all Sites (sites Top) if:(= 0 (count at:(site))))) (and {(forEach Site (sites P1) (fromTo (from (site)) (to (mapEntry P1)) count:(count at:(site)))) (forEach Site (sites P2) (fromTo (from (site)) (to (mapEntry P2)) count:(count at:(site)))) (forget Value "Playable" All)}))))) (end (if (all Sites (union (sites Top) (sites Bottom)) if:(= 0 (count at:(site)))) {(if (> 6 (count at:(mapEntry P1))) (result P2 Win)) (if (> 6 (count at:(mapEntry P2))) (result P1 Win))})) (nextPhase (all Sites (union (sites Top) (sites Bottom)) if:(= 0 (count at:(site)))) "BetweenRounds")) (phase "BetweenRounds" (play (if (not (all Sites (sites Mover) if:(is Occupied (site)))) (if (<= 6 (count at:(mapEntry Mover))) (move (from (mapEntry Mover)) (to (trackSite FirstSite from:(mapEntry "RightMost" Mover) if:(is Empty (to)))) count:6 (then (remember Value "Playable" (last To))))))) (nextPhase (all Passed) "Sowing"))})) 
2x6 board. Seventy counters. One player distributes the counters unevenly in the central four holes (central two holes of each row). The opponent then has the option to flip the board around if they are not satisfied with the distribution. Opponent begins play. The first move must be from the fourth hole in the row. Sowing occurs in a clockwise direction. Capturing cannot happen on the first move. If the last counter is dropped into a hole, creating an odd number of counters in it, play ends. If the number is now even and the hole in the other player's row also has an even number, the contents of both holes are captured. If the final hole is now even but the other player's row does not have an even number of counters, the counters are picked up and a new sowing begins. If the final hole has more than ten counters it cannot be captured and sowing must continue from this hole whether the number is even or odd. Play ends when a player has no more counters on their side of the board. The player who has captured the greatest number of counters wins.
(game "Mangala (Bedouin)" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "5,W,N,E" loop:True)) (piece "Seed" Shared) (hand Each) (hand Shared) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map "FourthHole" {(pair P1 3) (pair P2 8)})}) (rules (start (place "Seed" (handSite Shared) count:17)) phases:{(phase "OpeningP1" (play (move (from (handSite Shared)) (to (sites Centre)) (then (if (is Occupied (handSite Shared)) (moveAgain))))) (nextPhase (is Empty (handSite Shared)) "OpeningP2")) (phase "OpeningP2" (play (or (move Pass) (if (is Mover P2) (move Pass (then (and {(remove (sites Centre)) (add (piece (id "Seed" Shared)) (to 9) count:(count at:2)) (add (piece (id "Seed" Shared)) (to 2) count:(count at:9)) (add (piece (id "Seed" Shared)) (to 8) count:(count at:3)) (add (piece (id "Seed" Shared)) (to 3) count:(count at:8))})))))) (nextPhase (all Passed) "SowingRestricted")) (phase "SowingRestricted" (play (move Select (from (mapEntry Mover) if:(is Occupied (from))) (then (sow)))) (nextPhase Mover "Sowing")) (phase "Sowing" (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover)) if:(> (count at:(from)) 0)) (then (sow apply:(if (< 10 (count at:(to))) (moveAgain) (if (is Even (count at:(to))) (if (is Even (count at:(if (is Mover P1) (+ (to) 6) (- (to) 6)))) (and (fromTo (from (to)) (to (handSite Mover)) count:(count at:(to))) (fromTo (from (if (is Mover P1) (+ (to) 6) (- (to) 6))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 6) (- (to) 6))))) (moveAgain)))))))) (end (if (or (all Sites (sites P1) if:(= 0 (count at:(site)))) (all Sites (sites P2) if:(= 0 (count at:(site))))) (byScore {(score P1 (count Cell at:(handSite P1))) (score P2 (count Cell at:(handSite P2)))}))))})) 
2x6 board. Eight counters in each hole; two holes in one player's row and one in the opponent's row are left empty. Sowing in an anti-clockwise direction. No captures in first two turns. If the last counter falls into a hole that is occupied, these are picked up and the sowing continues. When the last counter of a sowing falls into an empty hole, the counters in the opposite hole are captured. The player continues play by moving the counter that made the capture into the next hole, and continuing play. If the last counter falls into an empty hole and the opposite hole is also empty, the turn ends. The player who captures the most counters wins.
(game "Mangala (Suez)" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "0,E,N,W" loop:True)) (piece "Seed" Shared) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (hand Each)}) (rules (start (set Count 8 to:(sites Track))) phases:{(phase "Opening" (play (move Remove (sites Mover) count:(count at:(to)))) (nextPhase (<= 3 (count Turns)) "Sowing")) (phase "Sowing" (play (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover)) if:(is Occupied (from))) (then (sow apply:(if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to))) (if (<= 7 (count Turns)) (if (is Occupied (if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6))) (and {(fromTo (from (if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6))) (to (handSite Mover)) count:(count at:(if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6)))) (moveAgain) (set Var "Replay" (to))})))))))) (end (if (no Moves Next) (byScore {(score P1 (+ (count Cell at:(handSite P1)) (count in:(sites P1)))) (score P2 (+ (count Cell at:(handSite P2)) (count in:(sites P2))))}))))})) 
2x7 board. The game starts with five counters in each hole. Play begins from a player's hole, sowing in a counter clockwise direction. If the last counter is sown in a hole containing one or three counters, they are taken. if the previous hole also has one or three, these are also taken. Play continues until all the holes are empty. The taken stones are then placed five in each hole, and the player with more counters than that needed to fill the holes in their row wins. Each player has 7 holes.
(game "Mangala (Turkey)" (players 2) (equipment {(mancalaBoard 2 7 store:None (track "Track" "0,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 5 to:(sites Track))) (play (move Select (from (sites Mover) if:(> (count at:(from)) 0)) (then (sow if:(or (= (count at:(to)) 1) (= (count at:(to)) 3)) apply:(fromTo (from (to)) (to (handSite Mover)) count:(count at:(to))) backtracking:True)))) (end (if (= (count in:(sites Track)) 0) (byScore {(score P1 (count Cell at:(handSite P1))) (score P2 (count Cell at:(handSite P2)))}))))) 
2x6 board. Six counters in each hole. Players take the contents of one of their holes and sow in an anti-clockwise direction. When the final counter of a sowing lands in a hole, making it contain two, four, or six counters, these counters are taken. If the second to last hole also contains two, four, or six counters, these are also taken, continuing in an unbroken line until a hole with containing a number of counters other than two, four, or six. The game continues until all of the counters have been captured. The player who captured the most counters wins.
(game "Mankala" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "0,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 6 to:(sites Track))) (play (move Select (from (sites Mover) if:(< 0 (count at:(from)))) (then (sow if:(or {(= (count at:(to)) 2) (= (count at:(to)) 4) (= (count at:(to)) 6)}) apply:(fromTo (from (to)) (to (handSite Mover)) count:(count at:(to))) backtracking:True)))) (end (if (and (no Moves Next) (no Moves Mover)) (byScore {(score P1 (count Cell at:(handSite P1))) (score P2 (count Cell at:(handSite P2)))}))))) 
2x7 board. Five counters in each hole. Players sow in a clockwise direction. When the final counter lands in a hole, the contents of the next hole are picked up and sowing continues. When the final counter is sown and the next hole is empty, the contents of the hole in the opposite row of the empty hole are captured. Play continues until all of the counters are captured. A new game begins. The players fill their holes with five counters in each, starting from their left. The player who has remaining counters after all of their holes are full puts the extra counters aside. The player who has fewer counters places the remainder in the next empty hole. Any empty holes are out of play for the round. Play begins with the same rules, with the following modifications: Each player, during their opponent's turn, also captures counters in any hole that are made to equal the number of extra counters they had at the beginning of this round (i.e., the number of counters set aside by the winning player or the number of counters less than five that placed in the final hole by the loser). The player who could fill their holes will capture one counter each time that player sows into the hole in which the opponent placed fewer than five counters at the beginning of the round. The opponent cannot sow in this hole. In addition, at the end of the round, the player who filled their holes at the beginning of the round will always capture pieces that accumulate in this hole. Subsequent rounds are played like this until one player captures all of the counters, and thus wins.
(game "Mawkar Katiya" (players 2) (equipment {(mancalaBoard 2 7 store:None {(track "TrackCW" "6,W,N,E" loop:True) (track "TrackCCW" "0,E,N,W" loop:True)}) (piece "Seed" Shared) (hand Each) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map "LeftMost" {(pair P1 0) (pair P2 13)})}) (rules (start {(set Count 5 to:(sites Track "TrackCW")) (set RememberValue "Playable" (union (sites Top) (sites Bottom)))}) phases:{(phase "Sowing" (play (or {(move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover)) if:(and {(is Occupied (from)) (is In (from) (sites (values Remembered "Playable"))) (!= (next) (state at:(from)))})) (then (do (and (set Var "NumSowed" (count at:(last To))) (set Var "StateSowFrom" (state at:(last To)))) next:(sow "TrackCW" apply:(if (is Occupied (trackSite Move from:(to) "Track" steps:1)) (and (moveAgain) (set Var "Replay" (trackSite Move from:(to) "Track" steps:1))) (if (is Occupied (if (is In (trackSite Move from:(to) "Track" steps:1) (sites Bottom)) (+ (trackSite Move from:(to) "Track" steps:1) 7) (- (trackSite Move from:(to) "Track" steps:1) 7))) (and (fromTo (from (if (is In (trackSite Move from:(to) "Track" steps:1) (sites Bottom)) (+ (trackSite Move from:(to) "Track" steps:1) 7) (- (trackSite Move from:(to) "Track" steps:1) 7))) (to (handSite Mover)) count:(count at:(if (is In (trackSite Move from:(to) "Track" steps:1) (sites Bottom)) (+ (trackSite Move from:(to) "Track" steps:1) 7) (- (trackSite Move from:(to) "Track" steps:1) 7)))) (set State at:(if (is In (trackSite Move from:(to) "Track" steps:1) (sites Bottom)) (+ (trackSite Move from:(to) "Track" steps:1) 7) (- (trackSite Move from:(to) "Track" steps:1) 7)) (state at:(if (is In (trackSite Move from:(to) "Track" steps:1) (sites Bottom)) (+ (trackSite Move from:(to) "Track" steps:1) 7) (- (trackSite Move from:(to) "Track" steps:1) 7))))))) skipIf:(or (and (!= (state at:(to)) (mover)) (!= (state at:(to)) 0)) (not (is In (to) (sites (values Remembered "Playable")))))) (then (and {(forEach Site (sites Track from:(last From) to:(trackSite Move from:(last From) "Track" steps:(var "NumSowed"))) (if (and (= (value Player Mover) (count at:(site))) (or (= (state at:(site)) (mover)) (= (state at:(site)) 0))) (and (fromTo (from (site)) (to (handSite Mover)) count:(value Player Mover)) (set State at:(site) (state at:(site)))) (if (and (is Occupied (site)) (= (mover) (state at:(site)))) (and (fromTo (from (site)) (to (handSite Mover)) count:1) (set State at:(site) (state at:(site))))))) (set Var "NumSowed" 0) (if (< 0 (var "StateSowFrom")) (set State at:(last From) (var "StateSowFrom")))})))))} (then (if (all Sites (forEach (sites Board) if:(= 0 (state at:(site)))) if:(= 0 (count at:(site)))) (and {(forEach Site (sites Board) (and (if (= (state at:(site)) 1) (fromTo (from (site)) (to (handSite P1)) count:(count at:(site)))) (if (= (state at:(site)) 2) (fromTo (from (site)) (to (handSite P2)) count:(count at:(site)))))) (forget Value "Playable" All) (if (>= (count Cell at:(handSite P1)) (count Cell at:(handSite P2))) (set Var "CurrentWinner" 1) (set Var "CurrentWinner" 2)) (set Value P2 0) (set Value P1 0) (forEach Site (sites Board) (if (!= 0 (state at:(site))) (set State at:(site) 0)))}))))) (end (if (all Sites (forEach (sites Board) if:(= 0 (state at:(site)))) if:(= 0 (count at:(site)))) {(if (= 0 (count Cell at:(handSite P1))) (result P2 Win)) (if (= 0 (count Cell at:(handSite P2))) (result P1 Win))})) (nextPhase (all Sites (forEach (sites Board) if:(= 0 (state at:(site)))) if:(= 0 (count at:(site)))) "BetweenRounds")) (phase "BetweenRounds" (play (if (not (all Sites (sites Mover) if:(is Occupied (site)))) (if (<= 5 (count Cell at:(handSite Mover))) (move (from (handSite Mover)) (to (trackSite FirstSite "TrackCCW" from:(mapEntry "LeftMost" Mover) if:(is Empty (to)))) count:5 (then (remember Value "Playable" (last To)))) (if (and (!= 0 (count Cell at:(handSite Mover))) (!= (mover) (var "CurrentWinner"))) (move (from (handSite Mover)) (to (trackSite FirstSite "TrackCCW" from:(mapEntry "LeftMost" Mover) if:(is Empty (to)))) count:(count Cell at:(handSite Mover)) (then (and {(remember Value "Playable" (last To)) (set Value Mover (count at:(last To))) (set State at:(last To) (next))}))))) (if (= (mover) (var "CurrentWinner")) (move Pass (then (set Value Mover (count Cell at:(handSite Mover)))))))) (nextPhase (all Passed) "Sowing"))})) 
2x6 board with two stores. Play begins with four counters in each hole. A move begins from any of a player's holes, sowing happens anti-clockwise. Move ends if the last counter falls into an empty hole. If it lands in a hole with counters, these are picked up and sowing continues, unless the sowing makes the last hole contain four counters, in which case these are captured and the sowing continues from the next hole. When both players have too few counters to play, each one makes one move with one of their counters and then adds all of the counters on their side of the board to the store. The player with the most counters in the store wins.
(game "Meusueb" (players 2) (equipment {(mancalaBoard 2 6 (track "Track" "1,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 FirstSite) (pair P2 LastSite)}) (piece "Seed" Shared)}) (rules (start (set Count 4 to:(sites Track))) (play (move Select (from (if (is Prev Mover) (if (is Pending) (sites {(trackSite Move from:(last From afterConsequence:True) steps:1)}) (sites {(last To afterConsequence:True)})) (sites Mover)) if:(> (count at:(from)) 0)) (then (sow apply:(if (= (count at:(to)) 4) (and (fromTo (from (to)) (to (mapEntry (mover))) count:(count at:(to))) (if (> (count at:(trackSite Move from:(to) steps:1)) 0) (and (moveAgain) (set Pending)))) (if (> (count at:(to)) 1) (moveAgain))))))) (end (if (no Moves Mover) (byScore {(score P1 (+ (count at:(mapEntry P1)) (count in:(sites P1)))) (score P2 (+ (count at:(mapEntry P2)) (count in:(sites P2))))}))))) 
2x6 board. Play begins with four counters in each hole. Players begin the game simultaneously, sowing according to the rules below, until one player drops their final counter into an empty hole. A player picks up the contents of any of their holes and sowing them in an anti-clockwise direction, picking up the contents of the last hole in which his counters fall, and continuing sowing. This continues until the last counter falls in an empty hole. Then it is the other player's turn. A hole is captured when the last ball is dropped into an opponent's hole containing three counters, making it four. A player cannot then take from one of these holes that they have captured. Therefore, the player cannot begin a turn from their own captured hole nor can they continue sowing from it. If the last counter of a sowing falls into an opponent's captured hole, nothing happens on the first instance, but every time after that, one of those counters are removed from the board and placed in the store, and the sowing continues with the contents of any of the player's holes. Ownership of a hole continues even if it becomes empty. When a player cannot move (i.e., there are no counters in their holes except any that are in captured holes), the opponent continues to move until the player is able to move. Play continues until all counters are either placed in the store or in captured holes and thus cannot be moved. Players then count their pieces by placing four in each hole, and the player who has more than their original number takes ownership of one of the opponent's holes for every four counters more than the original number that have been taken. If no player took four more than the original, the player with three extra gets the hole, if each player has two extra the weaker player is given the two extra counters. Play then begins again as before. The game ends when one player owns all of the counters, and thus all of the holes.
(game "Mewegae" (players 2) (equipment {(mancalaBoard 2 6 store:None {(track "TrackCCW" "0,E,N,W" loop:True) (track "TrackCW" "5,W,N,E" loop:True)}) (piece "Seed" Shared) (hand Each) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map "RightMost" {(pair P1 5) (pair P2 6)})}) (rules (start {(set RememberValue "OwnedP1" (sites Bottom)) (set RememberValue "OwnedP2" (sites Top)) (set Count 4 to:(sites Track))}) phases:{(phase "Sowing" (play (or {(move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (if (is Mover P1) (sites (values Remembered "OwnedP1")) (sites (values Remembered "OwnedP2")))) if:(and (< 0 (count at:(from))) (= 0 (state at:(from))))) (then (sow "TrackCCW" apply:(if (and (= 0 (state at:(to))) (= 4 (count at:(to)))) (set State at:(to) (mover)) (if (< 1 (count at:(to))) (if (= 0 (state at:(to))) (and (moveAgain) (set Var "Replay" (to))) (if (!= (mover) (state at:(to))) (if (is In (to) (if (is Mover P1) (sites (values Remembered "CanCaptureP1")) (sites (values Remembered "CanCaptureP2")))) (and (fromTo (from (to)) (to (handSite Mover)) count:1) (set State at:(to) (state at:(to)))) (if (is Mover P1) (remember Value "CanCaptureP1" (to)) (remember Value "CanCaptureP2" (to)))))))))))} (then (if (all Sites (forEach (sites Board) if:(= 0 (state at:(site)))) if:(= 0 (count at:(site)))) (and {(forEach Site (forEach (sites Board) if:(= 1 (state at:(site)))) (fromTo (from (site)) (to (handSite P1)) count:(count at:(site)))) (forEach Site (forEach (sites Board) if:(= 2 (state at:(site)))) (fromTo (from (site)) (to (handSite P2)) count:(count at:(site)))) (forget Value "OwnedP1" All) (forget Value "OwnedP2" All) (forget Value "CanCaptureP1" All) (forget Value "CanCaptureP2" All) (set Var "Round" (+ 1 (var "Round")))}))))) (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) {(if (>= 1 (count Cell at:(handSite P1))) (result P2 Win)) (if (>= 1 (count Cell at:(handSite P2))) (result P1 Win))})) (nextPhase (all Sites (sites Board) if:(= 0 (count at:(site)))) "BetweenRounds")) (phase "BetweenRounds" (play (if (<= 4 (count Cell at:(handSite Mover))) (move (from (handSite Mover)) (to (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))) count:4 (then (and {(if (is Mover P1) (remember Value "OwnedP1" (last To)) (remember Value "OwnedP2" (last To))) (if (<= 4 (count Cell at:(handSite Mover))) (moveAgain) (if (= 3 (count Cell at:(handSite Mover))) (and {(fromTo (from (handSite Mover)) (to (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))) count:3) (fromTo (from (handSite Next)) (to (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))) count:1) (if (is Mover P1) (remember Value "OwnedP1" (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))) (remember Value "OwnedP2" (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))))}) (if (= 2 (count Cell at:(handSite Mover))) (and {(fromTo (from (handSite Mover)) (to (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))) count:2) (fromTo (from (handSite Next)) (to (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))) count:2) (if (< 50 (value Random (range 1 100))) (remember Value "OwnedP1" (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))) (remember Value "OwnedP2" (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))))}))))}))) (then (if (and (is Empty (handSite P1)) (is Empty (handSite P2))) (and (if (is Even (var "Round")) (set NextPlayer (player 2)) (set NextPlayer (player 1))) (set Pending)))))) (nextPhase (and (is Empty (handSite P1)) (is Empty (handSite P2))) "Sowing"))})) 
2x6 board. Four counters per hole. Play begins with a simultaneous racing move, where players attempt to be the first to drop the final counter of their sowing into an empty hole. Sowing occurs in an anti-clockwise direction. If the final counter falls into an occupied hole, these are picked up and sowing continues. If the final counter falls into an empty hole, the turn ends. At any time during the sowing, if a hole is made to contain four counters, the owner of the hole in which the four counters are located captures them, unless it is the final hole of the sowing, in which case the player who is sowing captures them. Play continues until a player can no longer move because there are no counters in their row, and the opponent captures the remaining counters. Players then count their pieces by placing four in each hole, and the player who has more than their original number takes ownership of one of the opponent's holes for every four counters more than the original number that have been taken. If no player took four more than the original, the player with three extra gets the hole. Play then begins again as before. The game ends when one player owns all of the counters, and thus all of the holes.
(game "Mewelad" (players 2) (equipment {(mancalaBoard 2 6 store:None {(track "TrackCCW" "0,E,N,W" loop:True) (track "TrackCW" "5,W,N,E" loop:True)}) (piece "Seed" Shared) (hand Each) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map "RightMost" {(pair P1 5) (pair P2 6)})}) (rules (start {(set Count 4 to:(sites Track)) (set RememberValue "OwnedP1" (sites Bottom)) (set RememberValue "OwnedP2" (sites Top))}) phases:{(phase "Sowing" (play (or {(move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (if (is Mover P1) (sites (values Remembered "OwnedP1")) (sites (values Remembered "OwnedP2")))) if:(is Occupied (from))) (then (do (set Var "NumSowed" (count at:(last To))) next:(sow "TrackCCW" apply:(if (= 4 (count at:(to))) (fromTo (from (to)) (to (handSite Mover)) count:4) (if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to)))))) (then (and (forEach Site (sites Track from:(last From) to:(trackSite Move from:(last From) "Track" steps:(- (var "NumSowed") 1))) (if (= 4 (count at:(site))) (fromTo (from (site)) (to (if (is In (to) (sites (values Remembered "OwnedP1"))) (handSite P1) (handSite P2))) count:4))) (set Var "NumSowed" 0))))))} (then (if (and (not (is Next Mover)) (or (all Sites (sites (values Remembered "OwnedP1")) if:(is Empty (site))) (all Sites (sites (values Remembered "OwnedP2")) if:(is Empty (site))))) (and {(if (no Moves P1) (forEach Site (sites Board) (if (is Occupied (site)) (fromTo (from (site)) (to (handSite P1)) count:(count at:(site))))) (forEach Site (sites Board) (if (is Occupied (site)) (fromTo (from (site)) (to (handSite P2)) count:(count at:(site)))))) (forget Value "OwnedP1" All) (forget Value "OwnedP2" All)}))))) (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) {(if (> 3 (count Cell at:(handSite P1))) (result P2 Win)) (if (> 3 (count Cell at:(handSite P2))) (result P1 Win))})) (nextPhase (all Sites (sites Board) if:(= 0 (count at:(site)))) "BetweenRounds")) (phase "BetweenRounds" (play (if (<= 3 (count Cell at:(handSite Mover))) (move (from (handSite Mover)) (to (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))) count:(if (>= (count Cell at:(handSite Mover)) 4) 4 3) (then (if (is Mover P1) (remember Value "OwnedP1" (last To)) (remember Value "OwnedP2" (last To))))))) (nextPhase (all Passed) "Sowing"))})) 
2x7 board. Four counters in each hole. Sowing occurs in an anti-clockwise direction and begins from one of the holes in the player's row. When the final counter lands in an occupied hole, these are picked up and sowing continues. If the occupied hole has three counters (four including the final counter from the sowing), these are captured. Then, the player picks up the counters in the next hole after the one from which the capture was made and continues sowing from there. When the final counter lands into an empty hole the turn ends. The game ends when one player no longer has any counters on their side of the board. The opponent then captures the remaining counters on the board. A new game begins, with each player filling holes with the counters they captured, four to each hole. The player now controls as many holes as they can fill with counters. Play begins with the player who played second in the previous game. Subsequent games are played until one player captures all of the holes, becoming the winner.
(game "Motiq" (players 2) (equipment {(mancalaBoard 2 7 store:None (track "Track" "0,E,N,W" loop:True)) (regions "Home" P1 (sites Bottom)) (regions "Home" P2 (sites Top)) (piece "Seed" Shared) (hand Each)}) (rules (start {(set Count 4 to:(sites Track)) (set RememberValue "OwnedP1" (sites Bottom)) (set RememberValue "OwnedP2" (sites Top))}) phases:{(phase "Sowing" (play (or {(move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (if (is Mover P1) (sites (values Remembered "OwnedP1")) (sites (values Remembered "OwnedP2")))) if:(is Occupied (from))) (then (sow apply:(if (= 4 (count at:(to))) (and (fromTo (from (to)) (to (handSite Mover)) count:4) (if (is Occupied (trackSite Move from:(to) steps:1)) (and (moveAgain) (set Var "Replay" (trackSite Move from:(to) steps:1))))) (if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to))))))))} (then (if (or (all Sites (sites P1) if:(= 0 (count at:(site)))) (all Sites (sites P2) if:(= 0 (count at:(site))))) (and {(forEach Site (sites P1) (fromTo (from (site)) (to (handSite P1)) count:(count at:(site)))) (forEach Site (sites P2) (fromTo (from (site)) (to (handSite P2)) count:(count at:(site)))) (forget Value "OwnedP1" All) (forget Value "OwnedP2" All)}))))) (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) {(if (> 4 (count Cell at:(handSite P1))) (result P2 Win)) (if (> 4 (count Cell at:(handSite P2))) (result P1 Win))})) (nextPhase (all Sites (sites Board) if:(= 0 (count at:(site)))) "BetweenRounds")) (phase "BetweenRounds" (play (if (<= 4 (count Cell at:(handSite Mover))) (move (from (handSite Mover)) (to (if (all Sites (sites Mover) if:(is Occupied (site))) (sites Board) (sites Mover)) if:(is Empty (to))) count:4 (then (if (is Mover P1) (remember Value "OwnedP1" (last To)) (remember Value "OwnedP2" (last To))))))) (nextPhase (all Passed) "Sowing"))})) 
2x8 board. Four counters per hole. Players alternate turns taking the counters from one of the holes in their row and sowing them in an anticlockwise direction. When the final counter falls into a hole containing one or three counters, causing it to contain two or four, these counters are captured. Play continues until all of the counters have been captured. The player who captured the most counters wins.
(game "Ntyenge" (players 2) (equipment {(mancalaBoard 2 8 store:None (track "Track" "0,E,N,W" loop:True)) (piece "Seed" Shared) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (hand Each)}) (rules (start (set Count 4 to:(sites Track))) (play (move Select (from (sites Mover) if:(> (count at:(from)) 0)) (then (sow apply:(if (or (= 2 (count at:(to))) (= 4 (count at:(to)))) (fromTo (from (to)) (to (handSite Mover)) count:(count at:(to)))))))) (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) (byScore {(score P1 (+ (count Cell at:(handSite P1)) (count in:(sites P1)))) (score P2 (+ (count Cell at:(handSite P2)) (count in:(sites P2))))}))))) 
Oval board. Two semi-circles on the ends are stores, the middle section divided into two rows of five squares. Five counters in each of the rows of squares and one large stone in each end space. Sowing begins in any of the squares on the player's side of the board, and proceeds in either direction. Sowing also includes both end spaces. When the final counter is sown, the contents of the next square are picked up and sowing continues. If the end space is the next space, the turn ends. When the space after the one in which the final counter fell is empty, the contents of the hole after the empty hole are captured, including the end spaces. If there is an unbroken sequence of alternating empty and occupied squares, the contents of the occupied squares are captured. If there are two or more empty squares, the turn ends. If at any time the squares in a player's rows are empty, the player must place one of their captured counters into each of their squares. The game ends when both of the large stones in the end spaces are captured. The remaining counters belong to the player on whose row they are placed. The player with the most counters wins, with the large stones counting as ten. A new game begins. Players fill their holes with their captured stones. The player with fewer counters must then "sell" holes on their side to the opponent to have enough counters to fill the holes. If the difference in the number of captured counters is less than ten, the opponent is given half-ownership of a space, and the contents of it at the end of the game are split between the two players. If the difference is ten, the opponent then may take all of the stones from a sold space at the end of the game. The player may regain sold spaces on subsequent rounds by capturing ten counters more than their opponent. The game is then played as before. Games are played until three or four squares in the same row have been sold. The rules come from the Mancala World.
(game "O An Quan" (players 2) (equipment {(mancalaBoard 2 5 largeStack:True {(track "TrackCCW" "0,1,E,11,10,W" loop:True) (track "TrackCW" "0,6,E,11,5,W" loop:True)}) (piece "Seed" Shared) (piece "Ball" Shared) (hand Each size:2) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 FirstSite) (pair P2 LastSite)}) (regions "EndHoles" (sites {"A1" "G1"}))}) (rules (start {(place Stack "Seed" (union (sites Bottom) (sites Top)) count:5) (place Stack "Ball" (sites {"A1" "G1"})) (set RememberValue "OwnedP1" (sites Bottom)) (set RememberValue "OwnedP2" (sites Top))}) phases:{(phase "Sowing" (play (or {(if (!= (var "Direction") 2) (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (if (is Mover P1) (sites (values Remembered "OwnedP1")) (sites (values Remembered "OwnedP2")))) if:(!= 0 (size Stack at:(from)))) (then (and {(forEach Value min:1 max:(size Stack at:(last From)) (fromTo (from (last From) level:(- (size Stack at:(last From)) (value))) (to (trackSite Move from:(last From) "TrackCCW" steps:(value))) stack:True)) (if (or (is In (trackSite Move from:(last From) "TrackCCW" steps:(+ 1 (size Stack at:(last From)))) (sites "EndHoles")) (>= (size Stack at:(last From)) 10)) (set Var "Direction" 0) (if (!= 0 (size Stack at:(trackSite Move from:(last From) "TrackCCW" steps:(+ 1 (size Stack at:(last From)))))) (and {(set Var "Direction" 1) (moveAgain) (set Var "Replay" (trackSite Move from:(last From) "TrackCCW" steps:(+ 1 (size Stack at:(last From)))))}) (and (set Var "Direction" 0) (if (is Occupied (trackSite Move from:(last From) "TrackCCW" steps:(+ 2 (size Stack at:(last From))))) (forEach Level (trackSite Move from:(last From) "TrackCCW" steps:(+ 2 (size Stack at:(last From)))) FromTop (if (= (id "Seed" Shared) (what at:(trackSite Move from:(last From) "TrackCCW" steps:(+ 2 (size Stack at:(last From)))) level:(level))) (fromTo (from (trackSite Move from:(last From) "TrackCCW" steps:(+ 2 (size Stack at:(last From)))) level:(level)) (to (handSite Mover))) (fromTo (from (trackSite Move from:(last From) "TrackCCW" steps:(+ 2 (size Stack at:(last From)))) level:(level)) (to (handSite Mover 1)))))))))})))) (if (!= (var "Direction") 1) (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (if (is Mover P1) (sites (values Remembered "OwnedP1")) (sites (values Remembered "OwnedP2")))) if:(!= 0 (size Stack at:(from)))) (then (and (forEach Value min:1 max:(size Stack at:(last From)) (fromTo (from (last From) level:(- (size Stack at:(last From)) (value))) (to (trackSite Move from:(last From) "TrackCW" steps:(value))) stack:True)) (if (or (is In (trackSite Move from:(last From) "TrackCW" steps:(+ 1 (size Stack at:(last From)))) (sites "EndHoles")) (>= (size Stack at:(last From)) 10)) (set Var "Direction" 0) (if (!= 0 (size Stack at:(trackSite Move from:(last From) "TrackCW" steps:(+ 1 (size Stack at:(last From)))))) (and {(set Var "Direction" 2) (moveAgain) (set Var "Replay" (trackSite Move from:(last From) "TrackCW" steps:(+ 1 (size Stack at:(last From)))))}) (and (set Var "Direction" 0) (if (is Occupied (trackSite Move from:(last From) "TrackCW" steps:(+ 2 (size Stack at:(last From))))) (forEach Level (trackSite Move from:(last From) "TrackCW" steps:(+ 2 (size Stack at:(last From)))) FromTop (if (= (id "Seed" Shared) (what at:(trackSite Move from:(last From) "TrackCW" steps:(+ 2 (size Stack at:(last From)))) level:(level))) (fromTo (from (trackSite Move from:(last From) "TrackCW" steps:(+ 2 (size Stack at:(last From)))) level:(level)) (to (handSite Mover))) (fromTo (from (trackSite Move from:(last From) "TrackCW" steps:(+ 2 (size Stack at:(last From)))) level:(level)) (to (handSite Mover 1)))))))))))))} (then (if (= 2 (count Cell in:(sites {(handSite P1 1) (handSite P2 1)}))) (and {(forEach Site (intersection (sites (values Remembered "OwnedP1")) (sites (values Remembered "OwnedP2"))) (if (is Occupied (site)) (and (forEach Level (site) FromTop (if (>= (level) (/ (size Stack at:(site)) 2)) (fromTo (from (site) level:(level)) (to (handSite P1)) stack:True))) (forEach Level (site) FromTop (if (< (level) (/ (size Stack at:(site)) 2)) (fromTo (from (site) level:(level)) (to (handSite P2)) stack:True)))))) (forEach Site (union (difference (sites (values Remembered "OwnedP1")) (sites (values Remembered "OwnedP2"))) (sites {(mapEntry P1)})) (if (is Occupied (site)) (forEach Level (site) FromTop (fromTo (from (site) level:(level)) (to (handSite P1)) stack:True)))) (forEach Site (union (difference (sites (values Remembered "OwnedP2")) (sites (values Remembered "OwnedP1"))) (sites {(mapEntry P2)})) (if (is Occupied (site)) (forEach Level (site) FromTop (fromTo (from (site) level:(level)) (to (handSite P2)) stack:True)))) (forget Value "OwnedP1" All) (forget Value "OwnedP2" All)}) (and (if (and (if (= 1 P1) (no Pieces All in:(sites (values Remembered "OwnedP1"))) (no Pieces All in:(sites (values Remembered "OwnedP2")))) (>= (size Stack Cell at:(handSite P1)) (if (= 1 P1) (count Sites in:(sites (values Remembered "OwnedP1"))) (count Sites in:(sites (values Remembered "OwnedP2")))))) (forEach Value min:1 max:(if (= 1 P1) (count Sites in:(sites (values Remembered "OwnedP1"))) (count Sites in:(sites (values Remembered "OwnedP2")))) (fromTo (from Cell (handSite P1) level:(- (size Stack Cell at:(handSite P1)) (value))) (to (regionSite (sites (values Remembered "OwnedP1")) index:(- (value) 1))) stack:True))) (if (and (if (= 1 P2) (no Pieces All in:(sites (values Remembered "OwnedP1"))) (no Pieces All in:(sites (values Remembered "OwnedP2")))) (>= (size Stack Cell at:(handSite P2)) (if (= 1 P2) (count Sites in:(sites (values Remembered "OwnedP1"))) (count Sites in:(sites (values Remembered "OwnedP2")))))) (forEach Value min:1 max:(if (= 1 P2) (count Sites in:(sites (values Remembered "OwnedP1"))) (count Sites in:(sites (values Remembered "OwnedP2")))) (fromTo (from Cell (handSite P2) level:(- (size Stack Cell at:(handSite P2)) (value))) (to (regionSite (sites (values Remembered "OwnedP2")) index:(- (value) 1))) stack:True)))))))) (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) {(if (>= 9 (size Stack Cell at:(handSite P1))) (result P2 Win)) (if (>= 9 (size Stack Cell at:(handSite P2))) (result P1 Win))})) (nextPhase (all Sites (sites Board) if:(= 0 (count at:(site)))) "BetweenRounds")) (phase "BetweenRounds" (play (if (<= 5 (size Stack Cell at:(handSite Mover))) (move Select (from Cell (handSite Mover)) (to (trackSite FirstSite "TrackCCW" from:(mapEntry Mover) if:(and (not (is In (to) (sites "EndHoles"))) (is Empty (to))))) (then (and {(forEach Value min:1 max:5 (fromTo (from Cell (last From) level:(- (size Stack Cell at:(last From)) (value))) (to (last To)) stack:True)) (if (is Mover P1) (remember Value "OwnedP1" (last To)) (remember Value "OwnedP2" (last To))) (if (<= 10 (count Cell at:(handSite Mover))) (moveAgain) (if (or (= 8 (count Cell at:(handSite Mover))) (= 9 (count Cell at:(handSite Mover)))) (and {(forEach Value min:1 max:(- (count Cell at:(handSite Mover)) 5) (fromTo (from Cell (handSite Mover) level:(- (- (size Stack Cell at:(handSite Mover)) 5) (value))) (to (trackSite FirstSite "TrackCCW" from:(trackSite FirstSite "TrackCCW" from:(mapEntry Mover) if:(and (not (is In (to) (sites "EndHoles"))) (is Empty (to)))) if:(and {(not (is In (to) (sites "EndHoles"))) (is Empty (to)) (!= (trackSite FirstSite "TrackCCW" from:(mapEntry Mover) if:(and (not (is In (to) (sites "EndHoles"))) (is Empty (to)))) (to))}))) stack:True)) (forEach Value min:1 max:(- 5 (- (count Cell at:(handSite Mover)) 5)) (fromTo (from Cell (handSite Next) level:(- (size Stack Cell at:(handSite Next)) (value))) (to (trackSite FirstSite "TrackCCW" from:(trackSite FirstSite "TrackCCW" from:(mapEntry Mover) if:(and (not (is In (to) (sites "EndHoles"))) (is Empty (to)))) if:(and {(not (is In (to) (sites "EndHoles"))) (is Empty (to)) (!= (trackSite FirstSite "TrackCCW" from:(mapEntry Mover) if:(and (not (is In (to) (sites "EndHoles"))) (is Empty (to)))) (to))}))) stack:True)) (if (is Mover P1) (remember Value "OwnedP1" (trackSite FirstSite "TrackCCW" from:(trackSite FirstSite "TrackCCW" from:(mapEntry Mover) if:(and (not (is In (to) (sites "EndHoles"))) (is Empty (to)))) if:(and {(not (is In (to) (sites "EndHoles"))) (is Empty (to)) (!= (trackSite FirstSite "TrackCCW" from:(mapEntry Mover) if:(and (not (is In (to) (sites "EndHoles"))) (is Empty (to)))) (to))}))) (remember Value "OwnedP2" (trackSite FirstSite "TrackCCW" from:(trackSite FirstSite "TrackCCW" from:(mapEntry Mover) if:(and (not (is In (to) (sites "EndHoles"))) (is Empty (to)))) if:(and {(not (is In (to) (sites "EndHoles"))) (is Empty (to)) (!= (trackSite FirstSite "TrackCCW" from:(mapEntry Mover) if:(and (not (is In (to) (sites "EndHoles"))) (is Empty (to)))) (to))})))) (if (is Mover P2) (remember Value "OwnedP1" (trackSite FirstSite "TrackCCW" from:(trackSite FirstSite "TrackCCW" from:(mapEntry Mover) if:(and (not (is In (to) (sites "EndHoles"))) (is Empty (to)))) if:(and {(not (is In (to) (sites "EndHoles"))) (is Empty (to)) (!= (trackSite FirstSite "TrackCCW" from:(mapEntry Mover) if:(and (not (is In (to) (sites "EndHoles"))) (is Empty (to)))) (to))}))) (remember Value "OwnedP2" (trackSite FirstSite "TrackCCW" from:(trackSite FirstSite "TrackCCW" from:(mapEntry Mover) if:(and (not (is In (to) (sites "EndHoles"))) (is Empty (to)))) if:(and {(not (is In (to) (sites "EndHoles"))) (is Empty (to)) (!= (trackSite FirstSite "TrackCCW" from:(mapEntry Mover) if:(and (not (is In (to) (sites "EndHoles"))) (is Empty (to)))) (to))}))))})))}))) (then (if (and (is Empty Cell (handSite P1)) (is Empty Cell (handSite P2))) (if (= (size Stack Cell at:(handSite P1 1)) 2) (and (fromTo (from Cell (handSite P1 1) level:1) (to (mapEntry P1)) stack:True) (fromTo (from Cell (handSite P1 1) level:0) (to (mapEntry P2)) stack:True)) (if (= (size Stack Cell at:(handSite P2 1)) 2) (and (fromTo (from Cell (handSite P2 1) level:1) (to (mapEntry P1)) stack:True) (fromTo (from Cell (handSite P2 1) level:0) (to (mapEntry P2)) stack:True)) (and (fromTo (from Cell (handSite P1 1) level:0) (to (mapEntry P1)) stack:True) (fromTo (from Cell (handSite P2 1) level:0) (to (mapEntry P2)) stack:True)))))))) (nextPhase (and (is Empty Cell (handSite P1)) (is Empty Cell (handSite P2))) "Sowing"))})) 
2x6 board with two stores. Four counters in each hole. Play may begin from any of the player's holes. Counters are sown anti-clockwise. If the last counter falls into an empty hole or a hole in either row, making that hole contain four counters, play ends, and the four counters are taken. Also, if at any time during the sowing a hole contains four counters, the player on whose row this occurs takes those counters. Otherwise, the player lifts the counters in the hole in which the final counter lands and continues sowing. Play ends when one player can no longer move. The player with the most counters wins.
(game "Obridje" (players 2) (equipment {(mancalaBoard 2 6 (track "Track" "1,E,N,W" loop:True)) (piece "Seed" Shared) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 FirstSite) (pair P2 LastSite)})}) (rules (start (set Count 4 to:(sites Track))) (play (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover)) if:(> (count at:(from)) 0)) (then (do (set Var "NumSowed" (count at:(last To))) next:(sow apply:(if (and (!= 4 (count at:(to))) (< 1 (count at:(to)))) (and (moveAgain) (set Var "Replay" (to))))) (then (and (forEach Site (sites Track from:(last From) to:(trackSite Move from:(last From) "Track" steps:(var "NumSowed"))) (if (= 4 (count at:(site))) (fromTo (from (site)) (to (if (is In (to) (sites P1)) (mapEntry P1) (mapEntry P2))) count:4))) (set Var "NumSowed" 0))))))) (end (if (no Moves Next) (byScore {(score P1 (+ (count at:(mapEntry P1)) (count in:(sites P1)))) (score P2 (+ (count at:(mapEntry P2)) (count in:(sites P2))))}))))) 
2x10-20 board, 10 most common. Opening arrangement: Each player has this opening arrangement (number of counters in each hole, starting from the leftmost hole): 5-5-5-5-5-5-5-1-1-5-1-0-0-0-0-0-0-0-0-0. Boards have even numbers of holes, and the farthest left and farthest right holes are eliminated in succession from this opening arrangement to make smaller boards. The challenger concedes the first move. Opening phase: Player 1 removes the counters in the opponent's final four holes with counters and conceals them from the opponent. Player 2 removes the same counters, except leaving the single counter in the opponent's final hole with counters. Players take the counters from any of their holes and sow them in an anti-clockwise direction. When sowing, the first counter is dropped into the hole from which it just came, unless it is a single counter. If the last counter lands in the opponent's row and the opposite hole contains one, three, or five counters, theses are taken and added to the concealed store. In place of a move, a player may add some or all of the counters from the concealed store, sowing from the leftmost hole in their row. If the sowing reaches the rightmost hole in this row, sowing continues from the leftmost hole rather than continuing into the opponent's rows. Each row has 10 holes.
(game "Okwe (Nigeria)" (players 2) (equipment {(mancalaBoard 2 10 store:None {(track "Track" "0,E,N,W" loop:True) (track "TrackSpecialHome1" "0,E" loop:True P1) (track "TrackSpecialHome2" "19,W" loop:True P2)}) (regions "OpeningRegion" P1 (sites {14 15 16 17})) (regions "OpeningRegion" P2 (sites {2 3 4})) (piece "Seed" Shared) (hand Each) (map "LeftMost" {(pair P1 0) (pair P2 (- (* 10 2) 1))}) (regions "Home" P1 (sites Bottom)) (regions "Home" P2 (sites Top))}) (rules (start {(set Count 5 to:(sites {0 1 4 19 18 15})) (set Count 1 to:(sites {2 3 5 17 16 14}))}) phases:{(phase "Opening" (play (move (from (sites Mover "OpeningRegion") if:(is Occupied (from))) (to (handSite Mover)) count:(count at:(from)))) (nextPhase (all Sites (union (sites P1 "OpeningRegion") (sites P2 "OpeningRegion")) if:(is Empty (site))) "Sowing")) (phase "Sowing" (play (or (move Select (from (sites Mover "Home") if:(is Occupied (from))) (then (sow "Track" apply:(if (and (is In (to) (sites Next "Home")) (or {(= 1 (count at:(if (is In (to) (sites Bottom)) (+ (to) 10) (- (to) 10)))) (= 3 (count at:(if (is In (to) (sites Bottom)) (+ (to) 10) (- (to) 10)))) (= 5 (count at:(if (is In (to) (sites Bottom)) (+ (to) 10) (- (to) 10))))})) (fromTo (from (if (is In (to) (sites Bottom)) (+ (to) 10) (- (to) 10))) (to (handSite Mover)) count:(count at:(if (is In (to) (sites Bottom)) (+ (to) 10) (- (to) 10))))) origin:(< 1 (count at:(from)))))) (if (is Occupied Cell (handSite Mover)) (do (set Var "NumToSow" (count Cell at:(handSite Mover))) next:(move (from (handSite Mover)) (to (mapEntry "LeftMost" Mover)) count:(count Cell at:(handSite Mover)) (then (and (sow count:(var "NumToSow") "TrackSpecialHome" owner:(mover) origin:True) (set Var "NumToSow" 0)))))))))} (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) {(if (is Empty (handSite P1)) (result P2 Win)) (if (is Empty (handSite P2)) (result P1 Win))})))) 
2x7 board. Six counters in each hole, except the central hole in each row, which contains one counter. Sowing occurs in an anti-clockwise direction. When the last counter is sown, the player picks up the counters in the next hole in the direction of the sowing and continues sowing with those counters. When the hole after the hole in which the final counter is sown is empty, the counters in the next hole are captured, as well as the counters in the hole opposite this hole, and the turn ends. Sowing cannot begin from the central hole of either row. When a capture would occur from one of these central holes, the counters are not captured until the end of the round. At the end of the round, if both players are eligible to capture from the hole, they split the counters, leaving one in the hole if it is an odd number, or two if it is an even number. If only one player captured from the holes, they leave one counter in each hole. If neither player made a capture from the hole, the counters remain in the hole. When the players can no longer play, a new round begins. Each player then fills up as many holes, not counting the central holes, on their side of the board with six counters if possible. Any holes that do not contain counters are out of play. Play continues until one player captures all the counters, and is the winner.
(game "Omangunta Peeta" (players 2) (equipment {(mancalaBoard 2 7 store:None (track "Track" "0,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (piece "Seed" Shared) (hand Each)}) (rules (start {(set Count 6 to:(difference (sites Track) (sites Centre))) (set Count 1 to:(sites Centre)) (set RememberValue "Playable" (union (sites Top) (sites Bottom)))}) phases:{(phase "Sowing" (play (or {(move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (difference (sites Mover) (sites Centre))) if:(and (is Occupied (from)) (is In (from) (sites (values Remembered "Playable"))))) (then (sow apply:(if (is Occupied (trackSite Move from:(to) "Track" steps:1)) (and (moveAgain) (set Var "Replay" (to))) (if (is In (trackSite Move from:(to) "Track" steps:2) (sites Centre)) (set Value Mover 1) (and (if (is Occupied (trackSite Move from:(to) "Track" steps:2)) (fromTo (from (trackSite Move from:(to) "Track" steps:2)) (to (handSite Mover)) count:(count at:(trackSite Move from:(to) "Track" steps:2)))) (if (is Occupied (if (is In (trackSite Move from:(to) "Track" steps:2) (sites Bottom)) (+ (trackSite Move from:(to) "Track" steps:2) 7) (- (trackSite Move from:(to) "Track" steps:2) 7))) (fromTo (from (if (is In (trackSite Move from:(to) "Track" steps:2) (sites Bottom)) (+ (trackSite Move from:(to) "Track" steps:2) 7) (- (trackSite Move from:(to) "Track" steps:2) 7))) (to (handSite Mover)) count:(count at:(if (is In (trackSite Move from:(to) "Track" steps:2) (sites Bottom)) (+ (trackSite Move from:(to) "Track" steps:2) 7) (- (trackSite Move from:(to) "Track" steps:2) 7)))))))) skipIf:(and (not (is In (to) (sites Centre))) (not (is In (to) (sites (values Remembered "Playable"))))))))} (then (if (all Sites (difference (sites Board) (sites Centre)) if:(= 0 (count at:(site)))) (and {(forget Value "Playable" All) (if (!= 0 (+ (count at:3) (count at:10))) (if (and (= 1 (value Player P1)) (= 1 (value Player P2))) (if (is Even (+ (count at:3) (count at:10))) (and {(fromTo (from 3) (to Cell (handSite P1)) count:(- (count at:3) 1)) (fromTo (from 10) (to Cell (handSite P1)) count:(- (count at:10) 1)) (fromTo (from Cell (handSite P1)) (to Cell (handSite P2)) count:(/ (- (+ (count at:3) (count at:10)) 2) 2))}) (and {(fromTo (from 3) (to Cell (handSite P1)) count:(- (count at:3) 1)) (fromTo (from 10) (to Cell (handSite P1)) count:(count at:10)) (fromTo (from Cell (handSite P1)) (to Cell (handSite P2)) count:(/ (- (+ (count at:3) (count at:10)) 1) 2))})) (if (= 1 (value Player P1)) (and (fromTo (from 3) (to Cell (handSite P1)) count:(- (count at:3) 1)) (fromTo (from 10) (to Cell (handSite P1)) count:(- (count at:10) 1))) (if (= 1 (value Player P2)) (and (fromTo (from 3) (to Cell (handSite P2)) count:(- (count at:3) 1)) (fromTo (from 10) (to Cell (handSite P2)) count:(- (count at:10) 1)))))))}))))) (end (if (all Sites (difference (sites Board) (sites Centre)) if:(= 0 (count at:(site)))) {(if (= 0 (count Cell at:(handSite P1))) (result P2 Win)) (if (= 0 (count Cell at:(handSite P2))) (result P1 Win))})) (nextPhase (all Sites (difference (sites Board) (sites Centre)) if:(= 0 (count at:(site)))) "BetweenRounds")) (phase "BetweenRounds" (play (if (not (all Sites (difference (sites Mover) (sites Centre)) if:(is Occupied (site)))) (if (<= 6 (count Cell at:(handSite Mover))) (move (from Cell (handSite Mover)) (to (difference (sites Mover) (sites Centre)) if:(is Empty (to))) count:6 (then (remember Value "Playable" (last To))))))) (nextPhase (all Passed) "Sowing"))})) 
Two rows of four piles. Six counters in each pile. A player picks up the counters in one of her piles and sows them anti-clockwise, beginning in the place from which the pile originated. Any piles containing 2, 4, or 6 counters at the end of sowing are captured. Play continues until all of the counters have been captured. The player who captures the most counters wins.
(game "Oure Ngat" (players 2) (equipment {(mancalaBoard 2 4 store:None (track "Track" "0,E,N,W" loop:True)) (piece "Seed" Shared) (regions "Home" P1 (sites Bottom)) (regions "Home" P2 (sites Top)) (hand Each)}) (rules (start (set Count 6 to:(sites Track))) (play (move Select (from (sites Mover "Home") if:(> (count at:(from)) 0)) (then (sow origin:True (then (forEach Site (sites Track) (if (is In (count at:(site)) (sites {2 4 6})) (fromTo (from (site)) (to (handSite Mover)) count:(count at:(site)))))))))) (end (if (= 0 (count in:(sites Track))) (byScore {(score P1 (count Cell at:(handSite P1))) (score P2 (count Cell at:(handSite P2)))}))))) 
2x8 board, with a store on either end. Each player owns the store to their right. Eight counters in each hole. Players alternate turns sowing in an anti-clockwise direction from one of the holes on their side of the board. Sowing always includes the player's store (but not the opponent's store), and sowing cannot begin from the store. When the final counter lands in an occupied hole, the contents of that hole are picked up and sowing continues. If the last counter lands in the player's store, they may choose any of the holes on their side of the board and continue sowing from it. When the final counter lands in an empty hole, the counters in the opposite hole are captured. Play continues until all of the counters are captured. A new round begins. Players fill the holes on their side of the board with their captured counters. If a player cannot fill a hole with the required number of counters, the hole is closed and is out of play for that round. Play continues as before. Play continues in successive rounds until one player closes all of their opponent's holes and wins. 
(game "Ovalhu" (players 2) (equipment {(mancalaBoard 2 8 {(track "Track1" "1,E,17,16,W" loop:True P1) (track "Track2" "1,E,N,W,0" loop:True P2)}) (piece "Seed" Shared) (map {(pair P1 LastSite) (pair P2 FirstSite)}) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(set RememberValue "Playable" (union (sites Top) (sites Bottom))) (set Count 8 to:(union (sites Bottom) (sites Top)))}) phases:{(phase "Sowing" (play (or {(move Select (from (if (and (is Pending) (is Prev Mover)) (sites {(var "Replay")}) (sites Mover)) if:(and (is Occupied (from)) (is In (from) (sites (values Remembered "Playable"))))) (then (sow "Track" owner:(mover) apply:(if (or (is In (to) (sites {(mapEntry P1) (mapEntry P2)})) (< 1 (count at:(to)))) (and (moveAgain) (if (not (is In (to) (sites {(mapEntry P1) (mapEntry P2)}))) (and (set Pending) (set Var "Replay" (to))))) (if (is Occupied (if (is In (to) (sites Bottom)) (+ (to) 8) (- (to) 8))) (fromTo (from (if (is In (to) (sites Bottom)) (+ (to) 8) (- (to) 8))) (to (mapEntry Mover)) count:(count at:(if (is In (to) (sites Bottom)) (+ (to) 8) (- (to) 8)))))) skipIf:(and (not (is In (to) (sites {(mapEntry P1) (mapEntry P2)}))) (not (is In (to) (sites (values Remembered "Playable"))))))))} (then (if (no Pieces All in:(union (sites Top) (sites Bottom))) (forget Value "Playable" All))))) (end (if (no Pieces All in:(union (sites Top) (sites Bottom))) {(if (> 8 (count at:(mapEntry P1))) (result P2 Win)) (if (> 8 (count at:(mapEntry P2))) (result P1 Win))})) (nextPhase (no Pieces All in:(union (sites Top) (sites Bottom))) "BetweenRounds")) (phase "BetweenRounds" (play (if (not (all Sites (sites Mover) if:(is Occupied (site)))) (if (<= 8 (count at:(mapEntry Mover))) (move (from (mapEntry Mover)) (to (sites Mover) if:(is Empty (to))) count:8 (then (remember Value "Playable" (last To))))))) (nextPhase (all Passed) "Sowing"))})) 
2x6 board, with a storage hole on either end. The game starts with four counters in each hole. A player picks up all of the counters in one of the holes in their row and sows them one-by-one in a counterclockwise direction in consecutive holes from the hole the pieces originated. The starting hole is always left empty, even if a player sows in a complete circuit of the board, the original house is skipped and sowing continues in the next hole after it. Players capture counters when the final counter is sown in the opponent's row and the hole containing it has two or three counters (counting the counter just dropped into it). If the hole before it also has two or three counters, these are also captured and so on until reaching a hole without two or three counters or one not belonging to the opponent. A move which would capture all of the opponent's counters is not allowed. If an opponent's holes are all empty, the other player must make a move placing counters in the opponent's row. If not possible, the player captures all the counters in their row. Play continues until all of the counters are captured. The player who has captured the most counters wins. If the game continues in a repeating loop, the players can agree to end the game and capture the counters remaining in their row.  The game ended when a player has no piece on his side or if the two players are agree on the end of the game in case a cycle.
(game "Oware" (players 2) (equipment {(mancalaBoard 2 6 (track "Track" "1,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 FirstSite) (pair P2 LastSite)}) (piece "Seed" Shared)}) (rules (start (set Count 4 to:(sites Track))) (play (if (is Proposed "End") (or (move Vote "End") (move Vote "No")) (or (if (is Cycle) (move Propose "End")) (do (move Select (from (sites Mover) if:(< 0 (count at:(from)))) (then (sow if:(and (is In (to) (sites Next)) (or (= (count at:(to)) 2) (= (count at:(to)) 3))) apply:(fromTo (from (to)) (to (mapEntry (mover))) count:(count at:(to))) includeSelf:False backtracking:True))) ifAfterwards:(< 0 (count in:(sites Next))))))) (end (if (or (no Moves Mover) (is Decided "End")) (byScore {(score P1 (+ (count at:(mapEntry P1)) (count in:(sites P1)))) (score P2 (+ (count at:(mapEntry P2)) (count in:(sites P2))))}))))) 
2x5 board. Five counters in each hole. Sowing occurs in an anti-clockwise direction. When the final counters of a sowing lands in a hole, the contents of the next hole are picked up and sowing continues. When the final counter lands in a hole, and the next hole, from which sowing would normally continue, is empty, the player captures any counters in the next hole after the empty one. and the turn ends. Play continues until no more captures are possible, and the player who captured the most counters wins.
(game "Pachgarhwa" (players 2) (equipment {(mancalaBoard 2 5 store:None (track "Track" "0,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 5 to:(sites Track))) (play (move Select (from (if (is Prev Mover) (sites {(value Pending)}) (sites Mover)) if:(> (count at:(from)) 0)) (then (sow if:True apply:(if (is Occupied (trackSite Move from:(to) steps:1)) (and {(set Pending (to)) (fromTo (from (trackSite Move from:(to) steps:1)) (to (handSite Mover)) count:(count at:(trackSite Move from:(to) steps:1))) (moveAgain)}) (if (is Occupied (trackSite Move from:(to) steps:2)) (fromTo (from (trackSite Move from:(to) steps:2)) (to (handSite Mover)) count:(count at:(trackSite Move from:(to) steps:2))))))))) (end (if (= 1 (count in:(sites Board))) (byScore {(score P1 (+ (count Cell at:(handSite P1)) (count in:(sites P1)))) (score P2 (+ (count Cell at:(handSite P2)) (count in:(sites P2))))}))))) 
2x7 board. Six counters in each hole. Play begins from any one of a player's holes, even if there is just one. Sowing occurs in an anti-clockwise direction. If they end in a hole with counters, these are picked up and sowing continues. If sowing ends in an empty hole, the contents of the next hole are captured and the turn ends. When sowing, if the contents of a hole are brought to four, they are immediately captured by the player in whose row the counters are located. Play ends when a player has no counters in their holes, remaining player takes all the remaining counters. In the next round, the player with the smaller number of counters captured from the previous round fills as many of their holes as they can, starting from the left and filling each hole with six counters. Leftover counters are placed in the player's store. The opponent then does the same. Any holes remaining empty are out of play for this round, otherwise play continues as before. The right to begin alternates from round to round. Further rounds are played until one player has fewer than six counters.
(game "Pallankuli" (players 2) (equipment {(mancalaBoard 2 7 store:None (track "Track" "0,E,N,W" loop:True)) (piece "Seed" Shared) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map "LeftMost" {(pair P1 0) (pair P2 13)}) (hand Each)}) (rules (start {(set Count 6 to:(sites Track)) (set RememberValue "Playable" (union (sites Top) (sites Bottom)))}) phases:{(phase "Sowing" (play (or {(move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover)) if:(and (is Occupied (from)) (is In (from) (sites (values Remembered "Playable"))))) (then (do (set Var "NumSowed" (count at:(last To))) next:(sow apply:(if (and (!= 4 (count at:(to))) (< 1 (count at:(to)))) (and (moveAgain) (set Var "Replay" (to))) (if (= 1 (count at:(to))) (if (is Occupied (trackSite Move from:(to) steps:1)) (fromTo (from (trackSite Move from:(to) steps:1)) (to (handSite Mover)) count:(count at:(trackSite Move from:(to) steps:1)))))) skipIf:(not (is In (to) (sites (values Remembered "Playable"))))) (then (and (forEach Site (sites Track from:(last From) to:(trackSite Move from:(last From) "Track" steps:(var "NumSowed"))) (if (= 4 (count at:(site))) (fromTo (from (site)) (to (if (is In (to) (sites P1)) (handSite P1) (handSite P2))) count:4))) (set Var "NumSowed" 0))))))} (then (if (or (all Sites (sites Bottom) if:(= 0 (count at:(site)))) (all Sites (sites Top) if:(= 0 (count at:(site))))) (and {(forEach Site (sites P1) (fromTo (from (site)) (to (handSite P1)) count:(count at:(site)))) (forEach Site (sites P2) (fromTo (from (site)) (to (handSite P2)) count:(count at:(site)))) (forget Value "Playable" All)}))))) (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) {(if (> 6 (count Cell at:(handSite P1))) (result P2 Win)) (if (> 6 (count Cell at:(handSite P2))) (result P1 Win))})) (nextPhase (all Sites (sites Board) if:(= 0 (count at:(site)))) "BetweenRounds")) (phase "BetweenRounds" (play (if (<= 6 (count Cell at:(handSite Mover))) (move (from (handSite Mover)) (to (trackSite FirstSite from:(mapEntry "LeftMost" Mover) if:(is Empty (to))) if:(is In (to) (sites Mover))) count:6 (then (remember Value "Playable" (last To)))))) (nextPhase (all Passed) "Sowing"))})) 
2x7 board, with one store at either end. Each player owns the store to their left. Seven counters in each hole. The first turn is played simultaneously by both players; at the point which one player's sowing lasts longer than the others, the player whose turn was shorter plays next and turns alternate from this point. Players sow in a clockwise direction from one of the holes in their row, also sowing into their store, but not in their opponent's store. When the final counter lands in an empty hole or in the store, the turn ends. When the final counter falls into an occupied hole, the player picks up the contents of this hole and continues to sow. If this occupied hole is in the player's row, they have the option to instead place the final counter in the opposite hole in the opponent's row, and to place this last counter as well as the contents of that hole into the store. When all of the counters are in the stores, a new game begins. The players take the counters from their stores and place seven in each hole, beginning from their right. Any player which cannot fill a hole with seven counters places the remaining counters in their store. Any holes which are left empty are out of play for this game. Play continues as before. Multiple games are played like this until all of the holes on one side are left empty. This player loses.
(game "Papan Dakon" (players 2) (equipment {(mancalaBoard 2 7 {(track "Track1" "0,8,E,S,W" loop:True P1) (track "Track2" "15,7,W,N,E" loop:True P2)}) (piece "Seed" Shared) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 FirstSite) (pair P2 LastSite)}) (map "RightMost" {(pair P1 7) (pair P2 8)})}) (rules (start {(set Count 7 to:(union (sites P1) (sites P2))) (set RememberValue "Playable" (union (sites Top) (sites Bottom)))}) phases:{(phase "Sowing" (play (or (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover)) if:(and (> (count at:(from)) 0) (is In (from) (sites (values Remembered "Playable"))))) (then (sow "Track" owner:(mover) apply:(if (and (!= (to) (mapEntry Mover)) (< 1 (count at:(to)))) (moveAgain)) skipIf:(if (!= (to) (mapEntry Mover)) (not (is In (to) (sites (values Remembered "Playable")))))))) (if (and (is In (last To afterConsequence:True) (sites Mover)) (is Prev Mover)) (if (is In (last To afterConsequence:True) (sites (values Remembered "Playable"))) (move (from (last To afterConsequence:True)) (to (if (is Mover P1) (+ (last To afterConsequence:True) 7) (- (last To afterConsequence:True) 7))) count:1 (then (fromTo (from (last To)) (to (mapEntry Mover)) count:(count at:(last To))))))) (then (if (all Sites (union (sites Top) (sites Bottom)) if:(is Empty (site))) (forget Value "Playable" All))))) (end (if (all Sites (union (sites Top) (sites Bottom)) if:(is Empty (site))) {(if (> 7 (count at:(mapEntry P1))) (result P2 Win)) (if (> 7 (count at:(mapEntry P2))) (result P1 Win))})) (nextPhase (all Sites (union (sites Top) (sites Bottom)) if:(is Empty (site))) "BetweenRounds")) (phase "BetweenRounds" (play (if (not (all Sites (sites Mover) if:(is Occupied (site)))) (if (<= 7 (count at:(mapEntry Mover))) (move (from (mapEntry Mover)) (to (trackSite FirstSite from:(mapEntry "RightMost" Mover) if:(is Empty (to)))) count:7 (then (remember Value "Playable" (last To))))))) (nextPhase (all Passed) "Sowing"))})) 
2x7 board with two stores. Four counters in each hole. Sowing occurs in either a clockwise or anti-clockwise direction; the first player chooses the direction and all subsequent moves are made in that direction. Players sow beginning from holes in their row. In the course of sowing, a player cannot sow into a hole containing three counters; if one is encountered, it is skipped and the counter is sowed into the next hole without three. If the final counter falls into a hole containing three counters, the contents of the hole are captured and the contents of the next hole are picked up and sowing continues. Otherwise, if the last counter falls into a hole with counters, these are picked up and sowing continues, or if it falls into an empty hole the turn ends. Throughout the game, single counters cannot be moved if a player has a hole with multiple counters, and a single counter in the front hole cannot be moved if there are other single counters in the player's row. The round ends when one player's holes are empty. The player with counters remaining in their holes captures these counters. A second round begins with the winner of the first round placing four counters in each of their holes, leaving any surplus in the store. The loser of round one places four counters in as many consecutive holes on their side of the board as possible, and any remaining counters in the next hole. If this hole contains one, it is called puta, if two, naga, if three, wala. Holes with no counters are excluded from play for this round. If the loser has a puta hole, the opponent removes three counters from their hole opposite; if a naga, the opponent removes two from the opposite hole, if a wala, the opponent removes one. The removed counters go into their store. Puta and naga holes are marked with a piece of paper or straw in them. Empty holes are excluded from play in this round. The losing player begins the round, moving in the direction of the excluded holes, and played in the same way as the first round. The player with empty holes begins play in the direction of the empty hole. Counters cannot be captured or sowed from puta or naga holes. Play continues as before. When one player has fewer than twelve counters at the beginning of a round, they may arrange them differently at the beginning. They may put one or two counters in one end hole and not more than four in the other end hole, and one or two counters in the intermediate holes, leaving some empty and, thus, excluded. The opponent then puts four counters in each of their holes. There are no puta, naga, or wala holes in this round. The player with more counters plays as before, but the one with less has captures that are determined by the number of counters placed in the first end hole. If there were two in the end hole, the player captures when dropping the final counter into a hole to make it three; or when it makes two if there was one counter in the first end hole. Otherwise, the player does not sow in holes with one or two counters. Play continues until one player cannot sow at the beginning of a round.
(game "Puhulmutu" (players 2) (equipment {(mancalaBoard 2 7 {(track "TrackCCW" "1,E,N,W" loop:True) (track "TrackCW" "7,W,N,E" loop:True)}) (piece "Seed" Shared) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 FirstSite) (pair P2 LastSite)})}) (rules (start {(set Count 4 to:(sites Track)) (set RememberValue "Playable" (union (sites Top) (sites Bottom)))}) phases:{(phase "StartingMove" (play (or (move Select (from (sites Mover) if:(and (is Occupied (from)) (is In (from) (sites (values Remembered "Playable"))))) (then (and (sow "TrackCCW" apply:(if (= 4 (count at:(to))) (and (if (!= 0 (count at:(trackSite Move from:(to) "TrackCCW" steps:1))) (and (moveAgain) (set Var "Replay" (trackSite Move from:(to) "TrackCCW" steps:1)))) (fromTo (from (to)) (to (mapEntry Mover)) count:4)) (if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to))))) skipIf:(or (not (is In (to) (sites (values Remembered "Playable")))) (and (= 3 (count at:(to))) (!= 1 (value))))) (set Var "Direction" 1)))) (move Select (from (sites Mover) if:(and (is Occupied (from)) (is In (from) (sites (values Remembered "Playable"))))) (then (and (sow "TrackCW" apply:(if (= 4 (count at:(to))) (and (if (!= 0 (count at:(trackSite Move from:(to) "TrackCW" steps:1))) (and (moveAgain) (set Var "Replay" (trackSite Move from:(to) "TrackCW" steps:1)))) (fromTo (from (to)) (to (mapEntry Mover)) count:4)) (if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to))))) skipIf:(or (not (is In (to) (sites (values Remembered "Playable")))) (and (= 3 (count at:(to))) (!= 1 (value))))) (set Var "Direction" 2)))))) (nextPhase "Sowing")) (phase "Sowing" (play (if (= 1 (var "Direction")) (move Select (from (if (and (not (is Pending)) (is Prev Mover)) (sites {(var "Replay")}) (sites Mover)) if:(and {(is Occupied (from)) (is In (from) (sites (values Remembered "Playable"))) (not (is In (from) (sites (values Remembered "Blocked")))) (if (not (all Sites (forEach (sites Mover) if:(is In (site) (sites (values Remembered "Playable")))) if:(>= 1 (count at:(site))))) (< 1 (count at:(from))))})) (then (sow "TrackCCW" apply:(if (= 4 (count at:(to))) (and (if (!= 0 (count at:(trackSite Move from:(to) "TrackCCW" steps:1))) (and (moveAgain) (set Var "Replay" (trackSite Move from:(to) "TrackCCW" steps:1)))) (if (not (is In (to) (sites (values Remembered "Blocked")))) (fromTo (from (to)) (to (mapEntry Mover)) count:4))) (if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to))))) skipIf:(or (not (is In (to) (sites (values Remembered "Playable")))) (and (= 3 (count at:(to))) (!= 1 (value))))))) (move Select (from (if (and (not (is Pending)) (is Prev Mover)) (sites {(var "Replay")}) (sites Mover)) if:(and {(is Occupied (from)) (is In (from) (sites (values Remembered "Playable"))) (not (is In (from) (sites (values Remembered "Blocked")))) (if (not (all Sites (forEach (sites Mover) if:(is In (site) (sites (values Remembered "Playable")))) if:(>= 1 (count at:(site))))) (< 1 (count at:(from))))})) (then (sow "TrackCW" apply:(if (= 4 (count at:(to))) (and (if (!= 0 (count at:(trackSite Move from:(to) "TrackCW" steps:1))) (and (moveAgain) (set Var "Replay" (trackSite Move from:(to) "TrackCW" steps:1)))) (if (not (is In (to) (sites (values Remembered "Blocked")))) (fromTo (from (to)) (to (mapEntry Mover)) count:4))) (if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to))))) skipIf:(or (not (is In (to) (sites (values Remembered "Playable")))) (and (= 3 (count at:(to))) (!= 1 (value))))))) (then (if (no Moves Next) (and {(forEach Site (sites P1) (if (is Occupied (site)) (fromTo (from (site)) (to (mapEntry P1)) count:(count at:(site))))) (forEach Site (sites P2) (if (is Occupied (site)) (fromTo (from (site)) (to (mapEntry P2)) count:(count at:(site))))) (forget Value "Playable" All) (forget Value "Blocked" All) (if (< (+ (count at:(mapEntry P1)) (count in:(sites P1))) (+ (count at:(mapEntry P2)) (count in:(sites P2)))) (and (set NextPlayer (player 2)) (set Var "Winner" 2)) (and (set NextPlayer (player 1)) (set Var "Winner" 1)))}))))) (end (if (no Moves Next) {(if (> 2 (count at:(mapEntry P1))) (result P2 Win)) (if (> 2 (count at:(mapEntry P2))) (result P1 Win))})) (nextPhase (no Moves Next) "BetweenRounds")) (phase "BetweenRounds" (play (if (and (not (is Prev Mover)) (!= (mover) (var "Winner"))) (or (move (from (mapEntry Mover)) (to (if (is Mover P1) (intersection (sites Bottom) (expand (sites Right))) (intersection (sites Top) (expand (sites Left)))) if:(is Empty (to))) count:(min 4 (count at:(mapEntry Mover))) (then (and {(remember Value "Playable" (last To)) (if (> 4 (count at:(last To))) (and (fromTo (from (if (is Mover P1) (+ (to) 7) (- (to) 7))) (to (mapEntry Next)) count:(- 4 (count at:(last To)))) (remember Value "Blocked" (last To)))) (moveAgain) (if (= 0 (count at:(mapEntry Mover))) (set Pending)) (set Var "Direction" 2)}))) (move (from (mapEntry Mover)) (to (if (is Mover P1) (intersection (sites Bottom) (expand (sites Left))) (intersection (sites Top) (expand (sites Right)))) if:(is Empty (to))) count:(min 4 (count at:(mapEntry Mover))) (then (and {(remember Value "Playable" (last To)) (if (> 4 (count at:(last To))) (and (fromTo (from (if (is Mover P1) (+ (to) 7) (- (to) 7))) (to (mapEntry Next)) count:(- 4 (count at:(last To)))) (remember Value "Blocked" (last To)))) (moveAgain) (if (= 0 (count at:(mapEntry Mover))) (set Pending)) (set Var "Direction" 1)})))) (if (!= (mover) (var "Winner")) (move (from (mapEntry Mover)) (to (if (= (var "Direction") 1) (trackSite Move from:(last To) "TrackCCW" steps:1) (trackSite Move from:(last To) "TrackCW" steps:1)) if:(is Empty (to))) count:(min 4 (count at:(mapEntry Mover))) (then (and {(remember Value "Playable" (last To)) (moveAgain) (if (= 0 (count at:(mapEntry Mover))) (set Pending))}))) (move (from (mapEntry Mover)) (to (sites Mover) if:(is Empty (to))) count:4 (then (and (remember Value "Playable" (last To)) (if (not (all Sites (sites Mover) if:(is Occupied (site)))) (moveAgain)))))))) (nextPhase (and (!= (var "Winner") (mover)) (= 0 (count at:(mapEntry Mover)))) "Sowing"))})) 
2x6 board. Four counters in each hole. Sowing occurs in a clockwise direction when starting from the three holes on the left of the board, and in an anti-clockwise direction when starting from the three holes on the right. Sowing ends when the final counter is dropped, regardless of whether the hole is occupied or not. When the final counter is dropped into a hole containing three counters, thus making it contain four, the hole is captured. This can only be done if the hole is one of the end holes on either side of either row, or the penultimate holes on either side of the opponent's row. Sowing is not allowed from a captured hole. When no player is able to move, the player with the most counters in their captured holes wins.
(game "Qelat (Beni Amir-Mensa)" (players 2) (equipment {(mancalaBoard 2 6 store:None {(track "TrackCCW" "0,E,N,W" loop:True) (track "TrackCW" "5,W,N,E" loop:True)}) (piece "Seed" Shared) (regions "Left" P1 (intersection (expand (sites Left) steps:2) (sites Bottom))) (regions "Left" P2 (intersection (expand (sites Right) steps:2) (sites Top))) (regions "Right" P1 (intersection (expand (sites Right) steps:2) (sites Bottom))) (regions "Right" P2 (intersection (expand (sites Left) steps:2) (sites Top)))}) (rules (start (set Count 4 to:(sites Track))) (play (or (move Select (from (sites Mover "Left") if:(and (= 0 (state at:(from))) (is Occupied (from)))) (then (sow "TrackCW" apply:(if (and {(is In (to) (union (expand (sites Right)) (expand (sites Left)))) (= 4 (count at:(to))) (= 0 (state at:(to)))}) (set State at:(to) (mover)))))) (move Select (from (sites Mover "Right") if:(and (= 0 (state at:(from))) (is Occupied (from)))) (then (sow "TrackCCW" apply:(if (and {(is In (to) (union (expand (sites Right)) (expand (sites Left)))) (= 4 (count at:(to))) (= 0 (state at:(to)))}) (set State at:(to) (mover)))))))) (end (if (and (no Moves P1) (no Moves P2)) (byScore {(score P1 (count in:(forEach (sites Board) if:(= (id P1) (state at:(site)))))) (score P2 (count in:(forEach (sites Board) if:(= (id P2) (state at:(site))))))}))))) 
2x6 board. Play begins with four counters in each hole. A player picks up the contents of any of their holes and sowing them in an anti-clockwise direction, picking up the contents of the last hole in which his counters fall, and continuing sowing. This continues until the last counter falls in an empty hole. Then it is the other player's turn. A hole is captured when the last ball is dropped into an opponent's hole containing three counters, making it four. A player cannot then take from one of these holes that they have captured. Therefore, the player cannot begin a turn from their own captured hole nor can they continue sowing from it if their last counter falls into it. If the last counter of a sowing falls into an opponent's captured hole, one of those counters are removed from the board and placed in the store, and the sowing continues with the contents of any of the player's holes. Ownership of a hole continues even if it becomes empty. When a player cannot move (i.e., there are no counters in their holes except any that are in captured holes), the opponent continues to move until the player is able to move. Play continues until all counters are either placed in the store or in captured holes and thus cannot be moved. Players then count their pieces by placing four in each hole, and the player who has more than their original number takes ownership of one of the opponent's holes for every four counters more than the original number that have been taken. If no player took four more than the original, the player with three extra gets the hole, if each player has two extra they draw lots to see who gets an extra hole. Play then begins again as before. The game ends when one player owns all of the counters, and thus all of the holes.
(game "Qelat" (players 2) (equipment {(mancalaBoard 2 6 store:None {(track "TrackCCW" "0,E,N,W" loop:True) (track "TrackCW" "5,W,N,E" loop:True)}) (piece "Seed" Shared) (hand Each) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map "RightMost" {(pair P1 5) (pair P2 6)})}) (rules (start {(set RememberValue "OwnedP1" (sites Bottom)) (set RememberValue "OwnedP2" (sites Top)) (set Count 4 to:(sites Track))}) phases:{(phase "Sowing" (play (or {(move Select (from (if (and (is Prev Mover) (= 1 (var "ContinueSowing"))) (sites {(var "Replay")}) (if (is Mover P1) (sites (values Remembered "OwnedP1")) (sites (values Remembered "OwnedP2")))) if:(and (< 0 (count at:(from))) (= 0 (state at:(from))))) (then (sow "TrackCCW" apply:(if (and {(= 0 (state at:(to))) (= 4 (count at:(to))) (is In (to) (if (is Mover P1) (sites (values Remembered "OwnedP2")) (sites (values Remembered "OwnedP1"))))}) (set State at:(to) (mover)) (if (< 1 (count at:(to))) (if (= 0 (state at:(to))) (and {(moveAgain) (set Var "Replay" (to)) (set Var "ContinueSowing" 1)}) (if (!= (mover) (state at:(to))) (and {(fromTo (from (to)) (to (handSite Mover)) count:(min 2 (count at:(to)))) (set State at:(to) (state at:(to))) (moveAgain) (set Var "ContinueSowing" 0)}))))))))} (then (if (all Sites (forEach (sites Board) if:(= 0 (state at:(site)))) if:(= 0 (count at:(site)))) (and {(forEach Site (forEach (sites Board) if:(= 1 (state at:(site)))) (fromTo (from (site)) (to (handSite P1)) count:(count at:(site)))) (forEach Site (forEach (sites Board) if:(= 2 (state at:(site)))) (fromTo (from (site)) (to (handSite P2)) count:(count at:(site)))) (forget Value "OwnedP1" All) (forget Value "OwnedP2" All)}))))) (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) {(if (= 0 (count Cell at:(handSite P1))) (result P2 Win)) (if (= 0 (count Cell at:(handSite P2))) (result P1 Win))})) (nextPhase (all Sites (sites Board) if:(= 0 (count at:(site)))) "BetweenRounds")) (phase "BetweenRounds" (play (if (<= 4 (count Cell at:(handSite Mover))) (move (from (handSite Mover)) (to (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))) count:4 (then (and {(if (is Mover P1) (remember Value "OwnedP1" (last To)) (remember Value "OwnedP2" (last To))) (if (<= 4 (count Cell at:(handSite Mover))) (moveAgain) (if (= 3 (count Cell at:(handSite Mover))) (and {(fromTo (from (handSite Mover)) (to (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))) count:3) (fromTo (from (handSite Next)) (to (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))) count:1) (if (is Mover P1) (remember Value "OwnedP1" (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))) (remember Value "OwnedP2" (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))))}) (if (= 2 (count Cell at:(handSite Mover))) (and {(fromTo (from (handSite Mover)) (to (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))) count:2) (fromTo (from (handSite Next)) (to (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))) count:2) (if (< 50 (value Random (range 1 100))) (remember Value "OwnedP1" (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))) (remember Value "OwnedP2" (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))))}))))}))))) (nextPhase (and (is Empty (handSite P1)) (is Empty (handSite P2))) "Sowing"))})) 
2x7 board, with three store holes. Three players. One player, the Raja, owns the three central holes in each row, one player owns the holes to the left and the other player the holes to the right. Seven counters in each hole. Players alternate turns sowing the counters in an anti-clockwise direction. When the final counter lands in a hole, the contents of the following hole are picked up, and sowing continues. If the following hole is empty, the contents of the next hole after that one are captured. Also, if at any point during the sowing a hole contains four counters, they are immediately captured. Play continues until all of the counters have been captured. If a player cannot play, they pass their turn, until captures are no longer possible, at which point the last person who played captures the remaining counters. A new round begins. The Raja gives each of the other players one counter. Players fill their holes with their captured counters, seven per hole. Any holes which can not be filled with seven counters are out of play. Play continues as before. A player plays as the Raja for three turns in a row, after which point it rotates to the next player. Play continues until only one player can fill holes on the board, this player becoming the winner.
(game "Raja Pasu Mandiri" (players 3) (equipment {(board (merge {(rectangle 1 7) (shift 0 2 (rectangle 1 7)) (shift 3 1 (square 1)) (shift 1 1 (square 1)) (shift 5 1 (square 1))}) {(track "Track" "6,W,7,E" loop:True)} use:Vertex) (piece "Seed" Shared) (map {(pair P1 15) (pair P2 14) (pair P3 16)})}) (rules (start {(set Count 7 to:(difference (sites Board) (sites Row 1))) (set RememberValue "Playable" (difference (sites Board) (sites Row 1)))}) phases:{(phase "Sowing" (play (or {(move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (if (is Mover P1) (if (> 3 (% (+ 1 (var "Round")) 9)) (sites {0 1 7 8}) (if (> 6 (% (+ 1 (var "Round")) 9)) (sites {2 3 4 9 10 11}) (sites {5 6 12 13}))) (if (is Mover P2) (if (> 3 (% (+ 1 (var "Round")) 9)) (sites {2 3 4 9 10 11}) (if (> 6 (% (+ 1 (var "Round")) 9)) (sites {5 6 12 13}) (sites {0 1 7 8}))) (if (> 3 (% (+ 1 (var "Round")) 9)) (sites {5 6 12 13}) (if (> 6 (% (+ 1 (var "Round")) 9)) (sites {0 1 7 8}) (sites {2 3 4 9 10 11})))))) if:(and (is Occupied (from)) (is In (from) (sites (values Remembered "Playable"))))) (then (do (set Var "NumSowed" (count at:(last To))) next:(sow apply:(if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to))) (if (is Occupied (trackSite Move from:(to) "Track" steps:1)) (fromTo (from (to)) (to (mapEntry Mover)) count:(count at:(to))))) skipIf:(not (is In (to) (sites (values Remembered "Playable"))))) (then (and (forEach Site (sites Track from:(last From) to:(trackSite Move from:(last From) "Track" steps:(var "NumSowed"))) (if (= 4 (count at:(site))) (fromTo (from (site)) (to (mapEntry Mover)) count:4))) (set Var "NumSowed" 0))))))} (then (if (> 4 (count in:(difference (sites Board) (sites Row 1)))) (and {(forEach Site (difference (sites Board) (sites Row 1)) (if (is Occupied (site)) (fromTo (from (site)) (to (mapEntry Mover)) count:(count at:(site))))) (if (and (= 6 (count Sites in:(if (> 3 (% (+ 1 (var "Round")) 9)) (sites {0 1 7 8}) (if (> 6 (% (+ 1 (var "Round")) 9)) (sites {2 3 4 9 10 11}) (sites {5 6 12 13}))))) (< 2 (count at:(mapEntry P1)))) (and (fromTo (from (mapEntry P1)) (to (mapEntry P2)) count:1) (fromTo (from (mapEntry P1)) (to (mapEntry P3)) count:1)) (if (and (= 6 (count Sites in:(if (> 3 (% (+ 1 (var "Round")) 9)) (sites {2 3 4 9 10 11}) (if (> 6 (% (+ 1 (var "Round")) 9)) (sites {5 6 12 13}) (sites {0 1 7 8}))))) (< 2 (count at:(mapEntry P2)))) (and (fromTo (from (mapEntry P2)) (to (mapEntry P1)) count:1) (fromTo (from (mapEntry P2)) (to (mapEntry P3)) count:1)) (if (and (= 6 (count Sites in:(if (> 3 (% (+ 1 (var "Round")) 9)) (sites {5 6 12 13}) (if (> 6 (% (+ 1 (var "Round")) 9)) (sites {0 1 7 8}) (sites {2 3 4 9 10 11}))))) (< 2 (count at:(mapEntry P3)))) (and (fromTo (from (mapEntry P3)) (to (mapEntry P1)) count:1) (fromTo (from (mapEntry P3)) (to (mapEntry P2)) count:1))))) (set Var "Round" (+ 1 (var "Round"))) (forget Value "Playable" All)}))))) (end {(if (> 4 (count in:(difference (sites Board) (sites Row 1)))) {(if (> 7 (count at:(mapEntry P1))) (result P1 Loss)) (if (> 7 (count at:(mapEntry P2))) (result P2 Loss)) (if (> 7 (count at:(mapEntry P3))) (result P3 Loss))})}) (nextPhase (> 4 (count in:(difference (sites Board) (sites Row 1)))) "BetweenRounds")) (phase "BetweenRounds" (play (if (not (all Sites (if (is Mover P1) (if (> 3 (% (+ 1 (var "Round")) 9)) (sites {0 1 7 8}) (if (> 6 (% (+ 1 (var "Round")) 9)) (sites {2 3 4 9 10 11}) (sites {5 6 12 13}))) (if (is Mover P2) (if (> 3 (% (+ 1 (var "Round")) 9)) (sites {2 3 4 9 10 11}) (if (> 6 (% (+ 1 (var "Round")) 9)) (sites {5 6 12 13}) (sites {0 1 7 8}))) (if (> 3 (% (+ 1 (var "Round")) 9)) (sites {5 6 12 13}) (if (> 6 (% (+ 1 (var "Round")) 9)) (sites {0 1 7 8}) (sites {2 3 4 9 10 11}))))) if:(is Occupied (site)))) (if (<= 7 (count at:(mapEntry Mover))) (move (from (mapEntry Mover)) (to (if (is Mover P1) (if (> 3 (% (+ 1 (var "Round")) 9)) (sites {0 1 7 8}) (if (> 6 (% (+ 1 (var "Round")) 9)) (sites {2 3 4 9 10 11}) (sites {5 6 12 13}))) (if (is Mover P2) (if (> 3 (% (+ 1 (var "Round")) 9)) (sites {2 3 4 9 10 11}) (if (> 6 (% (+ 1 (var "Round")) 9)) (sites {5 6 12 13}) (sites {0 1 7 8}))) (if (> 3 (% (+ 1 (var "Round")) 9)) (sites {5 6 12 13}) (if (> 6 (% (+ 1 (var "Round")) 9)) (sites {0 1 7 8}) (sites {2 3 4 9 10 11})))))) count:7 (then (remember Value "Playable" (last To))))))) (nextPhase (all Passed) "Sowing"))})) 
2x6 board. Four counters per hole. Sowing occurs in an anti-clockwise direction. When the final counter of a sowing lands in an occupied hole, these counters are picked up and the sowing continues. During sowing, the contents of any hole made to contain four counters are captured by the player in whose row the hole is located, except when this is the final counter of a sowing, in which case the player who is sowing captures these counters. When the sowing ends in an empty hole, the turn ends. Play continues until one player cannot move, and the other player captures the remaining counters. A second round is played, each player placing four counters into each hole starting from the rightmost hole in their row. The player with more counters gains a hole from their opponent for every four extra balls they've captured. If an opponent has three extra after counting in such a way, they also gain a hole, but not if there are one or two extra. Play continues in several rounds like this until one player captures all the holes.
(game "Rio Kadalis" (players 2) (equipment {(mancalaBoard 2 6 store:None {(track "TrackCCW" "0,E,N,W" loop:True) (track "TrackCW" "5,W,N,E" loop:True)}) (piece "Seed" Shared) (hand Each) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map "RightMost" {(pair P1 5) (pair P2 6)})}) (rules (start {(set Count 4 to:(sites Track)) (set RememberValue "OwnedP1" (sites Bottom)) (set RememberValue "OwnedP2" (sites Top))}) phases:{(phase "Sowing" (play (or {(move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (if (is Mover P1) (sites (values Remembered "OwnedP1")) (sites (values Remembered "OwnedP2")))) if:(is Occupied (from))) (then (do (set Var "NumSowed" (count at:(last To))) next:(sow "TrackCCW" apply:(if (= 4 (count at:(to))) (fromTo (from (to)) (to (handSite Mover)) count:4) (if (< 1 (count at:(to))) (and (moveAgain) (set Var "Replay" (to)))))) (then (and (forEach Site (sites Track from:(last From) to:(trackSite Move from:(last From) "Track" steps:(- (var "NumSowed") 1))) (if (= 4 (count at:(site))) (fromTo (from (site)) (to (if (is In (to) (sites (values Remembered "OwnedP1"))) (handSite P1) (handSite P2))) count:4))) (set Var "NumSowed" 0))))))} (then (if (and (not (is Next Mover)) (or (all Sites (sites (values Remembered "OwnedP1")) if:(is Empty (site))) (all Sites (sites (values Remembered "OwnedP2")) if:(is Empty (site))))) (and {(if (no Moves P1) (forEach Site (sites Board) (if (is Occupied (site)) (fromTo (from (site)) (to (handSite P1)) count:(count at:(site))))) (forEach Site (sites Board) (if (is Occupied (site)) (fromTo (from (site)) (to (handSite P2)) count:(count at:(site)))))) (forget Value "OwnedP1" All) (forget Value "OwnedP2" All)}))))) (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) {(if (> 3 (count Cell at:(handSite P1))) (result P2 Win)) (if (> 3 (count Cell at:(handSite P2))) (result P1 Win))})) (nextPhase (all Sites (sites Board) if:(= 0 (count at:(site)))) "BetweenRounds")) (phase "BetweenRounds" (play (if (<= 3 (count Cell at:(handSite Mover))) (move (from (handSite Mover)) (to (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))) count:(if (>= (count Cell at:(handSite Mover)) 4) 4 3) (then (if (is Mover P1) (remember Value "OwnedP1" (last To)) (remember Value "OwnedP2" (last To))))))) (nextPhase (all Passed) "Sowing"))})) 
2x6 board with two stores. Five counters in each hole. Sowing occurs in an anti-clockwise direction. When the final counter lands in a hole in the opponent's row containing one or two counters, thus making it contain two or three counters, they are captured. Any other holes in the opponent's row which also contain two or three counters, in an unbroken sequence preceding the hole where the first capture was made, are captured. When a player sows around the board, the hole from which the coutners were taken is left empty. Play ends when one player cannot play from their row, and players capture any remaining counters in their holes. The player with the most counters wins. The seeds have a normal size.
(game "Shono" (players 2) (equipment {(mancalaBoard 2 6 (track "Track" "1,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 FirstSite) (pair P2 LastSite)}) (piece "Seed" Shared)}) (rules (start (set Count 5 to:(sites Track))) (play (move Select (from (sites Mover) if:(< 0 (count at:(from)))) (then (sow if:(and (is In (to) (sites Next)) (or (= (count at:(to)) 2) (= (count at:(to)) 3))) apply:(fromTo (from (to)) (to (mapEntry (mover))) count:(count at:(to))) includeSelf:False backtracking:True)))) (end (if (no Moves Mover) (byScore {(score P1 (+ (count at:(mapEntry P1)) (count in:(sites P1)))) (score P2 (+ (count at:(mapEntry P2)) (count in:(sites P2))))}))))) 
2x5 board with one store on either side. Six counters in each hole. Players play each turn simultaneously. Players sow from the holes in their row in an anti-clockwise direction, including their own store but not the opponent's store. When the final counter is sown, the contents of the next hole are picked up and sowing continues. If this hole is empty, the move ends and the player must wait for the other player to finish the move before they begin again. If the move ends in the player's own row, the player captures the counters in the opponent's row opposite to the one in which the last counter was dropped. Play continues until all of the counters are in the stores. The counters are then redistributed into the holes as at the beginning of the game. The player with extra counters places them in the store.
(game "Sonka" (players 2) (equipment {(mancalaBoard 2 5 {(track "Track1" "11,10,W,S,E" loop:True P1) (track "Track2" "0,1,E,N,W" loop:True P2)}) (piece "Seed" Shared) (regions "Home" P1 (sites Bottom)) (regions "Home" P2 (sites Top)) (map {(pair P1 LastSite) (pair P2 FirstSite)})}) (rules (start (set Count 6 to:(union (sites Bottom) (sites Top)))) phases:{(phase "Sowing" (play (move Select (from (if (is Prev Mover) (sites {(if (= (trackSite Move from:(last To afterConsequence:True) steps:1) (mapEntry Mover)) (trackSite Move from:(last To afterConsequence:True) steps:2) (trackSite Move from:(last To afterConsequence:True) steps:1))}) (sites Mover "Home")) if:(< 0 (count at:(from)))) (then (sow "Track" owner:(mover) apply:(if (!= 0 (count at:(if (= (trackSite Move from:(to) steps:1) (mapEntry Mover)) (trackSite Move from:(to) steps:2) (trackSite Move from:(to) steps:1)))) (moveAgain) (if (is In (to) (sites Mover "Home")) (if (!= 0 (count at:(if (is Mover P1) (+ (to) 5) (- (to) 5)))) (fromTo (from (if (is Mover P1) (+ (to) 5) (- (to) 5))) (to (mapEntry Mover)) count:(count at:(if (is Mover P1) (+ (to) 5) (- (to) 5))))))))))) (end (if (all Passed) {(if (> 6 (count at:(mapEntry P1))) (result P2 Win)) (if (> 6 (count at:(mapEntry P2))) (result P1 Win))})) (nextPhase (all Passed) "BetweenRounds")) (phase "BetweenRounds" (play (if (<= 6 (count at:(mapEntry Mover))) (move (from (mapEntry Mover)) (to (intersection (sites Empty) (sites Mover "Home"))) count:6))) (nextPhase (all Passed) "Sowing"))})) 
2x7 board, with two stores. Each player owns the store to their left. Seven counters per hole. Players take counters from one hole and sow them in a clockwise direction starting in the next hole from which the counters were taken. Players include their own store when sowing but ignore their opponent's store. If last counter falls into an empty hole, move ends. If it is on the player's side, the counters in the opponent's hole opposite are taken and added to the player's store. If the last counter falls into the player's store, the player may sow counters from another hole on their side. If the last counter drops into an occupied hole on either side of the board, the counters are picked up and sowing continues until the last counter drops into an empty hole. When all of the counters are in the players' stores, a new round begins. Players fill their holes with the counters in their store. Any holes which cannot be filled with seven counters are out of play for this round; any extra counters go back in the store. Play continues until one player cannot fill any holes, and the opponent wins.
(game "Sungka" (players 2) (equipment {(mancalaBoard 2 7 (track "Track" "7,W,WNW,ENE,E,ESE" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 FirstSite) (pair P2 LastSite)}) (piece "Seed" Shared)}) (rules (start (set Count 7 to:(union (sites P1) (sites P2)))) phases:{(phase "Sowing" (play (move Select (from (if (and (is Prev Mover) (not (is Pending))) (sites {(var)}) (sites Mover)) if:(< 0 (count at:(from)))) (then (sow apply:(if (= (to) (mapEntry Mover)) (and (moveAgain) (set Pending)) (if (and {(is In (to) (sites Mover)) (= (count at:(to)) 1) (< 0 (count at:(if (is Mover P1) (+ (to) 7) (- (to) 7))))}) (fromTo (from (if (is Mover P1) (+ (to) 7) (- (to) 7))) (to (mapEntry (mover))) count:(count at:(if (is Mover P1) (+ (to) 7) (- (to) 7)))) (if (> (count at:(to)) 1) (and (moveAgain) (set Var (to)))))) skipIf:(= (to) (mapEntry Next)))))) (end (if (all Passed) {(if (> 7 (count at:(mapEntry P1))) (result P2 Win)) (if (> 7 (count at:(mapEntry P2))) (result P1 Win))})) (nextPhase (all Passed) "BetweenRounds")) (phase "BetweenRounds" (play (if (<= 7 (count at:(mapEntry Mover))) (move (from (mapEntry Mover)) (to (intersection (sites Empty) (sites Mover))) count:7))) (nextPhase (all Passed) "Sowing"))})) 
2x6 board. Four counters in each hole. Players sow counters in a clockwise directions from one of the holes in their opponent's row. When the final counter lands in an occupied hole, the contents of that hole are picked up and sowing continues, unless the next hole is empty, in which case the contents of the next hole after the empty hole are captured. When the final counter falls in an empty hole, the turn ends. Play continues until all of the holes are empty in one of the rows. The player who captured the most counters wins.
(game "Tap Urdy" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "5,W,N,E" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (hand Each) (piece "Seed" Shared)}) (rules (start (set Count 4 to:(sites Track))) (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Next)) if:(< 0 (count at:(from)))) (then (sow apply:(if (and (!= (count at:(trackSite Move from:(to) steps:1)) 0) (> (count at:(to)) 1)) (moveAgain) (if (and (= (count at:(trackSite Move from:(to) steps:1)) 0) (> (count at:(to)) 1)) (fromTo (from (trackSite Move from:(to) steps:2)) (to (handSite (mover))) count:(count at:(trackSite Move from:(to) steps:2))))))))) (end (if (or (all Sites (sites P1) if:(= 0 (count at:(site)))) (all Sites (sites P2) if:(= 0 (count at:(site))))) (byScore {(score P1 (+ (count Cell at:(handSite P1)) (count in:(sites P1)))) (score P2 (+ (count Cell at:(handSite P2)) (count in:(sites P2))))}))))) 
2x12 board. Beginning from the leftmost hole closest to a player and proceeding in an anti-clockwise direction, the opening arrangement of counters is an alternating pattern of one empty hole, followed by two holes with three counters each. The first move for each player must be from an occupied hole in the right half of their row. Players sow in an anti-clockwise direction, but if the final counter is about to fall in a hole in the player's own row, it is instead placed in the first hole in the opponent's row. After this, players may sow from any hole in their row, provided that the final counter does not fall into an occupied hole in their row. When the final counter of a sowing lands in an occupied hole in the opponent's row, the counters there are picked up and sowing continues. When this happens, the player is allowed to drop the final counter into an occupied hole in their row, which would then be picked up and sowing would continue as before. When the final counter falls into an empty hole in the player's row, any counters in the opponent's hole opposite are captured. When the final counter falls into an empty hole in the opponent's row, the turn ends. The player who captures all of the opponent's counters wins. Players typically play to achieve five consecutive wins. 
(game "Tapata" (players 2) (equipment {(mancalaBoard 2 12 store:None (track "TrackCCW" "0,E,N,W" loop:True)) (piece "Seed" Shared) (regions "Home" P1 (sites Bottom)) (regions "Home" P2 (sites Top)) (regions "Right Half" P1 (intersection (sites Bottom) (expand (sites Right) steps:5))) (regions "Right Half" P2 (intersection (sites Top) (expand (sites Left) steps:5))) (map {(pair P1 0) (pair P2 23)})}) (rules (start (set Count 3 to:(sites {1 2 4 5 7 8 10 11 22 21 19 18 16 15 13 12}))) phases:{(phase "FirstMove" (play (move Select (from (difference (sites Mover "Right Half") (sites Empty))) (then (sow apply:(if (is In (to) (sites Mover "Home")) (fromTo (from (to)) (to (mapEntry Next)))))))) (nextPhase Mover "Play")) (phase "Play" (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover "Home")) if:(and (> (count at:(from)) 0) (or (is Prev Mover) (and (not (is Prev Mover)) (not (and (is In (trackSite Move from:(from) steps:(count at:(from))) (sites Mover "Home")) (!= 0 (count at:(trackSite Move from:(from) steps:(count at:(from))))))))))) (then (sow apply:(if (< 1 (count at:(to))) (moveAgain) (if (and (!= 0 (count at:(if (is Mover P1) (+ (to) 12) (- (to) 12)))) (is In (to) (sites Mover "Home"))) (remove (if (is Mover P1) (+ (to) 12) (- (to) 12))))))))))} (end (forEach NonMover if:(= (count in:(sites Player "Home")) 0) (result Player Loss))))) 
2x6 board with two stores. Four counters per hole. Sowing occurs in an anti-clockwise direction. In the first and second moves, players may choose to drop as many counters as they wish into the holes they are sowing into. From the third turn on, the players must sow one counter at a time. The hole from which a sowing began is skipped if the sowing goes all the way around the board. When the final counter lands in a hole containing one or two people, thus causing it to contain two or three, these are captured. Any previous holes, in an unbroken sequence, also containing two or three counters, are captured. A move of a single counter cannot capture. When a player's row is empty, the opponent must sow into their row if it is possible to do so. Play ends when one player's row is empty, and the opponent claims all of the remaining counters. The player with the most counters wins.
(game "Ti" (players 2) (equipment {(mancalaBoard 2 6 (track "Track" "1,E,N,W" loop:True)) (regions "Home" P1 (sites Bottom)) (regions "Home" P2 (sites Top)) (map {(pair P1 FirstSite) (pair P2 LastSite)}) (piece "Seed" Shared)}) (rules (start (set Count 4 to:(sites Track))) phases:{(phase "TwoFirstTurn" (play (if (is Prev Mover) (forEach Value min:1 max:(var "NumCounters") (move Add (piece (id "Seed" Shared)) (to (trackSite Move from:(last To) "Track" steps:1) (apply (set Var "NumCounters" (- (var "NumCounters") (value))))) count:(value) (then (if (< 0 (var "NumCounters")) (moveAgain) (set Value Mover (+ 1 (value Player Mover))))))) (move Select (from (sites Mover "Home") if:(> (count at:(from)) 0)) (then (and {(moveAgain) (remove (last To) count:(count at:(last To))) (set Var "NumCounters" (count at:(last To)))}))))) (nextPhase Mover (= (value Player Mover) 1) "Sowing")) (phase "Sowing" (play (do (or (move Select (from (sites Mover "Home") if:(> (count at:(from)) 1)) (then (sow if:(or (= (count at:(to)) 2) (= (count at:(to)) 3)) apply:(fromTo (from (to)) (to (mapEntry (mover))) count:(count at:(to))) includeSelf:False backtracking:True))) (move Select (from (sites Mover "Home") if:(= (count at:(from)) 1)) (then (sow)))) ifAfterwards:(< 0 (count in:(sites Next "Home"))))))} (end (if (no Moves Mover) (byScore {(score P1 (+ (count at:(mapEntry P1)) (count in:(sites P1)))) (score P2 (+ (count at:(mapEntry P2)) (count in:(sites P2))))}))))) 
2x9 board, with two stores in between the holes. Players own the store to their right. Nine counters in each hole. A player takes all of the counters from one of the holes in their row and sows them anti-clockwise. The first stone is dropped into the hole that was just emptied, except when there is only one stone, in which case it is moved to the next hole. If the last counter falls into an opponent's hole making this hole have an even number of counters, these counters are captured and placed in the player's store. Otherwise, the turn ends. When the last counter falls into an opponent's hole, making it contain three counters, it is made into a "tuzduk." A player can only create one tuzduk per game. When a player creates a tuzduk, the opponent cannot create a tuzduk in the same hole in the player's row, with respect to the index of the hole in the respective player's hole. Stones that fall into a tuzduk are captured by its owner. The game ends when a player cannot move because all of the holes, except the tuzduk, are empty. The other player claims the remaining counters and the player with the most counters wins.
(game "Toguz Kumalak" (players 2) (equipment {(board (merge {(rectangle 1 9) (shift 2.5 1 (rectangle 1 1)) (shift 5.5 1 (rectangle 1 1)) (shift 0 2 (rectangle 1 9))}) (track "Track" "0,E,19,W" loop:True) use:Vertex) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 9) (pair P2 10)}) (piece "Seed" Shared)}) (rules (start (set Count 9 to:(sites Track))) (play (move Select (from (sites Mover) if:(> (count at:(from)) 0)) (then (sow apply:(if (and (is In (to) (sites Next)) (is Even (count at:(to)))) (fromTo (from (to)) (to (mapEntry (mover))) count:(count at:(to))) (if (and {(is In (to) (sites Next)) (= (count at:(to)) 3) (< (value Player Mover) 0) (if (< (value Player Next) 0) True (!= (+ (to) (value Player Next)) 19))}) (and (set Value Mover (to)) (fromTo (from (to)) (to (mapEntry (mover))) count:(count at:(to)))))) origin:(!= (count at:(last From)) 1) (then (and (if (and (> (value Player P1) 0) (> (count at:(value Player P1)) 0)) (fromTo (from (value Player P1)) (to (mapEntry P1)) count:(count at:(value Player P1)))) (if (and (> (value Player P2) 0) (> (count at:(value Player P2)) 0)) (fromTo (from (value Player P2)) (to (mapEntry P2)) count:(count at:(value Player P2)))))))))) (end (if (no Moves Mover) (byScore {(score P1 (+ (count at:(mapEntry P1)) (count in:(sites P1)))) (score P2 (+ (count at:(mapEntry P2)) (count in:(sites P2))))}))))) 
2x6 board. Four counters in each hole. Players draw lots to see who goes first. There is a choice of stylised opening move. One player takes a counter from their rightmost hole, then another from the opposite hole in the opponent's row, then proceeding in this fashion in an anti-clockwise direction until the holes alternate with five and three counters, until reaching the hole from which sowing began, which will hold four. The original counter is sown into the next hole in the opponent's row, making four, thus creating a tuz, which behaves as explained below. Alternatively, the player may rearrange the counters in a similar manner, but creating an alternating pattern of holes with three and five counters, and not creating a tuz. After this, players pick up the counters in any of the holes in their row and sow them in an anti-clockwise direction. If the last counter falls into a hole that is occupied, the player picks up the contents of this hole and continues to sow. When the last counter falls into an empty hole, the play ends. Capturing occurs when the last counter falls into a hole on the opponent's side of the board containing three counters, increasing it to four. This hole, a tuz, then belongs to the player who captured it. A player cannot pick up counters from this hole, and the opponent can only do so if the last counter of their sowing falls in the tuz, in which case the opponent takes one counter from it, along with the final counter. The tuz remains in the ownership of the person who captured it. If it remains empty and the opponent drops their last counter into the tuz, the last counter is removed. Play then continues by picking up the contents of another hole and continuing to sow. If a player cannot move, they pass, but the opponent may continue to make moves. The player could then resume play if the opponent's moves create a possibility for a move. Play ends when there are no more counters available to move. Each player owns the counters in their tuz or which they have removed from the board. A second round is played, each player placing four counters into each hole starting from the rightmost hole in their row. The player with more counters gains a hole from their opponent for every four extra balls they've captured. If an opponent has three extra after counting in such a way, they also gain a hole, and if each player has two remaining counters ownership is determined by chance. Play continues in several rounds like this until one player takes all the counters.
(game "Tuz" (players 2) (equipment {(mancalaBoard 2 6 store:None {(track "TrackCCW" "0,E,N,W" loop:True) (track "TrackCW" "5,W,N,E" loop:True)}) (piece "Seed" Shared) (hand Each) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map "RightMost" {(pair P1 5) (pair P2 6)})}) (rules (start {(set RememberValue "OwnedP1" (sites Bottom)) (set RememberValue "OwnedP2" (sites Top)) (set Count 4 to:(sites Track))}) phases:{(phase "Opening" (play (move Select (from (if (is Prev Mover) (sites {(trackSite Move from:(last From) "TrackCCW" steps:2)}) (union (sites {10}) (intersection (sites Bottom) (sites Right))))) (then (sow count:1 "TrackCCW" apply:(if (not (is In (trackSite Move from:(from) "TrackCCW" steps:2) (intersection (sites Bottom) (sites Right)))) (moveAgain) (if (= 4 (count at:11)) (set State at:11 (mover)))))))) (nextPhase (is In (trackSite Move from:(last From) "TrackCCW" steps:2) (intersection (sites Bottom) (sites Right))) "Sowing")) (phase "Sowing" (play (or {(move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (if (is Mover P1) (sites (values Remembered "OwnedP1")) (sites (values Remembered "OwnedP2")))) if:(and (< 0 (count at:(from))) (= 0 (state at:(from))))) (then (sow "TrackCCW" apply:(if (and {(= 0 (state at:(to))) (= 4 (count at:(to))) (is In (to) (if (is Mover P1) (sites (values Remembered "OwnedP2")) (sites (values Remembered "OwnedP1"))))}) (set State at:(to) (mover)) (if (< 1 (count at:(to))) (if (= 0 (state at:(to))) (and (moveAgain) (set Var "Replay" (to))) (if (!= (mover) (state at:(to))) (and (fromTo (from (to)) (to (handSite Mover)) count:(min 2 (count at:(to)))) (set State at:(to) (state at:(to)))))))))))} (then (if (all Sites (forEach (sites Board) if:(= 0 (state at:(site)))) if:(= 0 (count at:(site)))) (and {(forEach Site (forEach (sites Board) if:(= 1 (state at:(site)))) (fromTo (from (site)) (to (handSite P1)) count:(count at:(site)))) (forEach Site (forEach (sites Board) if:(= 2 (state at:(site)))) (fromTo (from (site)) (to (handSite P2)) count:(count at:(site)))) (forget Value "OwnedP1" All) (forget Value "OwnedP2" All)}))))) (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) {(if (= 0 (count Cell at:(handSite P1))) (result P2 Win)) (if (= 0 (count Cell at:(handSite P2))) (result P1 Win))})) (nextPhase (all Sites (sites Board) if:(= 0 (count at:(site)))) "BetweenRounds")) (phase "BetweenRounds" (play (if (<= 4 (count Cell at:(handSite Mover))) (move (from (handSite Mover)) (to (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))) count:4 (then (and {(if (is Mover P1) (remember Value "OwnedP1" (last To)) (remember Value "OwnedP2" (last To))) (if (<= 4 (count Cell at:(handSite Mover))) (moveAgain) (if (= 3 (count Cell at:(handSite Mover))) (and {(fromTo (from (handSite Mover)) (to (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))) count:3) (fromTo (from (handSite Next)) (to (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))) count:1) (if (is Mover P1) (remember Value "OwnedP1" (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))) (remember Value "OwnedP2" (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))))}) (if (= 2 (count Cell at:(handSite Mover))) (and {(fromTo (from (handSite Mover)) (to (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))) count:2) (fromTo (from (handSite Next)) (to (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))) count:2) (if (< 50 (value Random (range 1 100))) (remember Value "OwnedP1" (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))) (remember Value "OwnedP2" (trackSite FirstSite "TrackCW" from:(mapEntry "RightMost" Mover) if:(is Empty (to)))))}))))}))))) (nextPhase (and (is Empty (handSite P1)) (is Empty (handSite P2))) "Sowing"))})) 
2x6 board. Four counters in each hole. Players sow from any of the holes in their row in an anti-clockwise direction. When the final counter of a sowing falls into an occupied hole (except in the scenario below), these are picked up and sowing continues. If the final counter falls into either an empty hole or one of the opponent's holes with three counters, making that hole now have four counters, the sowing ends. When the final counter falls into a hole in the opponent's row containing four counters after sowing concludes, this hole is marked. If a player sows their final counter into their opponent's marked hole, the final counter and one of the counters in the hole are captured. The player then gets another turn. If the final counter falls into a player's own marked hole, the turn ends. The contents of marked holes cannot be sown. The game ends when only marked holes contain counters. These are then captured by the players who marked them. A new game begins. The player with the most counters places four in each hole beginning from the left hole in their row. Each hole that contains four counters is owned by that player for the new round. If the player has three counters remaining after filling as many holes with four as possible, they borrow one counter from the opponent to make four and own the corresponding hole. If there are two or one remaining, the opponent borrows these to fill and own the last hole. Play continues until one player owns no more holes.
(game "Um el Banat" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "0,E,N,W" loop:True)) (regions "Home" P1 (sites Bottom)) (regions "Home" P2 (sites Top)) (piece "Seed" Shared) (hand Each) (map "LeftMost" {(pair P1 0) (pair P2 11)})}) (rules (start {(set Count 4 to:(sites Track)) (set RememberValue "OwnedP1" (sites Bottom)) (set RememberValue "OwnedP2" (sites Top))}) phases:{(phase "Sowing" (play (or {(move Select (from (if (and (is Prev Mover) (= 1 (var "ContinueSowing"))) (sites {(last To afterConsequence:True)}) (if (is Mover P1) (sites (values Remembered "OwnedP1")) (sites (values Remembered "OwnedP2")))) if:(and (< 0 (count at:(from))) (= 0 (state at:(from))))) (then (sow apply:(if (= (next) (state at:(to))) (and {(move (from (to)) (to (handSite Mover)) count:(min 2 (count at:(to)))) (moveAgain) (set Var "ContinueSowing" 0)}) (if (= (mover) (state at:(to))) (set Var "ContinueSowing" 0) (if (and (< 1 (count at:(to))) (!= 4 (count at:(to)))) (and (moveAgain) (set Var "ContinueSowing" 1)) (if (and (= 4 (count at:(to))) (not (is In (sites Mover "Home")))) (and (set State at:(to) (mover)) (set Var "ContinueSowing" 0)))))))))} (then (if (all Sites (forEach (sites Board) if:(= 0 (state at:(site)))) if:(= 0 (count at:(site)))) (and {(forEach Site (forEach (sites Board) if:(= 1 (state at:(site)))) (fromTo (from (site)) (to (handSite P1)) count:(count at:(site)))) (forEach Site (forEach (sites Board) if:(= 2 (state at:(site)))) (fromTo (from (site)) (to (handSite P2)) count:(count at:(site)))) (forget Value "OwnedP1" All) (forget Value "OwnedP2" All) (if (>= (+ (count Cell at:(handSite 1)) (count in:(forEach (sites Board) if:(= 1 (state at:(site)))))) (+ (count Cell at:(handSite 2)) (count in:(forEach (sites Board) if:(= 2 (state at:(site))))))) (set NextPlayer (player 1)) (set NextPlayer (player 2)))}))))) (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) {(if (= 0 (count Cell at:(handSite P1))) (result P2 Win)) (if (= 0 (count Cell at:(handSite P2))) (result P1 Win))})) (nextPhase (all Sites (sites Board) if:(= 0 (count at:(site)))) "BetweenRounds")) (phase "BetweenRounds" (play (if (<= 4 (count Cell at:(handSite Mover))) (move (from (handSite Mover)) (to (trackSite FirstSite from:(mapEntry "LeftMost" Mover) if:(is Empty (to)))) count:4 (then (and {(if (is Mover P1) (remember Value "OwnedP1" (last To)) (remember Value "OwnedP2" (last To))) (if (<= 4 (count Cell at:(handSite Mover))) (moveAgain) (if (= 3 (count Cell at:(handSite Mover))) (and {(fromTo (from (handSite Mover)) (to (trackSite FirstSite from:(mapEntry "LeftMost" Mover) if:(is Empty (to)))) count:3) (fromTo (from (handSite Next)) (to (trackSite FirstSite from:(mapEntry "LeftMost" Mover) if:(is Empty (to)))) count:1) (if (is Mover P1) (remember Value "OwnedP1" (trackSite FirstSite from:(mapEntry "LeftMost" Mover) if:(is Empty (to)))) (remember Value "OwnedP2" (trackSite FirstSite from:(mapEntry "LeftMost" Mover) if:(is Empty (to)))))}) (fromTo (from (handSite Mover)) (to (handSite Next)) count:(count Cell at:(handSite Mover)))))}))))) (nextPhase (and (is Empty (handSite P1)) (is Empty (handSite P2))) "Sowing"))})) 
2x3 board. Three counters in each hole. Players sow from any one of their holes. Sowing can occur in the following directions: From the leftmost hole, clockwise; from the rightmost hole, anti-clockwise; from the center hole, the player may choose either direction. If the final counter falls into a hole in the opponent's row containing one counter, making it now contain two, these are taken. If the holes before them also contain two, in an unbroken sequence, they may all be captured. Single counters cannot be sown. When neither player can move, the single counters in each player's rows are taken by the player belonging to those rows. The player with the most counters wins.
(game "Um el Tuweisat" (players 2) (equipment {(mancalaBoard 2 3 store:None {(track "TrackCCW" "0,E,N,W" loop:True) (track "TrackCW" "2,W,N,E" loop:True)}) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map "RightHole" {(pair P1 2) (pair P2 3)}) (map "CenterHole" {(pair P1 1) (pair P2 4)}) (map "LeftHole" {(pair P1 0) (pair P2 5)}) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 3 to:(sites Track))) (play (or {(move Select (from (mapEntry "RightHole" (mover)) if:(> (count at:(from)) 1)) (then (sow "TrackCCW" if:(and (= (count at:(to)) 2) (is In (to) (sites Next))) apply:(fromTo (from (to)) (to (handSite Mover)) count:(count at:(to))) backtracking:True))) (move Select (from (mapEntry "LeftHole" (mover)) if:(> (count at:(from)) 1)) (then (sow "TrackCW" if:(and (= (count at:(to)) 2) (is In (to) (sites Next))) apply:(fromTo (from (to)) (to (handSite Mover)) count:(count at:(to))) backtracking:True))) (move Select (from (mapEntry "CenterHole" (mover)) if:(> (count at:(from)) 1)) (then (sow "TrackCCW" if:(and (= (count at:(to)) 2) (is In (to) (sites Next))) apply:(fromTo (from (to)) (to (handSite Mover)) count:(count at:(to))) backtracking:True))) (move Select (from (mapEntry "CenterHole" (mover)) if:(> (count at:(from)) 1)) (then (sow "TrackCW" if:(and (= (count at:(to)) 2) (is In (to) (sites Next))) apply:(fromTo (from (to)) (to (handSite Mover)) count:(count at:(to))) backtracking:True)))})) (end (if (and (no Moves P1) (no Moves P2)) (byScore {(score P1 (+ (count Cell at:(handSite P1)) (count in:(sites P1)))) (score P2 (+ (count Cell at:(handSite P2)) (count in:(sites P2))))}))))) 
2x5 board. Play begins with five counters in each hole. Players sow from any one of their holes. Sowing can occur in the following directions: From the leftmost two holes: clockwise. From the rightmost two holes: anti-clockwise. from the center hole: the player may choose either direction. If the final counter falls into a hole in the opponent's row containing either one or three counters, making it now contain two or four, these are taken. If the holes before them also contain two or four, in an unbroken sequence, they may all be captured. Single counters cannot be sown. When neither player can move, the single counters in each player's rows are taken by the player belonging to those rows. The player with the most counters wins.
(game "Um el-Bagara" (players 2) (equipment {(mancalaBoard 2 5 store:None {(track "TrackCCW" "0,E,N,W" loop:True) (track "TrackCW" "4,W,N,E" loop:True)}) (regions "Home1" P1 (sites Bottom)) (regions "Home2" P2 (sites Top)) (regions "Left1" P1 (sites {0 1 2})) (regions "Left2" P2 (sites {9 8 7})) (regions "Right1" P1 (sites {2 3 4})) (regions "Right2" P2 (sites {7 6 5})) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 5 to:(sites Track))) (play (or (move Select (from (sites Mover "Left") if:(> (count at:(from)) 1)) (then (sow "TrackCW" if:(and (is In (to) (sites Next "Home")) (or (= (count at:(to)) 2) (= (count at:(to)) 4))) apply:(fromTo (from (to)) (to (handSite Mover)) count:(count at:(to))) backtracking:True))) (move Select (from (sites Mover "Right") if:(> (count at:(from)) 1)) (then (sow "TrackCCW" if:(and (is In (to) (sites Next "Home")) (or (= (count at:(to)) 2) (= (count at:(to)) 4))) apply:(fromTo (from (to)) (to (handSite Mover)) count:(count at:(to))) backtracking:True))))) (end (if (all Passed) (byScore {(score P1 (+ (count Cell at:(handSite P1)) (count in:(sites P1)))) (score P2 (+ (count Cell at:(handSite P2)) (count in:(sites P2))))}))))) 
2x6 board. Four counters in each hole. Sowing occurs in an anti-clockwise direction. The first player sows from the hole on their right. When the final counter lands in an occupied hole, the turn ends. When the final counter lands in an empty hole, that counter is captured. The player who captures the most counters wins. The game is played with 6 holes per row.
(game "Um el-Bil" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "0,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 4 to:(sites Track))) phases:{(phase "Opening" (play (move Select (from (- 6 1)) (then (sow if:(= (count at:(to)) 1) apply:(fromTo (from (to)) (to (handSite Mover)) count:1))))) (nextPhase "Play")) (phase "Play" (play (move Select (from (sites Mover) if:(< 0 (count at:(from)))) (then (sow if:(= (count at:(to)) 1) apply:(fromTo (from (to)) (to (handSite Mover)) count:1))))))} (end (if (all Sites (sites Board) if:(is Empty (site))) (byScore {(score P1 (count Cell at:(handSite P1))) (score P2 (count Cell at:(handSite P2)))}))))) 
2x6 board. Six counters in each hole. Sowing occurs from any of the holes in the player's row, and continues in a clockwise direction. If the final counter lands in a hole in the player's row containing three counters, four with the addition of the final counter, these are captured. Play continues until one player cannot move or the board position repeats. When one player cannot move, the other player captures the remaining counters. The player with the most counters wins. The game ends if no moves or a repeating state is detected.
(game "Unnee Tugalluulax" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "5,W,N,E" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 6 to:(sites Track))) (play (move Select (from (sites Mover) if:(< 0 (count at:(from)))) (then (sow if:(= (count at:(to)) 4) apply:(fromTo (from (to)) (to (handSite Mover)) count:(count at:(to))))))) (end (if (or (no Moves Mover) (is Cycle)) (byScore {(score P1 (+ (count Cell at:(handSite P1)) (count in:(sites P1)))) (score P2 (+ (count Cell at:(handSite P2)) (count in:(sites P2))))}))))) 
2x6 board with a store on either end. Four counters in each hole. Players take turns sowing in an anti-clockwise direction from one of the holes in their row. Counters are captured when the final counter of a sowing is dropped into a hole in the opponent's row containing one or two counters, making it contain two or three counters. If the previous hole also contains two or three counters, they are also captured, in an unbroken line until a hole with a different number of counters is reached. If, while sowing, the hole from which the sowing originated is reached, this hole is skipped and sowing continues. If a player has no counters in their holes, the opponent must play so as to place counters in their row. The player who captures 25 coutners first wins.
(game "Uril" (players 2) (equipment {(mancalaBoard 2 6 (track "Track" "1,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 FirstSite) (pair P2 LastSite)}) (piece "Seed" Shared)}) (rules (start (set Count 4 to:(sites Track))) (play (do (move Select (from (sites Mover) if:(< 0 (count at:(from)))) (then (sow if:(and (is In (to) (sites Next)) (or (= (count at:(to)) 2) (= (count at:(to)) 3))) apply:(fromTo (from (to)) (to (mapEntry (mover))) count:(count at:(to))) includeSelf:False backtracking:True))) ifAfterwards:(< 0 (count in:(sites Next))))) (end (forEach Player if:(>= (count at:(mapEntry Player)) 25) (result Player Win))))) 
2x8 and two stores. Five counters per hole. On each player's first move, they sow three counters into the first hole and two into the second hole. After this, sowing proceeds as usual, with one counter in each hole. Sowing may occur in either direction. When the final counter lands in an occupied hole, the contents of this hole are picked up and sowing continues in the opposite direction. When the final counter falls in an empty hole in the player's own row, the contents of the opposite hole are captured. If the final counter falls into the first of a series of empty holes, the contents of all of the holes opposite the empty holes are captured. It is necessary to enter the opponent's row first and return before making a capture.If the final counter lands in an empty hole in the opponent's row, the turn ends. The winner is the player who has captured the most counters.
(game "Uthi" (players 2) (equipment {(mancalaBoard 2 8 {(track "TrackCW" "8,W,N,E" loop:True) (track "TrackCCW" "1,E,N,W" loop:True)}) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 FirstSite) (pair P2 LastSite)}) (piece "Seed" Shared)}) (rules (start (set Count 5 to:(sites Track))) phases:{(phase "Opening" (play (or (move Select (from (sites Mover)) (then (and (fromTo (from (last To)) (to (trackSite Move from:(last To) "TrackCW" steps:1)) count:3) (fromTo (from (last To)) (to (trackSite Move from:(last To) "TrackCW" steps:2)) count:2)))) (move Select (from (sites Mover)) (then (and (fromTo (from (last To)) (to (trackSite Move from:(last To) "TrackCCW" steps:1)) count:3) (fromTo (from (last To)) (to (trackSite Move from:(last To) "TrackCCW" steps:2)) count:2)))))) (nextPhase Mover "Sowing")) (phase "Sowing" (play (or (if (!= (value Player Mover) 1) (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover)) if:(> (count at:(from)) 0)) (then (sow "TrackCW" apply:(if (> (count at:(to)) 1) (and {(moveAgain) (set Value Mover 1) (if (is In (to) (sites Next)) (set Var "GoInOpponentRow" 1))}) (and {(set Value Mover 0) (set Var "GoInOpponentRow" 0) (if (and (= 1 (var "GoInOpponentRow")) (is In (to) (sites Mover))) (if (!= 0 (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (mapEntry Mover)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))) (then (if (and (is Empty (trackSite Move from:(last From) "TrackCW" steps:1)) (is In (trackSite Move from:(last From) "TrackCW" steps:1) (sites Mover))) (and (if (!= 0 (count at:(trackSite Move from:(last From) "TrackCW" steps:1))) (fromTo (from (trackSite Move from:(last From) "TrackCW" steps:1)) (to (mapEntry Mover)) count:(count at:(trackSite Move from:(last From) "TrackCW" steps:1)))) (if (and (is Empty (trackSite Move from:(last From) "TrackCW" steps:2)) (is In (trackSite Move from:(last From) "TrackCW" steps:2) (sites Mover))) (and (if (!= 0 (count at:(trackSite Move from:(last From) "TrackCW" steps:2))) (fromTo (from (trackSite Move from:(last From) "TrackCW" steps:2)) (to (mapEntry Mover)) count:(count at:(trackSite Move from:(last From) "TrackCW" steps:2)))) (if (and (is Empty (trackSite Move from:(last From) "TrackCW" steps:3)) (is In (trackSite Move from:(last From) "TrackCW" steps:3) (sites Mover))) (and (if (!= 0 (count at:(trackSite Move from:(last From) "TrackCW" steps:3))) (fromTo (from (trackSite Move from:(last From) "TrackCW" steps:3)) (to (mapEntry Mover)) count:(count at:(trackSite Move from:(last From) "TrackCW" steps:3)))) (if (and (is Empty (trackSite Move from:(last From) "TrackCW" steps:4)) (is In (trackSite Move from:(last From) "TrackCW" steps:4) (sites Mover))) (and (if (!= 0 (count at:(trackSite Move from:(last From) "TrackCW" steps:4))) (fromTo (from (trackSite Move from:(last From) "TrackCW" steps:4)) (to (mapEntry Mover)) count:(count at:(trackSite Move from:(last From) "TrackCW" steps:4)))) (if (and (is Empty (trackSite Move from:(last From) "TrackCW" steps:5)) (is In (trackSite Move from:(last From) "TrackCW" steps:5) (sites Mover))) (and (if (!= 0 (count at:(trackSite Move from:(last From) "TrackCW" steps:5))) (fromTo (from (trackSite Move from:(last From) "TrackCW" steps:5)) (to (mapEntry Mover)) count:(count at:(trackSite Move from:(last From) "TrackCW" steps:5)))) (if (and (is Empty (trackSite Move from:(last From) "TrackCW" steps:6)) (is In (trackSite Move from:(last From) "TrackCW" steps:6) (sites Mover))) (and (if (!= 0 (count at:(trackSite Move from:(last From) "TrackCW" steps:6))) (fromTo (from (trackSite Move from:(last From) "TrackCW" steps:6)) (to (mapEntry Mover)) count:(count at:(trackSite Move from:(last From) "TrackCW" steps:6)))) (if (and (is Empty (trackSite Move from:(last From) "TrackCW" steps:7)) (is In (trackSite Move from:(last From) "TrackCW" steps:7) (sites Mover))) (if (!= 0 (count at:(trackSite Move from:(last From) "TrackCW" steps:7))) (fromTo (from (trackSite Move from:(last From) "TrackCW" steps:7)) (to (mapEntry Mover)) count:(count at:(trackSite Move from:(last From) "TrackCW" steps:7)))))))))))))))))))))})))))) (if (!= (value Player Mover) 2) (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover)) if:(> (count at:(from)) 0)) (then (sow "TrackCCW" apply:(if (> (count at:(to)) 1) (and {(moveAgain) (set Value Mover 2) (if (is In (to) (sites Next)) (set Var "GoInOpponentRow" 1))}) (and {(set Value Mover 0) (set Var "GoInOpponentRow" 0) (if (and (= 1 (var "GoInOpponentRow")) (is In (to) (sites Mover))) (if (!= 0 (count at:(if (is Mover P1) (+ (to) 8) (- (to) 8)))) (fromTo (from (if (is Mover P1) (+ (to) 8) (- (to) 8))) (to (mapEntry Mover)) count:(count at:(if (is Mover P1) (+ (to) 8) (- (to) 8))) (then (if (and (is Empty (trackSite Move from:(last From) "TrackCCW" steps:1)) (is In (trackSite Move from:(last From) "TrackCCW" steps:1) (sites Mover))) (and (if (!= 0 (count at:(trackSite Move from:(last From) "TrackCCW" steps:1))) (fromTo (from (trackSite Move from:(last From) "TrackCCW" steps:1)) (to (mapEntry Mover)) count:(count at:(trackSite Move from:(last From) "TrackCCW" steps:1)))) (if (and (is Empty (trackSite Move from:(last From) "TrackCCW" steps:2)) (is In (trackSite Move from:(last From) "TrackCCW" steps:2) (sites Mover))) (and (if (!= 0 (count at:(trackSite Move from:(last From) "TrackCCW" steps:2))) (fromTo (from (trackSite Move from:(last From) "TrackCCW" steps:2)) (to (mapEntry Mover)) count:(count at:(trackSite Move from:(last From) "TrackCCW" steps:2)))) (if (and (is Empty (trackSite Move from:(last From) "TrackCCW" steps:3)) (is In (trackSite Move from:(last From) "TrackCCW" steps:3) (sites Mover))) (and (if (!= 0 (count at:(trackSite Move from:(last From) "TrackCCW" steps:3))) (fromTo (from (trackSite Move from:(last From) "TrackCCW" steps:3)) (to (mapEntry Mover)) count:(count at:(trackSite Move from:(last From) "TrackCCW" steps:3)))) (if (and (is Empty (trackSite Move from:(last From) "TrackCCW" steps:4)) (is In (trackSite Move from:(last From) "TrackCCW" steps:4) (sites Mover))) (and (if (!= 0 (count at:(trackSite Move from:(last From) "TrackCCW" steps:4))) (fromTo (from (trackSite Move from:(last From) "TrackCCW" steps:4)) (to (mapEntry Mover)) count:(count at:(trackSite Move from:(last From) "TrackCCW" steps:4)))) (if (and (is Empty (trackSite Move from:(last From) "TrackCCW" steps:5)) (is In (trackSite Move from:(last From) "TrackCCW" steps:5) (sites Mover))) (and (if (!= 0 (count at:(trackSite Move from:(last From) "TrackCCW" steps:5))) (fromTo (from (trackSite Move from:(last From) "TrackCCW" steps:5)) (to (mapEntry Mover)) count:(count at:(trackSite Move from:(last From) "TrackCCW" steps:5)))) (if (and (is Empty (trackSite Move from:(last From) "TrackCCW" steps:6)) (is In (trackSite Move from:(last From) "TrackCCW" steps:6) (sites Mover))) (and (if (!= 0 (count at:(trackSite Move from:(last From) "TrackCCW" steps:6))) (fromTo (from (trackSite Move from:(last From) "TrackCCW" steps:6)) (to (mapEntry Mover)) count:(count at:(trackSite Move from:(last From) "TrackCCW" steps:6)))) (if (and (is Empty (trackSite Move from:(last From) "TrackCCW" steps:7)) (is In (trackSite Move from:(last From) "TrackCCW" steps:7) (sites Mover))) (if (!= 0 (count at:(trackSite Move from:(last From) "TrackCCW" steps:7))) (fromTo (from (trackSite Move from:(last From) "TrackCCW" steps:7)) (to (mapEntry Mover)) count:(count at:(trackSite Move from:(last From) "TrackCCW" steps:7)))))))))))))))))))))})))))))))} (end (if (no Moves Mover) (byScore {(score P1 (count at:(mapEntry P1))) (score P2 (count at:(mapEntry P2)))}))))) 
2x6 board. Five counters in each hole. Sowing occurs from any hole in the player's row in a clockwise direction. If the final counter lands into an empty hole, it is captured. If there is an unbroken line of holes behind it also having single counters, these are also captured. The player who captures the most counters wins.
(game "Vai Lung Thlan" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "5,W,N,E" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 5 to:(sites Track))) (play (move Select (from (sites Mover) if:(< 0 (count at:(from)))) (then (sow if:(= (count at:(to)) 1) apply:(fromTo (from (to)) (to (handSite Mover)) count:(count at:(to))) backtracking:True)))) (end (if (no Moves Mover) (byScore {(score P1 (count Cell at:(handSite P1))) (score P2 (count Cell at:(handSite P2)))}))))) 
2x6 board. Three counters per hole. Sowing occurs in an anti-clockwise direction when starting from the right three holes of a player's row, or in a clockwise direction when starting from the player's left three holes. When the final counter falls into an occupied hole, these are picked up and sowing continues, except when this hole is made to contain four counters, in which case these counters are captured and the player takes another turn. These captures may not be made on the first turn. When the final counter lands in an empty hole, the turn ends. Play continues until one player is without counters in their row. The opponent then captures the remaining counters in their row, and the player that has captured the most counters wins.
(game "Wa'ache Waledat" (players 2) (equipment {(mancalaBoard 2 6 store:None {(track "TrackCCW" "0,E,N,W" loop:True) (track "TrackCW" "5,W,N,E" loop:True)}) (piece "Seed" Shared) (regions "Home" P1 (sites Bottom)) (regions "Home" P2 (sites Top)) (regions "RightHome" P1 (intersection (expand (sites Right) steps:2) (sites Bottom))) (regions "RightHome" P2 (intersection (expand (sites Right) steps:2) (sites Top))) (regions "LeftHome" P1 (intersection (expand (sites Left) steps:2) (sites Bottom))) (regions "LeftHome" P2 (intersection (expand (sites Left) steps:2) (sites Top))) (hand Each)}) (rules (start (set Count 3 to:(sites Track))) (play (or (if (or (>= 0 (var "Direction")) (= 1 (var "Direction"))) (move Select (from (if (and (is Prev Mover) (= 1 (var "ContinueSowing"))) (sites {(last To afterConsequence:True)}) (sites Mover "RightHome")) if:(> (count at:(from)) 0)) (then (sow "TrackCCW" apply:(if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Direction" 1) (set Var "ContinueSowing" 1) (if (and (= 4 (count at:(to))) (< 2 (count Turns))) (and (fromTo (from (to)) (to (handSite Mover)) count:4) (set Var "ContinueSowing" 0)))}) (set Var "Direction" 0)))))) (if (or (>= 0 (var "Direction")) (= 2 (var "Direction"))) (move Select (from (if (and (is Prev Mover) (= 1 (var "ContinueSowing"))) (sites {(last To afterConsequence:True)}) (sites Mover "LeftHome")) if:(> (count at:(from)) 0)) (then (sow "TrackCW" apply:(if (< 1 (count at:(to))) (and {(moveAgain) (set Var "Direction" 2) (set Var "ContinueSowing" 1) (if (and (= 4 (count at:(to))) (< 2 (count Turns))) (and (fromTo (from (to)) (to (handSite Mover)) count:4) (set Var "ContinueSowing" 0)))}) (set Var "Direction" 0)))))) (then (if (or (all Sites (sites P1 "Home") if:(= 0 (count at:(site)))) (all Sites (sites P2 "Home") if:(= 0 (count at:(site))))) (and (forEach Site (sites P1 "Home") (fromTo (from (site)) (to (handSite P1)) count:(count at:(site)))) (forEach Site (sites P2 "Home") (fromTo (from (site)) (to (handSite P2)) count:(count at:(site))))))))) (end (if (all Sites (sites Board) if:(= 0 (count at:(site)))) (byScore {(score P1 (count Cell at:(handSite P1))) (score P2 (count Cell at:(handSite P2)))}))))) 
2x7 board with two stores. Four counters in each hole. Sowing occurs in either a clockwise or anti-clockwise direction; the first player chooses the direction and all subsequent moves are made in that direction. Players sow beginning from holes in their row. If the last counter falls into a hole with counters, the counters in the next hole are picked up and sowing continues, and if this hole is empty, the counters in the hole following the empty hole are captured. If there is an unbroken sequence of alternating empty and occupied holes, the counters in the occupied holes are captured until there are two empty or two occupied holes. If the final counter falls into an empty hole the turn ends. Throughout the game, singletons cannot be moved is a player has a hole with multiple counters, and a singleton in the front hole cannot be moved if there are other singletons in the player's row. The round ends when one player's holes are empty. A second round begins with the winner of the first round placing four counters in each of their holes, leaving any surplus in the store. The loser of round one places four counters in as many consecutive holes on their side of the board as possible, and any remaining counters in the next hole. If this hole contains one, it is called puta, if two, naga, if three, wala. Holes with no counters are excluded from play for this round. If the loser has a puta hole, the opponent removes three counters from their hole opposite; if a naga, the opponent removes two from the opposite hole, if a wala, the opponent removes one. The removed counters go into their store. Puta and naga holes are marked with a piece of paper or straw in them. Empty holes are excluded from play in this round. The losing player begins the round, moving in the direction of the excluded holes, and played in the same way as the first round. The player with empty holes begins play in the direction of the empty hole. Counters cannot be captured or sowed from puta or naga holes. Play continues as before. When one player has fewer than twelve counters at the beginning of a round, they may arrange them differently at the beginning. They may put one or two counters in one end hole and not more than four in the other end hole, and one or two counters in the intermediate holes, leaving some empty and, thus, excluded. The opponent then puts four counters in each of their holes. There are no puta, naga, or wala holes in this round. The player with more counters plays as before, but the one with less has captures that are determined by the number of counters placed in the first end hole. If there were two in the end hole, the player captures when dropping the final counter into a hole to make it three; or when it makes two if there was one counter in the first end hole. Otherwise, the player does not sow in holes with one or two counters. Play continues until one player cannot sow at the beginning of a round.
(game "Walak-Pussa" (players 2) (equipment {(mancalaBoard 2 7 {(track "TrackCCW" "1,E,N,W" loop:True) (track "TrackCW" "7,W,N,E" loop:True)}) (piece "Seed" Shared) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 FirstSite) (pair P2 LastSite)})}) (rules (start {(set Count 4 to:(sites Track)) (set RememberValue "Playable" (union (sites Top) (sites Bottom)))}) phases:{(phase "StartingMove" (play (or (move Select (from (sites Mover) if:(and (is Occupied (from)) (is In (from) (sites (values Remembered "Playable"))))) (then (and (sow "TrackCCW" apply:(if (= 1 (count at:(to))) (if (< 0 (count at:(trackSite Move from:(to) "TrackCCW" steps:1))) (and (fromTo (from (trackSite Move from:(to) "TrackCCW" steps:1)) (to (mapEntry Mover)) count:(count at:(trackSite Move from:(to) "TrackCCW" steps:1))) (if (and (= 0 (count at:(trackSite Move from:(to) "TrackCCW" steps:2))) (< 0 (count at:(trackSite Move from:(to) "TrackCCW" steps:3)))) (and (fromTo (from (trackSite Move from:(to) "TrackCCW" steps:3)) (to (mapEntry Mover)) count:(count at:(trackSite Move from:(to) "TrackCCW" steps:3))) (if (and (= 0 (count at:(trackSite Move from:(to) "TrackCCW" steps:4))) (< 0 (count at:(trackSite Move from:(to) "TrackCCW" steps:5)))) (and (fromTo (from (trackSite Move from:(to) "TrackCCW" steps:5)) (to (mapEntry Mover)) count:(count at:(trackSite Move from:(to) "TrackCCW" steps:5))) (if (and (= 0 (count at:(trackSite Move from:(to) "TrackCCW" steps:6))) (< 0 (count at:(trackSite Move from:(to) "TrackCCW" steps:7)))) (fromTo (from (trackSite Move from:(to) "TrackCCW" steps:7)) (to (mapEntry Mover)) count:(count at:(trackSite Move from:(to) "TrackCCW" steps:7)))))))))) (and (moveAgain) (set Var "Replay" (to)))) skipIf:(not (is In (to) (sites (values Remembered "Playable"))))) (set Var "Direction" 1)))) (move Select (from (sites Mover) if:(and (is Occupied (from)) (is In (from) (sites (values Remembered "Playable"))))) (then (and (sow "TrackCW" apply:(if (= 1 (count at:(to))) (if (< 0 (count at:(trackSite Move from:(to) "TrackCW" steps:1))) (and (fromTo (from (trackSite Move from:(to) "TrackCW" steps:1)) (to (mapEntry Mover)) count:(count at:(trackSite Move from:(to) "TrackCW" steps:1))) (if (and (= 0 (count at:(trackSite Move from:(to) "TrackCW" steps:2))) (< 0 (count at:(trackSite Move from:(to) "TrackCW" steps:3)))) (and (fromTo (from (trackSite Move from:(to) "TrackCW" steps:3)) (to (mapEntry Mover)) count:(count at:(trackSite Move from:(to) "TrackCW" steps:3))) (if (and (= 0 (count at:(trackSite Move from:(to) "TrackCW" steps:4))) (< 0 (count at:(trackSite Move from:(to) "TrackCW" steps:5)))) (and (fromTo (from (trackSite Move from:(to) "TrackCW" steps:5)) (to (mapEntry Mover)) count:(count at:(trackSite Move from:(to) "TrackCW" steps:5))) (if (and (= 0 (count at:(trackSite Move from:(to) "TrackCW" steps:6))) (< 0 (count at:(trackSite Move from:(to) "TrackCW" steps:7)))) (fromTo (from (trackSite Move from:(to) "TrackCW" steps:7)) (to (mapEntry Mover)) count:(count at:(trackSite Move from:(to) "TrackCW" steps:7)))))))))) (and (moveAgain) (set Var "Replay" (to)))) skipIf:(not (is In (to) (sites (values Remembered "Playable"))))) (set Var "Direction" 2)))))) (nextPhase "Sowing")) (phase "Sowing" (play (if (= 1 (var "Direction")) (move Select (from (if (and (not (is Pending)) (is Prev Mover)) (sites {(var "Replay")}) (sites Mover)) if:(and {(is Occupied (from)) (is In (from) (sites (values Remembered "Playable"))) (not (is In (from) (sites (values Remembered "Blocked")))) (if (not (all Sites (forEach (sites Mover) if:(is In (site) (sites (values Remembered "Playable")))) if:(>= 1 (count at:(site))))) (< 1 (count at:(from))))})) (then (sow "TrackCCW" apply:(if (= 1 (count at:(to))) (if (< 0 (count at:(trackSite Move from:(to) "TrackCCW" steps:1))) (and (fromTo (from (trackSite Move from:(to) "TrackCCW" steps:1)) (to (mapEntry Mover)) count:(count at:(trackSite Move from:(to) "TrackCCW" steps:1))) (if (and (= 0 (count at:(trackSite Move from:(to) "TrackCCW" steps:2))) (< 0 (count at:(trackSite Move from:(to) "TrackCCW" steps:3)))) (and (fromTo (from (trackSite Move from:(to) "TrackCCW" steps:3)) (to (mapEntry Mover)) count:(count at:(trackSite Move from:(to) "TrackCCW" steps:3))) (if (and (= 0 (count at:(trackSite Move from:(to) "TrackCCW" steps:4))) (< 0 (count at:(trackSite Move from:(to) "TrackCCW" steps:5)))) (and (fromTo (from (trackSite Move from:(to) "TrackCCW" steps:5)) (to (mapEntry Mover)) count:(count at:(trackSite Move from:(to) "TrackCCW" steps:5))) (if (and (= 0 (count at:(trackSite Move from:(to) "TrackCCW" steps:6))) (< 0 (count at:(trackSite Move from:(to) "TrackCCW" steps:7)))) (fromTo (from (trackSite Move from:(to) "TrackCCW" steps:7)) (to (mapEntry Mover)) count:(count at:(trackSite Move from:(to) "TrackCCW" steps:7)))))))))) (and (moveAgain) (set Var "Replay" (to)))) skipIf:(not (is In (to) (sites (values Remembered "Playable"))))))) (move Select (from (if (and (not (is Pending)) (is Prev Mover)) (sites {(var "Replay")}) (sites Mover)) if:(and {(is Occupied (from)) (is In (from) (sites (values Remembered "Playable"))) (not (is In (from) (sites (values Remembered "Blocked")))) (if (not (all Sites (forEach (sites Mover) if:(is In (site) (sites (values Remembered "Playable")))) if:(>= 1 (count at:(site))))) (< 1 (count at:(from))))})) (then (sow "TrackCW" apply:(if (= 1 (count at:(to))) (if (< 0 (count at:(trackSite Move from:(to) "TrackCW" steps:1))) (and (fromTo (from (trackSite Move from:(to) "TrackCW" steps:1)) (to (mapEntry Mover)) count:(count at:(trackSite Move from:(to) "TrackCW" steps:1))) (if (and (= 0 (count at:(trackSite Move from:(to) "TrackCW" steps:2))) (< 0 (count at:(trackSite Move from:(to) "TrackCW" steps:3)))) (and (fromTo (from (trackSite Move from:(to) "TrackCW" steps:3)) (to (mapEntry Mover)) count:(count at:(trackSite Move from:(to) "TrackCW" steps:3))) (if (and (= 0 (count at:(trackSite Move from:(to) "TrackCW" steps:4))) (< 0 (count at:(trackSite Move from:(to) "TrackCW" steps:5)))) (and (fromTo (from (trackSite Move from:(to) "TrackCW" steps:5)) (to (mapEntry Mover)) count:(count at:(trackSite Move from:(to) "TrackCW" steps:5))) (if (and (= 0 (count at:(trackSite Move from:(to) "TrackCW" steps:6))) (< 0 (count at:(trackSite Move from:(to) "TrackCW" steps:7)))) (fromTo (from (trackSite Move from:(to) "TrackCW" steps:7)) (to (mapEntry Mover)) count:(count at:(trackSite Move from:(to) "TrackCW" steps:7)))))))))) (and (moveAgain) (set Var "Replay" (to)))) skipIf:(not (is In (to) (sites (values Remembered "Playable"))))))) (then (if (no Moves Next) (and {(forEach Site (sites P1) (if (is Occupied (site)) (fromTo (from (site)) (to (mapEntry P1)) count:(count at:(site))))) (forEach Site (sites P2) (if (is Occupied (site)) (fromTo (from (site)) (to (mapEntry P2)) count:(count at:(site))))) (forget Value "Playable" All) (forget Value "Blocked" All) (if (< (+ (count at:(mapEntry P1)) (count in:(sites P1))) (+ (count at:(mapEntry P2)) (count in:(sites P2)))) (and (set NextPlayer (player 2)) (set Var "Winner" 2)) (and (set NextPlayer (player 1)) (set Var "Winner" 1)))}))))) (end (if (no Moves Next) {(if (> 2 (count at:(mapEntry P1))) (result P2 Win)) (if (> 2 (count at:(mapEntry P2))) (result P1 Win))})) (nextPhase (no Moves Next) "BetweenRounds")) (phase "BetweenRounds" (play (if (and (not (is Prev Mover)) (!= (mover) (var "Winner"))) (or (move (from (mapEntry Mover)) (to (if (is Mover P1) (intersection (sites Bottom) (expand (sites Right))) (intersection (sites Top) (expand (sites Left)))) if:(is Empty (to))) count:(min 4 (count at:(mapEntry Mover))) (then (and {(remember Value "Playable" (last To)) (if (> 4 (count at:(last To))) (and (fromTo (from (if (is Mover P1) (+ (to) 7) (- (to) 7))) (to (mapEntry Next)) count:(- 4 (count at:(last To)))) (remember Value "Blocked" (last To)))) (moveAgain) (if (= 0 (count at:(mapEntry Mover))) (set Pending)) (set Var "Direction" 2)}))) (move (from (mapEntry Mover)) (to (if (is Mover P1) (intersection (sites Bottom) (expand (sites Left))) (intersection (sites Top) (expand (sites Right)))) if:(is Empty (to))) count:(min 4 (count at:(mapEntry Mover))) (then (and {(remember Value "Playable" (last To)) (if (> 4 (count at:(last To))) (and (fromTo (from (if (is Mover P1) (+ (to) 7) (- (to) 7))) (to (mapEntry Next)) count:(- 4 (count at:(last To)))) (remember Value "Blocked" (last To)))) (moveAgain) (if (= 0 (count at:(mapEntry Mover))) (set Pending)) (set Var "Direction" 1)})))) (if (!= (mover) (var "Winner")) (move (from (mapEntry Mover)) (to (if (= (var "Direction") 1) (trackSite Move from:(last To) "TrackCCW" steps:1) (trackSite Move from:(last To) "TrackCW" steps:1)) if:(is Empty (to))) count:(min 4 (count at:(mapEntry Mover))) (then (and {(remember Value "Playable" (last To)) (moveAgain) (if (= 0 (count at:(mapEntry Mover))) (set Pending))}))) (move (from (mapEntry Mover)) (to (sites Mover) if:(is Empty (to))) count:4 (then (and (remember Value "Playable" (last To)) (if (not (all Sites (sites Mover) if:(is Occupied (site)))) (moveAgain)))))))) (nextPhase (and (!= (var "Winner") (mover)) (= 0 (count at:(mapEntry Mover)))) "Sowing"))})) 
2x6 board with two stores. Four counters in each hole. Players alternate turns sowing from one of the holes on their side of the board in an anticlockwise direction. When a counter lands in one of the opponent's holes, making it contain six counters, those counters are captured. The player who captures the most counters wins. 
(game "Wari" (players 2) (equipment {(mancalaBoard 2 6 {(track "Track" "1,E,N,W" loop:True)}) (piece "Seed" Shared) (hand Each) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 FirstSite) (pair P2 LastSite)})}) (rules (start (set Count 4 to:(sites Track))) (play (move Select (from (sites Mover) if:(> (count at:(from)) 0)) (then (sow apply:(if (= 6 (count at:(to))) (fromTo (from (to)) (to (mapEntry Mover)) count:6)))))) (end (if (no Moves Mover) (byScore {(score P1 (count at:(mapEntry P1))) (score P2 (count at:(mapEntry P2)))}))))) 
Two rows of six holes with two stores. Each player owns the store to their right. Four counters in each hole. Sowing occurs from any hole in the player's row in an anti-clockwise direction. Sowing includes the player's store but not the opponent's. When the final counter lands into the player's store, they play again. When a player has no more counters in their row, they win, even if it is now the opponent's turn and they could place counters in the player's row.
(game "Waurie" (players 2) (equipment {(mancalaBoard 2 6 (track "Track" "0,ESE,E,ENE,WNW,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 LastSite) (pair P2 FirstSite)}) (piece "Seed" Shared)}) (rules (start (set Count 4 to:(union (sites P1) (sites P2)))) (play (move Select (from (sites Mover) if:(> (count at:(from)) 0)) (then (sow apply:(if (= (to) (mapEntry Mover)) (moveAgain)) skipIf:(= (to) (mapEntry Next)))))) (end (if (all Sites (sites Mover) if:(= 0 (count at:(site)))) (result Mover Win))))) 
Two rows of six holes with two stores. Four counters in each hole. Players sow in an anti-clockwise direction from a hole in their row. Sowing ends when the last counter falls into a hole, making it contain four counters, which are taken. Sowing also ends when the last counter falls into an empty hole. Sowing continues in any other scenario by picking up the contents of the hole where the last counter was dropped and continuing to sow. The game ends when one player can no longer move. The remaining counters are taken by the last player that was able to move and put into the store. A new round begins: The winner of the previous round now owns seven holes - the six in his row and the next hole in the opponent's row. Player takes fours from the extra hole.
(game "Whyo" (players 2) (equipment {(mancalaBoard 2 6 (track "TrackCCW" "1,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (piece "Seed" Shared) (map {(pair P1 FirstSite) (pair P2 LastSite)})}) (rules (start (set Count 4 to:(sites Track))) (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (if (= (score P1) 1) (if (is Mover P1) (union (sites Mover) (sites {12})) (difference (sites Mover) (sites {12}))) (if (= (score P2) 1) (if (is Mover P2) (union (sites Mover) (sites {1})) (difference (sites Mover) (sites {1}))) (sites Mover)))) if:(> (count at:(from)) 0)) (then (sow apply:(if (= (count at:(to)) 4) (fromTo (from (to)) (to (mapEntry Mover)) count:(count at:(to))) (if (< (count at:(to)) 1) (moveAgain))) (then (if (no Moves Next) (and (forEach Site (union (sites P1) (sites P2)) (if (> (count at:(site)) 0) (fromTo (from (site)) (to (mapEntry Mover)) count:(count at:(site)))) (then (and {(if (< (+ (count at:(mapEntry P1)) (count in:(sites P1))) (+ (count at:(mapEntry P2)) (count in:(sites P2)))) (addScore P2 1)) (if (< (+ (count at:(mapEntry P2)) (count in:(sites P2))) (+ (count at:(mapEntry P1)) (count in:(sites P1)))) (addScore P1 1)) (if (< (var) 0) (and {(forEach Site (sites Board) (if (> (count at:(site)) 0) (remove (site)))) (forEach Site (union (sites P1) (sites P2)) (add (piece (id "Seed" Shared)) (to (site)) count:4))}))}))) (set Var (+ (var) 1))))))))) (end (if (= (var) 1) (byScore))))) 
2x6 board. Six counters in each hole. A player picks up all of the counters in one of the holes in their row and sows them one-by-one in a clockwise direction in consecutive holes from the hole the pieces originated. The starting hole is always left empty, even if a player sows in a complete circuit of the board, the original house is skipped and sowing continues in the next hole after it. Players capture counters when the final counter is sown in the opponent's row and the hole containing it has two or three counters (counting the counter just dropped into it). If the hole before it also has two or three counters, these are also captured and so on until reaching a hole without two or three counters or one not belonging to the opponent. A move which would capture all of the opponent's counters is not allowed. If an opponent's holes are all empty, the other player must make a move placing counters in the opponent's row. If not possible, the player captures all the counters in their row. The player who has captured the most counters wins. If the game continues in a repeating loop, the players can agree to end the game and capture the counters remaining in their row.
(game "Woli" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "5,W,N,E" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 6 to:(sites Track))) (play (if (is Proposed "End") (or (move Vote "End") (move Vote "No")) (or (if (is Cycle) (move Propose "End")) (do (move Select (from (sites Mover) if:(< 0 (count at:(from)))) (then (sow if:(and (is In (to) (sites Next)) (or (= (count at:(to)) 2) (= (count at:(to)) 3))) apply:(fromTo (from (to)) (to (handSite Mover)) count:(count at:(to))) includeSelf:False backtracking:True))) ifAfterwards:(< 0 (count in:(sites Next))))))) (end (if (or (no Moves Mover) (is Decided "End")) (byScore {(score P1 (+ (count Cell at:(handSite P1)) (count in:(sites P1)))) (score P2 (+ (count Cell at:(handSite P2)) (count in:(sites P2))))}))))) 
Counters are placed in piles: two rows of four piles. Six counters in each pile. A player sows from any of the piles in the player's row in an anti-clockwise direction. Any pile which contains 2, 4, or 6 counters is captured. The player with the most counters captured wins.
(game "Wore" (players 2) (equipment {(mancalaBoard 2 4 store:None (track "Track" "0,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 6 to:(sites Track))) (play (move Select (from (sites Mover) if:(< 0 (count at:(from)))) (then (sow if:(or {(= (count at:(to)) 2) (= (count at:(to)) 4) (= (count at:(to)) 6)}) apply:(fromTo (from (to)) (to (handSite Mover)) count:(count at:(to))))))) (end (if (no Moves Mover) (byScore {(score P1 (count Cell at:(handSite P1))) (score P2 (count Cell at:(handSite P2)))}))))) 
2x6 board. Four counters in each hole. Sowing occurs in an anti-clockwise direction, beginning from any hole in the player's row. When the final counter lands in a hole in the opponent's row containing three (four counting the last counter dropped into it), these are taken. In addition, the contents of any hole in the opponent's row which a player causes to contain four counters are captured. When the final counter lands in an empty hole, the turn ends. When the final counter lands in an occupied hole containing a number of counters other than three, the counters are picked up and sowing continues. If sowing reaches the original hole from which the sowing began, this hole is skipped over. A player must play so that the opponent has counters with which to play, if possible.
(game "Wouri" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "0,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 4 to:(sites Track))) (play (do (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover)) if:(< 0 (count at:(from)))) (then (sow apply:(if (and (is In (to) (sites Next)) (= (count at:(to)) 4)) (fromTo (from (to)) (to (handSite Mover)) count:(count at:(to)) (then (forEach Site (if (is Mover P1) (sites P2) (sites P1)) (if (= (count at:(site)) 4) (fromTo (from (site)) (to (handSite Mover)) count:(count at:(site))))))) (if (< 1 (count at:(to))) (moveAgain))) includeSelf:False))) ifAfterwards:(< 0 (count in:(if (is Mover P1) (sites P2) (sites P1)))))) (end (if (no Moves Mover) (byScore {(score P1 (+ (count Cell at:(handSite P1)) (count in:(sites P1)))) (score P2 (+ (count Cell at:(handSite P2)) (count in:(sites P2))))}))))) 
2x6 board with two stores. Four counters in each hole. Sowing occurs in a clockwise direction. When the final counter of a sowing lands in an occupied hole, these are picked up and sowing continues. When the final counter lands in an empty hole in the player's own row, the contents of the hole opposite it in the opponent's row are captured. If the final counter lands in an empty hole in the opponent's row, the opponent captures the counters in the hole opposite it in the player's row. The player who captures the most counters wins.
(game "Yovodi" (players 2) (equipment {(mancalaBoard 2 6 (track "Track" "6,W,N,E" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 FirstSite) (pair P2 LastSite)}) (piece "Seed" Shared)}) (rules (start (set Count 4 to:(sites Track))) (play (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover)) if:(< 0 (count at:(from)))) (then (sow apply:(if (> (count at:(to)) 1) (moveAgain) (if (is In (to) (sites Mover)) (fromTo (from (if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6))) (to (mapEntry (mover))) count:(count at:(if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6)))) (fromTo (from (if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6))) (to (mapEntry (next))) count:(count at:(if (is In (to) (sites Bottom)) (+ (to) 6) (- (to) 6)))))))))) (end (if (no Moves Mover) (byScore {(score P1 (+ (count at:(mapEntry P1)) (count in:(sites P1)))) (score P2 (+ (count at:(mapEntry P2)) (count in:(sites P2))))}))))) 
2x6 board. Four counters in each hole. A player picks up all of the counters in one of the holes in their row and sows them one-by-one in a counterclockwise direction in consecutive holes from the hole the pieces originated. The starting hole is always left empty, even if a player sows in a complete circuit of the board, the original house is skipped and sowing continues in the next hole after it. When the final counter falls into an occupied hole, these are picked up and sowing continues. When the final counter of a sowing lands on in an empty hole in the player's own row, the contents of the hole in the opponent's row opposite it are captured. If the opponent's holes are all empty, the other player must make a move placing counters in the opponent's row. If not possible, the player captures all the counters in their row. The player who has captured the most counters wins. If the game continues in a repeating loop, the players can agree to end the game and capture the counters remaining in their row.
(game "Yovodji" (players 2) (equipment {(mancalaBoard 2 6 store:None (track "Track" "0,E,N,W" loop:True)) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (piece "Seed" Shared) (hand Each)}) (rules (start (set Count 4 to:(sites Track))) (play (if (is Proposed "End") (or (move Vote "End") (move Vote "No")) (or (if (is Cycle) (move Propose "End")) (move Select (from (if (is Prev Mover) (sites {(last To afterConsequence:True)}) (sites Mover)) if:(< 0 (count at:(from)))) (then (sow apply:(if (and (is In (to) (sites Next)) (or (= (count at:(to)) 2) (= (count at:(to)) 3))) (fromTo (from (to)) (to (handSite Mover)) count:(count at:(to))) (if (< 1 (count at:(to))) (moveAgain) (if (and (is In (to) (sites Mover)) (< 1 (count at:(if (is Mover P1) (+ (to) 6) (- (to) 6))))) (fromTo (from (if (is Mover P1) (+ (to) 6) (- (to) 6))) (to (handSite Mover)) count:(count at:(if (is Mover P1) (+ (to) 6) (- (to) 6))))))) includeSelf:False backtracking:(and (is In (from) (sites Next)) (or (= (count at:(from)) 2) (= (count at:(from)) 3))))))))) (end (if (or (no Moves Mover) (is Decided "End")) (byScore {(score P1 (+ (count Cell at:(handSite P1)) (count in:(sites P1)))) (score P2 (+ (count Cell at:(handSite P2)) (count in:(sites P2))))}))))) 
2x5 board, with two stores. Five counters in each hole, with a large stone normally in each store, but which may be placed in any of the player's holes to start. The player owns the store to their right. Sowing proceeds in either direction, the first player chooses which and all sowing for the rest of the game proceeds in that direction. Sowing includes the stores. Players may sow from any hole on the board. If the last counter falls into a hole with counters, the counters in the next hole are picked up and sowing continues, and if this hole is empty, the counters in the hole following the empty hole are captured. If there is an unbroken sequence of alternating empty and occupied holes, the counters in the occupied holes are captured until there are two empty or two occupied holes. When the larger stone is sown into a hole with counters, those counters are taken by the player to whom the hole belongs. When a player has no further counters, they may, if they wish, place one captured counter in each of their holes to continue playing, or may choose to end the round, and the opponent captures the remaining counters on the board. Another round begins: Both players fill as many of their holes as they can with five counters. The player with more counters may continue filling holes, if possible, in a clockwise direction from the end of their row. Any remaining counters are lent to the player with fewer counters to fill their holes. Play continues until one player can no longer fill any holes. 
(game "Yucebao" (players 2) (equipment {(mancalaBoard 2 5 largeStack:True {(track "TrackCCW" "0,1,E,11,10,W" loop:True) (track "TrackCW" "11,5,W,0,6,E" loop:True)}) (piece "Seed" Shared) (piece "Ball" P1) (piece "Ball" P2) (hand Each size:2) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map {(pair P1 LastSite) (pair P2 FirstSite)}) (map "LeftMost" {(pair P1 1) (pair P2 10)}) (regions "EndHoles" (sites {"A1" "G1"}))}) (rules (start {(place Stack "Seed" (union (sites Bottom) (sites Top)) count:5) (place Stack "Ball1" (mapEntry P1)) (place Stack "Ball2" (mapEntry P2))}) phases:{(phase "Sowing" (play (or {(if (!= (var "Direction") 2) (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover)) if:(!= 0 (size Stack at:(from)))) (then (and {(forEach Value min:1 max:(size Stack at:(last From)) (if (= (id "Seed" Shared) (what at:(last From) level:(- (size Stack at:(last From)) (value)))) (fromTo (from (last From) level:(- (size Stack at:(last From)) (value))) (to (trackSite Move from:(last From) "TrackCCW" steps:(value))) stack:True) (and (if (and (is Occupied (trackSite Move from:(last From) "TrackCCW" steps:(value))) (!= (trackSite Move from:(last From) "TrackCCW" steps:(value)) (last From))) (if (= (who at:(last From) level:(- (size Stack at:(last From)) (value))) P1) (forEach Level (trackSite Move from:(last From) "TrackCCW" steps:(value)) FromTop (if (= (id "Seed" Shared) (what at:(trackSite Move from:(last From) "TrackCCW" steps:(value)) level:(level))) (fromTo (from (trackSite Move from:(last From) "TrackCCW" steps:(value)) level:(level)) (to (handSite P1))) (fromTo (from (trackSite Move from:(last From) "TrackCCW" steps:(value)) level:(level)) (to (handSite P1 1))))) (forEach Level (trackSite Move from:(last From) "TrackCCW" steps:(value)) FromTop (if (= (id "Seed" Shared) (what at:(trackSite Move from:(last From) "TrackCCW" steps:(value)) level:(level))) (fromTo (from (trackSite Move from:(last From) "TrackCCW" steps:(value)) level:(level)) (to (handSite P2))) (fromTo (from (trackSite Move from:(last From) "TrackCCW" steps:(value)) level:(level)) (to (handSite P2 1))))))) (fromTo (from (last From) level:(- (size Stack at:(last From)) (value))) (to (trackSite Move from:(last From) "TrackCCW" steps:(value))) stack:True)))) (if (< (var "Direction") 1) (set Var "Direction" 1)) (if (< (size Stack at:(last From)) 8) (if (!= 0 (size Stack at:(trackSite Move from:(last From) "TrackCCW" steps:(+ 1 (size Stack at:(last From)))))) (and (moveAgain) (set Var "Replay" (trackSite Move from:(last From) "TrackCCW" steps:(+ 1 (size Stack at:(last From)))))) (if (is Occupied (trackSite Move from:(last From) "TrackCCW" steps:(+ 2 (size Stack at:(last From))))) (forEach Level (trackSite Move from:(last From) "TrackCCW" steps:(+ 2 (size Stack at:(last From)))) FromTop (if (= (id "Seed" Shared) (what at:(trackSite Move from:(last From) "TrackCCW" steps:(+ 2 (size Stack at:(last From)))) level:(level))) (fromTo (from (trackSite Move from:(last From) "TrackCCW" steps:(+ 2 (size Stack at:(last From)))) level:(level)) (to (handSite Mover))) (fromTo (from (trackSite Move from:(last From) "TrackCCW" steps:(+ 2 (size Stack at:(last From)))) level:(level)) (to (handSite Mover 1))))))))})))) (if (!= (var "Direction") 1) (move Select (from (if (is Prev Mover) (sites {(var "Replay")}) (sites Mover)) if:(!= 0 (size Stack at:(from)))) (then (and {(forEach Value min:1 max:(size Stack at:(last From)) (if (= (id "Seed" Shared) (what at:(last From) level:(- (size Stack at:(last From)) (value)))) (fromTo (from (last From) level:(- (size Stack at:(last From)) (value))) (to (trackSite Move from:(last From) "TrackCW" steps:(value))) stack:True) (and (if (and (is Occupied (trackSite Move from:(last From) "TrackCW" steps:(value))) (!= (trackSite Move from:(last From) "TrackCW" steps:(value)) (last From))) (if (= (who at:(last From) level:(- (size Stack at:(last From)) (value))) P1) (forEach Level (trackSite Move from:(last From) "TrackCW" steps:(value)) FromTop (if (= (id "Seed" Shared) (what at:(trackSite Move from:(last From) "TrackCW" steps:(value)) level:(level))) (fromTo (from (trackSite Move from:(last From) "TrackCW" steps:(value)) level:(level)) (to (handSite P1))) (fromTo (from (trackSite Move from:(last From) "TrackCW" steps:(value)) level:(level)) (to (handSite P1 1))))) (forEach Level (trackSite Move from:(last From) "TrackCW" steps:(value)) FromTop (if (= (id "Seed" Shared) (what at:(trackSite Move from:(last From) "TrackCW" steps:(value)) level:(level))) (fromTo (from (trackSite Move from:(last From) "TrackCW" steps:(value)) level:(level)) (to (handSite P2))) (fromTo (from (trackSite Move from:(last From) "TrackCW" steps:(value)) level:(level)) (to (handSite P2 1))))))) (fromTo (from (last From) level:(- (size Stack at:(last From)) (value))) (to (trackSite Move from:(last From) "TrackCW" steps:(value))) stack:True)))) (if (< (var "Direction") 1) (set Var "Direction" 2)) (if (< (size Stack at:(last From)) 8) (if (!= 0 (size Stack at:(trackSite Move from:(last From) "TrackCW" steps:(+ 1 (size Stack at:(last From)))))) (and (moveAgain) (set Var "Replay" (trackSite Move from:(last From) "TrackCW" steps:(+ 1 (size Stack at:(last From)))))) (if (is Occupied (trackSite Move from:(last From) "TrackCW" steps:(+ 2 (size Stack at:(last From))))) (forEach Level (trackSite Move from:(last From) "TrackCW" steps:(+ 2 (size Stack at:(last From)))) FromTop (if (= (id "Seed" Shared) (what at:(trackSite Move from:(last From) "TrackCW" steps:(+ 2 (size Stack at:(last From)))) level:(level))) (fromTo (from (trackSite Move from:(last From) "TrackCW" steps:(+ 2 (size Stack at:(last From)))) level:(level)) (to (handSite Mover))) (fromTo (from (trackSite Move from:(last From) "TrackCW" steps:(+ 2 (size Stack at:(last From)))) level:(level)) (to (handSite Mover 1))))))))}))))} (then (if (no Pieces All in:(sites P1)) (forEach Site (sites Board) (if (is Occupied (site)) (forEach Level (site) FromTop (if (= (id "Seed" Shared) (what at:(site) level:(level))) (fromTo (from (site) level:(level)) (to (handSite P1)) stack:True) (fromTo (from (site) level:(level)) (to (handSite P1 1)) stack:True))))) (if (no Pieces All in:(sites P2)) (forEach Site (sites Board) (if (is Occupied (site)) (forEach Level (site) FromTop (if (= (id "Seed" Shared) (what at:(site) level:(level))) (fromTo (from (site) level:(level)) (to (handSite P2)) stack:True) (fromTo (from (site) level:(level)) (to (handSite P2 1)) stack:True)))))))))) (end (if (no Pieces All in:(sites Board)) {(if (> 5 (size Stack Cell at:(handSite P1))) (result P2 Win)) (if (> 5 (size Stack Cell at:(handSite P2))) (result P1 Win))})) (nextPhase (no Pieces All in:(sites Board)) "BetweenRounds")) (phase "BetweenRounds" (play (or (if (<= 5 (size Stack Cell at:(handSite Mover))) (move Select (from Cell (handSite Mover)) (to (trackSite FirstSite "TrackCCW" from:(mapEntry "LeftMost" Mover) if:(is Empty (to)))) (then (forEach Value min:1 max:5 (fromTo (from Cell (last From) level:(- (size Stack Cell at:(last From)) (value))) (to (last To)) stack:True))))) (if (!= 0 (size Stack Cell at:(handSite Mover 1))) (move Select (from Cell (handSite Mover 1)) (to (sites Mover)) (then (fromTo (from Cell (last From) level:(topLevel Cell at:(last From))) (to (last To)) stack:True)))))) (nextPhase (all Passed) "Sowing"))})) 
- BOARDS: The stones in each board are responsible for the moving possibilities of the stones in the next board (clockwise direction). E.g., board NW position determines the moves for board NE. - MOVE: Every stone allows the stones in the next board to move according to its position (using the red point as a reference point). E.g., A stone on b3, allows that player to move any stone in the next board one step to the left. A stone on e5 allows any stone in the next board to move two steps diagonally to the top right. A stone on a red point is useless for the moves in the next board . - TURN: On his turn a player must do one of two actions: Drop: The player drops a friendly stone on an empty cell. If there are no more offboard stones, he cannot choose this action. Move: The player moves a stone according to the moving rules. To move a stone there must be a friendly stone in the previous board. The move is only allowed if the moving stone stays in the same board. Stones jump. So if a stone moves from a5 to c5 (only possible if there is a friendly stone on e3 at the previous board) the status of b5 is irrelevant. The destination cell must be empty or occupied with an opponent stone, which is captured and removed from play. - GOAL: A player with no legal moves loses.
(game "4 Squared" (players 2) (equipment {(board (merge {(square 5) (shift 5 0 (square 5)) (shift 0 5 (square 5)) (shift 5 5 (square 5))}) use:Vertex) (piece "Ball" Each (if (is In (from) (sites "SW")) (or {(move Step S (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "H3") S)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Step SE (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "H3") SE)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Step SW (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "H3") SW)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Step E (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "H3") E)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Step W (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "H3") W)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Step NE (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "H3") NE)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Step NW (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "H3") NW)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Step N (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "H3") N)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Hop S (between if:True) (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "H3") steps:2 S)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Hop SE (between if:True) (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "H3") steps:2 SE)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Hop SW (between if:True) (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "H3") steps:2 SW)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Hop E (between if:True) (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "H3") steps:2 E)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Hop W (between if:True) (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "H3") steps:2 W)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Hop NE (between if:True) (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "H3") steps:2 NE)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Hop NW (between if:True) (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "H3") steps:2 NW)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Hop N (between if:True) (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "H3") steps:2 N)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))}) (if (is In (from) (sites "NW")) (or {(move Step S (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "C3") S)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Step SE (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "C3") SE)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Step SW (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "C3") SW)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Step E (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "C3") E)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Step W (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "C3") W)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Step NE (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "C3") NE)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Step NW (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "C3") NW)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Step N (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "C3") N)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Hop S (between if:True) (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "C3") steps:2 S)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Hop SE (between if:True) (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "C3") steps:2 SE)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Hop SW (between if:True) (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "C3") steps:2 SW)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Hop E (between if:True) (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "C3") steps:2 E)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Hop W (between if:True) (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "C3") steps:2 W)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Hop NE (between if:True) (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "C3") steps:2 NE)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Hop NW (between if:True) (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "C3") steps:2 NW)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Hop N (between if:True) (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "C3") steps:2 N)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))}) (if (is In (from) (sites "NE")) (or {(move Step S (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "C8") S)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Step SE (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "C8") SE)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Step SW (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "C8") SW)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Step E (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "C8") E)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Step W (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "C8") W)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Step NE (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "C8") NE)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Step NW (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "C8") NW)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Step N (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "C8") N)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Hop S (between if:True) (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "C8") steps:2 S)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Hop SE (between if:True) (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "C8") steps:2 SE)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Hop SW (between if:True) (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "C8") steps:2 SW)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Hop E (between if:True) (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "C8") steps:2 E)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Hop W (between if:True) (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "C8") steps:2 W)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Hop NE (between if:True) (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "C8") steps:2 NE)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Hop NW (between if:True) (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "C8") steps:2 NW)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Hop N (between if:True) (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "C8") steps:2 N)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))}) (if (is In (from) (sites "SE")) (or {(move Step S (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "H8") S)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Step SE (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "H8") SE)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Step SW (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "H8") SW)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Step E (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "H8") E)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Step W (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "H8") W)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Step NE (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "H8") NE)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Step NW (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "H8") NW)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Step N (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "H8") N)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Hop S (between if:True) (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "H8") steps:2 S)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Hop SE (between if:True) (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "H8") steps:2 SE)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Hop SW (between if:True) (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "H8") steps:2 SW)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Hop E (between if:True) (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "H8") steps:2 E)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Hop W (between if:True) (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "H8") steps:2 W)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Hop NE (between if:True) (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "H8") steps:2 NE)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Hop NW (between if:True) (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "H8") steps:2 NW)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Hop N (between if:True) (to if:(and (not (is Friend (who at:(to)))) (is Friend (who at:(ahead (coord "H8") steps:2 N)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))})))))) (hand Each) (regions "SW" (expand origin:(coord "C3") steps:2 All)) (regions "SE" (expand origin:(coord "H3") steps:2 All)) (regions "NW" (expand origin:(coord "C8") steps:2 All)) (regions "NE" (expand origin:(coord "H8") steps:2 All))}) (rules (start (place "Ball" "Hand" count:15)) (play (or (forEach Piece) (if (is Occupied (handSite Mover)) (move (from (handSite Mover)) (to (sites Empty)))))) (end (if (no Moves Next) (result Mover Win))))) 
Played on a 10x10 board. Each player has four Amazons (chess queens), with other pieces used as arrows. Two things happen on a turn: an amazon moves like a Chess queen, but cannot cross or enter a space occupied by another amazon or arrow. Then, it shoots an arrow to any space on the board that is along the path of a queen's move from that place. The last player able to make a move wins.
(game "Amazons" (players 2) (equipment {(board (square 10)) (piece "Queen" Each (move Slide (then (moveAgain)))) (piece "Dot" Neutral)}) (rules (start {(place "Queen1" {"A4" "D1" "G1" "J4"}) (place "Queen2" {"A7" "D10" "G10" "J7"})}) (play (if (is Even (count Moves)) (forEach Piece) (move Shoot (piece "Dot0")))) (end (if (no Moves Next) (result Mover Win))))) 
Each turn a player places a stone of their color on an empty hex. The placement is subject to the following restriction: After your placement you may not have a group containing more stones than the number of groups you have on the board. The first player unable to place a stone loses the game. A size 5 board is currently selected The standard goal is selected, which means that the first player unable to place loses.
(game "Bamboo" (players 2) (equipment {(board (hex 5)) (piece "Disc" Each) (piece "Disc" Neutral)}) (rules (play (do (move Add (to (sites Empty))) ifAfterwards:(<= (max (results from:(sites Occupied by:Mover) to:1 (* 1 (size Group at:(from))))) (count Groups if:(= (who at:(to)) (mover)))))) (end (if (no Moves Next) (result Next Loss))))) 
The 32 pieces are shuffled and randomly allocated face-down to squares on the board. The first player turns up a piece to begin the game. The color of that first uncovered piece is the color he or she will play in the game. The second player then makes a move, and the two alternate until the game is finished. There are three kinds of moves. A player may turn a piece face-up, move a piece, or capture an enemy piece. In some game variants, multiple captures may be made in one turn. Turning a piece face-up is a legal move if there are any face-down pieces on the board. Once revealed, a piece may move, capture, or be captured. A player may only move face-up pieces of their own color. Unlike Xiangqi, all pieces move identically: a piece may move only one square up, down, left, or right. A piece may never move onto a square that is already occupied unless such a move is a legal capture. A player may only capture with a face-up piece of their own color, and may only capture a face-up piece of the opposing color. In all captures, the captured piece is removed from the board and its square is occupied by the capturing piece. The pieces are ranked, forming a hierarchy with the general at the top and soldiers at the bottom. Only pieces of equal or lower rank may be captured, with one exception. For instance, a chariot may capture a horse, and the general may capture either, but a horse cannot capture a chariot, and neither can capture the general. The one exception concerns generals and soldiers: the general cannot capture soldiers, and soldiers can capture the general. In the Hong Kong version, the pieces are ranked in this order: General>Chariot>Horse>Cannon, Advisor>Minster>Soldier. This ranking reflects the approximate value of the corresponding pieces in Xiangqi (though the relative rank of horse and cannon is arguable). All pieces capture exactly as they move: one square up, down, left, or right. The game ends when a player cannot move, and that player is the loser. Most often, the game is lost because all of a player's pieces have been captured and so he has no pieces to move. However, it is possible for one player to surround all of the other player's remaining pieces in a manner that makes it impossible for them to move.
(game "Banqi" (players 2) (equipment {(board (rectangle 4 8)) (piece "Jiang" Each (move Step Orthogonal (to if:(or (is Empty (to)) (and {(not (is Hidden What at:(to) to:Mover)) (is Enemy (who at:(to))) (or (and (= (what at:(from)) (id "Zu" Mover)) (= (what at:(to)) (id "Jiang" Next))) (and (>= (value Piece at:(from)) (value Piece at:(to))) (not (and (= (what at:(from)) (id "Jiang" Mover)) (= (what at:(to)) (id "Zu" Next))))))})) (apply (remove (to)))))) (piece "Ju" Each (move Step Orthogonal (to if:(or (is Empty (to)) (and {(not (is Hidden What at:(to) to:Mover)) (is Enemy (who at:(to))) (or (and (= (what at:(from)) (id "Zu" Mover)) (= (what at:(to)) (id "Jiang" Next))) (and (>= (value Piece at:(from)) (value Piece at:(to))) (not (and (= (what at:(from)) (id "Jiang" Mover)) (= (what at:(to)) (id "Zu" Next))))))})) (apply (remove (to)))))) (piece "Ma" Each (move Step Orthogonal (to if:(or (is Empty (to)) (and {(not (is Hidden What at:(to) to:Mover)) (is Enemy (who at:(to))) (or (and (= (what at:(from)) (id "Zu" Mover)) (= (what at:(to)) (id "Jiang" Next))) (and (>= (value Piece at:(from)) (value Piece at:(to))) (not (and (= (what at:(from)) (id "Jiang" Mover)) (= (what at:(to)) (id "Zu" Next))))))})) (apply (remove (to)))))) (piece "Pao" Each (move Step Orthogonal (to if:(or (is Empty (to)) (and {(not (is Hidden What at:(to) to:Mover)) (is Enemy (who at:(to))) (or (and (= (what at:(from)) (id "Zu" Mover)) (= (what at:(to)) (id "Jiang" Next))) (and (>= (value Piece at:(from)) (value Piece at:(to))) (not (and (= (what at:(from)) (id "Jiang" Mover)) (= (what at:(to)) (id "Zu" Next))))))})) (apply (remove (to)))))) (piece "Shi" Each (move Step Orthogonal (to if:(or (is Empty (to)) (and {(not (is Hidden What at:(to) to:Mover)) (is Enemy (who at:(to))) (or (and (= (what at:(from)) (id "Zu" Mover)) (= (what at:(to)) (id "Jiang" Next))) (and (>= (value Piece at:(from)) (value Piece at:(to))) (not (and (= (what at:(from)) (id "Jiang" Mover)) (= (what at:(to)) (id "Zu" Next))))))})) (apply (remove (to)))))) (piece "Xiang" Each (move Step Orthogonal (to if:(or (is Empty (to)) (and {(not (is Hidden What at:(to) to:Mover)) (is Enemy (who at:(to))) (or (and (= (what at:(from)) (id "Zu" Mover)) (= (what at:(to)) (id "Jiang" Next))) (and (>= (value Piece at:(from)) (value Piece at:(to))) (not (and (= (what at:(from)) (id "Jiang" Mover)) (= (what at:(to)) (id "Zu" Next))))))})) (apply (remove (to)))))) (piece "Zu" Each (move Step Orthogonal (to if:(or (is Empty (to)) (and {(not (is Hidden What at:(to) to:Mover)) (is Enemy (who at:(to))) (or (and (= (what at:(from)) (id "Zu" Mover)) (= (what at:(to)) (id "Jiang" Next))) (and (>= (value Piece at:(from)) (value Piece at:(to))) (not (and (= (what at:(from)) (id "Jiang" Mover)) (= (what at:(to)) (id "Zu" Next))))))})) (apply (remove (to))))))}) (rules (start {(place Random {"Zu1"} count:5 value:1) (place Random {"Zu2"} count:5 value:1) (place Random {"Pao1"} count:2 value:4) (place Random {"Pao2"} count:2 value:4) (place Random {"Ju1"} count:2 value:6) (place Random {"Ju2"} count:2 value:6) (place Random {"Ma1"} count:2 value:5) (place Random {"Ma2"} count:2 value:5) (place Random {"Xiang1"} count:2 value:2) (place Random {"Xiang2"} count:2 value:2) (place Random {"Shi1"} count:2 value:3) (place Random {"Shi2"} count:2 value:3) (place Random {"Jiang1"} count:1 value:7) (place Random {"Jiang2"} count:1 value:7) (set Hidden {What Who} (sites Board) to:P1) (set Hidden {What Who} (sites Board) to:P2)}) phases:{(phase "Opening" P1 (play (move Select (from (sites Hidden What to:Mover)) (then (and {(set Hidden What at:(last To) False to:P1) (set Hidden Who at:(last To) False to:P1) (set Hidden What at:(last To) False to:P2) (set Hidden Who at:(last To) False to:P2) (set NextPlayer (player (who at:(last To))))})))) (nextPhase Mover "Play")) (phase "Play" (play (or (forEach Piece) (move Select (from (sites Hidden What to:Mover)) (then (and {(set Hidden What at:(last To) False to:P1) (set Hidden Who at:(last To) False to:P1) (set Hidden What at:(last To) False to:P2) (set Hidden Who at:(last To) False to:P2)}))))))} (end (if (no Moves Next) (result Mover Win))))) 
Played on a hexagonal board with five spaces per side. Players take turns placing stones on an empty space. The stone must be adjacent to the last stone played but cannot be adjacent to any other. The last player to be able to make a legal move wins.
(game "Blue Nile" (players 2) (equipment {(board (hex 5)) (piece "Marker" Neutral)}) (rules phases:{(phase "start" P1 (play (move Add (piece (id "Marker0")) (to (sites Empty)))) (nextPhase "play")) (phase "play" (play (move Add (piece "Marker0") (to (sites Around (last To) if:(and (is Empty (to)) (= (count Sites in:(difference (sites Around (to) if:(not (is In (to) (sites Empty)))) (last To))) 0)))))))} (end (if (no Moves Next) (result Next Loss))))) 
Board starts empty. Place on an empty location, unless it is next to more of your own pieces. Passing is not allowed. You lose if at the end of your turn, one of your stones is surrounded. Hex N / N-1 Grid Order 4 board
(game "Claustro" (players 2) (equipment {(board (tri Limping (- 4 1)) use:Vertex) (piece "Ball" P1) (piece "Ball" P2)}) (rules (start (set Score Each 0)) (play (move Add (piece (mover)) (to (sites Empty) if:(<= 0 (- (count Pieces Next in:(sites Around (to) Orthogonal)) (count Pieces Mover in:(sites Around (to) Orthogonal))))) (then (if (not (all Sites (sites Occupied by:Mover) if:(can Move (step (from (site)) Orthogonal (to if:(is Empty (to))))))) (trigger "End" Mover) (if (not (all Sites (sites Occupied by:Next) if:(can Move (step (from (site)) Orthogonal (to if:(is Empty (to))))))) (trigger "End" Next)))))) (end (if (or (is Triggered "End" Mover) (is Triggered "End" Next)) (if (is Triggered "End" Mover) (result Mover Loss)) (result Mover Win))))) 
The board is a square with diagonals drawn, with the bottom side of the square marked with an X. Two pieces per player, which begin on opposite corners of the square, one player on the side with the X and the other to the opposite side. Players alternate turns moving one of their pieces along the lines of the board to an empty adjacent point. Players cannot move along the line marked with an X. When one player cannot move, the opponent wins.
(game "Co Chan Cho" (players 2) (equipment {(board (square 2 diagonals:Solid) use:Vertex) (piece "Disc" Each (move Step (to if:(and {(or {(and (!= (from) (coord "A1")) (!= (from) (coord "C1"))) (and (= (from) (coord "C1")) (!= (to) (coord "A1"))) (and (= (from) (coord "A1")) (!= (to) (coord "C1")))}) (is Empty (to))}))))}) (rules (start {(place "Disc1" (sites Top)) (place "Disc2" (sites Bottom))}) (play (forEach Piece)) (end (if (no Moves Next) (result Next Loss))))) 
The game is played on a sheet of graph paper, with any set of designs traced out. It is most commonly played on rectangular board like a 6×6 square. Two players have a collection of dominoes which they place on the grid in turn. A player can place a domino either horizontally or vertically. Contrary to the related game of Domineering, the possible moves are the same for the two players, and Cram is then an impartial game. As for all impartial games, there are two possible conventions for victory: in the normal game, the first player who cannot move loses, and on the contrary, in the misere version, the first player who cannot move wins. The board has 6 rows. The board has 6 columns. The Last player to play wins.
(game "Cram" (players 2) (equipment {(board (rectangle 6 6)) (tile "Tile" P1 {F} numSides:4) (tile "Tile" P2 {F} numSides:4)}) (rules (play (or (move Add (piece (mover) state:0) (to (sites Empty))) (move Add (piece (mover) state:1) (to (sites Empty))))) (end (if (no Moves Next) (result Next Loss))))) 
A square, with diagonals, but one side of the square has been removed. Two pieces per player. Players alternate turns placing a piece on an empty spot on the board. When the pieces are placed, players alternate turns moving one of their pieces to an empty adjacent spot along the lines. The player who blocks the other from being able to move wins.
(game "Do Guti" (players 2) (equipment {(board (add (remove (rectangle 3 3 diagonals:Alternating) vertices:{1 3 5 7}) edges:{{3 0} {0 1} {1 4}}) use:Vertex) (hand Each) (piece "Disc" Each (move Step (to if:(is Empty (to)))))}) (rules (start (place "Disc" "Hand" count:2)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end (if (no Moves Next) (result Next Loss))))) 
On your turn you move one of your pieces one step onto an empty cell in one of the three forwards directions. Black's pieces move towards the bottom of the board, while White's pieces move towards the top. If, at the beginning of your turn, none of your pieces can move, you win.
(game "Dodo" (players {(player N) (player S)}) (equipment {(board (rotate 30 (hex 4))) (piece "Disc" Each (move Step Forwards (to if:(is Empty (to)))))}) (rules (start {(place "Disc1" {0 1 2 3 4 5 6 7 9 10 11 15 16}) (place "Disc2" {20 21 25 26 27 29 30 31 32 33 34 35 36})}) (play (forEach Piece)) (end (if (no Moves Mover) (result Mover Win))))) 
Two players have a collection of dominoes which they place on the grid in turn, covering up squares. One player places tiles vertically, while the other places them horizontally. The first player who cannot move loses. The board has 6 rows. The board has 6 columns. The Last player to play wins.
(game "Domineering" (players 2) (equipment {(board (rectangle 6 6)) (tile "Horz" P1 {R F} numSides:4) (tile "Vert" P2 {F} numSides:4)}) (rules (play (move Add (piece (mover) state:0) (to (sites Empty)))) (end (if (no Moves Next) (result Next Loss))))) 
A circle, with four points equally spaced along the circumference, as well as a point in the center. A diameter is drawn between two of the outer points and through the center. Two players. Two pieces per player. Players alternate turns placing a piece on the board. When all of the pieces are placed, players alternate turns moving a piece to an empty adjacent point along the lines. The player who blocks the other player from being able to move wins.
(game "Dorvon Cag" (players 2) (equipment {(board (remove (concentric {1 4}) edges:{{1 0} {0 3}}) use:Vertex) (hand Each) (piece "Disc" Each (move Step (to if:(is Empty (to)))))}) (rules (start (place "Disc" "Hand" count:2)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end (if (no Moves Next) (result Mover Win))))) 
The player to play the last possible legal move wins the game. The other player loses. Unless, that is, the board is completely full, in which case the game is a tie.
(game "Duidoku" (players 2) (equipment {(board (square 9)) (piece "1" Neutral) (piece "2" Neutral) (piece "3" Neutral) (piece "4" Neutral) (piece "5" Neutral) (piece "6" Neutral) (piece "7" Neutral) (piece "8" Neutral) (piece "9" Neutral) (regions "Square0" (sites {0 1 2 9 10 11 18 19 20})) (regions "Square1" (sites {3 4 5 12 13 14 21 22 23})) (regions "Square2" (sites {6 7 8 15 16 17 24 25 26})) (regions "Square3" (sites {27 28 29 36 37 38 45 46 47})) (regions "Square4" (sites {30 31 32 39 40 41 48 49 50})) (regions "Square5" (sites {33 34 35 42 43 44 51 52 53})) (regions "Square6" (sites {54 55 56 63 64 65 72 73 74})) (regions "Square7" (sites {57 58 59 66 67 68 75 76 77})) (regions "Square8" (sites {60 61 62 69 70 71 78 79 80}))}) (rules (play (or {(move Add (piece (id "1" Neutral)) (to (sites Empty) if:(and {(all Sites (sites Row (row of:(to))) if:(!= (id "1" Neutral) (what at:(site)))) (all Sites (sites Column (column of:(to))) if:(!= (id "1" Neutral) (what at:(site)))) (if (is In (to) (sites "Square0")) (all Sites (sites "Square0") if:(!= (id "1" Neutral) (what at:(site)))) (if (is In (to) (sites "Square1")) (all Sites (sites "Square1") if:(!= (id "1" Neutral) (what at:(site)))) (if (is In (to) (sites "Square2")) (all Sites (sites "Square2") if:(!= (id "1" Neutral) (what at:(site)))) (if (is In (to) (sites "Square3")) (all Sites (sites "Square3") if:(!= (id "1" Neutral) (what at:(site)))) (if (is In (to) (sites "Square4")) (all Sites (sites "Square4") if:(!= (id "1" Neutral) (what at:(site)))) (if (is In (to) (sites "Square5")) (all Sites (sites "Square5") if:(!= (id "1" Neutral) (what at:(site)))) (if (is In (to) (sites "Square6")) (all Sites (sites "Square6") if:(!= (id "1" Neutral) (what at:(site)))) (if (is In (to) (sites "Square7")) (all Sites (sites "Square7") if:(!= (id "1" Neutral) (what at:(site)))) (all Sites (sites "Square8") if:(!= (id "1" Neutral) (what at:(site))))))))))))}))) (move Add (piece (id "2" Neutral)) (to (sites Empty) if:(and {(all Sites (sites Row (row of:(to))) if:(!= (id "2" Neutral) (what at:(site)))) (all Sites (sites Column (column of:(to))) if:(!= (id "2" Neutral) (what at:(site)))) (if (is In (to) (sites "Square0")) (all Sites (sites "Square0") if:(!= (id "2" Neutral) (what at:(site)))) (if (is In (to) (sites "Square1")) (all Sites (sites "Square1") if:(!= (id "2" Neutral) (what at:(site)))) (if (is In (to) (sites "Square2")) (all Sites (sites "Square2") if:(!= (id "2" Neutral) (what at:(site)))) (if (is In (to) (sites "Square3")) (all Sites (sites "Square3") if:(!= (id "2" Neutral) (what at:(site)))) (if (is In (to) (sites "Square4")) (all Sites (sites "Square4") if:(!= (id "2" Neutral) (what at:(site)))) (if (is In (to) (sites "Square5")) (all Sites (sites "Square5") if:(!= (id "2" Neutral) (what at:(site)))) (if (is In (to) (sites "Square6")) (all Sites (sites "Square6") if:(!= (id "2" Neutral) (what at:(site)))) (if (is In (to) (sites "Square7")) (all Sites (sites "Square7") if:(!= (id "2" Neutral) (what at:(site)))) (all Sites (sites "Square8") if:(!= (id "2" Neutral) (what at:(site))))))))))))}))) (move Add (piece (id "3" Neutral)) (to (sites Empty) if:(and {(all Sites (sites Row (row of:(to))) if:(!= (id "3" Neutral) (what at:(site)))) (all Sites (sites Column (column of:(to))) if:(!= (id "3" Neutral) (what at:(site)))) (if (is In (to) (sites "Square0")) (all Sites (sites "Square0") if:(!= (id "3" Neutral) (what at:(site)))) (if (is In (to) (sites "Square1")) (all Sites (sites "Square1") if:(!= (id "3" Neutral) (what at:(site)))) (if (is In (to) (sites "Square2")) (all Sites (sites "Square2") if:(!= (id "3" Neutral) (what at:(site)))) (if (is In (to) (sites "Square3")) (all Sites (sites "Square3") if:(!= (id "3" Neutral) (what at:(site)))) (if (is In (to) (sites "Square4")) (all Sites (sites "Square4") if:(!= (id "3" Neutral) (what at:(site)))) (if (is In (to) (sites "Square5")) (all Sites (sites "Square5") if:(!= (id "3" Neutral) (what at:(site)))) (if (is In (to) (sites "Square6")) (all Sites (sites "Square6") if:(!= (id "3" Neutral) (what at:(site)))) (if (is In (to) (sites "Square7")) (all Sites (sites "Square7") if:(!= (id "3" Neutral) (what at:(site)))) (all Sites (sites "Square8") if:(!= (id "3" Neutral) (what at:(site))))))))))))}))) (move Add (piece (id "4" Neutral)) (to (sites Empty) if:(and {(all Sites (sites Row (row of:(to))) if:(!= (id "4" Neutral) (what at:(site)))) (all Sites (sites Column (column of:(to))) if:(!= (id "4" Neutral) (what at:(site)))) (if (is In (to) (sites "Square0")) (all Sites (sites "Square0") if:(!= (id "4" Neutral) (what at:(site)))) (if (is In (to) (sites "Square1")) (all Sites (sites "Square1") if:(!= (id "4" Neutral) (what at:(site)))) (if (is In (to) (sites "Square2")) (all Sites (sites "Square2") if:(!= (id "4" Neutral) (what at:(site)))) (if (is In (to) (sites "Square3")) (all Sites (sites "Square3") if:(!= (id "4" Neutral) (what at:(site)))) (if (is In (to) (sites "Square4")) (all Sites (sites "Square4") if:(!= (id "4" Neutral) (what at:(site)))) (if (is In (to) (sites "Square5")) (all Sites (sites "Square5") if:(!= (id "4" Neutral) (what at:(site)))) (if (is In (to) (sites "Square6")) (all Sites (sites "Square6") if:(!= (id "4" Neutral) (what at:(site)))) (if (is In (to) (sites "Square7")) (all Sites (sites "Square7") if:(!= (id "4" Neutral) (what at:(site)))) (all Sites (sites "Square8") if:(!= (id "4" Neutral) (what at:(site))))))))))))}))) (move Add (piece (id "5" Neutral)) (to (sites Empty) if:(and {(all Sites (sites Row (row of:(to))) if:(!= (id "5" Neutral) (what at:(site)))) (all Sites (sites Column (column of:(to))) if:(!= (id "5" Neutral) (what at:(site)))) (if (is In (to) (sites "Square0")) (all Sites (sites "Square0") if:(!= (id "5" Neutral) (what at:(site)))) (if (is In (to) (sites "Square1")) (all Sites (sites "Square1") if:(!= (id "5" Neutral) (what at:(site)))) (if (is In (to) (sites "Square2")) (all Sites (sites "Square2") if:(!= (id "5" Neutral) (what at:(site)))) (if (is In (to) (sites "Square3")) (all Sites (sites "Square3") if:(!= (id "5" Neutral) (what at:(site)))) (if (is In (to) (sites "Square4")) (all Sites (sites "Square4") if:(!= (id "5" Neutral) (what at:(site)))) (if (is In (to) (sites "Square5")) (all Sites (sites "Square5") if:(!= (id "5" Neutral) (what at:(site)))) (if (is In (to) (sites "Square6")) (all Sites (sites "Square6") if:(!= (id "5" Neutral) (what at:(site)))) (if (is In (to) (sites "Square7")) (all Sites (sites "Square7") if:(!= (id "5" Neutral) (what at:(site)))) (all Sites (sites "Square8") if:(!= (id "5" Neutral) (what at:(site))))))))))))}))) (move Add (piece (id "6" Neutral)) (to (sites Empty) if:(and {(all Sites (sites Row (row of:(to))) if:(!= (id "6" Neutral) (what at:(site)))) (all Sites (sites Column (column of:(to))) if:(!= (id "6" Neutral) (what at:(site)))) (if (is In (to) (sites "Square0")) (all Sites (sites "Square0") if:(!= (id "6" Neutral) (what at:(site)))) (if (is In (to) (sites "Square1")) (all Sites (sites "Square1") if:(!= (id "6" Neutral) (what at:(site)))) (if (is In (to) (sites "Square2")) (all Sites (sites "Square2") if:(!= (id "6" Neutral) (what at:(site)))) (if (is In (to) (sites "Square3")) (all Sites (sites "Square3") if:(!= (id "6" Neutral) (what at:(site)))) (if (is In (to) (sites "Square4")) (all Sites (sites "Square4") if:(!= (id "6" Neutral) (what at:(site)))) (if (is In (to) (sites "Square5")) (all Sites (sites "Square5") if:(!= (id "6" Neutral) (what at:(site)))) (if (is In (to) (sites "Square6")) (all Sites (sites "Square6") if:(!= (id "6" Neutral) (what at:(site)))) (if (is In (to) (sites "Square7")) (all Sites (sites "Square7") if:(!= (id "6" Neutral) (what at:(site)))) (all Sites (sites "Square8") if:(!= (id "6" Neutral) (what at:(site))))))))))))}))) (move Add (piece (id "7" Neutral)) (to (sites Empty) if:(and {(all Sites (sites Row (row of:(to))) if:(!= (id "7" Neutral) (what at:(site)))) (all Sites (sites Column (column of:(to))) if:(!= (id "7" Neutral) (what at:(site)))) (if (is In (to) (sites "Square0")) (all Sites (sites "Square0") if:(!= (id "7" Neutral) (what at:(site)))) (if (is In (to) (sites "Square1")) (all Sites (sites "Square1") if:(!= (id "7" Neutral) (what at:(site)))) (if (is In (to) (sites "Square2")) (all Sites (sites "Square2") if:(!= (id "7" Neutral) (what at:(site)))) (if (is In (to) (sites "Square3")) (all Sites (sites "Square3") if:(!= (id "7" Neutral) (what at:(site)))) (if (is In (to) (sites "Square4")) (all Sites (sites "Square4") if:(!= (id "7" Neutral) (what at:(site)))) (if (is In (to) (sites "Square5")) (all Sites (sites "Square5") if:(!= (id "7" Neutral) (what at:(site)))) (if (is In (to) (sites "Square6")) (all Sites (sites "Square6") if:(!= (id "7" Neutral) (what at:(site)))) (if (is In (to) (sites "Square7")) (all Sites (sites "Square7") if:(!= (id "7" Neutral) (what at:(site)))) (all Sites (sites "Square8") if:(!= (id "7" Neutral) (what at:(site))))))))))))}))) (move Add (piece (id "8" Neutral)) (to (sites Empty) if:(and {(all Sites (sites Row (row of:(to))) if:(!= (id "8" Neutral) (what at:(site)))) (all Sites (sites Column (column of:(to))) if:(!= (id "8" Neutral) (what at:(site)))) (if (is In (to) (sites "Square0")) (all Sites (sites "Square0") if:(!= (id "8" Neutral) (what at:(site)))) (if (is In (to) (sites "Square1")) (all Sites (sites "Square1") if:(!= (id "8" Neutral) (what at:(site)))) (if (is In (to) (sites "Square2")) (all Sites (sites "Square2") if:(!= (id "8" Neutral) (what at:(site)))) (if (is In (to) (sites "Square3")) (all Sites (sites "Square3") if:(!= (id "8" Neutral) (what at:(site)))) (if (is In (to) (sites "Square4")) (all Sites (sites "Square4") if:(!= (id "8" Neutral) (what at:(site)))) (if (is In (to) (sites "Square5")) (all Sites (sites "Square5") if:(!= (id "8" Neutral) (what at:(site)))) (if (is In (to) (sites "Square6")) (all Sites (sites "Square6") if:(!= (id "8" Neutral) (what at:(site)))) (if (is In (to) (sites "Square7")) (all Sites (sites "Square7") if:(!= (id "8" Neutral) (what at:(site)))) (all Sites (sites "Square8") if:(!= (id "8" Neutral) (what at:(site))))))))))))}))) (move Add (piece (id "9" Neutral)) (to (sites Empty) if:(and {(all Sites (sites Row (row of:(to))) if:(!= (id "9" Neutral) (what at:(site)))) (all Sites (sites Column (column of:(to))) if:(!= (id "9" Neutral) (what at:(site)))) (if (is In (to) (sites "Square0")) (all Sites (sites "Square0") if:(!= (id "9" Neutral) (what at:(site)))) (if (is In (to) (sites "Square1")) (all Sites (sites "Square1") if:(!= (id "9" Neutral) (what at:(site)))) (if (is In (to) (sites "Square2")) (all Sites (sites "Square2") if:(!= (id "9" Neutral) (what at:(site)))) (if (is In (to) (sites "Square3")) (all Sites (sites "Square3") if:(!= (id "9" Neutral) (what at:(site)))) (if (is In (to) (sites "Square4")) (all Sites (sites "Square4") if:(!= (id "9" Neutral) (what at:(site)))) (if (is In (to) (sites "Square5")) (all Sites (sites "Square5") if:(!= (id "9" Neutral) (what at:(site)))) (if (is In (to) (sites "Square6")) (all Sites (sites "Square6") if:(!= (id "9" Neutral) (what at:(site)))) (if (is In (to) (sites "Square7")) (all Sites (sites "Square7") if:(!= (id "9" Neutral) (what at:(site)))) (all Sites (sites "Square8") if:(!= (id "9" Neutral) (what at:(site))))))))))))})))})) (end {(if (all Sites (sites Board) if:(is Occupied (site))) (result Mover Draw)) (if (no Moves Next) (result Mover Win))}))) 
Use Options to select a board size. Goal: Be the last to play. Then the first player (Maroon) places a stone, after which the players alternate, taking up to two moves per turn. To move, either: 1. Add a stone to an empty space that is not in line-of-sight of any opponent's stone. -Or, 2. Slide a stone along a straight line to a new position, with the following restriction: Either -- A. The new location must have a greater number of opponent's stones adjacent to it, or -- B. The new location must have more sight-lines to opponent's stones than the old location, while keeping number of adjacent opponent's stones the same. To avoid forfeiting the game, a player must move at least once on a turn. The second move can be voluntarily skipped. The winner is last to play. The score shown is a count of the available moves at the beginning of a player's turn for use by the AI. Extra small board (39 nodes) as a filler game and for learning how to play
(game "Epoxy" (players 2) (equipment {(board (dual (remove (hex 4 5) cells:{0 1 15 20 25 32 36 39 44})) use:Vertex) (piece "Ball" Each (move Slide))}) (rules (start (set Score Each 0)) (play (or {(move Add (piece (mover)) (to (difference (sites Empty) (sites (results from:(sites Occupied by:Next) to:(sites LineOfSight Empty at:(from) Orthogonal) (to)))))) (forEach Piece (do (and (set Var "LoSFrom" (count Pieces Next in:(sites LineOfSight Piece at:(from) Orthogonal))) (set Var "QtyAroundFrom" (count Pieces Next in:(sites Around (from) Orthogonal)))) next:(move Slide Orthogonal) ifAfterwards:(or (> (count Pieces Next in:(sites Around (last To) Orthogonal)) (var "QtyAroundFrom")) (and (= (count Pieces Next in:(sites Around (last To) Orthogonal)) (var "QtyAroundFrom")) (> (count Pieces Next in:(sites LineOfSight Piece at:(last To) Orthogonal)) (var "LoSFrom"))))) Mover) (if (and (not (is Prev Next)) (< 0 (counter))) (move Pass))} (then (if (is Prev Next) (moveAgain) (and (set Score Mover (+ (size Array (array (sites From (forEach Piece (do (and (set Var "LoSFrom" (count Pieces Next in:(sites LineOfSight Piece at:(from) Orthogonal))) (set Var "QtyAroundFrom" (count Pieces Next in:(sites Around (from) Orthogonal)))) next:(move Slide Orthogonal) ifAfterwards:(or (> (count Pieces Next in:(sites Around (last To) Orthogonal)) (var "QtyAroundFrom")) (and (= (count Pieces Next in:(sites Around (last To) Orthogonal)) (var "QtyAroundFrom")) (> (count Pieces Next in:(sites LineOfSight Piece at:(last To) Orthogonal)) (var "LoSFrom"))))) Mover)))) (count Sites in:(difference (sites (results from:(sites Occupied by:Mover) to:(sites LineOfSight Empty at:(from) Orthogonal) (to))) (sites (results from:(sites Occupied by:Next) to:(sites LineOfSight Empty at:(from) Orthogonal) (to))))))) (set Score Next (+ (size Array (array (sites From (forEach Piece (do (and (set Var "LoSFrom" (count Pieces Next in:(sites LineOfSight Piece at:(from) Orthogonal))) (set Var "QtyAroundFrom" (count Pieces Next in:(sites Around (from) Orthogonal)))) next:(move Slide Orthogonal) ifAfterwards:(or (> (count Pieces Next in:(sites Around (last To) Orthogonal)) (var "QtyAroundFrom")) (and (= (count Pieces Next in:(sites Around (last To) Orthogonal)) (var "QtyAroundFrom")) (> (count Pieces Next in:(sites LineOfSight Piece at:(last To) Orthogonal)) (var "LoSFrom"))))) Next)))) (count Sites in:(difference (sites (results from:(sites Occupied by:Next) to:(sites LineOfSight Empty at:(from) Orthogonal) (to))) (sites (results from:(sites Occupied by:Mover) to:(sites LineOfSight Empty at:(from) Orthogonal) (to)))))))))))) (end (if (and (is Prev Mover) (no Moves Next)) (result Mover Win))))) 
Ex nihilo is a game for 2 players played with stackable pieces of two colors on the cells of a hexagonal arrangement of hexagons (a hexhex board). The board starts out empty. The game is over as soon as one player is unable to make a move. The other player is then the winner. Even though the goal is technically stalemate, out of the interlocking mechanics emerges a territorial goal with a constant threat of a clever check mate turning the tide or ending the game before territory is settled. The novelty of this game lies in its central gimmick: Every move consists in moving a stack. In this sense it is a pure movement game. Yet, the game features both placement and captures. Movement – overview: Stacks move along straight open lines and grow when they move away from the center cell. This game is unusual in allowing movement of stacks containing 0 pieces. It is by growing these that pieces get onto the board in the first place. Movement – details: On your turn, you must move a stack not topped by an enemy piece to an empty cell reachable through an unbroken line of empty cells. By convention, a single piece is considered a stack of size 1 and an empty cell is considered to contain a stack of size 0. If, after you have moved a stack, it is farther away from the center cell than before it was moved (measured in number of steps), its size is increased by 1 per step further away from the center it now is. This happens automatically in Ludii. You may move a proper part of a stack by splitting it. To move a part of a stack, drag the piece that will be the bottom piece of the new stack to its destination, or click it, then the destination. You may also move a whole stack, but only on the condition that you move it farther away from the center cell. A consequence is that moving a whole stack always results in its size increasing. Together with the convention that empty cells contain stacks of size 0, this also has the consequence that you can effectively place a new stack on the board by moving a stack of size 0. In Ludii a 0-stack is represented by a grey disc. You move it by dragging it to where you want to go, or click it, then the destination. Note that nothing special happens to the cell you moved the 0-stack from – it still contains a 0-stack. Capturing - overview: Flanked enemy stacks are captured by being taken hostage for a move. Capturing is obligatory: If a capturing move is available, a capturing move must be made. Capturing - details: If (and only if) the top piece of a stack is of your color, it is said to partake in flanking an enemy stack if (i) this enemy stack is exactly in the middle of a line of otherwise empty cells going from the flanking stack to another one of your stacks, and (ii) all three of these stacks are of the same size. If, after you have moved a stack, it partakes in flanking one or more enemy stacks, you must immediately move one of these enemy stacks. Except for the obvious difference that you are moving an enemy stack, all normal rules apply to this move. For example: If the captured stack grows (if you move it farther away from the center cell, that is), it grows by the addition of pieces of your color, so situations where this hostage move must itself be a capturing move are possible. Such chaining of captures must continue until you capture a stack that is not in a position to continue the chain. Growing captured stacks is the only way to take ownership of them more permanently. A base 5 board is currently selected
(game "Ex Nihilo" (players 2) (equipment {(board (hex 5)) (piece "Disc" Each) (piece "Disc" Neutral)}) (rules (start (place "Disc0" (sites Board))) (play (priority (do (if (= 1 (var)) (and (set Var 0) (or {(forEach Piece (move (from if:(is In (from) (sites (values Remembered)))) (to (sites Direction from:(from) stop:(< 0 (who at:(to)))) if:(< (count Steps (from) (centrePoint)) (count Steps (to) (centrePoint))) (apply (remove (to)))) count:(size Stack at:(from)) stack:True (then (and (add (to (last To)) count:(- (count Steps (last To) (centrePoint)) (count Steps (last From) (centrePoint))) stack:True) (add (piece "Disc0") (to (last From)))))) Next top:True) (forEach Piece (forEach Value min:1 max:(- (size Stack at:(from)) 1) (move (from if:(is In (from) (sites (values Remembered)))) (to (sites Direction from:(from) stop:(< 0 (who at:(to)))) (apply (remove (to)))) count:(value) stack:True (then (if (< (count Steps (last From) (centrePoint)) (count Steps (last To) (centrePoint))) (add (to (last To)) count:(- (count Steps (last To) (centrePoint)) (count Steps (last From) (centrePoint))) stack:True))))) Next top:True)})) (or {(forEach Piece (move (from) (to (sites Direction from:(from) stop:(< 0 (who at:(to)))) if:(< (count Steps (from) (centrePoint)) (count Steps (to) (centrePoint)))) copy:True (then (do (remove (last To) count:(size Stack at:(last To))) next:(add (to (last To)) count:(- (count Steps (last To) (centrePoint)) (count Steps (last From) (centrePoint))) stack:True)))) Neutral top:True) (forEach Piece (or (move (from if:True) (to (sites Direction from:(from) stop:(< 0 (who at:(to)))) if:(< (count Steps (from) (centrePoint)) (count Steps (to) (centrePoint))) (apply (remove (to)))) count:(size Stack at:(from)) stack:True (then (and (add (to (last To)) count:(- (count Steps (last To) (centrePoint)) (count Steps (last From) (centrePoint))) stack:True) (add (piece "Disc0") (to (last From)))))) (forEach Value min:1 max:(- (size Stack at:(from)) 1) (move (from if:(< 1 (size Stack at:(from)))) (to (sites Direction from:(from) stop:(< 0 (who at:(to)))) (apply (remove (to)))) count:(value) stack:True (then (if (< (count Steps (last From) (centrePoint)) (count Steps (last To) (centrePoint))) (add (to (last To)) count:(- (count Steps (last To) (centrePoint)) (count Steps (last From) (centrePoint))) stack:True)))))) Mover top:True)})) ifAfterwards:(or {(and {(= 1 (count Sites in:(intersection (sites Direction from:(last To) NNW stop:(= (mover) (who at:(to))) stopIncluded:True) (sites Occupied by:Mover)))) (= 1 (count Sites in:(intersection (sites Direction from:(last To) NNW stop:(= (mover) (who at:(to))) stopIncluded:True) (sites Occupied by:Next)))) (= (next) (who at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) NNW stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) NNW))) (is Even (count Sites in:(sites Direction from:(last To) NNW stop:(= (mover) (who at:(to))) stopIncluded:True))) (= (mover) (who at:(last To))) (= (size Stack at:(last To)) (size Stack at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) NNW stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) NNW))) (= (size Stack at:(ahead (last To) steps:(count Sites in:(sites Direction from:(last To) NNW stop:(= (mover) (who at:(to))) stopIncluded:True)) NNW)) (size Stack at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) NNW stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) NNW)))}) (and {(= 1 (count Sites in:(intersection (sites Direction from:(last To) W stop:(= (mover) (who at:(to))) stopIncluded:True) (sites Occupied by:Mover)))) (= 1 (count Sites in:(intersection (sites Direction from:(last To) W stop:(= (mover) (who at:(to))) stopIncluded:True) (sites Occupied by:Next)))) (= (next) (who at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) W stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) W))) (is Even (count Sites in:(sites Direction from:(last To) W stop:(= (mover) (who at:(to))) stopIncluded:True))) (= (mover) (who at:(last To))) (= (size Stack at:(last To)) (size Stack at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) W stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) W))) (= (size Stack at:(ahead (last To) steps:(count Sites in:(sites Direction from:(last To) W stop:(= (mover) (who at:(to))) stopIncluded:True)) W)) (size Stack at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) W stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) W)))}) (and {(= 1 (count Sites in:(intersection (sites Direction from:(last To) SSW stop:(= (mover) (who at:(to))) stopIncluded:True) (sites Occupied by:Mover)))) (= 1 (count Sites in:(intersection (sites Direction from:(last To) SSW stop:(= (mover) (who at:(to))) stopIncluded:True) (sites Occupied by:Next)))) (= (next) (who at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) SSW stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) SSW))) (is Even (count Sites in:(sites Direction from:(last To) SSW stop:(= (mover) (who at:(to))) stopIncluded:True))) (= (mover) (who at:(last To))) (= (size Stack at:(last To)) (size Stack at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) SSW stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) SSW))) (= (size Stack at:(ahead (last To) steps:(count Sites in:(sites Direction from:(last To) SSW stop:(= (mover) (who at:(to))) stopIncluded:True)) SSW)) (size Stack at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) SSW stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) SSW)))}) (and {(= 1 (count Sites in:(intersection (sites Direction from:(last To) SSE stop:(= (mover) (who at:(to))) stopIncluded:True) (sites Occupied by:Mover)))) (= 1 (count Sites in:(intersection (sites Direction from:(last To) SSE stop:(= (mover) (who at:(to))) stopIncluded:True) (sites Occupied by:Next)))) (= (next) (who at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) SSE stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) SSE))) (is Even (count Sites in:(sites Direction from:(last To) SSE stop:(= (mover) (who at:(to))) stopIncluded:True))) (= (mover) (who at:(last To))) (= (size Stack at:(last To)) (size Stack at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) SSE stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) SSE))) (= (size Stack at:(ahead (last To) steps:(count Sites in:(sites Direction from:(last To) SSE stop:(= (mover) (who at:(to))) stopIncluded:True)) SSE)) (size Stack at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) SSE stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) SSE)))}) (and {(= 1 (count Sites in:(intersection (sites Direction from:(last To) E stop:(= (mover) (who at:(to))) stopIncluded:True) (sites Occupied by:Mover)))) (= 1 (count Sites in:(intersection (sites Direction from:(last To) E stop:(= (mover) (who at:(to))) stopIncluded:True) (sites Occupied by:Next)))) (= (next) (who at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) E stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) E))) (is Even (count Sites in:(sites Direction from:(last To) E stop:(= (mover) (who at:(to))) stopIncluded:True))) (= (mover) (who at:(last To))) (= (size Stack at:(last To)) (size Stack at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) E stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) E))) (= (size Stack at:(ahead (last To) steps:(count Sites in:(sites Direction from:(last To) E stop:(= (mover) (who at:(to))) stopIncluded:True)) E)) (size Stack at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) E stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) E)))}) (and {(= 1 (count Sites in:(intersection (sites Direction from:(last To) NNE stop:(= (mover) (who at:(to))) stopIncluded:True) (sites Occupied by:Mover)))) (= 1 (count Sites in:(intersection (sites Direction from:(last To) NNE stop:(= (mover) (who at:(to))) stopIncluded:True) (sites Occupied by:Next)))) (= (next) (who at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) NNE stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) NNE))) (is Even (count Sites in:(sites Direction from:(last To) NNE stop:(= (mover) (who at:(to))) stopIncluded:True))) (= (mover) (who at:(last To))) (= (size Stack at:(last To)) (size Stack at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) NNE stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) NNE))) (= (size Stack at:(ahead (last To) steps:(count Sites in:(sites Direction from:(last To) NNE stop:(= (mover) (who at:(to))) stopIncluded:True)) NNE)) (size Stack at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) NNE stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) NNE)))})})) (if (= 1 (var)) (do (set Var 0) next:(or {(forEach Piece (move (from if:(is In (from) (sites (values Remembered)))) (to (sites Direction from:(from) stop:(< 0 (who at:(to)))) if:(< (count Steps (from) (centrePoint)) (count Steps (to) (centrePoint))) (apply (remove (to)))) count:(size Stack at:(from)) stack:True (then (and (add (to (last To)) count:(- (count Steps (last To) (centrePoint)) (count Steps (last From) (centrePoint))) stack:True) (add (piece "Disc0") (to (last From)))))) Next top:True) (forEach Piece (forEach Value min:1 max:(- (size Stack at:(from)) 1) (move (from if:(is In (from) (sites (values Remembered)))) (to (sites Direction from:(from) stop:(< 0 (who at:(to)))) (apply (remove (to)))) count:(value) stack:True (then (if (< (count Steps (last From) (centrePoint)) (count Steps (last To) (centrePoint))) (add (to (last To)) count:(- (count Steps (last To) (centrePoint)) (count Steps (last From) (centrePoint))) stack:True))))) Next top:True)})) (or {(forEach Piece (move (from) (to (sites Direction from:(from) stop:(< 0 (who at:(to)))) if:(< (count Steps (from) (centrePoint)) (count Steps (to) (centrePoint)))) copy:True (then (do (remove (last To) count:(size Stack at:(last To))) next:(add (to (last To)) count:(- (count Steps (last To) (centrePoint)) (count Steps (last From) (centrePoint))) stack:True)))) Neutral top:True) (forEach Piece (or (move (from if:True) (to (sites Direction from:(from) stop:(< 0 (who at:(to)))) if:(< (count Steps (from) (centrePoint)) (count Steps (to) (centrePoint))) (apply (remove (to)))) count:(size Stack at:(from)) stack:True (then (and (add (to (last To)) count:(- (count Steps (last To) (centrePoint)) (count Steps (last From) (centrePoint))) stack:True) (add (piece "Disc0") (to (last From)))))) (forEach Value min:1 max:(- (size Stack at:(from)) 1) (move (from if:(< 1 (size Stack at:(from)))) (to (sites Direction from:(from) stop:(< 0 (who at:(to)))) (apply (remove (to)))) count:(value) stack:True (then (if (< (count Steps (last From) (centrePoint)) (count Steps (last To) (centrePoint))) (add (to (last To)) count:(- (count Steps (last To) (centrePoint)) (count Steps (last From) (centrePoint))) stack:True)))))) Mover top:True)})) (then (and (forget Value All) (and {(if (and {(= 1 (count Sites in:(intersection (sites Direction from:(last To) NNW stop:(= (mover) (who at:(to))) stopIncluded:True) (sites Occupied by:Mover)))) (= 1 (count Sites in:(intersection (sites Direction from:(last To) NNW stop:(= (mover) (who at:(to))) stopIncluded:True) (sites Occupied by:Next)))) (= (next) (who at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) NNW stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) NNW))) (is Even (count Sites in:(sites Direction from:(last To) NNW stop:(= (mover) (who at:(to))) stopIncluded:True))) (= (mover) (who at:(last To))) (= (size Stack at:(last To)) (size Stack at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) NNW stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) NNW))) (= (size Stack at:(ahead (last To) steps:(count Sites in:(sites Direction from:(last To) NNW stop:(= (mover) (who at:(to))) stopIncluded:True)) NNW)) (size Stack at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) NNW stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) NNW)))}) (remember Value (ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) NNW stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) NNW))) (if (and {(= 1 (count Sites in:(intersection (sites Direction from:(last To) W stop:(= (mover) (who at:(to))) stopIncluded:True) (sites Occupied by:Mover)))) (= 1 (count Sites in:(intersection (sites Direction from:(last To) W stop:(= (mover) (who at:(to))) stopIncluded:True) (sites Occupied by:Next)))) (= (next) (who at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) W stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) W))) (is Even (count Sites in:(sites Direction from:(last To) W stop:(= (mover) (who at:(to))) stopIncluded:True))) (= (mover) (who at:(last To))) (= (size Stack at:(last To)) (size Stack at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) W stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) W))) (= (size Stack at:(ahead (last To) steps:(count Sites in:(sites Direction from:(last To) W stop:(= (mover) (who at:(to))) stopIncluded:True)) W)) (size Stack at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) W stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) W)))}) (remember Value (ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) W stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) W))) (if (and {(= 1 (count Sites in:(intersection (sites Direction from:(last To) SSW stop:(= (mover) (who at:(to))) stopIncluded:True) (sites Occupied by:Mover)))) (= 1 (count Sites in:(intersection (sites Direction from:(last To) SSW stop:(= (mover) (who at:(to))) stopIncluded:True) (sites Occupied by:Next)))) (= (next) (who at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) SSW stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) SSW))) (is Even (count Sites in:(sites Direction from:(last To) SSW stop:(= (mover) (who at:(to))) stopIncluded:True))) (= (mover) (who at:(last To))) (= (size Stack at:(last To)) (size Stack at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) SSW stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) SSW))) (= (size Stack at:(ahead (last To) steps:(count Sites in:(sites Direction from:(last To) SSW stop:(= (mover) (who at:(to))) stopIncluded:True)) SSW)) (size Stack at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) SSW stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) SSW)))}) (remember Value (ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) SSW stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) SSW))) (if (and {(= 1 (count Sites in:(intersection (sites Direction from:(last To) SSE stop:(= (mover) (who at:(to))) stopIncluded:True) (sites Occupied by:Mover)))) (= 1 (count Sites in:(intersection (sites Direction from:(last To) SSE stop:(= (mover) (who at:(to))) stopIncluded:True) (sites Occupied by:Next)))) (= (next) (who at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) SSE stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) SSE))) (is Even (count Sites in:(sites Direction from:(last To) SSE stop:(= (mover) (who at:(to))) stopIncluded:True))) (= (mover) (who at:(last To))) (= (size Stack at:(last To)) (size Stack at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) SSE stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) SSE))) (= (size Stack at:(ahead (last To) steps:(count Sites in:(sites Direction from:(last To) SSE stop:(= (mover) (who at:(to))) stopIncluded:True)) SSE)) (size Stack at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) SSE stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) SSE)))}) (remember Value (ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) SSE stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) SSE))) (if (and {(= 1 (count Sites in:(intersection (sites Direction from:(last To) E stop:(= (mover) (who at:(to))) stopIncluded:True) (sites Occupied by:Mover)))) (= 1 (count Sites in:(intersection (sites Direction from:(last To) E stop:(= (mover) (who at:(to))) stopIncluded:True) (sites Occupied by:Next)))) (= (next) (who at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) E stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) E))) (is Even (count Sites in:(sites Direction from:(last To) E stop:(= (mover) (who at:(to))) stopIncluded:True))) (= (mover) (who at:(last To))) (= (size Stack at:(last To)) (size Stack at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) E stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) E))) (= (size Stack at:(ahead (last To) steps:(count Sites in:(sites Direction from:(last To) E stop:(= (mover) (who at:(to))) stopIncluded:True)) E)) (size Stack at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) E stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) E)))}) (remember Value (ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) E stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) E))) (if (and {(= 1 (count Sites in:(intersection (sites Direction from:(last To) NNE stop:(= (mover) (who at:(to))) stopIncluded:True) (sites Occupied by:Mover)))) (= 1 (count Sites in:(intersection (sites Direction from:(last To) NNE stop:(= (mover) (who at:(to))) stopIncluded:True) (sites Occupied by:Next)))) (= (next) (who at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) NNE stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) NNE))) (is Even (count Sites in:(sites Direction from:(last To) NNE stop:(= (mover) (who at:(to))) stopIncluded:True))) (= (mover) (who at:(last To))) (= (size Stack at:(last To)) (size Stack at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) NNE stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) NNE))) (= (size Stack at:(ahead (last To) steps:(count Sites in:(sites Direction from:(last To) NNE stop:(= (mover) (who at:(to))) stopIncluded:True)) NNE)) (size Stack at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) NNE stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) NNE)))}) (remember Value (ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) NNE stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) NNE)))}) (then (if (or {(and {(= 1 (count Sites in:(intersection (sites Direction from:(last To) NNW stop:(= (mover) (who at:(to))) stopIncluded:True) (sites Occupied by:Mover)))) (= 1 (count Sites in:(intersection (sites Direction from:(last To) NNW stop:(= (mover) (who at:(to))) stopIncluded:True) (sites Occupied by:Next)))) (= (next) (who at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) NNW stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) NNW))) (is Even (count Sites in:(sites Direction from:(last To) NNW stop:(= (mover) (who at:(to))) stopIncluded:True))) (= (mover) (who at:(last To))) (= (size Stack at:(last To)) (size Stack at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) NNW stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) NNW))) (= (size Stack at:(ahead (last To) steps:(count Sites in:(sites Direction from:(last To) NNW stop:(= (mover) (who at:(to))) stopIncluded:True)) NNW)) (size Stack at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) NNW stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) NNW)))}) (and {(= 1 (count Sites in:(intersection (sites Direction from:(last To) W stop:(= (mover) (who at:(to))) stopIncluded:True) (sites Occupied by:Mover)))) (= 1 (count Sites in:(intersection (sites Direction from:(last To) W stop:(= (mover) (who at:(to))) stopIncluded:True) (sites Occupied by:Next)))) (= (next) (who at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) W stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) W))) (is Even (count Sites in:(sites Direction from:(last To) W stop:(= (mover) (who at:(to))) stopIncluded:True))) (= (mover) (who at:(last To))) (= (size Stack at:(last To)) (size Stack at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) W stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) W))) (= (size Stack at:(ahead (last To) steps:(count Sites in:(sites Direction from:(last To) W stop:(= (mover) (who at:(to))) stopIncluded:True)) W)) (size Stack at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) W stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) W)))}) (and {(= 1 (count Sites in:(intersection (sites Direction from:(last To) SSW stop:(= (mover) (who at:(to))) stopIncluded:True) (sites Occupied by:Mover)))) (= 1 (count Sites in:(intersection (sites Direction from:(last To) SSW stop:(= (mover) (who at:(to))) stopIncluded:True) (sites Occupied by:Next)))) (= (next) (who at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) SSW stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) SSW))) (is Even (count Sites in:(sites Direction from:(last To) SSW stop:(= (mover) (who at:(to))) stopIncluded:True))) (= (mover) (who at:(last To))) (= (size Stack at:(last To)) (size Stack at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) SSW stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) SSW))) (= (size Stack at:(ahead (last To) steps:(count Sites in:(sites Direction from:(last To) SSW stop:(= (mover) (who at:(to))) stopIncluded:True)) SSW)) (size Stack at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) SSW stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) SSW)))}) (and {(= 1 (count Sites in:(intersection (sites Direction from:(last To) SSE stop:(= (mover) (who at:(to))) stopIncluded:True) (sites Occupied by:Mover)))) (= 1 (count Sites in:(intersection (sites Direction from:(last To) SSE stop:(= (mover) (who at:(to))) stopIncluded:True) (sites Occupied by:Next)))) (= (next) (who at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) SSE stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) SSE))) (is Even (count Sites in:(sites Direction from:(last To) SSE stop:(= (mover) (who at:(to))) stopIncluded:True))) (= (mover) (who at:(last To))) (= (size Stack at:(last To)) (size Stack at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) SSE stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) SSE))) (= (size Stack at:(ahead (last To) steps:(count Sites in:(sites Direction from:(last To) SSE stop:(= (mover) (who at:(to))) stopIncluded:True)) SSE)) (size Stack at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) SSE stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) SSE)))}) (and {(= 1 (count Sites in:(intersection (sites Direction from:(last To) E stop:(= (mover) (who at:(to))) stopIncluded:True) (sites Occupied by:Mover)))) (= 1 (count Sites in:(intersection (sites Direction from:(last To) E stop:(= (mover) (who at:(to))) stopIncluded:True) (sites Occupied by:Next)))) (= (next) (who at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) E stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) E))) (is Even (count Sites in:(sites Direction from:(last To) E stop:(= (mover) (who at:(to))) stopIncluded:True))) (= (mover) (who at:(last To))) (= (size Stack at:(last To)) (size Stack at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) E stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) E))) (= (size Stack at:(ahead (last To) steps:(count Sites in:(sites Direction from:(last To) E stop:(= (mover) (who at:(to))) stopIncluded:True)) E)) (size Stack at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) E stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) E)))}) (and {(= 1 (count Sites in:(intersection (sites Direction from:(last To) NNE stop:(= (mover) (who at:(to))) stopIncluded:True) (sites Occupied by:Mover)))) (= 1 (count Sites in:(intersection (sites Direction from:(last To) NNE stop:(= (mover) (who at:(to))) stopIncluded:True) (sites Occupied by:Next)))) (= (next) (who at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) NNE stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) NNE))) (is Even (count Sites in:(sites Direction from:(last To) NNE stop:(= (mover) (who at:(to))) stopIncluded:True))) (= (mover) (who at:(last To))) (= (size Stack at:(last To)) (size Stack at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) NNE stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) NNE))) (= (size Stack at:(ahead (last To) steps:(count Sites in:(sites Direction from:(last To) NNE stop:(= (mover) (who at:(to))) stopIncluded:True)) NNE)) (size Stack at:(ahead (last To) steps:(/ (count Sites in:(sites Direction from:(last To) NNE stop:(= (mover) (who at:(to))) stopIncluded:True)) 2) NNE)))})}) (and (set Var 1) (moveAgain)))))))) (end (if (no Moves Next) (result Next Loss))))) 
TURN - On each turn, each player drops a neutral stone on an empty cell provided that it does not share the same row, column or diagonal with all the stones already on board. GOAL - Wins the last player to move
(game "First Attack" (players 2) (equipment {(board (square 8)) (piece "Ball" Shared)}) (rules (play (move Add (piece "Ball") (to (sites Empty) if:(all Sites (sites Direction from:(to) Adjacent) if:(is Empty (site)))))) (end (if (no Moves Next) (result Mover Win))))) 
MOVEMENT - A stone must move as far as it can (no jumps) in a forward direction (orthogonal or diagonal). - At the first move, a player may choose any of his stones to move. - After that, a player must move a stone that is adjacent to the last moved enemy stone. If that is not possible, the player may choose any unblocked of his stones to move. - There is no capturing. GOAL - Wins the player that moved the last stone.
(game "Forge" (players {(player N) (player S)}) (equipment {(board (rectangle 8 6) use:Vertex) (piece "Ball" Each (move Slide (directions Forwards of:All)))}) (rules (start {(place "Ball1" (expand (sites Bottom))) (place "Ball2" (expand (sites Top)))}) phases:{(phase "Opening" (play (forEach Piece)) (nextPhase "Main")) (phase "Main" (play (priority {(forEach Piece (move Slide (from (from) if:(is In (from) (sites Around (last To) All))) (directions Forwards of:All))) (forEach Piece)})))} (end (if (no Moves Next) (result Mover Win))))) 
One player has three dwarfs and the other has one giant. Firstly, the giant is placed on one of the top sites. After this first move of the giant, it is the dwarfs' move. Each piece can move between the different sites only if they are connected by an edge. The dwarfs can move only forwards or sideways, the giant can move in all the directions. The goal of the dwarfs is to block the giant on the top site. The giant has to break through the line of dwarfs to get 2 points and win. In case of a repetition of moves, the giant is winning with one point. 
(game "Game of Dwarfs" (players {(player S) (player N)}) (equipment {(board (add (remove (rotate 90 (merge {(rectangle 3 3 diagonals:Alternating) (shift 1.5 0.5 (rotate -90 (wedge 2))) (shift -1.5 0.5 (rotate 90 (wedge 2)))})) vertices:{3 7 1}) edges:{{0 1} {4 5} {2 7} {0 4}}) use:Vertex) (piece "Foot" P1 (move Step Adjacent (to if:(and (if (= 1 (count Turns)) (!= (centrePoint) (to)) True) (is Empty (to)))))) (piece "Gnome" P2 (move Step (directions {Forwards Rightward Leftward}) (to if:(is Empty (to))))) (hand P1) (regions "Home" P2 (intersection (sites Outer) (expand (sites Bottom)))) (regions "Home" P1 (sites Top))}) (rules (start {(place "Gnome2" (intersection (sites Outer) (expand (sites Bottom)))) (place "Foot1" (handSite P1))}) phases:{(phase "Opening" P1 (play (move (from (handSite Mover)) (to (expand (sites Top))))) (nextPhase P1 "MainP1")) (phase "MainP1" P1 (play (forEach Piece (then (if (is In (where "Foot" P1) (sites P2)) (set Score P1 2) (if (is Cycle) (set Score P1 1))))))) (phase "MainP2" P2 (play (forEach Piece (then (if (no Moves Next) (set Score P2 1) (if (is Cycle) (set Score P1 1)))))))} (end (forEach Player if:(!= 0 (score Player)) (result Player Win))))) 
The first player begins the game by placing a stone anywhere on the board. Then, starting with the second player, players take turns placing a stone orthogonally adjacent to exactly one enemy stone and no friendly stones.
(game "Gopher" (players 2) (equipment {(board (hex 6)) (piece "Disc" Each)}) (rules (play (if (= 0 (count Moves)) (move Add (to (sites Empty))) (move Add (to (sites Empty) if:(and (= 0 (count Sites in:(sites Around (to) Own))) (= 1 (count Sites in:(sites Around (to) Enemy)))))))) (end (if (no Moves Next) (result Next Loss))))) 
Three vertical lines, and two horizontal lines intersecting them along their top end points and their midpoints. The ends of the lines which are not connected to one another are the calves' pens. Three pieces per player, one playing as calves (black), and the other as guardians (white), arranged on the intersections of opposite vertical lines. Players alternate turns moving one of their pieces to an adjacent spot. The guardians attempt to trap the calves into the three pens, the calves attempt to block the guardians from being able to move.
(game "Gurvan Xudag" (players 2) (equipment {(board (remove (square 3) edges:{{0 1} {1 2}}) use:Vertex) (piece "Human" P1 (move Step (to if:(is Empty (to))))) (piece "Cow" P2 (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Human1" (sites Left)) (place "Cow2" (sites Right))}) (play (forEach Piece)) (end {(if (no Moves P1) (result P2 Win)) (if (and (all Sites (difference (sites Occupied by:P2) (sites Bottom)) if:(= 0 (count at:(site)))) (no Moves P2)) (result P1 Win))}))) 
Movement is the same as regular amazons. You can move or shoot as many spaces as you want in any orthogonal or diagonal direction. With a hex board you have 6 orthogonal lines of movement (green) as well as 6 diagonal lines of movement (blue). Like in the original, Amazons still cannot move or shoot through other arrows or other amazons. However the diagonals are a little bit more tricky than the original. If the two orthogonal spaces next to the diagonal line are blocked, than the amazon can no longer use (or continue along) this diagonal. This is important because it reduces the movement capabilities of the amazons and allows a wall of connected arrows to become impenetrable. One final rule, in order to balance the game (white has first move advantage). On whites first turn he/she can only move an amazon but not shoot an arrow afterwards. This prevents potential too strong opening moves. The first player to block the opponent wins.
(game "Hex Amazons" (players 2) (equipment {(board (hex 7)) (piece "Queen" Each (or (move Slide) (move Slide Diagonal (between if:(is Empty (between))) (to if:(and (is Empty (to)) (= 2 (count Sites in:(forEach (intersection (sites Incident Cell of:Cell at:(if (!= (between) -1) (between) (from))) (sites Incident Cell of:Cell at:(to))) if:(is Occupied (site)))))) (apply if:(or (= (between) (to)) (!= 2 (count Sites in:(forEach (intersection (sites Incident Cell of:Cell at:(if (!= (between) -1) (between) (from))) (sites Incident Cell of:Cell at:(to))) if:(is Occupied (site))))))))) (then (moveAgain)))) (piece "Dot" Neutral)}) (rules (start {(place "Queen1" {"B2" "G2" "E5" "B7"}) (place "Queen2" {"L12" "G12" "L7" "I9"})}) phases:{(phase "Opening" P1 (play (forEach Piece (or (move Slide) (move Slide Diagonal (between if:(is Empty (between))) (to if:(and (is Empty (to)) (= 2 (count Sites in:(forEach (intersection (sites Incident Cell of:Cell at:(if (!= (between) -1) (between) (from))) (sites Incident Cell of:Cell at:(to))) if:(is Occupied (site)))))) (apply if:(or (= (between) (to)) (!= 2 (count Sites in:(forEach (intersection (sites Incident Cell of:Cell at:(if (!= (between) -1) (between) (from))) (sites Incident Cell of:Cell at:(to))) if:(is Occupied (site)))))))))))) (nextPhase Mover "Playing")) (phase "Playing" (play (if (is Prev Mover) (or (move Shoot (piece "Dot0")) (move Shoot (piece "Dot0") Diagonal (between if:(is Empty (between))) (to if:(and (is Empty (to)) (!= 2 (count Sites in:(forEach (intersection (sites Incident Cell of:Cell at:(if (!= (between) -1) (between) (from))) (sites Incident Cell of:Cell at:(to))) if:(is Occupied (site))))))))) (forEach Piece))))} (end (if (no Moves Next) (result Mover Win))))) 
Each player has three pieces. Players take turns moving a piece to an empty dot. Players cannot return to their starting three dots. Pieces that move into the opponent’s starting three dots cannot exit them. A player wins by blocking the other player from being able to move.
(game "Ho-Bag Gonu" (players 2) (equipment {(board (add (merge {(rectangle 1 3) (shift 1 1 (scale 0.5 (concentric {1 4}))) (shift 0 2 (rectangle 1 3))}) edges:{{5 1} {9 7}}) use:Vertex) (piece "Disc" Each (move Step (to if:(or (and {(is In (from) (sites Next)) (is In (to) (sites Next)) (is Empty (to))}) (and (not (is In (from) (sites Next))) (if (not (is In (from) (sites Mover))) (is In (to) (difference (sites Empty) (sites Mover))) (is Empty (to)))))))) (regions "Home" P1 (sites {"A1" "C1" "E1"})) (regions "Home" P2 (sites {"A5" "C5" "E5"}))}) (rules (start {(place "Disc1" (sites P1)) (place "Disc2" (sites P2))}) (play (forEach Piece)) (end (if (no Moves Next) (result Next Loss))))) 
Each player has a pawn, that can move to any neighboring cell. After moving, the player places a block on the board to try to block the opponent's pawn. First player who cannot move loses. The game is played on a 7x7 board.
(game "Isolation" (players 2) (equipment {(board (rectangle 7 7)) (piece "Pawn" Each (move Step (to if:(is Empty (to))) (then (moveAgain)))) (piece "Square" Neutral)}) (rules (start {(place "Pawn1" {"A4"}) (place "Pawn2" {"G4"})}) (play (if (is Even (count Moves)) (forEach Piece) (move Add (piece "Square0") (to (sites Empty))))) (end (if (no Moves Next) (result Mover Win))))) 
3x3 intersecting lines, with triangles extending on opposite ends of the large square and the central line extending to the apices. One player plays as three notched sticks, called hares, and the other as three sharp sticks, known as the hounds. Players alternate turns placing a piece on the board. When the players have placed all of their pieces on the board, they move one of their pieces to an empty adjacent spot along the lines. The first player to block their opponent from being able to move wins.
(game "Janes Soppi (Symmetrical)" (players 2) (equipment {(board (remove (merge {(rectangle 3 3 diagonals:Alternating) (shift 1.5 0.5 (rotate -90 (wedge 2))) (shift -1.5 0.5 (rotate 90 (wedge 2)))}) edges:{{6 4} {4 2} {0 4} {4 8}}) use:Vertex) (hand Each) (piece "Hound" P1 (move Step (to if:(is Empty (to))))) (piece "Hare" P2 (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Hound1" (handSite P1) count:3) (place "Hare2" (handSite P2) count:3)}) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end (if (no Moves Next) (result Mover Win))))) 
OBJECT OF THE GAME The last player to make a move wins. FRIENDLY AND ENEMY CONNECTIONS A connection, i.e. an orthogonal adjacency between two checkers, is friendly if the two checkers are the same color and enemy if the two checkers are oppositely colored. CHECKER VALUE A checker’s value is its number of friendly connections minus its number of enemy connections. MOVES A checker’s value must increase when it‘s moved. Move a checker to an unoccupied, orthogonally adjacent square. There is no capturing in Jostle, only jostling. The game is played on a 10x10 square board.
(game "Jostle" (players 2) (equipment {(board (square 10)) (piece "Marker" Each (move Step Orthogonal (to if:(and (is Empty (to)) (< (+ (results from:(sites {(from)}) to:(sites Around (from) Orthogonal) (if (= (from) (to)) 0 (if (is Friend (who at:(to))) 1 (if (is Enemy (who at:(to))) -1 0))))) (+ (results from:(sites {(from)}) to:(sites Around (to) Orthogonal) (if (= (from) (to)) 0 (if (is Friend (who at:(to))) 1 (if (is Enemy (who at:(to))) -1 0))))))))))}) (rules (start {(place "Marker1" (sites {23 25 27 32 34 36 43 47 52 63 72 74 76 65 67 56})) (place "Marker2" (sites {22 24 26 33 35 37 42 46 53 57 62 64 66 73 75 77}))}) (play (forEach Piece)) (end (if (no Moves Next) (result Mover Win))))) 
Played on a board of 4x4 squares. Each player controls a 3x2 L-shaped piece, and there are two 1x1 pieces which either player can manipulate. On a turn, a player moves the L piece to a new available position, and then has the option to move one of the 1x1 pieces. When a player cannot move their L piece, they lose.
(game "L Game" (players 2) (equipment {(board (square 4)) (piece "Dot" Neutral) (tile "L" Each {{L F R F F} {R F L F F}})}) (rules (start {(place "Dot0" {"A4" "D1"}) (place "L1" coord:"C1" state:0) (place "L2" coord:"B4" state:2)}) (play (if (is Prev Mover) (or (move Pass) (move (from (sites Occupied by:Neutral)) (to (sites Empty)))) (move (from (sites Occupied by:Mover)) (to (union (sites Empty) (sites Occupied by:Mover))) (then (moveAgain))))) (end (if (and (not (is Mover (next))) (no Moves Next)) (result Mover Win))))) 
TURNS - At each turn, each player slides (vertically or horizontally) a stone into the only empty cell. GOAL - Wins the player who made the last move.
(game "Lewthwaite's Game" (players 2) (equipment {(board (square 5) use:Vertex) (piece "Ball" Each (move Slide))}) (rules (start {(place "Ball1" (sites Phase 1)) (place "Ball2" (difference (sites Phase 0) (sites Centre)))}) (play (forEach Piece)) (end (if (no Moves Next) (result Mover Win))))) 
Players move their pieces to an adjacent empty point. The goal is to block the other player from being able to move.
(game "Madelinette" (players 2) (equipment {(board (add (remove (rectangle 3 3 diagonals:Alternating) vertices:{7 1}) edges:{{0 1}}) use:Vertex) (piece "Counter" Each (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Counter1" (sites {"A1" "C2" "A3"})) (place "Counter2" (sites {"C1" "A2" "C3"}))}) (play (forEach Piece)) (end (if (no Moves Next) (result Next Loss))))) 
Play begins with the pieces on the kewai, each player on half of the circle. Players move by moving one piece to an empty adjacent space. Players can only move to the putahi when the piece being moved is next to an opponent's piece. The player that blocks the other from moving is the winner. The game is played on a wheel board. The game is played with all the rules
(game "Mu Torere" (players 2) (equipment {(board (concentric {1 8}) use:Vertex) (piece "Marker" Each (move Step (to if:(and (is Empty (to)) (or (not (= (to) (centrePoint))) (is Related Adjacent (from) (sites Occupied by:Next)))))))}) (rules (start {(place "Marker1" {1 2 3 8}) (place "Marker2" {4 5 6 7})}) (play (forEach Piece)) (end (if (no Moves Next) (result Next Loss))))) 
Black plays first, then turns alternate. On his turn, a player must place a stone of his color on an empty point of the board. At the end of a turn, all groups on the board (both friendly and enemy) must have at least one liberty. Otherwise the player's move is illegal. Whoever can't make a move on his turn loses. The game is played on 9x9 board.
(game "NoGo" (players 2) (equipment {(board (square 9) use:Vertex) (piece "Marker" Each)}) (rules (play (do (move Add (to (sites Empty))) ifAfterwards:(and (> (count Liberties Orthogonal) 0) (not (can Move (enclose (from (last To)) Orthogonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))))))))) (end (if (no Moves Next) (result Next Loss))))) 
The board is a square, with the diagonals drawn. A circle is drawn around the midpoint of the top side of the square. Two pieces per player, the pieces for one player on the top corners and the other on the remaining corners. Players alternate turns moving along the lines on the board, the player on the top corners moving first, but can never move along the line with the circle. The player who blocks their opponent from being able to move wins.
(game "Oumoul Kono" (players 2) (equipment {(board (square 2 diagonals:Solid) use:Vertex) (piece "Disc" Each (move Step (to if:(and {(or {(and (!= (from) (coord "A3")) (!= (from) (coord "C3"))) (and (= (from) (coord "C3")) (!= (to) (coord "A3"))) (and (= (from) (coord "A3")) (!= (to) (coord "C3")))}) (is Empty (to))}))))}) (rules (start {(place "Disc1" (sites Bottom)) (place "Disc2" (sites Top))}) (play (forEach Piece)) (end (if (no Moves Next) (result Next Loss))))) 
Overflow is played on a checkered board initially filled with neutral stackable pieces, one per square. The dark squares make up the house of the Dark player, and the light squares make up the house of the Light player. The goal is to empty your opponent's house. There are two types of moves in Overflow, both of which are sowing moves, somewhat akin to what you see in mancalas. All moves are bound by the restriction that there must always be exactly one orthodiagonally connected group of stacks on the board. The one kind of sowing only drops pieces onto already occupied squares and the other kind spills out of both the group of already occupied squares and out of the board itself, hence the names: contained moves and overflow moves. Sowing in general: Sowing in general is picking up a stack from any square and distributing its pieces along one of the 8 directions onto a contiguous line of squares – usually placing one of the N pieces from the chosen stack in each of the N or so squares in the sowing direction. The details are given below. Overflow moves: An overflow move involves sowing into empty squares – possibly in addition to occupied squares – and over the edge of the board. It's important to remember that these two things always go together in this game, namely (1) sowing over the edge and (2) sowing into empty squares. That is to say, if you are to sow into one or more empty squares, the number of squares in the chosen sowing direction must be smaller than the number of stones in the chosen stack. The pieces that end up outside the board are removed from the game. Contained moves: Contained moves only sow onto already occupied squares. A contained move must sow the chosen stack as far as possible. If it's impossible to sow each of the pieces in the stack into an occupied square of its own, you place the remainder of the pieces on the last occupied square you reached. You are not obligated to chose the stack that can be sown the farthest, but whatever stack you chose, if you do not make an overflow move move with it, you must chose a sowing direction that allows you to sow onto as many occupied squares as possible. You may always chose freely between contained moves and overflow moves when both kinds are available. Note that no stack will have both a contained move and an overflow move available in the same direction. All moves are completely determined by the choice of stack and direction. A 6x6 board is currently selected
(game "Overflow" (players 2) (equipment {(board (square 6)) (piece "Disc" P1)}) (rules (start {(place "Disc1" (sites Board)) (set Score P1 (count Sites in:(sites Phase 1))) (set Score P2 (count Sites in:(sites Phase 0)))}) (play (do (or (move Select (from (sites Occupied by:P1)) (to (sites Around (from) NotEmpty) if:(and (or (<= (size Stack at:(from)) (count Sites in:(sites Direction from:(from) (directions Cell from:(from) to:(to)) distance:(size Stack at:(from))))) (= 0 (count Sites in:(intersection (sites Empty) (sites Direction from:(from) (directions Cell from:(from) to:(to)) distance:(size Stack at:(from))))))) (all Sites (sites Around (from) NotEmpty) if:(not (and (< (count Sites in:(sites Direction from:(from) (directions Cell from:(from) to:(to)) stop:(is Empty (to)) distance:(size Stack at:(from)))) (count Sites in:(sites Direction from:(from) (directions Cell from:(from) to:(site)) stop:(is Empty (to)) distance:(size Stack at:(from))))) (or (<= (size Stack at:(from)) (count Sites in:(sites Direction from:(from) (directions Cell from:(from) to:(site)) distance:(size Stack at:(from))))) (= 0 (count Sites in:(intersection (sites Empty) (sites Direction from:(from) (directions Cell from:(from) to:(site)) distance:(size Stack at:(from)))))))))))) (then (forEach Site (sites Direction from:(last From) (directions Cell from:(last From) to:(last To)) stop:(is Empty (to)) distance:(size Stack at:(last From))) (if (= (count Sites in:(sites Direction from:(last From) (directions Cell from:(last From) to:(last To)) stop:(is Empty (to)) distance:(size Stack at:(last From)))) (count Steps (last From) (site))) (add (piece "Disc1") (to (site)) count:(- (size Stack at:(last From)) (- (count Sites in:(sites Direction from:(last From) (directions Cell from:(last From) to:(last To)) stop:(is Empty (to)) distance:(size Stack at:(last From)))) 1)) stack:True) (add (piece "Disc1") (to (site)) stack:True))))) (move Select (from (sites Occupied by:P1)) (to (sites Around (from)) if:(and (not (<= (size Stack at:(from)) (count Sites in:(sites Direction from:(from) (directions Cell from:(from) to:(to)) distance:(size Stack at:(from)))))) (not (= 0 (count Sites in:(intersection (sites Empty) (sites Direction from:(from) (directions Cell from:(from) to:(to)) distance:(size Stack at:(from))))))))) (then (forEach Site (sites Direction from:(last From) (directions Cell from:(last From) to:(last To)) distance:(size Stack at:(last From))) (add (piece "Disc1") (to (site)) stack:True)))) (then (remove (last From) count:(size Stack at:(last From))))) ifAfterwards:(= 1 (count Groups)) (then (and (set Score P1 (count Sites in:(forEach (sites Phase 1) if:(is Occupied (site))))) (set Score P2 (count Sites in:(forEach (sites Phase 0) if:(is Occupied (site))))))))) (end (if (= 0 (* (score P1) (score P2))) (byScore))))) 
Players take turns placing one of their stones on an empty square. It is not legal to place orthogonally adjacent to only enemy stones and it is not legal to place orthogonally adjacent to more than 1 friendly stone. All other placements onto empty squares are legal. Put differently: You may place adjacent to no stone or to exactly 1 friendly and any number of enemy stones. The first player unable to place a stone has won the game. A 6x6 board is currently selected
(game "Pathway" (players 2) (equipment {(board (square 6)) (piece "Disc" Each)}) (rules (play (move Add (to (sites Empty) if:(or (all Sites (sites Around (to) Orthogonal) if:(is Empty (site))) (= 1 (count Sites in:(sites Around (to) Own Orthogonal))))))) (end (if (no Moves Next) (result Next Win))))) 
Two players have a collection of dominoes which they place on the grid in turn, covering up squares. One player places tiles vertically, while the other places them horizontally. The first player who cannot move loses. The game is played by 2 players The board has 6 rows. The board has 10 columns. The Last player to play wins.
(game "Pentomino" (players 2) (equipment {(board (rectangle 6 10)) (tile "Z" Shared {F R F F L F}) (tile "Y" Shared {F R F R R F R F F}) (tile "X" Shared {F L F L L F F L L F R F}) (tile "W" Shared {F L F R F L F}) (tile "V" Shared {F F R F F}) (tile "U" Shared {F L F F L F}) (tile "T" Shared {F F R F R R F F}) (tile "P" Shared {F F R F R F}) (tile "N" Shared {F R F L F F}) (tile "L" Shared {F R F F F}) (tile "I" Shared {F F F F}) (tile "F" Shared {F L F L L F L F R F}) (hand Shared size:12)}) (rules (start {(place "F" (handSite Shared 0)) (place "I" (handSite Shared 1)) (place "L" (handSite Shared 2)) (place "N" (handSite Shared 3)) (place "P" (handSite Shared 4)) (place "T" (handSite Shared 5)) (place "U" (handSite Shared 6)) (place "V" (handSite Shared 7)) (place "W" (handSite Shared 8)) (place "X" (handSite Shared 9)) (place "Y" (handSite Shared 10)) (place "Z" (handSite Shared 11))}) (play (move (from (sites Hand Shared)) (to (sites Empty)))) (end (if (no Moves Next) (result Next Loss))))) 
Pieces begin on opposite sides of the square. Players take turns moving the piece to an empty spot either orthogonally or diagonally, but one orthogonal direction is forbidden. The player who blocks the other player from being able to move wins. The piece are already placed on the board.
(game "Pong Hau K'i" (players 2) (equipment {(board (add (remove (rectangle 3 3 diagonals:Alternating) vertices:{1 3 5 7}) edges:{{3 0} {0 1} {1 4}}) use:Vertex) (hand Each) (piece "Disc" Each (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Disc1" {"A3" "C3"}) (place "Disc2" {"A1" "C1"})}) (play (forEach Piece)) (end (if (no Moves Next) (result Next Loss))))) 
Play begins with the supply of pieces (30 of each colour) randomly distributed on the board, so each cell contains only one stone and there is one free space left. This free space can be anywhere except the centre space. Each player has an allocated colour. Before the game starts, Black can swap the positions of any two stones on the board. White then starts the game. Players alternate turns during the game until one of them cannot make a valid move, thereby losing the game. On a turn, a player must make one capture. A player makes a capture by leaping in a straight line in any of the 6 directions exactly as many spaces as friendly pieces surround its original position, and landing on an enemy piece, which is removed from the game. The player who cannot make a capture loses.
(game "Quantum Leap" (players 2) (equipment {(board (hex 5)) (piece "Marker" Each (move Hop Orthogonal (between (exact (- (count Sites in:(sites Around (from) Orthogonal if:(is Friend (who at:(to))))) 1)) if:True) (to if:(is Enemy (who at:(to))) (apply (remove (to))))))}) (rules (start {(place "Marker2" (centrePoint)) (place Random {"Marker2"} count:29) (place Random {"Marker1"} count:30)}) phases:{(phase "Swap" (play (or (move Pass) (move Select (from (sites Occupied by:Mover)) (to (sites Occupied by:Next)) (then (swap Pieces (last From) (last To)))))) (nextPhase "Play")) (phase "Play" (play (forEach Piece)))} (end (if (no Moves Next) (result Next Loss))))) 
First, the giant takes place on one of the top sites. Centre site in the opening move for the giant is not allowed. In any subsequent moves, the giant is allowed to enter the centre. The Giant piece can step to an empty site, the dwarves can step only forward to the top of the board. The giant wins if it reaches the bottom sites and the dwarves win if they block the giant to move. The rules of the game I.
(game "Ratio" (players {(player S) (player N)}) (equipment {(board (add (remove (merge {(rectangle 3 3 diagonals:Alternating) (shift 0 2 (wedge 2)) (shift 0 -1 (rotate 180 (wedge 2)))}) vertices:{3 5 1}) edges:{{0 3} {1 5} {2 7} {0 1}}) use:Vertex) (piece "Foot" P1 (move Step Adjacent (to if:(and (if (= 1 (count Turns)) (!= (centrePoint) (to)) True) (is Empty (to)))))) (piece "Gnome" P2 (move Step (directions {Forwards Rightward Leftward}) (to if:(is Empty (to))))) (hand P1) (regions "Home" P2 (intersection (sites Outer) (expand (sites Bottom)))) (regions "Home" P1 (sites Top))}) (rules (start {(place "Gnome2" (intersection (sites Outer) (expand (sites Bottom)))) (place "Foot1" (handSite P1))}) phases:{(phase "Opening" (play (move (from (handSite Mover)) (to (expand (sites Top))) (then (moveAgain)))) (nextPhase "Main")) (phase "Main" (play (forEach Piece)))} (end {(if (no Moves P1) (result P2 Win)) (if (is In (where "Foot" P1) (sites P2)) (result P1 Win))}))) 
Each player has a pawn, that can move to any neighboring cell. After moving, the player places a block to the cell he came from. First player who cannot move loses. The game is played on a 7x7 board.
(game "Snailtrail" (players 2) (equipment {(board (rectangle 7 7)) (piece "Pawn" Each (move Step (to if:(is Empty (to))) (then (moveAgain)))) (piece "Square" Neutral)}) (rules (start {(place "Pawn1" {"A1"}) (place "Pawn2" {"G7"})}) (play (if (is Even (count Moves)) (forEach Piece) (move Add (piece "Square0") (to (last From))))) (end (if (no Moves Next) (result Mover Win))))) 
Two players, black and white, take turns dropping pieces onto empty squares (that are not orthogonally adjacent to another enemy's piece) until no more moves are available. The last player to make a move wins the game.
(game "Snort" (players 2) (equipment {(board (square 8)) (piece "Cat" P1) (piece "Dog" P2)}) (rules (play (move Add (to (difference (sites Empty) (sites Around (sites Occupied by:Next) Orthogonal))))) (end (if (no Moves Next) (result P1 Win))))) 
Player 1 marks a cell. Then Players take turns marking any unmarked cell with exactly one marked neighbour. Player who can't move loses.
(game "Snowpaque" (players 2) (equipment {(board (hex 5)) (piece "Marker" Neutral)}) (rules phases:{(phase "start" P1 (play (move Add (piece (id "Marker0")) (to (sites Empty)))) (nextPhase "play")) (phase "play" (play (move Add (piece "Marker0") (to (sites Empty) if:(= (count Sites in:(sites Around (to) Orthogonal if:(is In (to) (sites Occupied by:Neutral)))) 1)))))} (end (if (no Moves Next) (result Next Loss))))) 
Players take turns marking any unmarked cell with no marked neighbour. Player who can’t move loses.
(game "Spots" (players 2) (equipment {(board (hex 5)) (piece "Marker" Neutral)}) (rules (play (move Add (piece "Marker0") (to (sites Empty) if:(= (count Sites in:(sites Around (to) Orthogonal if:(is In (to) (sites Occupied by:Neutral)))) 0)))) (end (if (no Moves Next) (result Next Loss))))) 
Players alternate turns. A player's turn consists on either placing piece on an empty field on board, or sliding one of their pieces into an empty one on the board. Players cannot pass. If each player performs three slides in a row then the game ends immediately as a draw. A player wins when any of the opponent's pieces are surrounded and cannot move. If one of a player's own pieces is surrounded on their turn, they lose even if an opponent's stone is surrounded at the same time.
(game "Susan" (players 2) (equipment {(board (hex 5)) (piece "Marker" Each (move Step Orthogonal (to if:(is Empty (to)))))}) (rules (play (or (move Add (to (sites Empty)) (then (set Counter))) (forEach Piece) (then (priority (surround (from (last To)) Orthogonal (between if:(is Friend (who at:(between))) (apply (trigger "Surrounded" (mover)))) (to if:(is Occupied (to)))) (surround (from (last To)) Orthogonal (between if:(is Enemy (who at:(between))) (apply (trigger "Surrounded" (next)))) (to if:(is Occupied (to)))))))) (end {(if (= (counter) 5) (result Mover Draw)) (if (= (count Sites in:(sites Around (last To) if:(is Empty (to)))) 0) (result Next Win)) (if (is Triggered "Surrounded" P1) (result P2 Win)) (if (is Triggered "Surrounded" P2) (result P1 Win))}))) 
Square grid of 36, 64, 100, or 144 squares. Each player has one piece lined up in each square on opposite sides of the square. Players may move their piece forward or backwards orthogonally. The player who blocks the opponent from being able to move wins. The board is 6x6.
(game "T'uk T'uk" (players 2) (equipment {(board (square 6)) (piece "Marker" Each (move Step Orthogonal (to if:(is Empty (to)))))}) (rules (start {(place "Marker1" (sites Bottom)) (place "Marker2" (sites Top))}) (play (forEach Piece)) (end (if (no Moves Next) (result Mover Win))))) 
A player may remove one or more adjacent pieces from a row or column. The loser is the person who takes the last piece off the board.
(game "TacTix" (players 2) (equipment {(board (square 4)) (piece "Ball" Shared)}) (rules (start (place "Ball" (sites Board))) (play (if (is Prev Mover) (or (if (= 1 (count MovesThisTurn)) (move Select (from (last To)) (to (intersection (sites Around (last To) Orthogonal) (sites Occupied by:Shared))) (then (and (remove (last To)) (if (and (is Occupied (ahead (last To) (directions Cell from:(last From) to:(last To)))) (!= (last To) (ahead (last To) (directions Cell from:(last From) to:(last To))))) (moveAgain))))) (move Select (from (last To)) (to (ahead (last To) (directions Cell from:(last From) to:(last To)))) (then (and (remove (last To)) (if (and (is Occupied (ahead (last To) (directions Cell from:(last From) to:(last To)))) (!= (last To) (ahead (last To) (directions Cell from:(last From) to:(last To))))) (moveAgain)))))) (move Pass)) (move Remove (sites Board) (then (if (not (all Sites (sites Around (last To) Orthogonal) if:(is Empty (site)))) (moveAgain)))))) (end (if (no Moves Next) (result Next Win))))) 
An X, with a rounded line connecting the four endpoints of the X, but leaving two unconnected. A circle is drawn between these two unconnected endpoints. Two pieces per player. Players alternate turns placing one of their pieces on an empty point on the board. When all of the pieces are placed, players alternate turns moving one of the pieces to an empty adjacent point on the board, moving along the lines. The player who blocks their opponent from being able to move wins. The board is a circle.
(game "Temeen Tavag" (players 2) (equipment {(board (remove (rotate 45 (concentric {1 4})) edges:{{1 4}}) use:Vertex) (hand Each) (piece "Disc" Each (move Step (to if:(is Empty (to)))))}) (rules (start (place "Disc" "Hand" count:2)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end (if (no Moves Next) (result Mover Win))))) 
This game is played on an empty 1row x n coloumn board with m stones on each side. At each turn, each player must do one of the following actions. Move a stone forward (i.e., left to one player, right to the other) or jump over one enemy stone, landing on the immediate empty cell. The player who makes the last move wins the game. The game is played on a 1x5 board.
(game "Toads and Frogs" (players 2) (equipment {(board (rectangle 1 5)) (piece "Toad" P1 E (or (move Hop Forward (between if:(is Enemy (who at:(between)))) (to if:(is Empty (to)))) (move Step Forward (to if:(is Empty (to)))))) (piece "Frog" P2 W (or (move Hop Forward (between if:(is Enemy (who at:(between)))) (to if:(is Empty (to)))) (move Step Forward (to if:(is Empty (to))))))}) (rules (start {(place "Toad1" (expand (sites Left) steps:(- 2 1))) (place "Frog2" (expand (sites Right) steps:(- 2 1)))}) (play (forEach Piece)) (end (if (no Moves Next) (result Mover Win))))) 
In the game, played on a grid of any size, two players move their pieces simultaneously, which leave a trail behind them. The first player to run into one of the trails or the edge of the board loses.
(game "Tron" (players 2) (equipment {(board (square 10)) (piece "King" Each (move Step Orthogonal (to (apply (if (is Occupied (to)) (trigger "Collision" (mover))))) (then (add (piece (id "Square" Mover)) (to (last From)))))) (piece "Square" Each)}) (rules (start {(place "King1" coord:"E5") (place "King2" coord:"F6")}) (play (forEach Piece)) (end (if (is Triggered "Collision" Mover) (result Next Win))))) 
Three vertical lines, and two horizontal lines intersecting them along their top end points and their midpoints. Three pieces per player, arranged on the intersections of opposite vertical lines. Players alternate turns moving one of their pieces to an adjacent spot. The object of the game is to block the opponent's pieces from moving.
(game "Tugul Shodra" (players 2) (equipment {(board (remove (square 3) edges:{{0 1} {1 2}}) use:Vertex) (piece "Disc" Each (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Disc1" {2 5 8}) (place "Disc2" {0 3 6})}) (play (forEach Piece)) (end (if (no Moves Next) (result Next Loss))))) 
The aim of Abak is to be the first player to connect one of the orange squares in the centre of the board to any one orange squares in the corners by forming a continuous row of counters of one colour. In the first phase, each player places one counter on one of the orange squares in the centre of the board. They continue to take turns to place their counters on a free adjacent square (squares are adjacent if they touch on the sides or diagonally by the points). The counter may be placed beside counters of any colour. Once placed, a counter may not be moved. During the game, if a counter is surrounded by more than 4 occupied squares, that counter is removed. Moreover, if then a counter becomes isolated, it is also removed from the board. The game is played on a 11x11 board. Two players.
(game "Abak" (players 2) (equipment {(board (square 11)) (piece "Disc" Each) (regions "Centre" (sites Centre)) (regions "CentreRing" (difference (expand (sites Centre)) (sites Centre))) (regions "OuterGoals" (expand (sites Corners)))}) (rules phases:{(phase "Placement" (play (move Add (to (intersection (sites "CentreRing") (sites Empty))))) (nextPhase (= (count Pieces All) 2) "Movement")) (phase "Movement" (play (move Add (to (difference (sites Playable) (sites Centre))) (then (forEach Site (sites Occupied by:All) (if (<= 4 (count Sites in:(intersection (sites Around (to)) (sites Occupied by:All)))) (remove (to))) (then (forEach Site (sites Occupied by:All) (if (= 0 (count Sites in:(intersection (sites Around (to)) (sites Occupied by:All)))) (remove (to))))))))))} (end (if (is Connected {(sites "CentreRing") (sites "OuterGoals")}) (result Mover Win))))) 
STONE PLACEMENT Players take turns adding their stones to the board, one stone per turn. Black makes the first placement of the game. Each player will always have a placement available on his turn and must make one. OBJECT OF THE GAME To win you must connect two of your islands, which are exactly opposite each other, with a contiguous sequence of your stones. The stones of your islands can be included in the sequence. 
(game "Atoll" (players 2) (equipment {(board (remove (rotate 90 (hex Rectangle 13 12)) cells:{138 139 148 149 0 1 10 11 69 80})) (piece "Marker" Each)}) (rules (start {(place "Marker1" (sites {132 133 134 135 131 120 108 97 85 7 6 5 4 8 19 31 42 54})) (place "Marker2" (sites {136 137 138 139 64 53 41 30 18 3 2 1 0 121 109 98 86 75}))}) (play (move Add (to (sites Empty)))) (end (if (is Mover P1) {(if (or (is Connected {(sites {132 133 134 135}) (sites {4 5 6 7})}) (is Connected {(sites {131 120 108 97 85}) (sites {54 42 31 19 8})})) (result Mover Win)) (if (or (is Connected {(sites {121 109 98 86 75}) (sites {64 53 41 30 18})}) (is Connected {(sites {136 137 138 139}) (sites {0 1 2 3})})) (result Mover Win))})))) 
Bide is a strategy game for 2 to 6 players on a hexhex-5 board that is initially empty. Players take turns by placing stones of their color on the hexagonal cells. At the beginning of your turn you are given a new stone. You can either play it, or bide. If you bide, set the stone aside and your turn ends immediately. The stone remains in your hand. If you play the new stone while having at least one stone in your hand, you may release, meaning you would play every stone in your hand in succession. If a player releases, all players must release on their next turn, including playing their stone for that turn. Stones when placed create shock waves, pushing all adjacent stones one space radially outward from the placement. If there are multiple connected stones adjacent to the placed stone, positioned directly in line of the shock wave, they all move one space. If this movement causes a stone to bump into another stone directly in line of the shock wave, that stone also gets pushed one space. Becoming adjacent along a different grid line than the shockwave does not count. However stones cannot be pushed past the edge of the board. Lines that are full between the edges and the placed stone cannot move. Players eventually score points when all cells are filled up with stones. Each stone is worth points equal to its distance from the edge, starting at zero. Groups consist of connected adjacent like colored stones. The player with the highest scoring group wins. If tied, remove the outermost ring of stones and rescore, repeating this process until there is a winner.  Two Players Order 5, Hex Grid
(game "Bide" (players 2) (equipment {(board (tri Hexagon 5) use:Vertex) (hand Each size:1) (piece "Disc" Each) (regions "R0x" (sites Outer)) (regions "R1x" (sites Around (sites "R0x") Orthogonal includeSelf:True)) (regions "R2x" (sites Around (sites "R1x") Orthogonal includeSelf:True)) (regions "R3x" (sites Around (sites "R2x") Orthogonal includeSelf:True)) (regions "R4x" (sites Around (sites "R3x") Orthogonal includeSelf:True)) (regions "R5x" (sites Around (sites "R4x") Orthogonal includeSelf:True))}) (rules (meta (passEnd NoEnd)) (play (if (or (is Prev Mover) (and (< 0 (size Array (values Remembered "Released"))) (> 2 (size Array (values Remembered "Released"))))) (if (is Empty (handSite Mover)) (move Add (to (intersection (sites Board) (sites Empty)))) (move (from (handSite Mover)) (to (sites Empty)) (then (moveAgain))) (then (and {(remember Value "Released" (mover) unique:True) (set Var "LF" (last To) (then (and {(if (and (!= (var "LF") (ahead (var "LF") NNE)) (not (is Empty (ahead (var "LF") NNE)))) (set Var "AnchorSite" (regionSite (forEach (sites Direction from:(var "LF") (directions Vertex from:(var "LF") to:(ahead (var "LF") NNE)) stop:(and (is Empty (to)) (is Empty (ahead (to) (directions Vertex from:(var "LF") to:(ahead (var "LF") NNE))))) stopIncluded:True distance:Infinity) if:(= (site) (ahead (site) (directions Vertex from:(var "LF") to:(ahead (var "LF") NNE))))) index:0) (then (forEach Site (difference (sites Direction from:(var "LF") (directions Vertex from:(var "LF") to:(ahead (var "LF") NNE)) stop:(and (is Empty (to)) (is Empty (ahead (to) (directions Vertex from:(var "LF") to:(ahead (var "LF") NNE))))) stopIncluded:True distance:Infinity) (if (or {(= -1 (var "AnchorSite")) (is Empty (var "AnchorSite")) (= (var "LF") (var "AnchorSite"))}) (sites {(var "LF")}) (sites Direction from:(var "AnchorSite") (directions Vertex from:(var "AnchorSite") to:(var "LF")) included:True stop:(is Empty (to)) stopIncluded:True distance:Infinity))) (if (is Empty (site)) (remove (ahead (site) (directions Vertex from:(var "LF") to:(ahead (var "LF") NNE)))) (add (piece (who at:(site))) (to (ahead (site) (directions Vertex from:(var "LF") to:(ahead (var "LF") NNE))) (apply (remove (to)))))) (then (remove (ahead (var "LF") NNE))))))) (if (and (!= (var "LF") (ahead (var "LF") E)) (not (is Empty (ahead (var "LF") E)))) (set Var "AnchorSite" (regionSite (forEach (sites Direction from:(var "LF") (directions Vertex from:(var "LF") to:(ahead (var "LF") E)) stop:(and (is Empty (to)) (is Empty (ahead (to) (directions Vertex from:(var "LF") to:(ahead (var "LF") E))))) stopIncluded:True distance:Infinity) if:(= (site) (ahead (site) (directions Vertex from:(var "LF") to:(ahead (var "LF") E))))) index:0) (then (forEach Site (difference (sites Direction from:(var "LF") (directions Vertex from:(var "LF") to:(ahead (var "LF") E)) stop:(and (is Empty (to)) (is Empty (ahead (to) (directions Vertex from:(var "LF") to:(ahead (var "LF") E))))) stopIncluded:True distance:Infinity) (if (or {(= -1 (var "AnchorSite")) (is Empty (var "AnchorSite")) (= (var "LF") (var "AnchorSite"))}) (sites {(var "LF")}) (sites Direction from:(var "AnchorSite") (directions Vertex from:(var "AnchorSite") to:(var "LF")) included:True stop:(is Empty (to)) stopIncluded:True distance:Infinity))) (if (is Empty (site)) (remove (ahead (site) (directions Vertex from:(var "LF") to:(ahead (var "LF") E)))) (add (piece (who at:(site))) (to (ahead (site) (directions Vertex from:(var "LF") to:(ahead (var "LF") E))) (apply (remove (to)))))) (then (remove (ahead (var "LF") E))))))) (if (and (!= (var "LF") (ahead (var "LF") SSE)) (not (is Empty (ahead (var "LF") SSE)))) (set Var "AnchorSite" (regionSite (forEach (sites Direction from:(var "LF") (directions Vertex from:(var "LF") to:(ahead (var "LF") SSE)) stop:(and (is Empty (to)) (is Empty (ahead (to) (directions Vertex from:(var "LF") to:(ahead (var "LF") SSE))))) stopIncluded:True distance:Infinity) if:(= (site) (ahead (site) (directions Vertex from:(var "LF") to:(ahead (var "LF") SSE))))) index:0) (then (forEach Site (difference (sites Direction from:(var "LF") (directions Vertex from:(var "LF") to:(ahead (var "LF") SSE)) stop:(and (is Empty (to)) (is Empty (ahead (to) (directions Vertex from:(var "LF") to:(ahead (var "LF") SSE))))) stopIncluded:True distance:Infinity) (if (or {(= -1 (var "AnchorSite")) (is Empty (var "AnchorSite")) (= (var "LF") (var "AnchorSite"))}) (sites {(var "LF")}) (sites Direction from:(var "AnchorSite") (directions Vertex from:(var "AnchorSite") to:(var "LF")) included:True stop:(is Empty (to)) stopIncluded:True distance:Infinity))) (if (is Empty (site)) (remove (ahead (site) (directions Vertex from:(var "LF") to:(ahead (var "LF") SSE)))) (add (piece (who at:(site))) (to (ahead (site) (directions Vertex from:(var "LF") to:(ahead (var "LF") SSE))) (apply (remove (to)))))) (then (remove (ahead (var "LF") SSE))))))) (if (and (!= (var "LF") (ahead (var "LF") SSW)) (not (is Empty (ahead (var "LF") SSW)))) (set Var "AnchorSite" (regionSite (forEach (sites Direction from:(var "LF") (directions Vertex from:(var "LF") to:(ahead (var "LF") SSW)) stop:(and (is Empty (to)) (is Empty (ahead (to) (directions Vertex from:(var "LF") to:(ahead (var "LF") SSW))))) stopIncluded:True distance:Infinity) if:(= (site) (ahead (site) (directions Vertex from:(var "LF") to:(ahead (var "LF") SSW))))) index:0) (then (forEach Site (difference (sites Direction from:(var "LF") (directions Vertex from:(var "LF") to:(ahead (var "LF") SSW)) stop:(and (is Empty (to)) (is Empty (ahead (to) (directions Vertex from:(var "LF") to:(ahead (var "LF") SSW))))) stopIncluded:True distance:Infinity) (if (or {(= -1 (var "AnchorSite")) (is Empty (var "AnchorSite")) (= (var "LF") (var "AnchorSite"))}) (sites {(var "LF")}) (sites Direction from:(var "AnchorSite") (directions Vertex from:(var "AnchorSite") to:(var "LF")) included:True stop:(is Empty (to)) stopIncluded:True distance:Infinity))) (if (is Empty (site)) (remove (ahead (site) (directions Vertex from:(var "LF") to:(ahead (var "LF") SSW)))) (add (piece (who at:(site))) (to (ahead (site) (directions Vertex from:(var "LF") to:(ahead (var "LF") SSW))) (apply (remove (to)))))) (then (remove (ahead (var "LF") SSW))))))) (if (and (!= (var "LF") (ahead (var "LF") W)) (not (is Empty (ahead (var "LF") W)))) (set Var "AnchorSite" (regionSite (forEach (sites Direction from:(var "LF") (directions Vertex from:(var "LF") to:(ahead (var "LF") W)) stop:(and (is Empty (to)) (is Empty (ahead (to) (directions Vertex from:(var "LF") to:(ahead (var "LF") W))))) stopIncluded:True distance:Infinity) if:(= (site) (ahead (site) (directions Vertex from:(var "LF") to:(ahead (var "LF") W))))) index:0) (then (forEach Site (difference (sites Direction from:(var "LF") (directions Vertex from:(var "LF") to:(ahead (var "LF") W)) stop:(and (is Empty (to)) (is Empty (ahead (to) (directions Vertex from:(var "LF") to:(ahead (var "LF") W))))) stopIncluded:True distance:Infinity) (if (or {(= -1 (var "AnchorSite")) (is Empty (var "AnchorSite")) (= (var "LF") (var "AnchorSite"))}) (sites {(var "LF")}) (sites Direction from:(var "AnchorSite") (directions Vertex from:(var "AnchorSite") to:(var "LF")) included:True stop:(is Empty (to)) stopIncluded:True distance:Infinity))) (if (is Empty (site)) (remove (ahead (site) (directions Vertex from:(var "LF") to:(ahead (var "LF") W)))) (add (piece (who at:(site))) (to (ahead (site) (directions Vertex from:(var "LF") to:(ahead (var "LF") W))) (apply (remove (to)))))) (then (remove (ahead (var "LF") W))))))) (if (and (!= (var "LF") (ahead (var "LF") NNW)) (not (is Empty (ahead (var "LF") NNW)))) (set Var "AnchorSite" (regionSite (forEach (sites Direction from:(var "LF") (directions Vertex from:(var "LF") to:(ahead (var "LF") NNW)) stop:(and (is Empty (to)) (is Empty (ahead (to) (directions Vertex from:(var "LF") to:(ahead (var "LF") NNW))))) stopIncluded:True distance:Infinity) if:(= (site) (ahead (site) (directions Vertex from:(var "LF") to:(ahead (var "LF") NNW))))) index:0) (then (forEach Site (difference (sites Direction from:(var "LF") (directions Vertex from:(var "LF") to:(ahead (var "LF") NNW)) stop:(and (is Empty (to)) (is Empty (ahead (to) (directions Vertex from:(var "LF") to:(ahead (var "LF") NNW))))) stopIncluded:True distance:Infinity) (if (or {(= -1 (var "AnchorSite")) (is Empty (var "AnchorSite")) (= (var "LF") (var "AnchorSite"))}) (sites {(var "LF")}) (sites Direction from:(var "AnchorSite") (directions Vertex from:(var "AnchorSite") to:(var "LF")) included:True stop:(is Empty (to)) stopIncluded:True distance:Infinity))) (if (is Empty (site)) (remove (ahead (site) (directions Vertex from:(var "LF") to:(ahead (var "LF") NNW)))) (add (piece (who at:(site))) (to (ahead (site) (directions Vertex from:(var "LF") to:(ahead (var "LF") NNW))) (apply (remove (to)))))) (then (remove (ahead (var "LF") NNW)))))))})))}))) (or (do (add (to (handSite Mover)) stack:True) next:(move Pass)) (or (move (from (handSite Mover)) (to (sites Empty)) (then (moveAgain))) (move Add (to (intersection (sites Board) (sites Empty)))) (then (set Var "LF" (last To) (then (and {(if (and (!= (var "LF") (ahead (var "LF") NNE)) (not (is Empty (ahead (var "LF") NNE)))) (set Var "AnchorSite" (regionSite (forEach (sites Direction from:(var "LF") (directions Vertex from:(var "LF") to:(ahead (var "LF") NNE)) stop:(and (is Empty (to)) (is Empty (ahead (to) (directions Vertex from:(var "LF") to:(ahead (var "LF") NNE))))) stopIncluded:True distance:Infinity) if:(= (site) (ahead (site) (directions Vertex from:(var "LF") to:(ahead (var "LF") NNE))))) index:0) (then (forEach Site (difference (sites Direction from:(var "LF") (directions Vertex from:(var "LF") to:(ahead (var "LF") NNE)) stop:(and (is Empty (to)) (is Empty (ahead (to) (directions Vertex from:(var "LF") to:(ahead (var "LF") NNE))))) stopIncluded:True distance:Infinity) (if (or {(= -1 (var "AnchorSite")) (is Empty (var "AnchorSite")) (= (var "LF") (var "AnchorSite"))}) (sites {(var "LF")}) (sites Direction from:(var "AnchorSite") (directions Vertex from:(var "AnchorSite") to:(var "LF")) included:True stop:(is Empty (to)) stopIncluded:True distance:Infinity))) (if (is Empty (site)) (remove (ahead (site) (directions Vertex from:(var "LF") to:(ahead (var "LF") NNE)))) (add (piece (who at:(site))) (to (ahead (site) (directions Vertex from:(var "LF") to:(ahead (var "LF") NNE))) (apply (remove (to)))))) (then (remove (ahead (var "LF") NNE))))))) (if (and (!= (var "LF") (ahead (var "LF") E)) (not (is Empty (ahead (var "LF") E)))) (set Var "AnchorSite" (regionSite (forEach (sites Direction from:(var "LF") (directions Vertex from:(var "LF") to:(ahead (var "LF") E)) stop:(and (is Empty (to)) (is Empty (ahead (to) (directions Vertex from:(var "LF") to:(ahead (var "LF") E))))) stopIncluded:True distance:Infinity) if:(= (site) (ahead (site) (directions Vertex from:(var "LF") to:(ahead (var "LF") E))))) index:0) (then (forEach Site (difference (sites Direction from:(var "LF") (directions Vertex from:(var "LF") to:(ahead (var "LF") E)) stop:(and (is Empty (to)) (is Empty (ahead (to) (directions Vertex from:(var "LF") to:(ahead (var "LF") E))))) stopIncluded:True distance:Infinity) (if (or {(= -1 (var "AnchorSite")) (is Empty (var "AnchorSite")) (= (var "LF") (var "AnchorSite"))}) (sites {(var "LF")}) (sites Direction from:(var "AnchorSite") (directions Vertex from:(var "AnchorSite") to:(var "LF")) included:True stop:(is Empty (to)) stopIncluded:True distance:Infinity))) (if (is Empty (site)) (remove (ahead (site) (directions Vertex from:(var "LF") to:(ahead (var "LF") E)))) (add (piece (who at:(site))) (to (ahead (site) (directions Vertex from:(var "LF") to:(ahead (var "LF") E))) (apply (remove (to)))))) (then (remove (ahead (var "LF") E))))))) (if (and (!= (var "LF") (ahead (var "LF") SSE)) (not (is Empty (ahead (var "LF") SSE)))) (set Var "AnchorSite" (regionSite (forEach (sites Direction from:(var "LF") (directions Vertex from:(var "LF") to:(ahead (var "LF") SSE)) stop:(and (is Empty (to)) (is Empty (ahead (to) (directions Vertex from:(var "LF") to:(ahead (var "LF") SSE))))) stopIncluded:True distance:Infinity) if:(= (site) (ahead (site) (directions Vertex from:(var "LF") to:(ahead (var "LF") SSE))))) index:0) (then (forEach Site (difference (sites Direction from:(var "LF") (directions Vertex from:(var "LF") to:(ahead (var "LF") SSE)) stop:(and (is Empty (to)) (is Empty (ahead (to) (directions Vertex from:(var "LF") to:(ahead (var "LF") SSE))))) stopIncluded:True distance:Infinity) (if (or {(= -1 (var "AnchorSite")) (is Empty (var "AnchorSite")) (= (var "LF") (var "AnchorSite"))}) (sites {(var "LF")}) (sites Direction from:(var "AnchorSite") (directions Vertex from:(var "AnchorSite") to:(var "LF")) included:True stop:(is Empty (to)) stopIncluded:True distance:Infinity))) (if (is Empty (site)) (remove (ahead (site) (directions Vertex from:(var "LF") to:(ahead (var "LF") SSE)))) (add (piece (who at:(site))) (to (ahead (site) (directions Vertex from:(var "LF") to:(ahead (var "LF") SSE))) (apply (remove (to)))))) (then (remove (ahead (var "LF") SSE))))))) (if (and (!= (var "LF") (ahead (var "LF") SSW)) (not (is Empty (ahead (var "LF") SSW)))) (set Var "AnchorSite" (regionSite (forEach (sites Direction from:(var "LF") (directions Vertex from:(var "LF") to:(ahead (var "LF") SSW)) stop:(and (is Empty (to)) (is Empty (ahead (to) (directions Vertex from:(var "LF") to:(ahead (var "LF") SSW))))) stopIncluded:True distance:Infinity) if:(= (site) (ahead (site) (directions Vertex from:(var "LF") to:(ahead (var "LF") SSW))))) index:0) (then (forEach Site (difference (sites Direction from:(var "LF") (directions Vertex from:(var "LF") to:(ahead (var "LF") SSW)) stop:(and (is Empty (to)) (is Empty (ahead (to) (directions Vertex from:(var "LF") to:(ahead (var "LF") SSW))))) stopIncluded:True distance:Infinity) (if (or {(= -1 (var "AnchorSite")) (is Empty (var "AnchorSite")) (= (var "LF") (var "AnchorSite"))}) (sites {(var "LF")}) (sites Direction from:(var "AnchorSite") (directions Vertex from:(var "AnchorSite") to:(var "LF")) included:True stop:(is Empty (to)) stopIncluded:True distance:Infinity))) (if (is Empty (site)) (remove (ahead (site) (directions Vertex from:(var "LF") to:(ahead (var "LF") SSW)))) (add (piece (who at:(site))) (to (ahead (site) (directions Vertex from:(var "LF") to:(ahead (var "LF") SSW))) (apply (remove (to)))))) (then (remove (ahead (var "LF") SSW))))))) (if (and (!= (var "LF") (ahead (var "LF") W)) (not (is Empty (ahead (var "LF") W)))) (set Var "AnchorSite" (regionSite (forEach (sites Direction from:(var "LF") (directions Vertex from:(var "LF") to:(ahead (var "LF") W)) stop:(and (is Empty (to)) (is Empty (ahead (to) (directions Vertex from:(var "LF") to:(ahead (var "LF") W))))) stopIncluded:True distance:Infinity) if:(= (site) (ahead (site) (directions Vertex from:(var "LF") to:(ahead (var "LF") W))))) index:0) (then (forEach Site (difference (sites Direction from:(var "LF") (directions Vertex from:(var "LF") to:(ahead (var "LF") W)) stop:(and (is Empty (to)) (is Empty (ahead (to) (directions Vertex from:(var "LF") to:(ahead (var "LF") W))))) stopIncluded:True distance:Infinity) (if (or {(= -1 (var "AnchorSite")) (is Empty (var "AnchorSite")) (= (var "LF") (var "AnchorSite"))}) (sites {(var "LF")}) (sites Direction from:(var "AnchorSite") (directions Vertex from:(var "AnchorSite") to:(var "LF")) included:True stop:(is Empty (to)) stopIncluded:True distance:Infinity))) (if (is Empty (site)) (remove (ahead (site) (directions Vertex from:(var "LF") to:(ahead (var "LF") W)))) (add (piece (who at:(site))) (to (ahead (site) (directions Vertex from:(var "LF") to:(ahead (var "LF") W))) (apply (remove (to)))))) (then (remove (ahead (var "LF") W))))))) (if (and (!= (var "LF") (ahead (var "LF") NNW)) (not (is Empty (ahead (var "LF") NNW)))) (set Var "AnchorSite" (regionSite (forEach (sites Direction from:(var "LF") (directions Vertex from:(var "LF") to:(ahead (var "LF") NNW)) stop:(and (is Empty (to)) (is Empty (ahead (to) (directions Vertex from:(var "LF") to:(ahead (var "LF") NNW))))) stopIncluded:True distance:Infinity) if:(= (site) (ahead (site) (directions Vertex from:(var "LF") to:(ahead (var "LF") NNW))))) index:0) (then (forEach Site (difference (sites Direction from:(var "LF") (directions Vertex from:(var "LF") to:(ahead (var "LF") NNW)) stop:(and (is Empty (to)) (is Empty (ahead (to) (directions Vertex from:(var "LF") to:(ahead (var "LF") NNW))))) stopIncluded:True distance:Infinity) (if (or {(= -1 (var "AnchorSite")) (is Empty (var "AnchorSite")) (= (var "LF") (var "AnchorSite"))}) (sites {(var "LF")}) (sites Direction from:(var "AnchorSite") (directions Vertex from:(var "AnchorSite") to:(var "LF")) included:True stop:(is Empty (to)) stopIncluded:True distance:Infinity))) (if (is Empty (site)) (remove (ahead (site) (directions Vertex from:(var "LF") to:(ahead (var "LF") NNW)))) (add (piece (who at:(site))) (to (ahead (site) (directions Vertex from:(var "LF") to:(ahead (var "LF") NNW))) (apply (remove (to)))))) (then (remove (ahead (var "LF") NNW)))))))}))))) (then (forget Value "Released" All))) (then (and {(set Score All 0) (forEach Player (do (and {(forEach Site (sites Around (sites "R0x") Orthogonal if:(= (player) (who at:(to)))) (set Value at:(site) 1)) (forEach Site (sites Around (sites "R1x") Orthogonal if:(= (player) (who at:(to)))) (set Value at:(site) 2)) (forEach Site (sites Around (sites "R2x") Orthogonal if:(= (player) (who at:(to)))) (set Value at:(site) 3)) (forEach Site (sites Around (sites "R3x") Orthogonal if:(= (player) (who at:(to)))) (set Value at:(site) 4)) (forEach Site (sites Around (sites "R4x") Orthogonal if:(= (player) (who at:(to)))) (set Value at:(site) 5))}) next:(if (< 0 (count Sites in:(intersection (difference (sites Board) (sites Empty)) (sites Occupied by:(player (player)))))) (do (forEach Group Orthogonal if:(and {(is In (to) (intersection (difference (sites Board) (sites Empty)) (sites Occupied by:(player (player)))))}) (remember Value "PlayerGroups" (+ (results from:(sites) to:(from) (value Piece at:(from)))))) next:(addScore (player (player)) (* 10000000 (max (values Remembered "PlayerGroups"))) (then (forget Value "PlayerGroups" All))))))) (forEach Player (do (and {(forEach Site (sites Around (sites "R0x") Orthogonal if:(= (player) (who at:(to)))) (set Value at:(site) 1)) (forEach Site (sites Around (sites "R1x") Orthogonal if:(= (player) (who at:(to)))) (set Value at:(site) 2)) (forEach Site (sites Around (sites "R2x") Orthogonal if:(= (player) (who at:(to)))) (set Value at:(site) 3)) (forEach Site (sites Around (sites "R3x") Orthogonal if:(= (player) (who at:(to)))) (set Value at:(site) 4)) (forEach Site (sites Around (sites "R4x") Orthogonal if:(= (player) (who at:(to)))) (set Value at:(site) 5))}) next:(if (< 0 (count Sites in:(intersection (difference (sites Board) (sites "R0x")) (sites Occupied by:(player (player)))))) (do (forEach Group Orthogonal if:(and {(is In (to) (intersection (difference (sites Board) (sites "R0x")) (sites Occupied by:(player (player)))))}) (remember Value "PlayerGroups" (+ (results from:(sites) to:(from) (value Piece at:(from)))))) next:(addScore (player (player)) (* 100000 (max (values Remembered "PlayerGroups"))) (then (forget Value "PlayerGroups" All))))))) (forEach Player (do (and {(forEach Site (sites Around (sites "R0x") Orthogonal if:(= (player) (who at:(to)))) (set Value at:(site) 1)) (forEach Site (sites Around (sites "R1x") Orthogonal if:(= (player) (who at:(to)))) (set Value at:(site) 2)) (forEach Site (sites Around (sites "R2x") Orthogonal if:(= (player) (who at:(to)))) (set Value at:(site) 3)) (forEach Site (sites Around (sites "R3x") Orthogonal if:(= (player) (who at:(to)))) (set Value at:(site) 4)) (forEach Site (sites Around (sites "R4x") Orthogonal if:(= (player) (who at:(to)))) (set Value at:(site) 5))}) next:(if (< 0 (count Sites in:(intersection (difference (sites Board) (sites "R1x")) (sites Occupied by:(player (player)))))) (do (forEach Group Orthogonal if:(and {(is In (to) (intersection (difference (sites Board) (sites "R1x")) (sites Occupied by:(player (player)))))}) (remember Value "PlayerGroups" (+ (results from:(sites) to:(from) (value Piece at:(from)))))) next:(addScore (player (player)) (* 1000 (max (values Remembered "PlayerGroups"))) (then (forget Value "PlayerGroups" All))))))) (forEach Player (do (and {(forEach Site (sites Around (sites "R0x") Orthogonal if:(= (player) (who at:(to)))) (set Value at:(site) 1)) (forEach Site (sites Around (sites "R1x") Orthogonal if:(= (player) (who at:(to)))) (set Value at:(site) 2)) (forEach Site (sites Around (sites "R2x") Orthogonal if:(= (player) (who at:(to)))) (set Value at:(site) 3)) (forEach Site (sites Around (sites "R3x") Orthogonal if:(= (player) (who at:(to)))) (set Value at:(site) 4)) (forEach Site (sites Around (sites "R4x") Orthogonal if:(= (player) (who at:(to)))) (set Value at:(site) 5))}) next:(if (< 0 (count Sites in:(intersection (difference (sites Board) (sites "R2x")) (sites Occupied by:(player (player)))))) (do (forEach Group Orthogonal if:(and {(is In (to) (intersection (difference (sites Board) (sites "R2x")) (sites Occupied by:(player (player)))))}) (remember Value "PlayerGroups" (+ (results from:(sites) to:(from) (value Piece at:(from)))))) next:(addScore (player (player)) (* 10 (max (values Remembered "PlayerGroups"))) (then (forget Value "PlayerGroups" All))))))) (forEach Player (do (and {(forEach Site (sites Around (sites "R0x") Orthogonal if:(= (player) (who at:(to)))) (set Value at:(site) 1)) (forEach Site (sites Around (sites "R1x") Orthogonal if:(= (player) (who at:(to)))) (set Value at:(site) 2)) (forEach Site (sites Around (sites "R2x") Orthogonal if:(= (player) (who at:(to)))) (set Value at:(site) 3)) (forEach Site (sites Around (sites "R3x") Orthogonal if:(= (player) (who at:(to)))) (set Value at:(site) 4)) (forEach Site (sites Around (sites "R4x") Orthogonal if:(= (player) (who at:(to)))) (set Value at:(site) 5))}) next:(if (< 0 (count Sites in:(intersection (difference (sites Board) (sites "R3x")) (sites Occupied by:(player (player)))))) (do (forEach Group Orthogonal if:(and {(is In (to) (intersection (difference (sites Board) (sites "R3x")) (sites Occupied by:(player (player)))))}) (remember Value "PlayerGroups" (+ (results from:(sites) to:(from) (value Piece at:(from)))))) next:(addScore (player (player)) (* 1 (max (values Remembered "PlayerGroups"))) (then (forget Value "PlayerGroups" All)))))))})))) (end (if (= 0 (count Sites in:(intersection (sites Board) (sites Empty)))) (byScore))))) 
Played on a Hex board. Players may play a piece of any color piece. The goal is to form a line connecting the player's two sides with either color. The game is played on a 11x11 board The first player to connect his two sides wins.
(game "Chameleon" (players 2) (equipment {(board (hex Diamond 11)) (piece "Marker" Each) (hand Shared size:2) (regions P1 {(sites Side NE) (sites Side SW)}) (regions P2 {(sites Side NW) (sites Side SE)})}) (rules (meta (swap)) (start {(place "Marker1" (handSite Shared)) (place "Marker2" (handSite Shared 1))}) (play (move (from (sites Hand Shared)) (to (sites Empty)) copy:True)) (end {(if (is Connected Mover) (result Mover Win)) (if (is Connected Next) (result Next Win))}))) 
This game is played on a hexagonal board made up of hexagonal cells, usually 7 cells per side, although bigger sizes may also be used. Initially the board is empty except for the six corner cells, upon which black stones are placed. Then the players take it in turns to place 1-3 black stones each turn until one decides to pass; that player then becomes Black, and the other becomes White. After that, players take it in turns to place one stone of their colour on the board on any empty hex. If Black forms a continuous loop composed of their pieces, they win; if the board fills up with no loop of Black pieces being formed, White wins. During the initial chicken ballot phase, you may add stones by clicking on available spaces, or skip the rest of your placements (by choosing the Next Player action). Alternatively, you may Pass at the start of your turn to take Black. After that, you and your opponent will alternate playing one stone of your colour per turn, until the board is full or Black forms a loop. Played on a Hexagonal Board, pre-filled corners. The game is played on a board with 7 hexes per side.
(game "Coil" (players 2) (equipment {(board (hex Hexagon 7)) (piece "Disc" Each)}) (rules (start {(place "Disc2" {0 (- (/ (- (* {3 7 7}) 7) 2) 1) (+ 1 (- (* {3 7 7}) (* 4 7)))}) (place "Disc2" {(- 7 1) (+ 1 (/ (- (* {3 7 7}) (* 5 7)) 2)) (- (* {3 7 7}) (* 3 7))})}) phases:{(phase "Opening" (play (or (or (move Add (piece (id "Disc" P2)) (to (sites Empty) if:(not (is Within (id "Disc" P2) in:(sites Around (to))))) (then (if (< (count MovesThisTurn) 2) (moveAgain)))) (move Set NextPlayer (player (next)))) (if (= (count MovesThisTurn) 0) (move Pass (then (if (is Mover P1) (swap Players P1 P2 (then (note "Player 1 is now Black. Player 2 is now White." to:All))) (note "Player 1 remains White. Player 2 remains Black." to:All) (then (do (set NextPlayer (player 1)) next:(set Var 1))))))))) (nextPhase (= 1 (var)) "Playing")) (phase "Playing" (play (move Add (to (sites Empty)))))} (end (forEach Player if:(and {(= 1 (var)) (= (id Player) (mover)) (is Loop)}) (result Player Win))))) 
Each player has an allocated colour. The game is played in turns. On his first move, the second player may elect to swap colours (swap option). This is to prevent overly strong opening moves. Each turn the current player places one of their pegs on an empty hole, which may conquer one or more cells. A cell is conquered by the first player to occupy at least half of its surrounding holes. A blue rectangle is placed on cells conquered by Blue, and a red rectangle is placed on cells conquered by Red. The central cell, which has five holes, is conquered by the player who has occupied any three of these holes. The first player that completes a contiguous chain of connected cells of his colour between the 2 sides of his colour wins the game. 
(game "ConHex" (players 2) (equipment {(board (add (keep (splitCrossings (merge (rotate 45 (dual (square 12 diagonals:Concentric))) (shift 3 3 (scale 6 (square 1))))) (poly {{3 3} {3 9} {9 9} {9 3}})) vertices:{{6 6}})) (piece "Marker" Each) (piece "Rectangle" Each) (regions "Holes" (union (difference (sites Board Vertex) (sites Outer Vertex)) (sites Corners Vertex))) (regions P1 {(sites Side N) (sites Side S)}) (regions P2 {(sites Side W) (sites Side E)})}) (rules (meta (swap)) (play (move Add (to Vertex (sites Empty Vertex) if:(is In (to) (sites "Holes"))) (then (forEach Site (sites Incident Cell of:Vertex at:(last To)) (if (if (is In (site) (sites Centre)) (>= (+ (count Sites in:(intersection (intersection (sites Incident Vertex of:Cell at:(site)) (sites "Holes")) (sites Occupied by:Mover on:Vertex))) (if (= (mover) (who Vertex at:(centrePoint Vertex))) 1 0)) 3) (>= (count Sites in:(intersection (intersection (sites Incident Vertex of:Cell at:(site)) (sites "Holes")) (sites Occupied by:Mover on:Vertex))) (if (is Even (count Sites in:(intersection (sites Incident Vertex of:Cell at:(site)) (sites "Holes")))) (/ (count Sites in:(intersection (sites Incident Vertex of:Cell at:(site)) (sites "Holes"))) 2) (+ (/ (count Sites in:(intersection (sites Incident Vertex of:Cell at:(site)) (sites "Holes"))) 2) 1)))) (claim (piece (id "Rectangle" Mover)) (to Cell (site)))) (then (forEach Site (forEach (sites Incident Cell of:Vertex at:(last To)) if:(is Mover (who Cell at:(site)))) (if (is Connected at:(site) Mover) (trigger "Connected" Mover)))))))) (end {(if (is Triggered "Connected" Mover) (result Mover Win)) (if (<= 52 (count Moves)) (result Mover Draw))}))) 
A player wins by connecting three non-adjacent board sides with a chain of their pieces. A player loses by connecting two opposite board sides with a chain of their pieces (without also connecting three non-adjacent sides). The game is played on a 5x5 board
(game "Cross" (players 2) (equipment {(board (hex 5)) (piece "Marker" Each)}) (rules (play (move Add (to (sites Empty)))) (end {(if (is Connected {(sites Side S) (sites Side NW) (sites Side NE)}) (result Mover Win)) (if (is Connected {(sites Side N) (sites Side SW) (sites Side SE)}) (result Mover Win)) (if (is Connected {(sites Side N) (sites Side S)}) (result Mover Loss)) (if (is Connected {(sites Side NW) (sites Side SE)}) (result Mover Loss)) (if (is Connected {(sites Side NE) (sites Side SW)}) (result Mover Loss))}))) 
Crossway is played with a Go set. The board starts out empty. Each player takes possession of all of the stones of one color. Players take turns adding their stones to the board, one stone per turn. A player must never create a crosscut formation. Black makes the first placement of the game. If you have no more available placements, you forfeit your turn and your opponent can continue making placements until completing his goal connection. For White to win, White must form a contiguous sequence of white stones connecting the West edge to the East edge of the board. Each stone in the sequence must be connected to neighboring stones in the sequence by horizontal, vertical, or diagonal adjacencies. Likewise for Black and the North and South edges. A corner is considered to be part of both adjoining edges. Crossway makes use of the pie rule. This means Black makes the first placement, and White has the option of switching colors with Black, and claiming Black's first move as his own. If White chooses to exercise the pie rule, Black then becomes White and now makes the second placement of the game. The pie rule can only be used once and on the second move of the game. The game is played on a 19x19 board
(game "Crossway" (players 2) (equipment {(board (square 19) use:Vertex) (piece "Marker" Each) (regions P1 {(sites Side N) (sites Side S)}) (regions P2 {(sites Side W) (sites Side E)})}) (rules (meta (swap)) (play (do (move Add (to (sites Empty))) ifAfterwards:(not (is Pattern {F R F R F} whats:{(mover) (next)})))) (end (if (is Connected All Mover) (result Mover Win))))) 
Players take turns placing their pieces on one space on the board, with the goal of connecting the opposite sides of the board corresponding to the color of their pieces with a line of pieces. The game is played on a 11x11 board. The board is a diamond tiling by hexagon. The game uses the swap rule. The first player to connect their two sides wins. The connection between two stones is using all the diagonal directions.
(game "Diagonal Hex" (players 2) (equipment {(board (hex Diamond 11)) (piece "Marker" Each) (regions P1 {(sites Side NE) (sites Side SW)}) (regions P2 {(sites Side NW) (sites Side SE)})}) (rules (meta (swap)) (play (move Add (to (sites Empty)))) (end (if (is Connected Diagonal Mover) (result Mover Win))))) 
White starts by placing one disc or ring on any cell of the board. Then, each player in turn must perform two actions: 1. add one of her discs to an empty cell or move one of her discs on the board into any ring located in a neighbor cell, and 2. add one of her rings to an empty cell or move one of her rings on the board to a neighbor cell occupied by a disc. The disc-ring pair (a disc inside a ring) cannot be modified for the rest of the game.
(game "DuploHex" (players 2) (equipment {(board (hex Diamond 7)) (piece "DoubleCounter" Each) (piece "Disc" Each (move Step (to if:(or (= (what at:(to)) (id "Ring1")) (= (what at:(to)) (id "Ring2")))) (then (promote (last To) (piece "DoubleCounter") Mover)))) (piece "Ring" Each (move Step (to if:(or (= (what at:(to)) (id "Disc1")) (= (what at:(to)) (id "Disc2")))) (then (promote (last To) (piece "DoubleCounter") Mover)))) (hand Each size:2) (regions P1 {(sites Side NE) (sites Side SW)}) (regions P2 {(sites Side NW) (sites Side SE)})}) (rules (start {(place "Disc1" (handSite P1 0) count:25) (place "Ring1" (handSite P1 1) count:25) (place "Disc2" (handSite P2 0) count:25) (place "Ring2" (handSite P2 1) count:25)}) phases:{(phase "Placement" (play (move (from (sites Hand P1)) (to (sites Empty)) (then (moveAgain)))) (nextPhase "Game")) (phase "Game" (play (if (is Odd (count Moves)) (or (move (from (handSite Mover 0)) (to (sites Empty)) (then (moveAgain))) (forEach Piece "Disc")) (or (move (from (handSite Mover 1)) (to (sites Empty))) (forEach Piece "Ring")))))} (end (if (is Connected Mover) (result Mover Win))))) 
The rules are similar to Hex. Players take turns placing their pieces on one space on the board, with the goal of connecting the opposite sides of the board corresponding to the color of their pieces with a line of pieces. However, in the first turn, P1 places a piece of their colour as first move. Then, players alternate placing two pieces of their colour per turn. No swap rule is needed. The game is played on a 11x11 board. The game does not use the swap rule. The first player to connect their two sides wins.
(game "Esa Hex" (players 2) (equipment {(board (hex Diamond 11)) (piece "Marker" Each) (regions P1 {(sites Side NE) (sites Side SW)}) (regions P2 {(sites Side NW) (sites Side SE)})}) (rules phases:{(phase "Opening" P1 (play (move Add (to (sites Empty)))) (nextPhase "Playing")) (phase "Playing" (play (move Add (to (sites Empty)) (then (if (= 0 (count MovesThisTurn)) (moveAgain))))))} (end (if (is Connected Mover) (result Mover Win))))) 
The two players, Red and Blue, take turns coloring cells with their own color, one cell per turn, starting with Red. To win you must form a path of cells of your own color connecting the two border regions of your color.
(game "Fractal" (players 2) (equipment {(board (add (add (union (shift 3.45 6 (scale 3 (remove (remove (clip (hex 3) (poly {{0 1} {2 1} {4 5} {1 4}})) cells:{9}) vertices:{26 30 34 39 35 40 36 31 27 22 18 14 9 13 8 12 17 21 25}))) (union (remove (shift 5.77 10 (scale 0.333 (remove (remove (hex Star 5) cells:{0 1 2 3 4 5 6 7 8 9 30 29 45 28 44 59 27 43 58 72 165 164 149 163 148 134 162 147 133 120 180 178 179 175 176 177 171 172 173 174 150 135 151 152 136 121 108 122 137 153 15 16 31 17 32 46 18 33 47 60}) cells:{0 1 2 3 4 12 21 31 42 54 77 88 98 107 115 120 119 118 117 116 108 99 89 78 66 43 32 22 13 5 6 8 9 11 30 41 65 87 97 114 112 111 109 90 79 55 33 23}))) vertices:{0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 42 43 45 46 47 48 49 50 62 63 64 65 66 67 80 81 82 83 84 97 98 99 100 113 114 115 116 128 129 130 131 143 144 145 146 158 159 160 173 174 187 200 212 224 366 237 250 263 264 276 277 278 290 291 292 293 305 306 307 308 321 322 323 324 337 338 339 340 353 354 355 356 357 369 370 371 372 373 374 375 376 377 378 379 380 382 383 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 358 359 360 361 362 363 341 342 343 344 345 325 326 327 328 309 310 311 312 294 295 296 297 279 280 281 282 265 266 267 251 252 238 225 213 201 188 175 161 162 147 148 149 132 133 134 135 117 118 119 120 101 102 103 104 85 86 87 88 68 69 70 71 72 51 52 53 54 55 56 59}) (remove (remove (remove (remove (remove (hex Star 5) cells:{0 1 2 3 4 5 6 7 8 9 30 29 45 28 44 59 27 43 58 72 165 164 149 163 148 134 162 147 133 120 180 178 179 175 176 177 171 172 173 174 150 135 151 152 136 121 108 122 137 153 15 16 31 17 32 46 18 33 47 60}) cells:{0 1 2 3 4 12 21 31 42 54 77 88 98 107 115 120 119 118 117 116 108 99 89 78 66 43 32 22 13 5 6 8 9 11 30 41 65 87 97 114 112 111 109 90 79 55 33 23}) cells:{26 27 35 36 37 45 46}) vertices:{193 180 167 181 168 182 195 208 220 232 245 258 244 257 243 230 217 205}) vertices:{188 198 199 208 209 219 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 42 43 59 45 46 47 48 49 50 62 63 64 65 66 67 80 81 82 83 84 97 98 99 100 113 114 115 116 128 129 130 131 143 144 145 146 158 159 160 171 172 182 193 203 213 224 234 245 246 258 259 260 272 273 274 275 287 288 289 290 303 304 305 306 319 320 321 322 335 336 337 338 339 351 352 353 354 355 356 357 358 359 360 361 362 364 365 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 340 341 342 343 344 345 323 324 325 326 327 307 308 309 310 291 292 293 294 276 277 278 279 261 262 263 264 247 248 249 235 236 225 214 204 194 183 173 161 162 147 148 149 132 133 134 135 117 118 119 120 101 102 103 104 85 86 87 88 68 69 70 71 72 51 52 53 54 55 56}))) edges:{{216 4} {7 229} {217 5} {236 8} {12 282} {18 318} {22 364} {25 378} {24 377} {21 357} {17 311} {11 275} {91 286} {43 270} {30 262} {31 263} {50 271} {287 101} {307 154} {323 202} {331 215} {330 214} {322 195} {306 144}}) cells:{{0 4 216 218 223 230 222 229 7 3} {4 1 5 217 220 226 233 225 232 224 219 216} {5 2 6 8 236 228 235 227 221 217} {8 10 12 282 274 281 273 266 258 251 244 236} {12 14 16 18 318 310 302 296 290 282} {18 20 22 364 356 348 341 334 325 317 326 318} {22 26 29 25 378 376 370 363 371 364} {25 28 24 377 373 367 360 368 361 369 375 378} {24 27 23 21 357 365 358 366 372 377} {21 19 17 311 319 312 320 327 335 342 349 357} {17 15 13 11 275 283 291 297 303 311} {275 11 9 7 229 237 245 252 259 268 276 267} {43 36 44 37 32 30 262 254 261 270} {30 33 38 46 39 47 40 34 31 263 255 262} {31 35 41 49 42 50 271 264 256 263} {50 58 65 72 80 89 100 90 101 287 279 271} {101 112 122 132 143 154 307 300 294 287} {202 323 315 307 154 164 153 163 172 179 186 194} {323 332 339 331 215 213 208 201 209 202} {338 331 215 212 207 199 206 198 205 211 214 330} {330 337 329 322 195 203 196 204 210 214} {322 314 306 144 155 145 156 165 173 180 187 195} {306 299 293 286 91 102 113 123 133 144} {286 278 270 43 51 59 66 73 82 92 81 91}})) (piece "Marker" Each) (regions P1 {(sites Side NW) (sites Side SE)}) (regions P2 {(sites Side NE) (sites Side SW)})}) (rules (play (move Claim (to (sites Empty)))) (end (if (is Connected Mover) (result Mover Win))))) 
A player wins by connecting opposite sides of the square board with a chain of their pieces. The game is played on a 13x13 board The first player to connect their two sides wins.
(game "Gale" (players 2) (equipment {(board (square 13)) (piece "Square" Each) (regions P1 {(sites Top) (sites Bottom)}) (regions P2 {(sites Left) (sites Right)})}) (rules (start {(place "Square1" (forEach (sites Board) if:(and (is Even (column of:(site))) (is Odd (row of:(site)))))) (place "Square2" (forEach (sites Board) if:(and (is Even (row of:(site))) (is Odd (column of:(site))))))}) (play (move Add (to (sites Empty)))) (end (if (is Connected Mover) (result Mover Win))))) 
All the rules of Go apply, except that passing is not allowed. A player loses if he has no legal move. A player wins if they successfully connect two opposite sides of the board. The game is played on a 13x13 board
(game "Gonnect" (players 2) (equipment {(board (square 13) use:Vertex) (piece "Marker" Each) (regions P1 {(sites Side N) (sites Side S)}) (regions P2 {(sites Side W) (sites Side E)})}) (rules (meta {(swap) (no Repeat)}) (play (do (move Add (to (sites Empty)) (then (enclose (from (last To)) Orthogonal (between if:(is Enemy (who at:(between))) (apply (remove (between))))))) ifAfterwards:(> (count Liberties Orthogonal) 0))) (end {(if (is Connected Mover) (result Mover Win)) (if (no Moves Next) (result Mover Win))}))) 
Players take turns placing a stone on an empty cell. A player wins as soon as some or all of their stones form a group with the following property: If all the cells of that group where removed (imagined away) from the board, none of the resulting partitions of the board would contain a majority of the set of cells comprising both the center cell and the perimeter cells (a majority relative to the entire intact board, that is, not of the imagined result of partitioning it). A size 7 board is currently selected
(game "Gyre" (players 2) (equipment {(board (hex 7)) (piece "Disc" Each)}) (rules (meta (swap)) (play (move Add (to (sites Empty)))) (end (if (>= (count Sites in:(union (sites Outer) (sites {(centrePoint)}))) (max (results from:(difference (sites Board) (sites Group at:(last To))) to:2 (* (to) (count Sites in:(intersection (union (sites Outer) (sites {(centrePoint)})) (sites Group at:(from) if:(not (is In (to) (sites Group at:(last To))))))))))) (result Mover Win))))) 
Players take turns placing pieces on the board. There are three winning conditions: 1. Connect any three edges (without corner points), or 2. Make a bridge connection between any two corners, or 3. loop around any site. The game is played on a 8x8 board The game does not use the swap rule.
(game "Havannah" (players 2) (equipment {(board (hex 8)) (piece "Marker" Each)}) (rules (play (move Add (to (sites Empty)))) (end (if (or {(is Loop) (is Connected 3 SidesNoCorners) (is Connected 2 Corners)}) (result Mover Win))))) 
Players take turns placing a piece of their colour at an empty cell, and win by connecting their board sides with a chain of their pieces. The game is played on a 11x11 board. The game uses the swap rule. The first player to connect their two sides wins.
(game "Hex" (players 2) (equipment {(board (hex Diamond 11)) (piece "Marker" Each) (regions P1 {(sites Side NE) (sites Side SW)}) (regions P2 {(sites Side NW) (sites Side SE)})}) (rules (meta (swap)) (play (move Add (to (sites Empty)))) (end (if (is Connected Mover) (result Mover Win))))) 
Players take turns placing two pieces of their colour on empty cells. White places only one stone on their first turn. A player wins by connecting all three board sides with a connected group of their pieces. Played on a size 13 board. The first player to connect all three sides wins.
(game "Master Y" (players 2) (equipment {(board (hex Triangle 13)) (piece "Disc")}) (rules phases:{(phase "Opening" P1 (play (move Add (to (sites Empty)))) (nextPhase "Playing")) (phase "Playing" (play (move Add (to (sites Empty)) (then (if (= 0 (count MovesThisTurn)) (moveAgain))))))} (end (if (is Connected 3 Sides) (result Mover Win))))) 
The initial setup has four black pieces and four white pieces pre-placed. Black moves first by placing a black piece on any empty point of the board. White follows suit. Turns continue to alternate. A piece can be placed on the midpoint of a square only if all four corners of that square are currently unoccupied. Once placed, pieces do not move. Captured pieces are immediately removed from the game. The rule for capturing allows a player to capture two enemy pieces in a single turn. All of the following conditions must be met: - the two enemy pieces occupy opposite corners of a square; - a third corner of the square is already occupied by a piece owned by the capturing player; - the square's midpoint is unoccupied. The capture is executed by placing a piece on the remaining unoccupied corner of the square. If the capturing move also simultaneously completes a second square on the board where the same conditions prevail, then the move results in the capture of four enemy pieces instead of two. Black tries to connect the two horizontal (black) sides with an unbroken chain of black pieces, while White tries to connect the two vertical (white) sides with an unbroken chain of white pieces. The first to do so wins the game.
(game "Onyx" (players 2) (equipment {(board (keep (rotate -45 (subdivide (tiling T33434 7 7) min:4)) (poly {{-6.5 1.75} {-6.5 12.75} {4.5 12.75} {4.5 1.75}})) use:Vertex) (piece "Disc" Each) (regions P1 {(sites Side W) (sites Side E)}) (regions P2 {(sites Side N) (sites Side S)})}) (rules (start {(place "Disc1" (sites {15 24 119 128})) (place "Disc2" (sites {20 27 116 123}))}) (play (move Add (to (forEach (sites Empty) if:(if (is In (site) (forEach (sites Board) if:(and (= 4 (count Sites in:(sites Around (site)))) (not (is In (site) (sites Outer)))))) (all Sites (sites Around (site)) if:(is Empty (site))) True))) (then (forEach Site (forEach (sites Board) if:(and (= 4 (count Sites in:(sites Around (site)))) (not (is In (site) (sites Outer))))) (if (and {(is Empty (site)) (is In (last To) (sites Around (site))) (all Sites (sites Around (site)) if:(is Occupied (site))) (= 2 (count Sites in:(forEach (sites Around (site)) if:(is Enemy (who at:(site)))))) (= 2 (count Sites in:(forEach (sites Around (site)) if:(and (is In (site) (sites Around (last To))) (is Enemy (who at:(site)))))))}) (remove (forEach (sites Around (site)) if:(is Enemy (who at:(site)))))))))) (end (if (is Connected Mover) (result Mover Win))))) 
This game is played on a square grid board of any size, though 13x13 or 19x19 are recommended. Then the players take it in turns to place 1-3 White stones each turn until one decides to pass; that player then becomes White, and the other becomes Black. After that, Black places two stones per turn on any empty point, while White places just one White stone per turn. If Black connects any two sides of the board with a single orthogonally-connected group, they win; White wins if they connect all four sides with a group connected either orthogonally or diagonally. During the initial chicken ballot phase, you may add stones by clicking on available spaces, or skip the rest of your placements (by choosing the Next Player action). Alternatively, you may Pass at the start of your turn to take White. After that, play continues with White playing one stone and Black playing two, until one player forms a connection (draws are impossible). Played on a size 13 board.
(game "Pippinzip (Zipline variant)" (players 2) (equipment {(board (square 13) use:Vertex) (piece "Disc" Each)}) (rules phases:{(phase "Opening" (play (or (or (move Add (piece (id "Disc" P2)) (to (sites Empty)) (then (if (< (count MovesThisTurn) 2) (moveAgain)))) (move Set NextPlayer (player (next)))) (if (= (count MovesThisTurn) 0) (move Pass (then (if (is Mover P1) (swap Players P1 P2 (then (note "Player 1 is now White. Player 2 is now Black." to:All))) (note "Player 1 is now Black. Player 2 is now White." to:All) (then (do (set NextPlayer (player 1)) next:(set Var 1))))))))) (nextPhase (= 1 (var)) "Playing")) (phase "Playing" (play (or (move Add (to (sites Empty) if:(= (id P1) (mover))) (then (if (= 0 (count MovesThisTurn)) (moveAgain)))) (move Add (to (sites Empty) if:(= (id P2) (mover)))))))} (end {(if (and (not (= 1 (var))) (is Connected All {(sites Side N) (sites Side S) (sites Side E) (sites Side W)})) (result Mover Win)) (if (and {(= (id P1) (mover)) (or (is Connected Orthogonal {(sites Side N) (sites Side S)}) (is Connected Orthogonal {(sites Side E) (sites Side W)}))}) (result P1 Win)) (if (and {(= (id P2) (mover)) (is Connected All {(sites Side N) (sites Side S) (sites Side E) (sites Side W)})}) (result P2 Win))}))) 
This game is played on a square grid board of any size, though 13x13 or 19x19 are recommended. Then the players take it in turns to place 1-3 black stones each turn until one decides to pass; that player then becomes Black, and the other becomes White. After that, players take it in turns to place one stone of their colour on the board on any empty point. If Black connects any two sides of the board with a single orthogonally-connected group, they win; White wins if they connect all four sides with a group connected either orthogonally or diagonally. During the initial chicken ballot phase, you may add stones by clicking on available spaces, or skip the rest of your placements (by choosing the Next Player action). Alternatively, you may Pass at the start of your turn to take Black. After that, you and your opponent will alternate playing one stone of your colour per turn, until one player forms a connection (draws are impossible in Pippinzip). Played on a size 13 board.
(game "Pippinzip" (players 2) (equipment {(board (square 13) use:Vertex) (piece "Disc" Each)}) (rules phases:{(phase "Opening" (play (or (or (move Add (piece (id "Disc" P2)) (to (sites Empty)) (then (if (< (count MovesThisTurn) 2) (moveAgain)))) (move Set NextPlayer (player (next)))) (if (= (count MovesThisTurn) 0) (move Pass (then (if (is Mover P1) (swap Players P1 P2 (then (note "Player 1 is now Black. Player 2 is now White." to:All))) (note "Player 1 remains White. Player 2 remains Black." to:All) (then (do (set NextPlayer (player 1)) next:(set Var 1))))))))) (nextPhase (= 1 (var)) "Playing")) (phase "Playing" (play (move Add (to (sites Empty)))))} (end {(if (and (not (= 1 (var))) (or (is Connected Orthogonal {(sites Side N) (sites Side S)}) (is Connected Orthogonal {(sites Side E) (sites Side W)}))) (result Mover Win)) (if (and {(= (id P2) (mover)) (or (is Connected Orthogonal {(sites Side N) (sites Side S)}) (is Connected Orthogonal {(sites Side E) (sites Side W)}))}) (result P2 Win)) (if (and {(= (id P1) (mover)) (is Connected All {(sites Side N) (sites Side S) (sites Side E) (sites Side W)})}) (result P1 Win))}))) 
Resolve is a connection game for two players: a player with Black stones who wins by connecting the East/West sides, and a player with White stones who wins by connecting the North/South sides. Players take turns placing and swapping stones on the intersections of a square grid which is initially empty. Passing is forbidden. Same-colored stones with orthogonal adjacency are connected. The game is over when a player wins by connecting their designated sides of the board with a single group of connected stones of their color, at any time during their turn or their opponent's turn. Cutting stones are any four stones in a generic crosscut configuration. OX XO On your turn you must select the following one of two actions. 1. Place a stone of your color on an empty point. If that stone creates a crosscut, swap it with different adjacent enemy stones that share a crosscut with it, until that stone is no longer part of a crosscut. 2. Choose a stone of your color that is part of a crosscut, and use it to resolve crosscuts as in 1. Then place a stone of your color on an empty point, if possible. Order 9 board
(game "Resolve" (players 2) (equipment {(board (square 9) use:Vertex) (regions P1 {(sites Side N) (sites Side S)}) (regions P2 {(sites Side W) (sites Side E)}) (piece "Ball" P1) (piece "Ball" P2)}) (rules (play (if (not (is Prev Mover)) (or (move Add (to (sites Empty)) (then (if (and (not (is Prev Mover)) (< 0 (count Sites in:(sites (results from:(last To) to:(sites Around (from) Diagonal if:(and (is Mover (who at:(to))) (= 2 (count Pieces Next in:(intersection (sites Around (to) Orthogonal) (sites Around (from) Orthogonal)))))) (to)))))) (set Var "LT" (last To) (then (moveAgain))) (set Var "LT" -1)))) (forEach Site (sites Occupied by:Mover) (do (set Var "LT" (site)) next:(forEach Site (intersection (sites Around (var "LT") Orthogonal) (sites Around (sites (results from:(var "LT") to:(sites Around (from) Diagonal if:(and (is Mover (who at:(to))) (= 2 (count Pieces Next in:(intersection (sites Around (to) Orthogonal) (sites Around (from) Orthogonal)))))) (to))) Orthogonal)) (move (from (var "LT")) (to (site) if:(!= (last From) (to)) (apply (remove (site)))) (then (and (add (piece (id "Ball" Next)) (to (var "LT"))) (set Var "LT" (last To) (then (if (< 0 (count Sites in:(sites (results from:(var "LT") to:(sites Around (from) Diagonal if:(and (is Mover (who at:(to))) (= 2 (count Pieces Next in:(intersection (sites Around (to) Orthogonal) (sites Around (from) Orthogonal)))))) (to))))) (set NextPlayer (player (mover))) (set Var "LT" -1))))))))))) (if (<= 0 (var "LT")) (forEach Site (intersection (sites Around (var "LT") Orthogonal) (sites Around (sites (results from:(var "LT") to:(sites Around (from) Diagonal if:(and (is Mover (who at:(to))) (= 2 (count Pieces Next in:(intersection (sites Around (to) Orthogonal) (sites Around (from) Orthogonal)))))) (to))) Orthogonal)) (move (from (var "LT")) (to (site) if:(!= (last From) (to)) (apply (remove (site)))) (then (and (add (piece (id "Ball" Next)) (to (var "LT"))) (set Var "LT" (last To) (then (if (< 0 (count Sites in:(sites (results from:(var "LT") to:(sites Around (from) Diagonal if:(and (is Mover (who at:(to))) (= 2 (count Pieces Next in:(intersection (sites Around (to) Orthogonal) (sites Around (from) Orthogonal)))))) (to))))) (set NextPlayer (player (mover))) (set Var "LT" -1)))))))) (move Add (to (sites Empty)) (then (if (and (not (is Prev Mover)) (< 0 (count Sites in:(sites (results from:(last To) to:(sites Around (from) Diagonal if:(and (is Mover (who at:(to))) (= 2 (count Pieces Next in:(intersection (sites Around (to) Orthogonal) (sites Around (from) Orthogonal)))))) (to)))))) (set Var "LT" (last To) (then (moveAgain))) (set Var "LT" -1))))))) (end {(if (is Connected Orthogonal Mover) (result Mover Win))}))) 
Definitions Group: Either a single stone (a group of one) or any number of stones of the same color connected through a continuous series of orthogonal adjacencies. Rules Scaffold is a drawless connection game played on the intersections of a square grid using stones (as in Go). Black is trying to connect N-S edges of the board, White E-W with an orthogonally connected group. First player places a single black stone on any grid intersection, after which the second player decides which color they will play (pie rule). Players then alternate taking turns. On your turn, place a stone of your color on an empty point. Then, if possible, place a stone of your color on an empty point that is orthogonally adjacent to two groups of your color, and keep making such placements until no more are possible. A 12x12 board is currently selected
(game "Scaffold" (players 2) (equipment {(board (square 12) use:Vertex) (piece "Marker" Each) (regions P1 {(sites Side N) (sites Side S)}) (regions P2 {(sites Side W) (sites Side E)})}) (rules (meta (swap)) (play (if (< 0 (count MovesThisTurn)) (do (move Add (to (sites Around (sites Occupied by:Mover) Empty) (apply (set Var "NumberOfFriendlyGroupsBeforePlacement" (count Groups Orthogonal if:(is Mover (who at:(to)))))))) ifAfterwards:(< (count Groups Orthogonal if:(is Mover (who at:(to)))) (var "NumberOfFriendlyGroupsBeforePlacement"))) (move Add (to (sites Empty))) (then (if (can Move (do (move Add (to (sites Around (sites Occupied by:Mover) Empty) (apply (set Var "NumberOfFriendlyGroupsBeforePlacement" (count Groups Orthogonal if:(is Mover (who at:(to)))))))) ifAfterwards:(< (count Groups Orthogonal if:(is Mover (who at:(to)))) (var "NumberOfFriendlyGroupsBeforePlacement")))) (moveAgain))))) (end (if (is Connected Orthogonal Mover) (result Mover Win))))) 
Players take turns placing one piece of their colour on empty cells; the piece they place may not be adjacent to the last piece placed by their opponent. A player wins by connecting all three board sides with a connected group of their pieces. Played on a size 11 board. The first player to connect all three sides wins.
(game "Tabu Y" (players 2) (equipment {(board (hex Triangle 11)) (piece "Disc")}) (rules (play (move Add (to (sites Empty) if:(not (is In (to) (sites Around (last To))))))) (end (if (is Connected 3 Sides) (result Mover Win))))) 
MOVE - Each player inserts a stone onto the board from an edge. Black inserts from top and pushes from top to bottom, White inserts from left and pushes from left to right. - Black starts with a stone on the top-left corner. - Passing is not allowed - If a stone, when pushed meets another stone, this too is pushed on the same direction, and so on... EDGE - A stone pushed off the edge during a push is returned to the player (there are no captures). If it is an opponent stone, this row/column cannot be used on the next turn (friendly stones do not have such restriction). GOAL - Wins the player which makes a path between the edges (top-bottom for Black, right-left for White). Stones may be connected orthogonal or diagonal.
(game "Tara" (players 2) (equipment {(board (square 5) use:Vertex) (piece "Ball" Each) (regions P1 {(sites Top) (sites Bottom)}) (regions P2 {(sites Left) (sites Right)})}) (rules phases:{(phase "Opening" (play (move Add (to (intersection (sites Top) (sites Left))))) (nextPhase "Main")) (phase "Main" (play (if (is Mover P1) (move Select (from (sites Top) if:(not (is In (column of:(from)) (sites Pending)))) (then (and {(if (is Enemy (who at:(coord row:0 column:(column of:(last From))))) (set Pending (row of:(coord row:0 column:(column of:(last From)))))) (push (from (last To)) S) (add (piece (id "Ball" Mover)) (to (last To)))}))) (move Select (from (sites Left) if:(not (is In (row of:(from)) (sites Pending)))) (then (and {(if (is Enemy (who at:(coord row:(row of:(last From)) column:(- (count Columns) 1)))) (set Pending (column of:(coord row:(row of:(last From)) column:(- (count Columns) 1))))) (push (from (last To)) E) (add (piece (id "Ball" Mover)) (to (last To)))}))))))} (end {(if (!= 0 (count Sites in:(forEach (sites Occupied by:P1) if:(is Connected at:(site) All P1)))) (result P1 Win)) (if (!= 0 (count Sites in:(forEach (sites Occupied by:P2) if:(is Connected at:(site) All P2)))) (result P2 Win))}))) 
Three-Player Hex is played on the Hex board, typically with five cells per side. As in standard Hex, players take turn placing a piece of their color on an empty cell, and the first player to connect the opposite sides of the board marked his color with a chain of his pieces wins. As soon as it it no longer possible for a player to connect his edges, that player is eliminated from the game and may not place any more stones. The game is played on a 4x4 board The first player to connect his two sides wins.
(game "Three-Player Hex" (players 3) (equipment {(board (hex 4)) (piece "Marker" Each) (regions P1 {(sites Side N) (sites Side S)}) (regions P2 {(sites Side NW) (sites Side SE)}) (regions P3 {(sites Side SW) (sites Side NE)})}) (rules (play (move Add (to (sites Empty)))) (end {(forEach NonMover if:(is Blocked Player) (result Player Loss)) (if (is Connected Mover) (result Mover Win))}))) 
The rules of TRAX are simple: - Place tiles adjacent to those already in play such that the colours of the tracks match. - The objective is to get a loop or line of your colour while attempting to stop your opponent in their colour. - A line is a continuous path of track that connects opposite and outermost edges of the tiles in play, over at least 8 rows of tiles, across or down. - What gives Trax its strategic depth is the forced play rule which allows (or even requires) multiple tiles to be played in a turn. 
(game "Trax" (players 2) (equipment {(boardless Square) (hand Shared size:2) (tile "TileX" numSides:4 {(path from:0 to:2 colour:1) (path from:1 to:3 colour:2)}) (tile "TileCurved" numSides:4 {(path from:0 to:1 colour:1) (path from:2 to:3 colour:2)})}) (rules (meta (automove)) (start {(place "TileX" (handSite Shared)) (place "TileCurved" (handSite Shared 1))}) phases:{(phase "Opening" (play (or (move (from (handSite Shared)) (to (centrePoint) (rotations {N E})) copy:True) (move (from (handSite Shared 1)) (to (centrePoint) (rotations Orthogonal)) copy:True))) (nextPhase "Connection")) (phase "Connection" (play (do (or (move (from (handSite Shared)) (to (sites Around (sites Occupied by:All) Orthogonal if:(is Empty (to))) (rotations {N E})) copy:True) (move (from (handSite Shared 1)) (to (sites Around (sites Occupied by:All) Orthogonal if:(is Empty (to))) (rotations Orthogonal)) copy:True)) ifAfterwards:(is SidesMatch))) (end {(if (or (is Loop (mover) path:True) (<= (/ 32 4) (pathExtent (mover)))) (result Mover Win)) (if (or (is Loop (next) path:True) (<= (/ 32 4) (pathExtent (next)))) (result Next Win)) (if (>= (count Sites in:(sites Occupied by:All)) (* (count Players) 32)) (result Mover Draw))}))})) 
EDGES - Each player owns two opposite edges, say, the first player has top and bottom edges, while the second player has left and right edges. DROP - Each player drops one of his stones on an empty cell. - If at least one opponent stone is between that stone and another friendly stone (orthogonal or diagonal), then all opponent stones that were between those stones flip their colour. - Stones cannot be dropped on the opponent's edges (including corners). GOAL - Wins the first player who manages to do a path connecting his two opposite edges. - Two tiles diagonally aside are not continuous in a path. - The corners belong to both edges.
(game "Troll" (players 2) (equipment {(board (square 8)) (piece "Ball" Each) (regions P1 {(sites Top) (sites Bottom)}) (regions P2 {(sites Left) (sites Right)})}) (rules (play (move Add (to (if (is Mover P1) (difference (sites Empty) (union (sites Left) (sites Right))) (difference (sites Empty) (union (sites Top) (sites Bottom))))) (then (custodial (from (last To)) (between if:(is Enemy (who at:(between))) (apply (and (remove (between)) (add (piece (id "Ball" Mover)) (to (between)))))) (to if:(is Friend (who at:(to)))))))) (end {(if (!= 0 (count Sites in:(forEach (sites Occupied by:P1) if:(is Connected at:(site) Orthogonal P1)))) (result P1 Win)) (if (!= 0 (count Sites in:(forEach (sites Occupied by:P2) if:(is Connected at:(site) Orthogonal P2)))) (result P2 Win))}))) 
This game is played on a hexagonal board made up of hexagonal squares, usually 6 squares per side, although other sizes are possible. Initially the board is empty and black pieces are placed in turns until one player passes. The player who passed becomes Black. The other player becomes White and takes the next turn. Play continues, with each player in turn placing pieces of their colour on unoccupied squares on the board. White wins if they manage to connect two opposite sides of the board. Black wins if they manage to connect three non-adjacent sides of the board. To avoid ties, if a player meets the opponent's goal with their pieces, they lose the game. The game is played on a board with 6 hexes per side. You cannot place stones on the edge in the opening phase.
(game "Unlur" (players 2) (equipment {(board (hex 6)) (piece "Disc" Each)}) (rules phases:{(phase "Opening" (play (or (move Add (piece (id "Disc" P2)) (to (intersection (sites Empty) (sites Inner)))) (move Pass (then (if (is Mover P1) (swap Players P1 P2 (then (note "Player 1 is now Black. Player 2 is now White." to:All))) (note "Player 1 remains White. Player 2 remains Black." to:All) (then (do (set NextPlayer (player 1)) next:(set Var 1)))))))) (nextPhase (= 1 (var)) "Playing")) (phase "Playing" (play (move Add (to (sites Empty)))))} (end {(if (and {(= 1 (var)) (= (id P1) (mover)) (or (is Connected {(sites Side S) (sites Side NW) (sites Side NE)}) (is Connected {(sites Side N) (sites Side SW) (sites Side SE)})) (not (or {(is Connected {(sites Side S) (sites Side N)}) (is Connected {(sites Side SW) (sites Side NE)}) (is Connected {(sites Side SE) (sites Side NW)})}))}) (result P1 Loss)) (if (and {(= 1 (var)) (= (id P2) (mover)) (or {(is Connected {(sites Side S) (sites Side N)}) (is Connected {(sites Side SW) (sites Side NE)}) (is Connected {(sites Side SE) (sites Side NW)})}) (not (or (is Connected {(sites Side S) (sites Side NW) (sites Side NE)}) (is Connected {(sites Side N) (sites Side SW) (sites Side SE)})))}) (result P2 Loss)) (if (and {(= 1 (var)) (= (id P1) (mover)) (or {(is Connected {(sites Side S) (sites Side N)}) (is Connected {(sites Side SW) (sites Side NE)}) (is Connected {(sites Side SE) (sites Side NW)})})}) (result P1 Win)) (if (and {(= 1 (var)) (= (id P2) (mover)) (or (is Connected {(sites Side S) (sites Side NW) (sites Side NE)}) (is Connected {(sites Side N) (sites Side SW) (sites Side SE)}))}) (result P2 Win))}))) 
Players take turns placing their pieces on a space on the board, with the goal of connecting all three sides of the triangle with their pieces. Corners count as belonging to both sides they touch.
(game "Y (Hex)" (players 2) (equipment {(board (tri Hexagon 7) use:Vertex) (piece "Marker" Each) (regions "SSW" {(sites Side S) (sites Side SW)}) (regions "NNW" {(sites Side NW) (sites Side N)}) (regions "NESE" {(sites Side NE) (sites Side SE)})}) (rules (play (move Add (to (sites Empty)))) (end (if (is Connected {(sites "SSW") (sites "NNW") (sites "NESE")}) (result Mover Win))))) 
Players take turns placing a piece of their colour on an empty cell. A player wins by connecting all three board sides with a connected group of their pieces. Played on a size 11 board. The first player to connect all three sides wins.
(game "Y" (players 2) (equipment {(board (hex Triangle 11)) (piece "Disc")}) (rules (play (move Add (to (sites Empty)))) (end (if (is Connected 3 Sides) (result Mover Win))))) 
Goal: You try to both reduce the number of your own groups as much as possible, and also to block your opponent's ability to reduce his groups down to fewer than yours. Whoever decides to end the game must fill the empty spaces with opponent's pieces, and only then, wins by having equal or fewer groups. Play: Starting with the board empty, player's take turns placing a piece of their color on an empty position that does not abut any friendly piece. If it is impossible to place a piece, the player, instead, moves a piece to the first empty position in any direction. But whenever a new opportunity for placement is available, the turn must be used for placement. Ending the Game: The game ends at the choice of the player about to move, but only at the beginning of a turn in which there is no forced placement. Before scoring, the empty spaces are filled with the opponent's pieces. The player who ended the game wins unless the opponent has fewer groups. Because the empty spaces are filled with opponent's pieces, a player who ends the game too soon will lose. On the other hand, since ties go to the player who ends the game, it is important to end the game as soon as you can actually win. Variations: Options are available to select the board size, and also to use other movement rules, instead of the standard one. Board & size: Hexhex with edges alternately 2 and 3 Movement: Pieces step or jump once, to the first empty position in that direction.
(game "Abrobad" (players 2) (equipment {(board (hex Limping 2)) (piece "Hex" Each)}) (rules (play (priority (move Add (to (sites Empty) if:(= 0 (count Sites in:(sites Around (to) Own))))) (or (forEach Piece (move Hop (between (range 0 18) if:(is Occupied (between))) (to if:(is Empty (to))))) (move Propose "Conclude" (then (if (is Proposed "Conclude") (add (piece (next)) (to (sites Empty)) (then (and (set Score Mover (count Groups if:(= (who at:(to)) (mover)))) (set Score Next (count Groups if:(= (who at:(to)) (next))))))))))))) (end (if (is Proposed "Conclude") (if (<= (score Mover) (score Next)) (result Mover Win)) (result Next Win))))) 
Goal: Score the most points: -- One point for each stone in one's largest group. -- Bonus points are also added to the scores according to the selected option. The board starts empty. Players take turns in alternation, placing one of their own stones onto an empty site. Restriction on placement: Every site of the board must remain connected to an empty perimeter site via a continuous path of empty sites. There is no passing. The game ends when no more placements can be made. Players score one point for every stone in their largest group, then, if applicable, score bonus points according to the selected option. Bonus Options are: -- Count of one's own groups. Standard -- Count of the opponent's groups -- No Bonus The player with the higher score wins. If the scores are tied, the game is decided by the tiebreaker option used: A: Cascading largest group LOSES -- i.e. negative scores -- This excludes tied pairs; If all groups are paired, last to place. B: Last player to have placed a stone. Order 5 board - about 20 moves each Hex N / N-1 Grid, about 20% less moves Scoring Option: Score the size of your largest group, then score an additional point for every group you have on the board. Tiebreaker is largest group (excluding tied pairs) LOSES. If all are paired, last placement wins.
(game "Brain Coral" (players 2) (equipment {(board (hex Limping (- 5 1)) use:Cell) (piece "Ball" Each) (piece "Disc" Each)}) (rules (start (set Score Each 0)) (play (do (move Add (to (sites Empty))) ifAfterwards:(all Sites (sites Around (last To) Orthogonal includeSelf:True) if:(or (and (is Empty (site)) (is In (site) (sites Outer))) (!= Infinity (count Steps (step Orthogonal (to if:(is Empty (to)))) (site) (difference (sites Outer) (site)))))) (then (set Var "MoverScore" (+ (max 0 (max (sizes Group Orthogonal Mover))) (count Groups Orthogonal if:(= (who at:(to)) (mover)))) (then (set Var "NextScore" (+ (max 0 (max (sizes Group Orthogonal Next))) (count Groups Orthogonal if:(= (who at:(to)) (next)))) (then (if (= (var "MoverScore") (var "NextScore")) (and (set Score Mover (* -1 (max 0 (max (difference (sizes Group Orthogonal Mover) (sizes Group Orthogonal Next)))))) (set Score Next (* -1 (max 0 (max (difference (sizes Group Orthogonal Next) (sizes Group Orthogonal Mover))))))) (and (set Score Mover (var "MoverScore")) (set Score Next (var "NextScore"))))))))))) (end (if (no Moves Next) {(if (= (score Mover) (score Next)) (result Mover Win)) (if (!= (score Mover) (score Next)) (byScore))})))) 
Definitions: 1 A group is a stone along with all stones one can reach from it through a series of steps onto adjacent stones of the same color. 1.1 The size of a group is the number of stones in it. 2 A brood is a group along with all other groups of identical color, size and shape. Shapes are considered identical across symmetries (just like in Bug). 2.1 The size of a brood is the number of groups in it. 2.2 The order of a brood is the size of the groups in it. 2.3 The mass of a brood is the number of stones in it (its size times its order). Play: On the very first turn of the game, Black places one stone of their colour on any hex. After, that – starting with White – take turns doing one of the following: - Pass. - Place two stones of your colour on empty hexes. When the players pass consecutively, the winner is the player with the higher score. Scoring: For each of your broods, you score its mass multiplied by the lesser of its size and its order. For example, if a brood consists of 2 groups of size 3, it is worth 12 points. Its order is 3, its size is 2 and its mass is 6. Since 2 is smaller than 3, the brood is worth 6*2 = 12. A boad of size 5 is currently selected. Nothing is currently printed on the pieces. The 12* placement protocol is currently in effect. This is the protocol described in the rules above.
(game "Brood" (players 2) (equipment {(board (hex Hexagon 5) use:Cell) (piece "Hex" Each maxState:7 maxValue:1023) (piece "Disc" Neutral) (hand Shared)}) (rules (play (if (or (= 0 (count Moves)) (!= 0 (count MovesThisTurn))) (do (forEach Site (sites Occupied by:Mover) (set State at:(site) 0)) next:(move Add (piece (id "Hex" Mover)) (to (sites Empty)) (then (set Var "LastRow" (row of:(max (array (sites Group at:(last To))))) (then (set Var "LastCol" (max (results from:(sites Group at:(last To)) to:(from) (column of:(from)))) (then (forEach Site (sites Group at:(last To)) (set Value at:(site) (+ (* 32 (- (var "LastRow") (row of:(site)))) (- (var "LastCol") (column of:(site)))))))))))) (then (forEach Group if:(= (mover) (who at:(to))) (remember Value (regionSite (sites) index:0) unique:True) (then (and {(forEach Value (values Remembered) (and {(set Var "KeySite" (value) (then (forEach Group if:(= (mover) (who at:(to))) (if (= (size Array (array (sites))) (size Array (array (sites Group at:(var "KeySite"))))) (priority {(if (= 0 (size Array (difference (results from:(sites Group at:(var "KeySite")) to:(from) (+ (+ (* 32 (/ (value Piece at:(from)) 32)) (% (value Piece at:(from)) 32)) (+ (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (* 32 (/ (value Piece at:(from)) 32))))) (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (% (value Piece at:(from)) 32))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (remember Value "ShapeCount" (var "KeySite"))) (if (= 0 (size Array (difference (results from:(sites Group at:(var "KeySite")) to:(from) (+ (+ (* 32 (/ (value Piece at:(from)) 32)) (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (* 32 (/ (value Piece at:(from)) 32))))) (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (remember Value "ShapeCount" (var "KeySite"))) (if (= 0 (size Array (difference (results from:(sites Group at:(var "KeySite")) to:(from) (+ (+ (* 32 (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32))) (/ (value Piece at:(from)) 32)) (+ (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (* 32 (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (/ (value Piece at:(from)) 32))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (remember Value "ShapeCount" (var "KeySite"))) (if (= 0 (size Array (difference (results from:(sites Group at:(var "KeySite")) to:(from) (+ (+ (* 32 (% (value Piece at:(from)) 32)) (/ (value Piece at:(from)) 32)) (+ (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (* 32 (% (value Piece at:(from)) 32))))) (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (/ (value Piece at:(from)) 32))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (remember Value "ShapeCount" (var "KeySite"))) (if (= 0 (size Array (difference (results from:(sites Group at:(var "KeySite")) to:(from) (+ (+ (* 32 (- (% (value Piece at:(from)) 32))) (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (* 32 (- (% (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (remember Value "ShapeCount" (var "KeySite"))) (if (= 0 (size Array (difference (results from:(sites Group at:(var "KeySite")) to:(from) (+ (+ (* 32 (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32))) (% (value Piece at:(from)) 32)) (+ (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (* 32 (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (% (value Piece at:(from)) 32))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (remember Value "ShapeCount" (var "KeySite"))) (if (= 0 (size Array (difference (results from:(sites Group at:(var "KeySite")) to:(from) (+ (+ (* 32 (- (/ (value Piece at:(from)) 32))) (- (% (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (* 32 (- (/ (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (- (% (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (remember Value "ShapeCount" (var "KeySite"))) (if (= 0 (size Array (difference (results from:(sites Group at:(var "KeySite")) to:(from) (+ (+ (* 32 (- (/ (value Piece at:(from)) 32))) (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (* 32 (- (/ (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (remember Value "ShapeCount" (var "KeySite"))) (if (= 0 (size Array (difference (results from:(sites Group at:(var "KeySite")) to:(from) (+ (+ (* 32 (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32))) (- (/ (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (* 32 (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (- (/ (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (remember Value "ShapeCount" (var "KeySite"))) (if (= 0 (size Array (difference (results from:(sites Group at:(var "KeySite")) to:(from) (+ (+ (* 32 (- (% (value Piece at:(from)) 32))) (- (/ (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (* 32 (- (% (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (- (/ (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (remember Value "ShapeCount" (var "KeySite"))) (if (= 0 (size Array (difference (results from:(sites Group at:(var "KeySite")) to:(from) (+ (+ (* 32 (% (value Piece at:(from)) 32)) (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (* 32 (% (value Piece at:(from)) 32))))) (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (remember Value "ShapeCount" (var "KeySite"))) (if (= 0 (size Array (difference (results from:(sites Group at:(var "KeySite")) to:(from) (+ (+ (* 32 (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32))) (- (% (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (* 32 (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (- (% (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (remember Value "ShapeCount" (var "KeySite")))})))))} (then (forEach Site (sites Group at:(var "KeySite")) (set State at:(site) (min (count Value (var "KeySite") in:(values Remembered "ShapeCount")) (size Group at:(var "KeySite"))))))) (then (forget Value All))) (set Score Mover 0 (then (forEach Piece (addScore Mover (state at:(from))))))}))))) (or (move Pass) (and {(do (forEach Site (sites Occupied by:Mover) (set State at:(site) 0)) next:(move Add (piece (id "Hex" Mover)) (to (sites Empty)) (then (set Var "LastRow" (row of:(max (array (sites Group at:(last To))))) (then (set Var "LastCol" (max (results from:(sites Group at:(last To)) to:(from) (column of:(from)))) (then (forEach Site (sites Group at:(last To)) (set Value at:(site) (+ (* 32 (- (var "LastRow") (row of:(site)))) (- (var "LastCol") (column of:(site)))))))))))) (then (forEach Group if:(= (mover) (who at:(to))) (remember Value (regionSite (sites) index:0) unique:True) (then (and {(forEach Value (values Remembered) (and {(set Var "KeySite" (value) (then (forEach Group if:(= (mover) (who at:(to))) (if (= (size Array (array (sites))) (size Array (array (sites Group at:(var "KeySite"))))) (priority {(if (= 0 (size Array (difference (results from:(sites Group at:(var "KeySite")) to:(from) (+ (+ (* 32 (/ (value Piece at:(from)) 32)) (% (value Piece at:(from)) 32)) (+ (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (* 32 (/ (value Piece at:(from)) 32))))) (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (% (value Piece at:(from)) 32))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (remember Value "ShapeCount" (var "KeySite"))) (if (= 0 (size Array (difference (results from:(sites Group at:(var "KeySite")) to:(from) (+ (+ (* 32 (/ (value Piece at:(from)) 32)) (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (* 32 (/ (value Piece at:(from)) 32))))) (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (remember Value "ShapeCount" (var "KeySite"))) (if (= 0 (size Array (difference (results from:(sites Group at:(var "KeySite")) to:(from) (+ (+ (* 32 (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32))) (/ (value Piece at:(from)) 32)) (+ (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (* 32 (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (/ (value Piece at:(from)) 32))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (remember Value "ShapeCount" (var "KeySite"))) (if (= 0 (size Array (difference (results from:(sites Group at:(var "KeySite")) to:(from) (+ (+ (* 32 (% (value Piece at:(from)) 32)) (/ (value Piece at:(from)) 32)) (+ (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (* 32 (% (value Piece at:(from)) 32))))) (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (/ (value Piece at:(from)) 32))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (remember Value "ShapeCount" (var "KeySite"))) (if (= 0 (size Array (difference (results from:(sites Group at:(var "KeySite")) to:(from) (+ (+ (* 32 (- (% (value Piece at:(from)) 32))) (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (* 32 (- (% (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (remember Value "ShapeCount" (var "KeySite"))) (if (= 0 (size Array (difference (results from:(sites Group at:(var "KeySite")) to:(from) (+ (+ (* 32 (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32))) (% (value Piece at:(from)) 32)) (+ (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (* 32 (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (% (value Piece at:(from)) 32))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (remember Value "ShapeCount" (var "KeySite"))) (if (= 0 (size Array (difference (results from:(sites Group at:(var "KeySite")) to:(from) (+ (+ (* 32 (- (/ (value Piece at:(from)) 32))) (- (% (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (* 32 (- (/ (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (- (% (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (remember Value "ShapeCount" (var "KeySite"))) (if (= 0 (size Array (difference (results from:(sites Group at:(var "KeySite")) to:(from) (+ (+ (* 32 (- (/ (value Piece at:(from)) 32))) (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (* 32 (- (/ (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (remember Value "ShapeCount" (var "KeySite"))) (if (= 0 (size Array (difference (results from:(sites Group at:(var "KeySite")) to:(from) (+ (+ (* 32 (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32))) (- (/ (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (* 32 (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (- (/ (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (remember Value "ShapeCount" (var "KeySite"))) (if (= 0 (size Array (difference (results from:(sites Group at:(var "KeySite")) to:(from) (+ (+ (* 32 (- (% (value Piece at:(from)) 32))) (- (/ (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (* 32 (- (% (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (- (/ (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (remember Value "ShapeCount" (var "KeySite"))) (if (= 0 (size Array (difference (results from:(sites Group at:(var "KeySite")) to:(from) (+ (+ (* 32 (% (value Piece at:(from)) 32)) (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (* 32 (% (value Piece at:(from)) 32))))) (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (remember Value "ShapeCount" (var "KeySite"))) (if (= 0 (size Array (difference (results from:(sites Group at:(var "KeySite")) to:(from) (+ (+ (* 32 (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32))) (- (% (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (* 32 (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (- (% (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (remember Value "ShapeCount" (var "KeySite")))})))))} (then (forEach Site (sites Group at:(var "KeySite")) (set State at:(site) (min (count Value (var "KeySite") in:(values Remembered "ShapeCount")) (size Group at:(var "KeySite"))))))) (then (forget Value All))) (set Score Mover 0 (then (forEach Piece (addScore Mover (state at:(from))))))})))))} (then (moveAgain)))) (then (forget Value All)))) (end (if (all Passed) (byScore))))) 
Players take turns placing a stone of their own color on any empty cell of a hexagonal grid of hexagons (a hexhex board). The game is over when the board is full, and the player with the lower score wins. Your score is 1 point per odd-sized group and 2 points even-sized group. In this implementation, you get -1 per odd-sized group and -2 per even-sized group, so the winner will be the player with the higher score. The score is currently updated after each move, and groups of even size are marked with a red outline. A size 5 board is currently selected
(game "Elea" (players 2) (equipment {(board (hex 5)) (piece "Disc" Each)}) (rules (meta (swap)) (play (move Add (to (sites Empty)) (then (and (set Score Mover 0) (forEach Group Orthogonal if:(is Mover (who at:(to))) (if (is Odd (count Sites in:(sites))) (and (addScore Mover -1) (forEach Site (sites) (set State at:(site) 0))) (and (addScore Mover -2) (forEach Site (sites) (set State at:(site) 1))))))))) (end (if (is Full) (byScore))))) 
The game is played in turns. White starts by placing the breadcrumb on any empty space on the board. Now, any and every duck in the six lines radiating out from the breadcrumb move straight toward the breadcrumb as far as they can. There will never be more than one duck in a space, and the ducks stop just before they reach the breadcrumb (a fish gets it first). Then the turn passes to the next player. From now on, on your turn, you must take the breadcrumb and place it on an empty space of the board that is not on any of the six lines radiating from the breadcrumb's previous location and then move the ducks toward the breadcrumb as usual. The game ends when all the ducks of one colour have gathered into a single connected group. In case of both groups (White and Black) are created simultaneously, the player who placed the game-ending breadcrumb wins.
(game "Feed the Ducks" (players 2) (equipment {(board (hex 5)) (piece "Marker" Each) (piece "Disc" Neutral)}) (rules (start {(place "Marker1" {"A5" "C7" "D8" "F9" "H9" "I9" "I7" "I5" "F2" "C1" "A1" "A2"}) (place "Marker2" {"A4" "A3" "B1" "D1" "E1" "G3" "H4" "I6" "I8" "G9" "E9" "B6"})}) phases:{(phase "Throw Bread" (play (move Add (piece "Disc0") (to (sites Empty)) (then (attract (from (last To)))))) (nextPhase "Move Bread")) (phase "Move Bread" (play (move (from (sites Occupied by:Neutral)) (to (difference (sites Empty) (sites Direction from:(last To)))) (then (attract (from (last To)))))))} (end {(if (= 1 (count Groups if:(= (who at:(to)) P1))) (result P1 Win)) (if (= 1 (count Groups if:(= (who at:(to)) P2))) (result P2 Win))}))) 
Pieces move to any adjacent empty square or jumping one of their pieces over an adjacent piece to the empty point immediately beyond. The game is won by the first player to move all six pieces into a single orthogonally connected group
(game "Groups" (players 2) (equipment {(board (square 8)) (piece "Disc" Each (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Occupied (between))) (to if:(is Empty (to))))))}) (rules (start {(place "Disc1" {"D3" "C4" "E4" "D5" "F5" "E6"}) (place "Disc2" {"E3" "D4" "F4" "C5" "E5" "D6"})}) (play (forEach Piece)) (end (if (= 1 (count Groups Orthogonal if:(= (who at:(to)) Mover))) (result Mover Win))))) 
Each turn you must perform exactly one of the following two actions: 1. Add a friendly piece orthogonally adjacent to one of your pieces. 2. Remove an enemy group. As soon as one player only has 1 group, the game is over and that player is the winner. A size 10 board is currently selected
(game "Gygoreg" (players 2) (equipment {(board (square Diamond 10)) (piece "Disc" Each)}) (rules (start {(place "Disc1" (forEach (sites Phase 0) if:(is Odd (site)))) (place "Disc2" (forEach (sites Phase 0) if:(is Even (site))))}) (play (or (move Add (to (sites Around (sites Occupied by:Mover) Empty Orthogonal))) (move Select (from (sites Occupied by:Enemy)) (then (forEach Site (sites Group at:(last From) Orthogonal) (remove (site))))))) (end {(if (= 1 (count Groups Orthogonal if:(= (who at:(to)) P1))) (result P1 Win)) (if (= 1 (count Groups Orthogonal if:(= (who at:(to)) P2))) (result P2 Win))}))) 
Hermit is a two player abstract game in which players drop stones to create edgewise connected, owned groups of odd sizes 1, 3 and 5 exclusively. The game ends when neither player can legally place a stone. The player with the most groups on the board at game's end wins. Ties are broken by the most groups of size 1 (hermits), then by the most groups of size 3, and finally, the last player to place a stone wins. Scores are formatted 'aa1133', where aa = count of all groups, 11 = count of size 1 groups, and 33 = count of size 3 groups. It is helpful to turn on 'Show Legal Moves' (Alt-M). Base 5 hexagonal board of triangles
(game "Hermit" (players 2) (equipment {(board (tri Hexagon 5) use:Vertex) (piece "Marker" Each) (piece "Marker" Neutral)}) (rules (start {(set Score P1 0) (set Score P2 0)}) (play (do (move Add (to (sites Empty))) ifAfterwards:(or {(= 1 (size Group at:(last To) Orthogonal)) (= 3 (size Group at:(last To) Orthogonal)) (= 5 (size Group at:(last To) Orthogonal))}) (then (addScore Mover (- (+ {(* 10000 (count Groups Orthogonal if:(= (who at:(to)) (mover)))) (* 100 (- (count Groups Orthogonal if:(= (who at:(to)) (mover))) (count Groups Orthogonal if:(= (who at:(to)) (mover)) min:3))) (- (- (count Groups Orthogonal if:(= (who at:(to)) (mover))) (count Groups Orthogonal if:(= (who at:(to)) (mover)) min:5)) (- (count Groups Orthogonal if:(= (who at:(to)) (mover))) (count Groups Orthogonal if:(= (who at:(to)) (mover)) min:3)))}) (score Mover)))))) (end (if (all Passed) {(if (> (+ {(* 10000 (count Groups Orthogonal if:(= (who at:(to)) P1))) (* 100 (- (count Groups Orthogonal if:(= (who at:(to)) P1)) (count Groups Orthogonal if:(= (who at:(to)) P1) min:3))) (- (- (count Groups Orthogonal if:(= (who at:(to)) P1)) (count Groups Orthogonal if:(= (who at:(to)) P1) min:5)) (- (count Groups Orthogonal if:(= (who at:(to)) P1)) (count Groups Orthogonal if:(= (who at:(to)) P1) min:3)))}) (+ {(* 10000 (count Groups Orthogonal if:(= (who at:(to)) P2))) (* 100 (- (count Groups Orthogonal if:(= (who at:(to)) P2)) (count Groups Orthogonal if:(= (who at:(to)) P2) min:3))) (- (- (count Groups Orthogonal if:(= (who at:(to)) P2)) (count Groups Orthogonal if:(= (who at:(to)) P2) min:5)) (- (count Groups Orthogonal if:(= (who at:(to)) P2)) (count Groups Orthogonal if:(= (who at:(to)) P2) min:3)))})) (result P1 Win)) (if (< (+ {(* 10000 (count Groups Orthogonal if:(= (who at:(to)) P1))) (* 100 (- (count Groups Orthogonal if:(= (who at:(to)) P1)) (count Groups Orthogonal if:(= (who at:(to)) P1) min:3))) (- (- (count Groups Orthogonal if:(= (who at:(to)) P1)) (count Groups Orthogonal if:(= (who at:(to)) P1) min:5)) (- (count Groups Orthogonal if:(= (who at:(to)) P1)) (count Groups Orthogonal if:(= (who at:(to)) P1) min:3)))}) (+ {(* 10000 (count Groups Orthogonal if:(= (who at:(to)) P2))) (* 100 (- (count Groups Orthogonal if:(= (who at:(to)) P2)) (count Groups Orthogonal if:(= (who at:(to)) P2) min:3))) (- (- (count Groups Orthogonal if:(= (who at:(to)) P2)) (count Groups Orthogonal if:(= (who at:(to)) P2) min:5)) (- (count Groups Orthogonal if:(= (who at:(to)) P2)) (count Groups Orthogonal if:(= (who at:(to)) P2) min:3)))})) (result P2 Win))} (result Mover Win))))) 
A player wins by connecting all of one's pieces into a contiguous body so that they are connected orthogonally or diagonally. Players alternate moves. Pieces move orthogonally or diagonally. A piece moves exactly as many spaces as there are pieces (belonging to both the player and their opponent) on the line in which it is moving. A piece may jump over the player's own pieces, but not over one belonging to the opponent. A piece can capture piece belonging to the opponent by landing on it. If the two players make a group in the same turn, the game ends in a draw.
(game "Lines of Action" (players 2) (equipment {(board (square 8)) (piece "Disc" Each (or {(move Hop (directions {N S}) (between (exact (- (count Sites in:(difference (sites Column (column of:(from))) (sites Empty))) 1)) if:(not (is Enemy (who at:(between))))) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Hop (directions {W E}) (between (exact (- (count Sites in:(difference (sites Row (row of:(from))) (sites Empty))) 1)) if:(not (is Enemy (who at:(between))))) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Hop (directions {NE SW}) (between (exact (- (count Sites in:(difference (sites Direction from:(from) (directions {NE SW}) included:True) (sites Empty))) 1)) if:(not (is Enemy (who at:(between))))) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Hop (directions {NW SE}) (between (exact (- (count Sites in:(difference (sites Direction from:(from) (directions {NW SE}) included:True) (sites Empty))) 1)) if:(not (is Enemy (who at:(between))))) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))}))}) (rules (start {(place "Disc1" (difference (union (sites Top) (sites Bottom)) (sites Corners))) (place "Disc2" (difference (union (sites Right) (sites Left)) (sites Corners)))}) (play (forEach Piece)) (end {(if (and (= 1 (count Groups if:(= (who at:(to)) P1))) (= 1 (count Groups if:(= (who at:(to)) P2)))) (result Mover Draw)) (if (= 1 (count Groups if:(= (who at:(to)) P1))) (result P1 Win)) (if (= 1 (count Groups if:(= (who at:(to)) P2))) (result P2 Win))}))) 
On your turn, place a single piece of your color on an empty position that is not next to another friendly piece. This is compulsory whenever it is possible to do so. When it is not possible to place a piece; then instead, step one of your pieces to an adjacent empty position. You win either: -- when all your pieces become connected, or -- when you cut-off your opponent from being able to connect theirs. Board: Muster order 3 board - 45 positions Angled cells
(game "Make Muster" (players 2) (equipment {(board (rotate (- 90 62) (square (poly {{1 5} {2 4} {8 1} {9 2} {12 8} {11 9} {5 12} {4 11}}))) use:Cell) (piece "Disc" Each (move Step (to if:(is Empty (to)))))}) (rules (play (priority (move Add (to (sites Empty) if:(no Pieces Mover in:(sites Around (to) Adjacent)))) (forEach Piece))) (end (if (or (and {(= 1 (count Groups All if:(= (who at:(to)) Mover))) (< 1 (count Pieces Mover))}) (< 1 (count Groups All if:(!= (mover) (who at:(to)))))) (result Mover Win))))) 
Players take turns placing pieces of any colour. They can't create groups of more than five pieces which are adjacent to each other. A group of 4 pieces is called a quart. A group of 5 pieces is called a quint. Players win if they finish their turn with a friendly quint, but lose if they finish their turn with a friendly quart on the board. Note: The winning and losing conditions for a player are checked after their move, only on their own turn. An end condition (win or loss) is effective when it occurred first and cannot be averted.
(game "Manalath" (players 2) (equipment {(board (rotate 90 (hex 5))) (piece "Marker" Each) (hand Shared size:2)}) (rules (start {(place "Marker1" (handSite Shared)) (place "Marker2" (handSite Shared 1))}) (play (do (move (from (sites Hand Shared)) (to (sites Empty)) copy:True) ifAfterwards:(< (size Group at:(last To)) 6) (then (forEach Site (sites Occupied by:Mover container:"Board") (if (= (size Group at:(site)) 5) (set Var "Group5" 1) (if (= (size Group at:(site)) 4) (set Var "Group4" 1))))))) (end {(if (= (var "Group4") 1) (result Mover Loss)) (if (= (var "Group5") 1) (result Mover Win))}))) 
Definitions: 1 A group is a stone along with all stones one can reach from it through a series of steps onto adjacent stones of the same color. 1.1 The size of a group is the number of stones in it. 2 A brood is a group along with all other groups of identical color, size and shape. Shapes are considered identical across rotational and mirror-symmetries. 2.1 The size of a brood is the number of groups in it. 2.2 The order of a brood is the size of the groups in it. Play: On the very first turn of the game, Black places one stone of their color on any hex. After, that – starting with White – take turns doing one of the following: • Pass. • Place two stones of your color on empty hexes. When the players pass consecutively, the winner is the player with the higher score. Scoring: For each of your odd-sized broods, you score 1 point if its order is odd and 2 points if its order is even. A boad of size 5 is currently selected. Nothing is currently printed on the pieces.
(game "Manifold" (players 2) (equipment {(board (hex Hexagon 5) use:Cell) (piece "Hex" Each maxState:7 maxValue:1023) (piece "Disc" Neutral)}) (rules (play (if (or (= 0 (count Moves)) (!= 0 (count MovesThisTurn))) (do (forEach Site (sites Occupied by:Mover) (set State at:(site) 0)) next:(move Add (piece (id "Hex" Mover)) (to (sites Empty)) (then (set Var "LastRow" (row of:(max (array (sites Group at:(last To))))) (then (set Var "LastCol" (max (results from:(sites Group at:(last To)) to:(from) (column of:(from)))) (then (forEach Site (sites Group at:(last To)) (set Value at:(site) (+ (* 32 (- (var "LastRow") (row of:(site)))) (- (var "LastCol") (column of:(site)))))))))))) (then (forEach Group if:(= (mover) (who at:(to))) (remember Value (regionSite (sites) index:0) unique:True) (then (and {(forEach Value (values Remembered) (and {(set Var "KeySite" (value) (then (forEach Group if:(= (mover) (who at:(to))) (if (= (size Array (array (sites))) (size Array (array (sites Group at:(var "KeySite"))))) (priority {(if (= 0 (size Array (difference (results from:(sites Group at:(var "KeySite")) to:(from) (+ (+ (* 32 (/ (value Piece at:(from)) 32)) (% (value Piece at:(from)) 32)) (+ (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (* 32 (/ (value Piece at:(from)) 32))))) (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (% (value Piece at:(from)) 32))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (remember Value "ShapeCount" (+ (if (> (var "KeySite") (regionSite (sites) index:0)) 0 1000) (var "KeySite")))) (if (= 0 (size Array (difference (results from:(sites Group at:(var "KeySite")) to:(from) (+ (+ (* 32 (/ (value Piece at:(from)) 32)) (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (* 32 (/ (value Piece at:(from)) 32))))) (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (remember Value "ShapeCount" (+ (if (> (var "KeySite") (regionSite (sites) index:0)) 0 1000) (var "KeySite")))) (if (= 0 (size Array (difference (results from:(sites Group at:(var "KeySite")) to:(from) (+ (+ (* 32 (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32))) (/ (value Piece at:(from)) 32)) (+ (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (* 32 (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (/ (value Piece at:(from)) 32))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (remember Value "ShapeCount" (+ (if (> (var "KeySite") (regionSite (sites) index:0)) 0 1000) (var "KeySite")))) (if (= 0 (size Array (difference (results from:(sites Group at:(var "KeySite")) to:(from) (+ (+ (* 32 (% (value Piece at:(from)) 32)) (/ (value Piece at:(from)) 32)) (+ (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (* 32 (% (value Piece at:(from)) 32))))) (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (/ (value Piece at:(from)) 32))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (remember Value "ShapeCount" (+ (if (> (var "KeySite") (regionSite (sites) index:0)) 0 1000) (var "KeySite")))) (if (= 0 (size Array (difference (results from:(sites Group at:(var "KeySite")) to:(from) (+ (+ (* 32 (- (% (value Piece at:(from)) 32))) (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (* 32 (- (% (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (remember Value "ShapeCount" (+ (if (> (var "KeySite") (regionSite (sites) index:0)) 0 1000) (var "KeySite")))) (if (= 0 (size Array (difference (results from:(sites Group at:(var "KeySite")) to:(from) (+ (+ (* 32 (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32))) (% (value Piece at:(from)) 32)) (+ (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (* 32 (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (% (value Piece at:(from)) 32))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (remember Value "ShapeCount" (+ (if (> (var "KeySite") (regionSite (sites) index:0)) 0 1000) (var "KeySite")))) (if (= 0 (size Array (difference (results from:(sites Group at:(var "KeySite")) to:(from) (+ (+ (* 32 (- (/ (value Piece at:(from)) 32))) (- (% (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (* 32 (- (/ (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (- (% (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (remember Value "ShapeCount" (+ (if (> (var "KeySite") (regionSite (sites) index:0)) 0 1000) (var "KeySite")))) (if (= 0 (size Array (difference (results from:(sites Group at:(var "KeySite")) to:(from) (+ (+ (* 32 (- (/ (value Piece at:(from)) 32))) (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (* 32 (- (/ (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (remember Value "ShapeCount" (+ (if (> (var "KeySite") (regionSite (sites) index:0)) 0 1000) (var "KeySite")))) (if (= 0 (size Array (difference (results from:(sites Group at:(var "KeySite")) to:(from) (+ (+ (* 32 (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32))) (- (/ (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (* 32 (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (- (/ (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (remember Value "ShapeCount" (+ (if (> (var "KeySite") (regionSite (sites) index:0)) 0 1000) (var "KeySite")))) (if (= 0 (size Array (difference (results from:(sites Group at:(var "KeySite")) to:(from) (+ (+ (* 32 (- (% (value Piece at:(from)) 32))) (- (/ (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (* 32 (- (% (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (- (/ (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (remember Value "ShapeCount" (+ (if (> (var "KeySite") (regionSite (sites) index:0)) 0 1000) (var "KeySite")))) (if (= 0 (size Array (difference (results from:(sites Group at:(var "KeySite")) to:(from) (+ (+ (* 32 (% (value Piece at:(from)) 32)) (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (* 32 (% (value Piece at:(from)) 32))))) (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (remember Value "ShapeCount" (+ (if (> (var "KeySite") (regionSite (sites) index:0)) 0 1000) (var "KeySite")))) (if (= 0 (size Array (difference (results from:(sites Group at:(var "KeySite")) to:(from) (+ (+ (* 32 (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32))) (- (% (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (* 32 (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (- (% (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (remember Value "ShapeCount" (+ (if (> (var "KeySite") (regionSite (sites) index:0)) 0 1000) (var "KeySite"))))})))))} (then (if (= 0 (count Value (var "KeySite") in:(values Remembered "ShapeCount"))) (set State at:(var "KeySite") (* (% (+ (count Value (var "KeySite") in:(values Remembered "ShapeCount")) (count Value (+ 1000 (var "KeySite")) in:(values Remembered "ShapeCount"))) 2) (- 2 (% (size Group at:(var "KeySite")) 2)))) (set State at:(var "KeySite") 0)))) (then (forget Value All))) (set Score Mover 0 (then (forEach Piece (addScore Mover (state at:(from))))))}))))) (or (move Pass) (and {(do (forEach Site (sites Occupied by:Mover) (set State at:(site) 0)) next:(move Add (piece (id "Hex" Mover)) (to (sites Empty)) (then (set Var "LastRow" (row of:(max (array (sites Group at:(last To))))) (then (set Var "LastCol" (max (results from:(sites Group at:(last To)) to:(from) (column of:(from)))) (then (forEach Site (sites Group at:(last To)) (set Value at:(site) (+ (* 32 (- (var "LastRow") (row of:(site)))) (- (var "LastCol") (column of:(site)))))))))))) (then (forEach Group if:(= (mover) (who at:(to))) (remember Value (regionSite (sites) index:0) unique:True) (then (and {(forEach Value (values Remembered) (and {(set Var "KeySite" (value) (then (forEach Group if:(= (mover) (who at:(to))) (if (= (size Array (array (sites))) (size Array (array (sites Group at:(var "KeySite"))))) (priority {(if (= 0 (size Array (difference (results from:(sites Group at:(var "KeySite")) to:(from) (+ (+ (* 32 (/ (value Piece at:(from)) 32)) (% (value Piece at:(from)) 32)) (+ (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (* 32 (/ (value Piece at:(from)) 32))))) (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (% (value Piece at:(from)) 32))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (remember Value "ShapeCount" (+ (if (> (var "KeySite") (regionSite (sites) index:0)) 0 1000) (var "KeySite")))) (if (= 0 (size Array (difference (results from:(sites Group at:(var "KeySite")) to:(from) (+ (+ (* 32 (/ (value Piece at:(from)) 32)) (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (* 32 (/ (value Piece at:(from)) 32))))) (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (remember Value "ShapeCount" (+ (if (> (var "KeySite") (regionSite (sites) index:0)) 0 1000) (var "KeySite")))) (if (= 0 (size Array (difference (results from:(sites Group at:(var "KeySite")) to:(from) (+ (+ (* 32 (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32))) (/ (value Piece at:(from)) 32)) (+ (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (* 32 (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (/ (value Piece at:(from)) 32))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (remember Value "ShapeCount" (+ (if (> (var "KeySite") (regionSite (sites) index:0)) 0 1000) (var "KeySite")))) (if (= 0 (size Array (difference (results from:(sites Group at:(var "KeySite")) to:(from) (+ (+ (* 32 (% (value Piece at:(from)) 32)) (/ (value Piece at:(from)) 32)) (+ (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (* 32 (% (value Piece at:(from)) 32))))) (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (/ (value Piece at:(from)) 32))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (remember Value "ShapeCount" (+ (if (> (var "KeySite") (regionSite (sites) index:0)) 0 1000) (var "KeySite")))) (if (= 0 (size Array (difference (results from:(sites Group at:(var "KeySite")) to:(from) (+ (+ (* 32 (- (% (value Piece at:(from)) 32))) (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (* 32 (- (% (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (remember Value "ShapeCount" (+ (if (> (var "KeySite") (regionSite (sites) index:0)) 0 1000) (var "KeySite")))) (if (= 0 (size Array (difference (results from:(sites Group at:(var "KeySite")) to:(from) (+ (+ (* 32 (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32))) (% (value Piece at:(from)) 32)) (+ (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (* 32 (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (% (value Piece at:(from)) 32))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (remember Value "ShapeCount" (+ (if (> (var "KeySite") (regionSite (sites) index:0)) 0 1000) (var "KeySite")))) (if (= 0 (size Array (difference (results from:(sites Group at:(var "KeySite")) to:(from) (+ (+ (* 32 (- (/ (value Piece at:(from)) 32))) (- (% (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (* 32 (- (/ (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (- (% (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (remember Value "ShapeCount" (+ (if (> (var "KeySite") (regionSite (sites) index:0)) 0 1000) (var "KeySite")))) (if (= 0 (size Array (difference (results from:(sites Group at:(var "KeySite")) to:(from) (+ (+ (* 32 (- (/ (value Piece at:(from)) 32))) (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (* 32 (- (/ (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (remember Value "ShapeCount" (+ (if (> (var "KeySite") (regionSite (sites) index:0)) 0 1000) (var "KeySite")))) (if (= 0 (size Array (difference (results from:(sites Group at:(var "KeySite")) to:(from) (+ (+ (* 32 (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32))) (- (/ (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (* 32 (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (- (/ (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (remember Value "ShapeCount" (+ (if (> (var "KeySite") (regionSite (sites) index:0)) 0 1000) (var "KeySite")))) (if (= 0 (size Array (difference (results from:(sites Group at:(var "KeySite")) to:(from) (+ (+ (* 32 (- (% (value Piece at:(from)) 32))) (- (/ (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (* 32 (- (% (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (- (/ (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (remember Value "ShapeCount" (+ (if (> (var "KeySite") (regionSite (sites) index:0)) 0 1000) (var "KeySite")))) (if (= 0 (size Array (difference (results from:(sites Group at:(var "KeySite")) to:(from) (+ (+ (* 32 (% (value Piece at:(from)) 32)) (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (* 32 (% (value Piece at:(from)) 32))))) (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (remember Value "ShapeCount" (+ (if (> (var "KeySite") (regionSite (sites) index:0)) 0 1000) (var "KeySite")))) (if (= 0 (size Array (difference (results from:(sites Group at:(var "KeySite")) to:(from) (+ (+ (* 32 (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32))) (- (% (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (* 32 (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(var "KeySite")) to:(from) (- (- (% (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (remember Value "ShapeCount" (+ (if (> (var "KeySite") (regionSite (sites) index:0)) 0 1000) (var "KeySite"))))})))))} (then (if (= 0 (count Value (var "KeySite") in:(values Remembered "ShapeCount"))) (set State at:(var "KeySite") (* (% (+ (count Value (var "KeySite") in:(values Remembered "ShapeCount")) (count Value (+ 1000 (var "KeySite")) in:(values Remembered "ShapeCount"))) 2) (- 2 (% (size Group at:(var "KeySite")) 2)))) (set State at:(var "KeySite") 0)))) (then (forget Value All))) (set Score Mover 0 (then (forEach Piece (addScore Mover (state at:(from))))))})))))} (then (moveAgain)))) (then (forget Value All)))) (end (if (all Passed) (byScore))))) 
DEFINITIONS Group: like-colored stones adjacent to each other. Singletons are considered groups of size 1. Path: an empty point, or an uninterrupted straight line of empty points that have a pair of like-colored stones on both ends, which are not part of the same group. Such a pair is said to have a path. Dead group: a group in which all stones belonging to it have no path. If any stone belonging to a group has a path, the group is said to have a path. GAME PLAY (Overview) Decide which player plays as which color (Light or Dark) in any adequate way. Light goes first, then alternate turns. On each player's first turn, players place a stone of their own color on any empty point. On each player's second turn, players place another stone of their color so that their own two stones have a path. Then players take actions below on each turn, in this order. 1. Remove all opponent’s dead groups. This happens automatically in Ludii. 2. Place a stone of their own color on an empty point that is on at least one same straight line with an existing friendly stone, and no opponent's stone in between. Passing is not allowed. After the second turn, the player with no stones of their color on the board at the beginning of their turn loses. A board with side lengths 6 and 7 is currently selected
(game "Meridians" (players 2) (equipment {(board (dual (hex Prism 7 6)) use:Vertex) (piece "Disc" Each)}) (rules phases:{(phase "Opening" (play (move Add (to (if (< 0 (count Sites in:(sites Occupied by:Mover))) (forEach (sites Empty) if:(and (> (count Pieces Mover in:(sites LineOfSight at:(site))) 0) (= (count Sites in:(sites Around (site) Own)) 0))) (sites Empty))))) (nextPhase (= 4 (count Moves)) "Play")) (phase "Play" (play (if (can Move (move Add (to (forEach (sites Empty) if:(> (count Pieces Mover in:(sites LineOfSight at:(site))) 0))))) (move Add (to (forEach (sites Empty) if:(> (count Pieces Mover in:(sites LineOfSight at:(site))) 0))) (then (forEach Group (if (all Sites (sites) if:(= 0 (count Sites in:(difference (intersection (sites Occupied by:Mover) (sites Direction from:(site) stop:(is Occupied (to)) stopIncluded:True)) (sites))))) (remove (sites)))))) (move Pass (then (forEach Group (if (all Sites (sites) if:(= 0 (count Sites in:(difference (intersection (sites Occupied by:Mover) (sites Direction from:(site) stop:(is Occupied (to)) stopIncluded:True)) (sites))))) (remove (sites)))))))))} (end (if (and (< 4 (count Moves)) (or (= 0 (count Sites in:(sites Occupied by:P1))) (= 0 (count Sites in:(sites Occupied by:P2))))) (result Mover Loss))))) 
Players take turns placing a stone of their own color on any empty cell of a hexagonal grid of hexagons (a hexhex board). The game is over when the board is full, and the player with the lower score wins. If both players have the same number of groups, your score is your number of odd-sized groups, otherwise it is simply your number of groups. The running score only shows the number of odd groups (with a minus sign in front of it, for technical reasons). Groups of odd size is marked with a red outline. A size 5 board is currently selected
(game "Mono" (players 2) (equipment {(board (hex 5)) (piece "Disc" Each)}) (rules (meta (swap)) (play (move Add (to (sites Empty)) (then (and (set Score Mover 0) (forEach Group Orthogonal if:(is Mover (who at:(to))) (if (is Odd (count Sites in:(sites))) (and (addScore Mover -1) (forEach Site (sites) (set State at:(site) 1))) (forEach Site (sites) (set State at:(site) 0)))))))) (end (if (is Full) {(if (= (count Groups if:(= (id P1) (who at:(to)))) (count Groups if:(= (id P2) (who at:(to))))) (byScore)) (if True (byScore {(score P1 (- (count Groups if:(= (id P1) (who at:(to)))))) (score P2 (- (count Groups if:(= (id P2) (who at:(to))))))}))})))) 
Players take turns placing one stone of either color on the board, until it is full. Player One wins if there is an odd number of groups with at least five pieces on the board, Player Two wins otherwise. Played on a size 5 board. Min group size 5.
(game "Odd" (players 2) (equipment {(board (rotate 90 (hex 5))) (piece "Marker" Each) (hand Shared size:2)}) (rules (start {(place "Marker1" (handSite Shared)) (place "Marker2" (handSite Shared 1))}) (play (move (from (sites Hand Shared)) (to (sites Empty)) copy:True)) (end (if (is Full) (if (is Odd (+ (count Groups if:(= (who at:(to)) P1) min:5) (count Groups if:(= (who at:(to)) P2) min:5))) (result P1 Win)) (result P2 Win))))) 
Players take turns placing a piece of each color in an empty site. Play ends at the start of the first players turn, if all the players would not be able to complete their turn. Example: for 2 players less than 4 empty sites. Scores are awarded based on the sizes of the groups of each color on the board, which are multiplied. The player with the highest score wins. The game is played on a 5x5 board The version of the game played with 2 players.
(game "Omega" (players 2) (equipment {(board (hex 5)) (piece "Marker" Each)}) (rules (play (move Add (piece (+ 1 (% (count Moves) (count Players)))) (to (sites Empty)) (then (if (!= (count MovesThisTurn) (- (count Players) 1)) (moveAgain))))) (end (if (and {(not (is Mover P1)) (is Next P1) (> (pow (count Players) 2) (count Sites in:(sites Empty)))}) (byScore {(score P1 (* (sizes Group P1))) (score P2 (* (sizes Group P2)))}))))) 
Omny is played on the cells of any hexagonal grid where some or all of the cells are designated star cells. Players take turns placing a stone of one's own color on an empty cell. A group is a set of connected stones of the same color. A cut of a group X is any set of connected cells (empty or occupied by either player) including no stones in X. You win by making a group such that none of its cuts include more than half the cells of the board. For serious play it is advised to play with a balance rule in force. In Misère Omny you lose if you make a group whose cuts each contain no more than half of the star cells. A hex board is currently selected A size 7 board is currently selected The currently selected star cells are all the cells on the board. The pie rule is currently in force The standard win condition is currently selected.
(game "Omny" (players 2) (equipment {(board (hex 7)) (piece "Disc" Each)}) (rules (play (if (= 1 (var)) (or (move Swap Players P1 P2) (move Add (to (sites Empty)) (then (set Var 0)))) (move Add (to (sites Empty)) (then (if (= 1 (count Moves)) (set Var 1)))))) (end (if (>= (count Sites in:(sites Board)) (max (results from:(difference (sites Board) (sites Group at:(last To))) to:2 (* (to) (count Sites in:(intersection (sites Board) (sites Group at:(from) if:(not (is In (to) (sites Group at:(last To))))))))))) (result Mover Win))))) 
GROUP - A connected chain of friendly stones. TURN - Initially, Black drops one stone of either color, then for the remaining turns players drop two stones of either color. GOAL - After the board is full, wins the player with the higher product between its two largest groups. If both products are equal, wins the player with less stones on board (note: draws are impossible).
(game "Product" (players 2) (equipment {(board (hex 5)) (piece "Marker" Each)}) (rules (play (move Add (to (sites Empty)))) (end (if (is Full) (byScore {(score P1 (* (max (sizes Group P1)) (max (difference (sizes Group P1) (max (sizes Group P1)))))) (score P2 (* (max (sizes Group P2)) (max (difference (sizes Group P2) (max (sizes Group P2))))))}))))) 
Goal: Scoring is based on your largest group (x2), with an extra point given to the first player to create a given size. The player with the largest group at the end of the game thus wins, and ties go to the first player to achieve this goal. Setup: Yellow starts by creating a set-up, then Orange begins actual play - Pass to skip this phase To create a set-up, Yellow first places a black blocking stone on any intersection and then a Yellow stone on an empty edge position. Orange then either begins play, or else exchanges the yellow piece with his own. Play: Players take turns placing their piece on an empty intersection that is either along the edge or next to another fiendly piece, but never adjacent to an enemy position. These placements are subject to 2 possible additional restrictions selected by the players before starting: A) The number range of friendly neighbors the piece being placed may have: (Standard is to play with no restriction.) and/or B) The maximum number of neighbors that are allowed for the pieces against which the piece may be placed, with 2 being standard play. Ending the game. Play continues until both players pass consecutively, and then the final scores are compared. Board & size: Hexhex with edges alternating 4 and 6 Place next to any friendly piece(s), but not next to pieces that already have more than 2 neighbors.
(game "RootZone" (players 2) (equipment {(board (tri {4 6 4 7 4}) use:Vertex) (piece "Disc" Each) (piece "Disc" Neutral)}) (rules (play (if (= -1 (counter)) (or (move Pass) (move Add (piece "Disc0") (to (sites Board)))) (or {(if (= 1 (counter)) (move Select (from (sites Occupied by:Enemy)) (then (remove (last To) (then (add (to (last To)))))))) (move Pass) (move Add (to (difference (union (sites Outer) (sites Around (sites Occupied by:Mover))) (union {(sites Around (sites Occupied by:Enemy)) (sites Around (forEach (sites Occupied by:Mover) if:(<= 3 (count Pieces Mover in:(sites Around (site)))))) (sites Around (sites Occupied by:Neutral))})) if:(and (is Empty (to)) (>= 6 (count Pieces Mover in:(sites Around (to)))))) (then (if (> (* 2 (size Group at:(last To))) (score Mover)) (if (> (* 2 (size Group at:(last To))) (score Next)) (set Score Mover (+ 1 (* 2 (size Group at:(last To))))) (set Score Mover (* 2 (size Group at:(last To))))))))}))) (end (if (all Passed) (byScore))))) 
Play: Players take turns placing one stone of their color on any empty hex. Goal: When the board is full, the game is over and the player with the higher score is the winner. Scoring: Each stone is worth 1 point for its owner if it is part of a group connecting opposite sides of the board, and -1 point otherwise. The scoring trick that gave the game its name – namely that each stone is worth either +1 point or -1 point – was (unbeknownst to the inventor of Signum) discovered by Brian Wittmann (the inventor of Loops) 9 years earlier. The score is currently updated only when the board is full. (This makes the AI stronger.) A size 6 board is currently selected
(game "Signum" (players 2) (equipment {(board (hex 6)) (piece "Disc" Each)}) (rules (meta (swap)) (play (move Add (to (sites Empty)))) (end (if (is Full) (byScore {(score P1 (+ (results from:(sites Occupied by:P1) to:0 (if (or {(is Connected at:(from) {(sites Side N) (sites Side S)}) (is Connected at:(from) {(sites Side NW) (sites Side SE)}) (is Connected at:(from) {(sites Side NE) (sites Side SW)})}) 1 -1)))) (score P2 (+ (results from:(sites Occupied by:P2) to:0 (if (or {(is Connected at:(from) {(sites Side N) (sites Side S)}) (is Connected at:(from) {(sites Side NW) (sites Side SE)}) (is Connected at:(from) {(sites Side NE) (sites Side SW)})}) 1 -1))))}))))) 
Players alternate making a move. White plays with the white stones and makes the first move, Black plays with the black stones. On his turn, a player may choose either a) to place a stone on the board without contact to other stones of his color in order to start a new group, or b) to grow all possible groups by one stone. When you grow your groups in this implementation, you place grey stones adjacent to your groups until each of your groups is adjacent to exactly one grey stone. At no point may a group of yours be adjacent to more than one grey stone. When your turn ends, all grey stones are replaced with stones of your color. For balancing, there is an extra rule: Black is allowed to grow all his groups and place a single stone as long as neither player has not yet grown any groups. The game ends when the board is filled in. The score is the number of stones each player has on the board minus 'P' times the number of groups he has, where 'P' is en even number of 4 or higher (the Ludii implementation also allows 0 and 2 as values of 'P'). With an even penalty and an odd boardsize, draws are not possible. A size 19 board is currently selected A group penalty of 10 points is currently selected
(game "Symple" (players 2) (equipment {(board (square 19) use:Vertex) (piece "Marker" Each) (piece "Marker" Neutral)}) (rules (play (if (= (count Moves) (var "MoveThatMustBePlant")) (move Add (to (sites Empty) if:(= 0 (count Sites in:(sites Around (to) Own Orthogonal)))) (then (set Score Mover (- (count Sites in:(sites Occupied by:Mover)) (* 10 (count Groups Orthogonal if:(is Mover (who at:(to))))))))) (if (= 0 (count MovesThisTurn)) (or (move Add (to (sites Empty) if:(= 0 (count Sites in:(sites Around (to) Own Orthogonal)))) (then (set Score Mover (- (count Sites in:(sites Occupied by:Mover)) (* 10 (count Groups Orthogonal if:(is Mover (who at:(to))))))))) (do (move Add (piece "Marker0") (to (sites Empty) if:(< 0 (count Sites in:(sites Around (to) Own Orthogonal))))) ifAfterwards:(all Groups Orthogonal of:(is Mover (who at:(to))) if:(> 2 (count Sites in:(intersection (sites Around (sites) NotEmpty Orthogonal) (sites Occupied by:Neutral))))) (then (if (can Move (do (move Add (piece "Marker0") (to (sites Empty) if:(< 0 (count Sites in:(sites Around (to) Own Orthogonal))))) ifAfterwards:(all Groups Orthogonal of:(is Mover (who at:(to))) if:(> 2 (count Sites in:(intersection (sites Around (sites) NotEmpty Orthogonal) (sites Occupied by:Neutral))))))) (moveAgain) (do (add (to (sites Occupied by:Neutral) (apply (remove (to)))) (then (if (!= 1 (var "HasGrown")) (and (set Var "HasGrown" 1) (if (= (id P2) (mover)) (and (set Var "MoveThatMustBePlant" (count Moves)) (moveAgain))))))) next:(set Score Mover (- (count Sites in:(sites Occupied by:Mover)) (* 10 (count Groups Orthogonal if:(is Mover (who at:(to)))))))))))) (do (move Add (piece "Marker0") (to (sites Empty) if:(< 0 (count Sites in:(sites Around (to) Own Orthogonal))))) ifAfterwards:(all Groups Orthogonal of:(is Mover (who at:(to))) if:(> 2 (count Sites in:(intersection (sites Around (sites) NotEmpty Orthogonal) (sites Occupied by:Neutral))))) (then (if (can Move (do (move Add (piece "Marker0") (to (sites Empty) if:(< 0 (count Sites in:(sites Around (to) Own Orthogonal))))) ifAfterwards:(all Groups Orthogonal of:(is Mover (who at:(to))) if:(> 2 (count Sites in:(intersection (sites Around (sites) NotEmpty Orthogonal) (sites Occupied by:Neutral))))))) (moveAgain) (do (add (to (sites Occupied by:Neutral) (apply (remove (to)))) (then (if (!= 1 (var "HasGrown")) (and (set Var "HasGrown" 1) (if (= (id P2) (mover)) (and (set Var "MoveThatMustBePlant" (count Moves)) (moveAgain))))))) next:(set Score Mover (- (count Sites in:(sites Occupied by:Mover)) (* 10 (count Groups Orthogonal if:(is Mover (who at:(to)))))))))))))) (end (if (is Full) (byScore))))) 
Definitions A group is a stone along with all other stones one could reach from it through a series of steps between adjacent stones of its color. The size of a group is the number of stones in it. Play Black plays first, then turns alternate. On your turn, place a stone of your color on an empty cell. When the board is full, the winner is determined as follows: (1) Let n equal 0. (2) The player with fewer groups bigger than n stones wins. (3) If no winner is found, increase n by 1 and go back to (2). The pie rule is used in order to make the game fair. This means White will have the option, on their first turn only, to swap sides with their opponent instead of making a regular move. A size 7 board is currently selected The score is currently updated only when the board is full. (This makes the AI stronger.)
(game "Yoin" (players 2) (equipment {(board (hex 7)) (piece "Disc" Each)}) (rules (meta (swap)) (play (move Add (to (sites Empty)) (then (if (is Full) (do (set Var "CutOff" 0) next:(do (while (and (= 0 (- (count Groups if:(= (id P1) (who at:(to))) min:(var "CutOff")) (count Groups if:(= (id P2) (who at:(to))) min:(var "CutOff")))) (!= 0 (+ (count Groups if:(= (id P1) (who at:(to))) min:(var "CutOff")) (count Groups if:(= (id P2) (who at:(to))) min:(var "CutOff"))))) (set Var "CutOff" (+ 1 (var "CutOff")))) next:(and (set Score P1 (count Groups if:(= (id P1) (who at:(to))) min:(var "CutOff"))) (set Score P2 (count Groups if:(= (id P2) (who at:(to))) min:(var "CutOff")))))))))) (end (if (is Full) {(if (< (score P1) (score P2)) (result P1 Win)) (if (> (score P1) (score P2)) (result P2 Win))})))) 
Play occurs on a 4x4x4 grid. One player places an X, the other places an O and players take turns placing their marks in the grid, attempting to get four in a row of their color. For the lines between levels, the diagonals are not taken in account. The game is played on a 3x3x3 board.
(game "3D Tic-Tac-Toe" (players 2) (equipment {(board (rectangle (+ (^ 3 2) (- 3 1)) 3)) (piece "Disc" P1) (piece "Cross" P2) (piece "Dot" Neutral)}) (rules (start (place "Dot0" (union {(sites Row 3) (sites Row 7)}))) (play (move Add (to (sites Empty)))) (end {(if (is Line 3) (result Mover Win)) (if (!= 0 (count Sites in:(forEach (expand (sites Bottom) steps:(- 3 1)) if:(all Sites (sites {(site) (ahead (site) steps:4 N) (ahead (site) steps:8 N)}) if:(= (mover) (who at:(site))))))) (result Mover Win))}))) 
MOVE - On each turn, each player move one of his stones into an adjacent orthogonal empty cell. GOAL - Wins the player that makes a (orthogonal or diagonal) 3 in-a-row.
(game "A Simple Game" (players 2) (equipment {(board (square 4) use:Vertex) (piece "Ball" Each (move Step Orthogonal (to if:(is Empty (to))))) (hand Each)}) (rules (start {(place "Ball1" (intersection (sites Phase 0) (union (sites Top) (sites Bottom)))) (place "Ball2" (intersection (sites Phase 1) (union (sites Top) (sites Bottom))))}) (play (forEach Piece)) (end (if (is Line 3 All) (result Mover Win))))) 
Two concentric squares with a line connecting their midpoints. Six pieces per player. Players alternate placing one of their pieces on the intersections of the lines. Whenever a player places three of their pieces in a row, they may remove one of the opponent's pieces from the board. Once all of the pieces are placed, players may take turns moving a piece to an adjacent point along the lines, attempting to place three of their pieces in a row. When one player is reduced to two pieces, that player loses. The game is played according to the rules of Murray.
(game "Achi" (players 2) (equipment {(board (concentric Square rings:2) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to))) (then (if (is Line 3 Orthogonal exact:True) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:6)) phases:{(phase "Placement" (play (if (is Prev Mover) (move Remove (sites Occupied by:Enemy container:"Board")) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3 Orthogonal exact:True) (moveAgain)))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (sites Occupied by:Enemy container:"Board")) (forEach Piece))))} (end (if (<= (count Pieces Next) 2) (result Mover Win))))) 
White starts and, in turn, pieces are placed on any one of 5 spaces, including on other pieces. The object is to get 3 same color pieces in a row - horizontally, vertically or diagonally.
(game "Agilidade" (players 2) (equipment {(board (skew 0.5 (scale 1 0.5 (merge {(wedge 2 2) (shift 0 1 (rotate 180 (wedge 2 2)))}))) use:Vertex) (piece "discFlat" Each) (hand Each)}) (rules (start {(place Stack "discFlat1" (handSite P1) count:7) (place Stack "discFlat2" (handSite P2) count:7)}) (play (move (from (handSite Mover)) (to (sites Board)))) (end (if (is Line 3 byLevel:True) (result Mover Win))))) 
3x3 intersecting lines. Three sticks per player, the sticks angled toward the player to indicate ownership. Players alternate turns placing sticks on the board. Once all of the sticks are placed, players alternate turns moving a stick to any empty spot on the board. The first player to place three sticks in an orthogonal row along the lines wins.
(game "Akidada" (players 2) (equipment {(board (square 3) use:Vertex) (hand Each) (piece "Stick" Each (move (from) (to (sites Empty))))}) (rules (start (place "Stick" "Hand" count:3)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end (if (is Line 3 Orthogonal) (result Mover Win))))) 
Each player has 6 Chess queens. It is played on a 5x5 board. The starting position has the queens arranged on opposite sides, alternating white-black-white-black in each space. The pieces move as queens in Chess. The first player to line up four queens in a row wins.
(game "All Queens Chess" (players 2) (equipment {(board (square 5)) (piece "Queen" Each (move Slide))}) (rules (start {(place "Queen1" (union {(difference (sites Bottom) (sites Phase 1)) (intersection (sites Left) (sites Row (/ (count Rows) 2))) (difference (sites Top) (sites Phase 0))})) (place "Queen2" (union {(difference (sites Bottom) (sites Phase 0)) (intersection (sites Right) (sites Row (/ (count Rows) 2))) (difference (sites Top) (sites Phase 1))}))}) (play (forEach Piece)) (end (if (is Line 4) (result Mover Win))))) 
3x3 intersecting lines, with diagonal lines of the board. Three pieces per player. players alternate turns placing a piece on one of the empty spots. The player who places their pieces in a line wins.
(game "Alquerque de Tres" (players 2) (equipment {(board (rectangle 3 3 diagonals:Alternating) use:Vertex) (hand Each) (piece "Marker" Each)}) (rules (start (place "Marker" "Hand" count:3)) (play (move (from (handSite Mover)) (to (sites Empty)))) (end (if (is Line 3) (result Mover Win))))) 
5x5 intersecting lines, with diagonals in each quadrant. Six pieces per player. Players alternate turns placing one of their pieces on an empty spot on the board. When all of the pieces are placed, they alternate turns moving one of their pieces to an empty adjacent spot along the lines of the board. During either phase, when a player places three of their pieces in a row, they may remove one of the opponent's pieces from the board. Pieces which are in a three-in-a-row arrangement cannot be removed from the board. The player who captures all of the opponent's pieces wins. 
(game "Altan Xaraacaj" (players 2) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to))) (then (if (is Line 3 Orthogonal exact:True) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:6)) phases:{(phase "Placement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3 Orthogonal exact:True) (moveAgain)))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (forEach Piece))))} (end (if (no Pieces Next) (result Next Loss))))) 
The game starts with a tile of each color touching one another. Players take turns placing tiles which must touch at least two other tiles. A player wins by either completely surrounding one or more of the opponent's tiles, or by creating a straight line of five tiles. The game uses hexagonal tiles.
(game "Andantino" (players 2) (equipment {(boardless Hexagonal) (tile "Hex" Each numSides:6)}) (rules (start {(place "Hex1" (centrePoint)) (place "Hex2" (ahead (centrePoint) E))}) (play (move Add (to (sites Playable) if:(<= 2 (count Sites in:(sites Around (to) NotEmpty)))))) (end {(if (or (is Loop surround:Next) (is Line 5)) (result Mover Win)) (if (= (count Moves) (* (count Players) 24)) (result Mover Draw))}))) 
7x6 board. Eighteen pieces per player. Players alternate turns placing a piece on the board. When all of the pieces have been placed, players alternate turns moving a piece to an adjacent empty square in an orthogonal direction. When a player places three of their pieces in an orthogonal line, they capture one of the opponent's pieces. The player who captures all of the opponent's pieces wins.
(game "Aqrad" (players 2) (equipment {(board (rectangle 7 6)) (hand Each) (piece "Marker" Each (move Step Orthogonal (to if:(is Empty (to))) (then (if (is Line 3 Orthogonal exact:True) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:18)) phases:{(phase "Placement" (play (if (is Prev Mover) (move Remove (sites Occupied by:Enemy container:"Board")) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3 Orthogonal exact:True) (moveAgain)))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (sites Occupied by:Enemy container:"Board")) (forEach Piece))))} (end (if (no Pieces Next) (result Next Loss))))) 
6x6 grid. Twelve pieces per player. In the first phase, players alternate turns placing their pieces on an empty space on the board. They are forbidden from placing two of their own pieces orthogonally adjacent to one another. Once all of the pieces are placed, players alternate turns moving the pieces in an orthogonal direction to an empty adjacent spot. When they place a piece so that two are in a row, they capture one of the opponent's pieces. The player who captures all of the opponent's pieces wins.
(game "Bolotudu" (players 2) (equipment {(board (square 6)) (hand Each) (piece "Marker" Each (move Step Orthogonal (to if:(is Empty (to))) (then (if (is Line 2 Orthogonal) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:12)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (difference (sites Empty) (sites Around (sites Occupied by:Mover) Orthogonal))))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (sites Occupied by:Next)) (forEach Piece))))} (end (if (no Pieces Next) (result Next Loss))))) 
Start with a tile of each colour placed next to each other. Players take turns adding a tile of their colour touching at least one existing tile. Win by making a line of four (or more) of your colour, but lose by making a line of three of your colour beforehand. The game uses hexagonal tiles.
(game "Bravalath" (players 2) (equipment {(boardless Hexagonal) (tile "Hex" Each numSides:6)}) (rules (start {(place "Hex1" (centrePoint)) (place "Hex2" (ahead (centrePoint) E))}) (play (move Add (to (sites Playable) if:(<= 1 (count Sites in:(sites Around (to) NotEmpty)))))) (end {(if (is Line 4) (result Mover Win)) (if (is Line 3) (result Mover Loss))}))) 
Players take turns placing their pieces on one empty space on the board, with the goal of making a line with stones connected diagonally of at least length 4. The length of the line is 4 or more. The game is played on a 11x11 board. The board is a diamond tiling by hexagon. The game uses the swap rule. The first player to connect their two sides wins. The connection between two stones is using all the diagonal directions.
(game "Broken Line" (players 2) (equipment {(board (hex Diamond 11)) (piece "Marker" Each)}) (rules (meta (swap)) (play (move Add (to (sites Empty)))) (end (if (is Line 4 Diagonal) (result Mover Win))))) 
The board is initially empty. Each player chooses a colour: White or Black. White starts by placing a stone on a vacant square. Black does the same. Players continue taking turns; however, your turn goes as follows: 1. Mark one of your exposed stones for removal from the board (i.e. it cannot be under an enemy stone). 2. Add one of your stones to the board. 3. Add another one of your stones to the board, at which point the marked stone is removed. The following rules constrain where you can add each stone: It must be a “knight’s move” away from the marked stone. That is to say, either 2 spaces vertically and 1 horizontally, or 2 spaces horizontally, and 1 vertically away from the marked stone. The space on which you place it must have none of your stones, and either: be vacant, or have an enemy stone, in which case you will place yours on top, creating a stack that you control. If, at the end of your opponent’s turn, you have at least 5 of your stones and/or stacks in the same rank, or in the same file, you win.
(game "Callanish" (players 2) (equipment {(board (square 9)) (piece "Disc" Each (move Select (from if:(and (= (topLevel at:(from)) (level)) (<= 2 (count Sites in:(sites To (move Leap (from (from)) {{F F R F} {F F L F} {F R F F} {F L F F}} (to if:(or (is Empty (to)) (and (is Enemy (who at:(to))) (= (topLevel at:(to)) 0)))))))))) (then (do (set Var "CondemnedSite" (last From)) next:(do (set State at:(var "CondemnedSite") 1) next:(moveAgain))))))}) (rules phases:{(phase "Opening" (play (move Add (to (sites Empty)))) (nextPhase (>= (count Turns) 2) "Playing")) (phase "Playing" (play (if (is Prev Mover) (if (is Pending) (move Add (to (sites To (move Leap (from (var "CondemnedSite")) {{F F R F} {F F L F} {F R F F} {F L F F}} (to if:(or (is Empty (to)) (and (is Enemy (who at:(to))) (= (topLevel at:(to)) 0))))))) stack:True (then (remove (var "CondemnedSite")))) (move Add (to (sites To (move Leap (from (var "CondemnedSite")) {{F F R F} {F F L F} {F R F F} {F L F F}} (to if:(or (is Empty (to)) (and (is Enemy (who at:(to))) (= (topLevel at:(to)) 0))))))) stack:True (then (do (set Pending) next:(moveAgain))))) (forEach Piece))))} (end {(if (and (= (% (- (count Moves) 2) 3) 0) (or {(<= 5 (count Sites in:(intersection (sites Row 0) (sites Occupied by:Next container:"Board")))) (<= 5 (count Sites in:(intersection (sites Row 1) (sites Occupied by:Next container:"Board")))) (<= 5 (count Sites in:(intersection (sites Row 2) (sites Occupied by:Next container:"Board")))) (<= 5 (count Sites in:(intersection (sites Row 3) (sites Occupied by:Next container:"Board")))) (<= 5 (count Sites in:(intersection (sites Row 4) (sites Occupied by:Next container:"Board")))) (<= 5 (count Sites in:(intersection (sites Row 5) (sites Occupied by:Next container:"Board")))) (<= 5 (count Sites in:(intersection (sites Row 6) (sites Occupied by:Next container:"Board")))) (<= 5 (count Sites in:(intersection (sites Row 7) (sites Occupied by:Next container:"Board")))) (<= 5 (count Sites in:(intersection (sites Row 8) (sites Occupied by:Next container:"Board")))) (<= 5 (count Sites in:(intersection (sites Column 0) (sites Occupied by:Next container:"Board")))) (<= 5 (count Sites in:(intersection (sites Column 1) (sites Occupied by:Next container:"Board")))) (<= 5 (count Sites in:(intersection (sites Column 2) (sites Occupied by:Next container:"Board")))) (<= 5 (count Sites in:(intersection (sites Column 3) (sites Occupied by:Next container:"Board")))) (<= 5 (count Sites in:(intersection (sites Column 4) (sites Occupied by:Next container:"Board")))) (<= 5 (count Sites in:(intersection (sites Column 5) (sites Occupied by:Next container:"Board")))) (<= 5 (count Sites in:(intersection (sites Column 6) (sites Occupied by:Next container:"Board")))) (<= 5 (count Sites in:(intersection (sites Column 7) (sites Occupied by:Next container:"Board")))) (<= 5 (count Sites in:(intersection (sites Column 8) (sites Occupied by:Next container:"Board"))))})) (result Mover Loss)) (if (no Moves Mover) (result Mover Loss))}))) 
Connect 4 is played on a vertically placed grid of 7x6, where colored disks are dropped from the top of the grid. Players alternate dropping discs, which fall to the bottom of the column in which they are dropped. The first player to create a row of four disks in their color wins. 
(game "Connect Four" (players 2) (equipment {(board (rectangle 1 7)) (piece "Disc" Each)}) (rules (play (move Add (to (forEach (sites Board) if:(< (size Stack at:(site)) 6))) stack:True)) (end (if (is Line 4 byLevel:True) (result Mover Win))))) 
Played on a Go-like board (6x6 or larger, but a 19x19 go board is ideal) with two colors of stones (usually white and black). Black goes first by placing one stone. Play continues with each player playing two stones per turn. The first player to make a line of six in a row wins.
(game "Connect6" (players 2) (equipment {(board (square 19) use:Vertex) (piece "Marker" Each)}) (rules phases:{(phase "Opening" (play (move Add (to (sites Empty)))) (nextPhase "Playing")) (phase "Playing" (play (move Add (to (sites Empty)) (then (if (is Even (count Moves)) (moveAgain))))) (nextPhase "Playing"))} (end (if (is Line 6 All) (result Mover Win))))) 
Played on a 9x9 board with nine Go pieces per player occupying their two nearest ranks. Pieces move as a rook in Shogi. Pieces may also move by hopping over an adjacent piece of any color. This does not capture the piece, and multiple hops are not allowed in on turn. The goal is to create an orthogonal line of five of a player's pieces outside the player's starting rows. The game is played on a Shogi board.
(game "Dai Hasami Shogi" (players 2) (equipment {(board (square 9)) (piece "Marker" Each (or (move Slide Orthogonal) (move Hop Orthogonal (between if:(is Occupied (between))) (to if:(is Empty (to)))) (then (or (custodial (from (last To)) Orthogonal (between (max 1) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Friend (who at:(to))))) (surround (from (last To)) Orthogonal (between if:(and (is In (between) (sites Corners)) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Friend (who at:(to))))))))) (regions P1 (expand (sites Bottom))) (regions P2 (expand (sites Top)))}) (rules (start {(place "Marker1" (sites P1)) (place "Marker2" (sites P2))}) (play (forEach Piece)) (end {(if (is Line 5 Orthogonal if:(not (is In (to) (sites Mover)))) (result Mover Win)) (if (and (< (count Pieces P1) 5) (< (count Pieces P2) 5)) (result Mover Draw))}))) 
6x6 board. Each player has twelve sticks. One player's sticks are without bark to distinguish them. Players placing their sticks in empty spaces, filling the central four first. Once all of the sticks have been placed, the players may move their sticks orthogonally one space. If a player can bring three of their sticks in a row, they may then remove one of the opponent's sticks during either phase of the game. During the movement phase, if a player has a row of four pieces and moves one away, leaving a row of three spaces, this also allows the player to capture an opponent's piece. The player who can no longer play loses.
(game "Dala" (players 2) (equipment {(board (square 6)) (hand Each) (piece "Stick" Each (if (is Line 4 Orthogonal through:(from) exact:True) (move Step Orthogonal (to if:(is Empty (to))) (then (and {(if (and (!= (last From) (ahead (last From) N)) (= (mover) (who at:(ahead (last From) N)))) (if (is Line 3 Orthogonal through:(ahead (last From) N) exact:True) (and (moveAgain) (addScore Mover 1)))) (if (and (!= (last From) (ahead (last From) S)) (= (mover) (who at:(ahead (last From) S)))) (if (is Line 3 Orthogonal through:(ahead (last From) S) exact:True) (and (moveAgain) (addScore Mover 1)))) (if (and (!= (last From) (ahead (last From) E)) (= (mover) (who at:(ahead (last From) E)))) (if (is Line 3 Orthogonal through:(ahead (last From) E) exact:True) (and (moveAgain) (addScore Mover 1)))) (if (and (!= (last From) (ahead (last From) W)) (= (mover) (who at:(ahead (last From) W)))) (if (is Line 3 Orthogonal through:(ahead (last From) W) exact:True) (and (moveAgain) (addScore Mover 1))))}))) (move Step Orthogonal (to if:(is Empty (to))) (then (if (is Line 3 Orthogonal exact:True) (and (moveAgain) (addScore Mover 1)))))))}) (rules (start (place "Stick" "Hand" count:12)) phases:{(phase "PlacementCenter" (play (move (from (handSite Mover)) (to (forEach (sites Centre) if:(is Empty (site)))))) (nextPhase (= (count Moves) 4) "Placement")) (phase "Placement" (play (if (!= 0 (score Mover)) (move Remove (sites Occupied by:Next container:"Board") (then (and (set Score Mover (- (score Mover) 1)) (if (< 1 (score Mover)) (moveAgain))))) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3 Orthogonal exact:True) (and (moveAgain) (addScore Mover 1))))))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (!= 0 (score Mover)) (move Remove (sites Occupied by:Next container:"Board") (then (and (set Score Mover (- (score Mover) 1)) (if (< 1 (score Mover)) (moveAgain))))) (forEach Piece))) (end (if (<= (count Pieces Next) 2) (result Next Loss))))})) 
5x6 board. Players have 12 pieces each. They take turns placing pieces on an empty board.Once all pieces are placed, players can move pieces orthogonally to an adjacent space, attempting to make three in a row. When three in a row are made, an opponent's piece is removed from the board that is not in a three in a row pattern. Placing more than three in a row is not allowed. Three in a row during the initial phase of the game does not count. When a player has only two pieces left, they lose. Lines of 4 cannot be made during the drop phase.
(game "Dara" (players 2) (equipment {(board (rectangle 5 6)) (hand Each) (piece "Marker" Each (move Step Orthogonal (to if:(is Empty (to))) (then (if (is Line 3 Orthogonal) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:12)) phases:{(phase "Placement" (play (do (move (from (handSite Mover)) (to (sites Empty))) ifAfterwards:(not (is Line 4 Orthogonal)))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (do (forEach Piece) ifAfterwards:(not (is Line 4 Orthogonal))))))} (end (if (<= (count Pieces Next) 2) (result Next Loss))))) 
Three concentric squares, with lines connecting the corners and midpoints of the squares. Two players. Players alternate turns placing one of their pieces on one of the spots on the board. A player may place a piece on top of a piece belonging to their opponent during this phase of the game, and they are both canceled out. When three uncanceled pieces form a row along the lines on the board, the player may capture one of the opponent's pieces. Once all of the spots have been occupied, the canceled pieces are removed. Players alternate turns moving one of their pieces to an empty adjacent spot on the board.The player who captures all of the opponent's pieces wins.
(game "Dig Dig" (players 2) (equipment {(board (concentric Square rings:3 joinCorners:True) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to))) (then (if (is Line 3 if:(= 1 (size Stack at:(to)))) (moveAgain)))))}) (rules (start {(place Stack "Marker1" (handSite P1)) (place Stack "Marker2" (handSite P2))}) phases:{(phase "Placement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Next container:"Board") if:(= 1 (size Stack at:(site))))) (move (from (handSite Mover)) (to (union (forEach (sites Occupied by:Next container:"Board") if:(= 1 (size Stack at:(site)))) (sites Empty))) copy:True (then (if (is Line 3 if:(= 1 (size Stack at:(to)))) (moveAgain)))) (then (if (and (not (is Next Mover)) (is Full)) (and {(forEach Site (forEach (sites Occupied by:P1 container:"Board") if:(= (size Stack at:(site)) 2)) (and (remove (site)) (remove (site)))) (forEach Site (forEach (sites Occupied by:P2 container:"Board") if:(= (size Stack at:(site)) 2)) (and (remove (site)) (remove (site)))) (set Pending)}))))) (nextPhase (is Pending) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Next container:"Board") if:(= 1 (size Stack at:(site))))) (forEach Piece))) (end (if (all Sites (sites Occupied by:Next) if:(not (is In (site) (sites Board)))) (result Mover Win))))})) 
3x3 intersecting lines. Three pieces per player. Players alternate turns placing a piece on an empty spot on the board. When all of the pieces are placed, players alternate turns moving a piece to an empty adjacent spot. The first player to place their three pieces along one of the lines wins.
(game "Djara-Badakh" (players 2) (equipment {(board (square 3) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to)))))}) (rules (start (place "Marker" "Hand" count:3)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end (if (is Line 3) (result Mover Win))))) 
5x6 board. Each player has twelve pieces. Players alternate placing their pieces until they are all placed on the board. Players cannot make a row of three pieces in the placement phase. Once the pieces are all on the board, they may be moved one space orthogonally. The goal is to make a line of three, which allows the player to capture one of the opponent's pieces. In the case that a move creates two lines of three, only one capture is made. The player who captures the most pieces wins. Matches are typically played to a score of ten, with a player scoring one point by winning a game, and two points for winning without any of their pieces being captured.
(game "Dra" (players 2) (equipment {(board (rectangle 5 6)) (hand Each) (piece "Marker" Each (move Step Orthogonal (to if:(is Empty (to))) (then (if (is Line 3 Orthogonal exact:True) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:12)) phases:{(phase "Placement" (play (do (move (from (handSite Mover)) (to (sites Empty))) ifAfterwards:(not (is Line 3 Orthogonal)))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (sites Occupied by:Enemy container:"Board")) (forEach Piece))) (end (if (<= (count Pieces Next) 2) (result Next Loss))))})) 
3x3 intersecting lines. Three pieces per player. Players alternate turns placing pieces on an empty spot on the board. When all pieces are placed, players alternate turns moving a piece to any empty spot on the board. The first player to place their pieces in an orthogonal row along the lines wins. 
(game "Driesticken" (players 2) (equipment {(board (square 3) use:Vertex) (hand Each) (piece "Marker" Each (move (from) (to (sites Empty))))}) (rules (start (place "Marker" "Hand" count:3)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end (if (is Line 3 Orthogonal) (result Mover Win))))) 
3x3 grid. Three pieces per player. Players alternate turns placing a piece on the board. When all of the pieces are placed, players alternate turns moving a piece to any empty space on the board. The player who places three pieces in an orthogonal row wins. 
(game "Dris at-Talata" (players 2) (equipment {(board (square 3)) (hand Each) (piece "Marker" Each)}) (rules (start (place "Marker" "Hand" count:3)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (move (from (sites Occupied by:Mover)) (to (sites Empty)))))} (end (if (is Line 3 Orthogonal) (result Mover Win))))) 
3x3 intersecting lines, with diagonals. Three pieces per player. Players alternate turns placing pieces on the board. Once all of the pieces have been placed, the players alternate turns moving a piece to an empty adjacent spot on the board. The first player to place their pieces in a row along one of the lines wins.
(game "Engijn Zirge" (players 2) (equipment {(board (rectangle 3 3 diagonals:Alternating) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to)))))}) (rules (start (place "Marker" "Hand" count:3)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end (if (is Line 3) (result Mover Win))))) 
3x3 intersecting lines with diagonals. Play occurs on the intersections of the lines. Players each have three pieces, initially placed on the sides closest to the player. Players move the pieces to an adjacent unoccupied intersection along the lines. The goal is to make three in a row which cannot be in the starting position.
(game "Epelle" (players 2) (equipment {(board (rectangle 3 diagonals:Alternating) use:Vertex) (piece "Marker" Each (move Step (to if:(is Empty (to))))) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Marker1" (sites P1)) (place "Marker2" (sites P2))}) (play (forEach Piece)) (end (if (and (not (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover)))) (is Line 3)) (result Mover Win))))) 
3x3 intersecting lines with diagonals. Play occurs on the intersections of the lines. Each player has three pieces. Play begins with each player placing pieces on empty points. If they make three in a row along the lines, they win. Once all pieces are placed, players take turns moving pieces one spot to an adjacent point along the lines trying to make three in a row. 
(game "Fanorona Telo" (players 2) (equipment {(board (rectangle 3 3 diagonals:Alternating) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to)))))}) (rules (start (place "Marker" "Hand" count:3)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end (if (is Line 3) (result Mover Win))))) 
5x5 board. Twelve pieces per player. Players alternate turns placing two pieces on the board. When all of the pieces are placed, players alternate turns moving one piece orthogonally any distance. The first player to place five of their pieces in an orthogonal or diagonal line wins. 
(game "Fart (5x5)" (players 2) (equipment {(board (square 5)) (piece "Marker" Each (move Slide Orthogonal)) (hand Each)}) (rules (start (place "Marker" "Hand" count:12)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (difference (sites Board) (centrePoint)) if:(is Empty (to))) (then (if (not (is Prev Mover)) (moveAgain))))) (nextPhase Mover (is Empty (handSite Mover)) "Move")) (phase "Move" (play (forEach Piece)))} (end (if (is Line 5) (result Mover Win))))) 
7x7 board. 24 pieces per player. Players alternate turns placing two pieces on the board. When all of the pieces are placed, players alternate turns moving one piece orthogonally any distance. The first player to place seven of their pieces in an orthogonal or diagonal line wins. 
(game "Fart (7x7)" (players 2) (equipment {(board (square 7)) (piece "Marker" Each (move Slide Orthogonal)) (hand Each)}) (rules (start (place "Marker" "Hand" count:24)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (difference (sites Board) (centrePoint)) if:(is Empty (to))) (then (if (not (is Prev Mover)) (moveAgain))))) (nextPhase Mover (is Empty (handSite Mover)) "Move")) (phase "Move" (play (forEach Piece)))} (end (if (is Line 7) (result Mover Win))))) 
Three concentric squares, with lines connecting the midpoints of the sides. Eleven pieces per player. Players alternate turns placing a piece on the board. When a player lines up three of their pieces in a row along one of the lines of the board, the player removes one of the opponent's pieces. When all of the pieces are placed, players move their pieces one spot along the lines of the board. The player who captures all of the opponent's pieces wins.
(game "Fettas" (players 2) (equipment {(board (concentric Square rings:3) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to))) (then (if (is Line 3 Orthogonal exact:True) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:11)) phases:{(phase "Placement" (play (if (is Prev Mover) (move Remove (sites Occupied by:Enemy container:"Board")) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3 Orthogonal exact:True) (moveAgain)))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (sites Occupied by:Enemy container:"Board")) (forEach Piece))))} (end (if (no Pieces Next) (result Next Loss))))) 
Played on a square grid (8x8 or larger) with two players. Players alternate placing one stone of their colour on the board on any empty point. If a player makes a line of five pieces, either orthogonally or diagonally, they win; but if they make a line of four pieces, they lose. Played on a size 10 board.
(game "Fivalath" (players 2) (equipment {(board (square 10) use:Vertex) (piece "Ball" Each)}) (rules (play (move Add (to (sites Empty)))) (end {(if (is Line 5 All) (result Mover Win)) (if (is Line 4 All) (result Mover Loss))}))) 
The board has two concentric squares, with a line connecting the center points of each side of the two squares, but not extending inside the perimeter of the central square. Play occurs on the intersections of the lines and the corners of the squares. Each player has five pieces. Play begins with each player placing pieces on empty points. If they make three in a row along the lines, they can remove one of the opponent's pieces. Once all pieces are place, players take turns moving pieces one spot to an adjacent point along the lines. If a player makes three in a row, an opponent's piece is removed as in the first phase of the game. The game is won when the opponent is reduced to two pieces. Any Enemy piece can be captured.
(game "Five Men's Morris" (players 2) (equipment {(board (concentric Square rings:2) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to))) (then (if (is Line 3 Orthogonal exact:True) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:5)) phases:{(phase "Placement" (play (if (is Prev Mover) (move Remove (sites Occupied by:Enemy container:"Board")) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3 Orthogonal exact:True) (moveAgain)))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (sites Occupied by:Enemy container:"Board")) (forEach Piece))))} (end (if (<= (count Pieces Next) 2) (result Next Loss))))) 
Your goal in Gobblet Junior is to place three of your pieces in a horizontal, vertical or diagonal row. Your pieces can stack on top of each other, and they start the game nested, off the board. On a turn, you either play one exposed piece from your three off-the-board piles or move one piece on the board to any other spot on the board where it fits. A larger piece can cover any smaller piece. Your memory is tested as you try to remember which color one of your larger pieces is covering before you move it. As soon as a player has three like-colored pieces in a row, he wins.
(game "Gobblet Gobblers" (players 2) (equipment {(board (square 3)) (piece "Disc1" Each) (piece "Disc2" Each) (piece "Disc3" Each) (hand Each size:3)}) (rules (start {(place Stack "Disc11" (handSite P1) count:3) (place Stack "Disc12" (handSite P2) count:3) (place Stack "Disc21" (handSite P1 1) count:3) (place Stack "Disc22" (handSite P2 1) count:3) (place Stack "Disc31" (handSite P1 2) count:3) (place Stack "Disc32" (handSite P2 2) count:3)}) (play (or (move (from (sites Hand Mover)) (to (sites Board) if:(and (!= (from) (to)) (or (is Empty (to)) (< (- (what at:(from) level:(topLevel at:(from))) (who at:(from) level:(topLevel at:(from)))) (- (what at:(to) level:(topLevel at:(to))) (who at:(to) level:(topLevel at:(to))))))))) (move (from (sites Occupied by:Mover top:True)) (to (sites Board) if:(and (!= (from) (to)) (or (is Empty (to)) (< (- (what at:(from) level:(topLevel at:(from))) (who at:(from) level:(topLevel at:(from)))) (- (what at:(to) level:(topLevel at:(to))) (who at:(to) level:(topLevel at:(to))))))))))) (end (forEach Player if:(is Line 3 Player top:True) (result Player Win))))) 
Played on a Go board, using 15x15 of the intersecting lines. The first player places 2 black and 1 white piece on the board. The second player can then choose to: play as black, play as white and place another white piece, or place two more stones and let the other player choose which color to play. Players take turns placing pieces in an attempt to make 5 in a row. In the Standard version, rows of more than five do not count. Played on a 15x15 board. Open anywhere. Win with a line of exactly five stones.
(game "Gomoku" (players 2) (equipment {(board (square 15) use:Vertex) (piece "Marker" Each)}) (rules (play (move Add (to (sites Empty)))) (end (if (is Line 5 All exact:True) (result Mover Win))))) 
Three concentric triangles, with lines connecting their midpoints and corners. Eight pieces per player. Players alternate turns placing a piece on an empty spot on the board. When all of the pieces are placed, players alternate turns moving a piece to an empty adjacent spot along the lines. When a player places three of their pieces in a row, they remove one of the opponent's pieces from the board. A piece that is in a three-in-a-row pattern cannot be removed. The player who removes all of the opponent's pieces wins.
(game "Gurgaldaj" (players 2) (equipment {(board (concentric Triangle rings:3 joinCorners:True) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to))) (then (if (is Line 3 Orthogonal) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:8)) phases:{(phase "Placement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3 Orthogonal) (moveAgain)))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (forEach Piece))))} (end (if (no Pieces Next) (result Next Loss))))) 
Two triangles, which form a six-pointed star, with lines connecting the corner of one triangle with the corner of the other triangle which is opposite it. Nine pieces per player. Players alternate turns placing a piece on an empty point on the board. Players cannot place a piece in the central point during this phase. When all of the pieces are placed, players alternate turns moving a piece to an empty adjacent point on the board. During either phase, when a player places three of their pieces in a row, they remove one of the opponent's pieces. When three pieces are in a three-in-a-row pattern, they cannot be removed. The player who removes all of the opponent's pieces from the board wins.
(game "Jeson Zam" (players 2) (equipment {(board (add (remove (add (merge {(rotate 30 (tri 2)) (shift 0.2 0 (rotate -30 (tri 2)))}) vertices:{{0.6 0.3}}) edges:{{0 2} {0 1} {1 2} {3 5} {5 4} {4 3}}) vertices:{{0.6 0.625} {0.915 0.3} {0.285 0.3} {0.6 -0.01} {0.285 0.1725} {0.285 0.4375} {0.915 0.4375} {0.915 0.1725} {0.75 0.075} {0.45 0.075} {0.75 0.535} {0.45 0.535}} edges:{{1 13} {13 17} {17 7} {7 2} {2 12} {12 9} {9 11} {11 0} {5 13} {13 8} {8 14} {14 4} {1 14} {14 15} {15 10} {10 0} {5 7} {7 18} {18 12} {12 3} {3 11} {11 16} {16 10} {10 4} {0 16} {16 6} {6 17} {17 5} {4 15} {15 6} {6 18} {18 2} {3 9} {9 6} {6 8} {8 1}}) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to))) (then (if (is Line 3) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:9)) phases:{(phase "Placement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (move (from (handSite Mover)) (to (difference (sites Empty) (sites Centre))) (then (if (is Line 3) (moveAgain)))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (forEach Piece))))} (end (if (no Pieces Next) (result Next Loss))))) 
DROP - A player, on his turn, can drop a stone on an empty cell. SHIFT - Instead of dropping a stone, the player may decide to shift one row or column, one cell left/right (for rows) or up/down (for columns). All stones are shifted on the chosen direction. If a stone is shifted off-board, it is placed on the other end of the shifted row/column (so, for shift purposes, the board is a Torus). KO rule- If a player has just shifted, the next player cannot shift that row/column. GOAL - A player wins when he makes a 5 in-a-row (orthogonal or diagonal). If a shift give both players a 5 in-a-row, wins the player that made that shift.
(game "Kassle" (players 2) (equipment {(board (square 5)) (piece "Square" Each)}) (rules (play (or {(move Add (to (sites Empty))) (move Select (from (forEach (sites Column (- (count Columns) 1)) if:(not (all Sites (sites Row (row of:(site))) if:(is Empty (site)))))) (to (ahead (from) W) if:(not (is In (+ (from) (to)) (sites Pending)))) (then (and {(forEach Site (sites Row (row of:(last From))) (remove (site))) (forEach Site (sites Row (row of:(last From))) (if (!= (ahead (site) W) (site)) (add (piece (what at:(site))) (to (ahead (site) W))) (add (piece (what at:(site))) (to (coord row:(row of:(last From)) column:(- (count Columns) 1)))))) (set Pending (+ (last From) (last To))) (set Pending (+ (coord row:(row of:(last From)) column:0) (ahead (coord row:(row of:(last From)) column:0) E)))}))) (move Select (from (forEach (sites Column 0) if:(not (all Sites (sites Row (row of:(site))) if:(is Empty (site)))))) (to (ahead (from) E) if:(not (is In (+ (from) (to)) (sites Pending)))) (then (and {(forEach Site (sites Row (row of:(last From))) (remove (site))) (forEach Site (sites Row (row of:(last From))) (if (!= (ahead (site) E) (site)) (add (piece (what at:(site))) (to (ahead (site) E))) (add (piece (what at:(site))) (to (coord row:(row of:(last From)) column:0))))) (set Pending (+ (last From) (last To))) (set Pending (+ (coord row:(row of:(last From)) column:(- (count Columns) 1)) (ahead (coord row:(row of:(last From)) column:(- (count Columns) 1)) W)))}))) (move Select (from (forEach (sites Row 0) if:(not (all Sites (sites Column (column of:(site))) if:(is Empty (site)))))) (to (ahead (from) N) if:(not (is In (+ (from) (to)) (sites Pending)))) (then (and {(forEach Site (sites Column (column of:(last From))) (remove (site))) (forEach Site (sites Column (column of:(last From))) (if (!= (ahead (site) N) (site)) (add (piece (what at:(site))) (to (ahead (site) N))) (add (piece (what at:(site))) (to (coord row:0 column:(column of:(last From))))))) (set Pending (+ (last From) (last To))) (set Pending (+ (coord row:(- (count Rows) 1) column:(column of:(last To))) (ahead (coord row:(- (count Rows) 1) column:(column of:(last To))) S)))}))) (move Select (from (forEach (sites Row (- (count Rows) 1)) if:(not (all Sites (sites Column (column of:(site))) if:(is Empty (site)))))) (to (ahead (from) S) if:(not (is In (+ (from) (to)) (sites Pending)))) (then (and {(forEach Site (sites Column (column of:(last From))) (remove (site))) (forEach Site (sites Column (column of:(last From))) (if (!= (ahead (site) S) (site)) (add (piece (what at:(site))) (to (ahead (site) S))) (add (piece (what at:(site))) (to (coord row:(- (count Rows) 1) column:(column of:(last From))))))) (set Pending (+ (last From) (last To))) (set Pending (+ (coord row:(- (count Rows) 1) column:0) (ahead (coord row:(- (count Rows) 1) column:0) N)))})))})) (end {(if (and (not (all Sites (sites Occupied by:P1) if:(not (is Line 5 through:(site))))) (not (all Sites (sites Occupied by:P2) if:(not (is Line 5 through:(site)))))) (result Mover Win)) (if (not (all Sites (sites Occupied by:P1) if:(not (is Line 5 through:(site))))) (result P1 Win)) (if (not (all Sites (sites Occupied by:P2) if:(not (is Line 5 through:(site))))) (result P2 Win))}))) 
Three intersecting lines, with diagonals drawn in the square. Two players. Three pieces per player, one playing as red and the other as white. The red player plays first and places their piece in the central spot. Players alternate turns placing one of their pieces on an empty space on the board. When all of the pieces are placed, players alternate turns moving one of their pieces to an empty adjacent spot on the board along the lines. The first player to place three of their pieces in a row wins.
(game "Katsela" (players 2) (equipment {(board (rectangle 3 3 diagonals:Alternating) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to)))))}) (rules (start (place "Marker" "Hand" count:3)) phases:{(phase "Opening" (play (move (from (handSite Mover)) (to (centrePoint)))) (nextPhase "Placing")) (phase "Placing" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Moving")) (phase "Moving" (play (forEach Piece)))} (end (if (is Line 3) (result Mover Win))))) 
Keryo-Pente is played on a 19x19 Go board. White goes first, and plays their first move on the centre point (unless playing Freestyle). After the opening, players alternate playing one stone of their colour onto any empty point. If their placement results in a pair or a line of three enemy stones being sandwiched between two of their own stones, those enemy stones are captured. The first player to form an orthogonal or diagonal line of five (or more) of their stones, or to capture 15 enemy stones, wins the game. Played on a 19x19 board. Open at the centre point.
(game "Keryo-Pente" (players 2) (equipment {(board (square 19) use:Vertex) (piece "Ball" Each)}) (rules (start (set Score Each 0)) phases:{(phase "Opening" (play (move Add (to (sites "J10")))) (nextPhase "General")) (phase "General" (play (move Add (to (sites Empty)) (then (custodial (from (last To)) All (between if:(is Next (who at:(between))) (apply (remove (between)))) (to if:(and (or (= 3 (count Steps Vertex All (last To) (to))) (= 4 (count Steps Vertex All (last To) (to)))) (is Mover (who at:(to))))) (then (addScore Mover 1)))))))} (end {(if (is Line 5 All) (result Mover Win)) (if (> (score Mover) 14) (result Mover Win))}))) 
Three concentric squares, with lines connecting the midpoints of the sides. Nine pieces per player. Players alternate turns placing a piece on the board. When a player places three of their pieces in a line of three along one of the lines on the board, they capture one of the opponent's pieces. When all of the pieces have been placed, players alternate turns moving one of their pieces to an adjacent empty spot on the board. Players cannot capture one of their opponent's pieces which is in a three-in-a-row alignment. The player who either captures seven of their opponent's pieces or blocks the opponent from being able to move wins.
(game "La Chascona" (players 2) (equipment {(board (concentric Square rings:3) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to))) (then (if (is Line 3 Orthogonal exact:True) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:9)) phases:{(phase "Placement" (play (if (is Prev Mover) (if (can Move (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site)))))) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (move Remove (sites Occupied by:Enemy container:"Board"))) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3 Orthogonal exact:True) (moveAgain)))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (if (can Move (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site)))))) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (move Remove (sites Occupied by:Enemy container:"Board"))) (forEach Piece))))} (end (if (or (no Moves Next) (<= (count Pieces Next) 2)) (result Mover Win))))) 
3x3 board with diagonals. Three pieces per player. Players take turns placing their pieces. Once all pieces have been placed, they may move a piece to any unoccupied spot. The first player to align their three pieces in a row along one of lines on the board is the winner. The board is 3x3 and the winning conditions is a 3 in a row.
(game "Les Pendus" (players 2) (equipment {(board (square 3 diagonals:Alternating) use:Vertex) (hand Each) (piece "Marker" Each (move (from) (to (sites Empty))))}) (rules (start (place "Marker" "Hand" count:3)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end (if (is Line 3) (result Mover Win))))) 
3x3 intersecting lines, with diagonals. Three pieces per player. Players alternate turns placing a piece on an empty spot on the board. Once all of the pieces are placed, the players alternate turns moving a piece to an empty adjacent spot along the lines. The first player to place three pieces in a line wins.
(game "Liu Tsi" (players 2) (equipment {(board (rectangle 3 3 diagonals:Alternating) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to)))))}) (rules (start (place "Marker" "Hand" count:3)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end (if (is Line 3) (result Mover Win))))) 
5x5 intersecting lines, with diagonals in the quadrants. Five pieces per player. Players alternate turns placing a piece on the board. Once all of the pieces are placed on the board, players alternate turns moving a piece to an empty adjacent spot on the board. The player who places all five of their pieces in a line wins.
(game "Marelle Quadruple" (players 2) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to)))))}) (rules (start (place "Marker" "Hand" count:5)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end (if (is Line 5) (result Mover Win))))) 
Three concentric squares, the corners and midpoints of the squares connected with lines. Nine pieces per player. Players alternate turns placing a piece on an empty spot on the board. When all of the pieces are placed, the players alternate turns moving a piece to an empty adjacent spot along the lines. During either phase, when a player places three of their pieces in a row along the orthogonal lines (not along the diagonal lines), the player removes any one of the opponent's pieces. When a player is reduced to four pieces, they may move a piece to any open spot on the board. The player who reduces the opponent to two pieces wins. 
(game "Marelle Triple" (players 2) (equipment {(board (concentric Square rings:3 joinCorners:True) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to))) (then (if (or {(is Line 3 N exact:True) (is Line 3 S exact:True) (is Line 3 E exact:True) (is Line 3 W exact:True)}) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:9)) phases:{(phase "Placement" (play (if (is Prev Mover) (move Remove (sites Occupied by:Enemy container:"Board")) (move (from (handSite Mover)) (to (sites Empty)) (then (if (or {(is Line 3 N exact:True) (is Line 3 S exact:True) (is Line 3 E exact:True) (is Line 3 W exact:True)}) (moveAgain)))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (sites Occupied by:Enemy container:"Board")) (if (> (count Pieces Mover) 4) (forEach Piece) (move (from (sites Occupied by:Mover)) (to (sites Empty)))))))} (end (if (<= (count Pieces Next) 2) (result Next Loss))))) 
Goal: The last player to complete a turn wins - typically when the opponent runs out of pieces in their hand. Each player starts with a full set of 9 pieces: each combination of shape and color. Pieces once played are not owned, but may be recaptured during the game for reuse. The game starts with a placement by the first player. Thereafter, each turn has a placement followed by a movement, and one or more required piece recaptures if available. -- 1. Placement: The first step in every turn is a placement to an empty point next to at least one existing piece that can slide. -- 2. Movement: The player must choose on piece next to the newly placed piece and slide it orthogonally one or two points to a new position. The piece can only move to empty points, never crossing a piece in play. -- 3. Capture: Either (or both) of the first two actions can form one or more 'mills'. A mill is an orthogonal line of three uniquely different piece types that all share one common attribute - either color or shape. The player completes their turn by destroying every mill on the board by removing one of the 2 unmoved pieces that it contains. (Newly added and moved pieces may not be removed.) A turn is not complete until all the applicable actions have been performed. A player may not make a move that would bring their hand size to more than 9 pieces.
(game "Millieu" (players 2) (equipment {(board (remove (rectangle 9 3) cells:{4 5 10 11}) use:Vertex) (hand Each size:9) (piece "Disc" Shared maxState:3) (piece "Square" Shared maxState:3) (piece "Hex" Shared maxState:3)}) (rules (start {(place "Disc" (handSite P1 0) state:3) (place "Disc" (handSite P1 1) state:1) (place "Disc" (handSite P1 2) state:2) (place "Square" (handSite P1 3) state:3) (place "Square" (handSite P1 4) state:1) (place "Square" (handSite P1 5) state:2) (place "Hex" (handSite P1 6) state:3) (place "Hex" (handSite P1 7) state:1) (place "Hex" (handSite P1 8) state:2) (place "Disc" (handSite P2 0) state:3) (place "Disc" (handSite P2 1) state:1) (place "Disc" (handSite P2 2) state:2) (place "Square" (handSite P2 3) state:3) (place "Square" (handSite P2 4) state:1) (place "Square" (handSite P2 5) state:2) (place "Hex" (handSite P2 6) state:3) (place "Hex" (handSite P2 7) state:1) (place "Hex" (handSite P2 8) state:2) (set Score Each 9)}) (play (if (> 0 (counter)) (move (from (sites Hand Mover)) (to (sites Board) if:(is Empty (to)))) (if (not (is Prev Mover)) (move (from (sites Hand Mover)) (to (sites Board) if:(and (is Empty (to)) (or (< 0 (count Pieces in:(sites Around (to)))) (< 0 (count Pieces in:(sites (results from:(to) to:(forEach (difference (difference (sites {(% (from) 9) (+ (% (from) 9) 9) (+ (% (from) 9) 18)}) (from)) (sites Empty)) if:(or (= (site) (+ (% (from) 9) 9)) (= (from) (+ (% (from) 9) 9)))) (to)))))))) (then (and (set Var "LastMove1" (last To)) (moveAgain)))) (if (= 0 (count Sites in:(sites Pending))) (move (from (union (sites Around (var "LastMove1")) (sites (results from:(var "LastMove1") to:(forEach (difference (difference (sites {(% (from) 9) (+ (% (from) 9) 9) (+ (% (from) 9) 18)}) (from)) (sites Empty)) if:(or (= (site) (+ (% (from) 9) 9)) (= (from) (+ (% (from) 9) 9)))) (to))))) (to (union (sites LineOfSight Empty Vertex at:(from)) (sites (results from:(from) to:(forEach (intersection (difference (sites {(% (from) 9) (+ (% (from) 9) 9) (+ (% (from) 9) 18)}) (from)) (sites Empty)) if:(or (is Empty (+ (% (from) 9) 9)) (= (from) (+ (% (from) 9) 9)))) (to))))) (then (set Var "LastMove2" (last To)))) (do (move (from (sites Pending)) (to (sites Hand Mover) if:(is Empty (to)))) ifAfterwards:(all Sites (sites {(var "LastMove1") (var "LastMove2")}) if:(is Occupied (site)))) (then (and {(and {(if (or (and {(= (state at:(* (/ (var "LastMove1") 3) 3)) (state at:(+ {(* (/ (var "LastMove1") 3) 3) 1}))) (= (state at:(* (/ (var "LastMove1") 3) 3)) (state at:(+ {(* (/ (var "LastMove1") 3) 3) 1 1}))) (!= (what at:(* (/ (var "LastMove1") 3) 3)) (what at:(+ {(* (/ (var "LastMove1") 3) 3) 1}))) (!= (what at:(* (/ (var "LastMove1") 3) 3)) (what at:(+ {(* (/ (var "LastMove1") 3) 3) 1 1}))) (!= (what at:(+ {(* (/ (var "LastMove1") 3) 3) 1})) (what at:(+ {(* (/ (var "LastMove1") 3) 3) 1 1})))}) (and {(= (what at:(* (/ (var "LastMove1") 3) 3)) (what at:(+ {(* (/ (var "LastMove1") 3) 3) 1}))) (= (what at:(* (/ (var "LastMove1") 3) 3)) (what at:(+ {(* (/ (var "LastMove1") 3) 3) 1 1}))) (!= (state at:(* (/ (var "LastMove1") 3) 3)) (state at:(+ {(* (/ (var "LastMove1") 3) 3) 1}))) (!= (state at:(* (/ (var "LastMove1") 3) 3)) (state at:(+ {(* (/ (var "LastMove1") 3) 3) 1 1}))) (!= (state at:(+ {(* (/ (var "LastMove1") 3) 3) 1})) (state Vertex at:(+ {(* (/ (var "LastMove1") 3) 3) 1 1})))})) (and {(set Pending (* (/ (var "LastMove1") 3) 3)) (set Pending (+ (* (/ (var "LastMove1") 3) 3) 1)) (set Pending (+ (* (/ (var "LastMove1") 3) 3) 2))})) (if (or (and {(= (state at:(+ (% (var "LastMove1") 3) (* (/ (var "LastMove1") 9) 9))) (state at:(+ {(+ (% (var "LastMove1") 3) (* (/ (var "LastMove1") 9) 9)) 3}))) (= (state at:(+ (% (var "LastMove1") 3) (* (/ (var "LastMove1") 9) 9))) (state at:(+ {(+ (% (var "LastMove1") 3) (* (/ (var "LastMove1") 9) 9)) 3 3}))) (!= (what at:(+ (% (var "LastMove1") 3) (* (/ (var "LastMove1") 9) 9))) (what at:(+ {(+ (% (var "LastMove1") 3) (* (/ (var "LastMove1") 9) 9)) 3}))) (!= (what at:(+ (% (var "LastMove1") 3) (* (/ (var "LastMove1") 9) 9))) (what at:(+ {(+ (% (var "LastMove1") 3) (* (/ (var "LastMove1") 9) 9)) 3 3}))) (!= (what at:(+ {(+ (% (var "LastMove1") 3) (* (/ (var "LastMove1") 9) 9)) 3})) (what at:(+ {(+ (% (var "LastMove1") 3) (* (/ (var "LastMove1") 9) 9)) 3 3})))}) (and {(= (what at:(+ (% (var "LastMove1") 3) (* (/ (var "LastMove1") 9) 9))) (what at:(+ {(+ (% (var "LastMove1") 3) (* (/ (var "LastMove1") 9) 9)) 3}))) (= (what at:(+ (% (var "LastMove1") 3) (* (/ (var "LastMove1") 9) 9))) (what at:(+ {(+ (% (var "LastMove1") 3) (* (/ (var "LastMove1") 9) 9)) 3 3}))) (!= (state at:(+ (% (var "LastMove1") 3) (* (/ (var "LastMove1") 9) 9))) (state at:(+ {(+ (% (var "LastMove1") 3) (* (/ (var "LastMove1") 9) 9)) 3}))) (!= (state at:(+ (% (var "LastMove1") 3) (* (/ (var "LastMove1") 9) 9))) (state at:(+ {(+ (% (var "LastMove1") 3) (* (/ (var "LastMove1") 9) 9)) 3 3}))) (!= (state at:(+ {(+ (% (var "LastMove1") 3) (* (/ (var "LastMove1") 9) 9)) 3})) (state Vertex at:(+ {(+ (% (var "LastMove1") 3) (* (/ (var "LastMove1") 9) 9)) 3 3})))})) (and {(set Pending (+ (% (var "LastMove1") 3) (* (/ (var "LastMove1") 9) 9))) (set Pending (+ (+ (% (var "LastMove1") 3) (* (/ (var "LastMove1") 9) 9)) 3)) (set Pending (+ (+ (% (var "LastMove1") 3) (* (/ (var "LastMove1") 9) 9)) 6))})) (if (or (and {(= (state at:(% (var "LastMove1") 9)) (state at:(+ {(% (var "LastMove1") 9) 9}))) (= (state at:(% (var "LastMove1") 9)) (state at:(+ {(% (var "LastMove1") 9) 9 9}))) (!= (what at:(% (var "LastMove1") 9)) (what at:(+ {(% (var "LastMove1") 9) 9}))) (!= (what at:(% (var "LastMove1") 9)) (what at:(+ {(% (var "LastMove1") 9) 9 9}))) (!= (what at:(+ {(% (var "LastMove1") 9) 9})) (what at:(+ {(% (var "LastMove1") 9) 9 9})))}) (and {(= (what at:(% (var "LastMove1") 9)) (what at:(+ {(% (var "LastMove1") 9) 9}))) (= (what at:(% (var "LastMove1") 9)) (what at:(+ {(% (var "LastMove1") 9) 9 9}))) (!= (state at:(% (var "LastMove1") 9)) (state at:(+ {(% (var "LastMove1") 9) 9}))) (!= (state at:(% (var "LastMove1") 9)) (state at:(+ {(% (var "LastMove1") 9) 9 9}))) (!= (state at:(+ {(% (var "LastMove1") 9) 9})) (state Vertex at:(+ {(% (var "LastMove1") 9) 9 9})))})) (and {(set Pending (% (var "LastMove1") 9)) (set Pending (+ (% (var "LastMove1") 9) 9)) (set Pending (+ (% (var "LastMove1") 9) 18))}))}) (and {(if (or (and {(= (state at:(* (/ (var "LastMove2") 3) 3)) (state at:(+ {(* (/ (var "LastMove2") 3) 3) 1}))) (= (state at:(* (/ (var "LastMove2") 3) 3)) (state at:(+ {(* (/ (var "LastMove2") 3) 3) 1 1}))) (!= (what at:(* (/ (var "LastMove2") 3) 3)) (what at:(+ {(* (/ (var "LastMove2") 3) 3) 1}))) (!= (what at:(* (/ (var "LastMove2") 3) 3)) (what at:(+ {(* (/ (var "LastMove2") 3) 3) 1 1}))) (!= (what at:(+ {(* (/ (var "LastMove2") 3) 3) 1})) (what at:(+ {(* (/ (var "LastMove2") 3) 3) 1 1})))}) (and {(= (what at:(* (/ (var "LastMove2") 3) 3)) (what at:(+ {(* (/ (var "LastMove2") 3) 3) 1}))) (= (what at:(* (/ (var "LastMove2") 3) 3)) (what at:(+ {(* (/ (var "LastMove2") 3) 3) 1 1}))) (!= (state at:(* (/ (var "LastMove2") 3) 3)) (state at:(+ {(* (/ (var "LastMove2") 3) 3) 1}))) (!= (state at:(* (/ (var "LastMove2") 3) 3)) (state at:(+ {(* (/ (var "LastMove2") 3) 3) 1 1}))) (!= (state at:(+ {(* (/ (var "LastMove2") 3) 3) 1})) (state Vertex at:(+ {(* (/ (var "LastMove2") 3) 3) 1 1})))})) (and {(set Pending (* (/ (var "LastMove2") 3) 3)) (set Pending (+ (* (/ (var "LastMove2") 3) 3) 1)) (set Pending (+ (* (/ (var "LastMove2") 3) 3) 2))})) (if (or (and {(= (state at:(+ (% (var "LastMove2") 3) (* (/ (var "LastMove2") 9) 9))) (state at:(+ {(+ (% (var "LastMove2") 3) (* (/ (var "LastMove2") 9) 9)) 3}))) (= (state at:(+ (% (var "LastMove2") 3) (* (/ (var "LastMove2") 9) 9))) (state at:(+ {(+ (% (var "LastMove2") 3) (* (/ (var "LastMove2") 9) 9)) 3 3}))) (!= (what at:(+ (% (var "LastMove2") 3) (* (/ (var "LastMove2") 9) 9))) (what at:(+ {(+ (% (var "LastMove2") 3) (* (/ (var "LastMove2") 9) 9)) 3}))) (!= (what at:(+ (% (var "LastMove2") 3) (* (/ (var "LastMove2") 9) 9))) (what at:(+ {(+ (% (var "LastMove2") 3) (* (/ (var "LastMove2") 9) 9)) 3 3}))) (!= (what at:(+ {(+ (% (var "LastMove2") 3) (* (/ (var "LastMove2") 9) 9)) 3})) (what at:(+ {(+ (% (var "LastMove2") 3) (* (/ (var "LastMove2") 9) 9)) 3 3})))}) (and {(= (what at:(+ (% (var "LastMove2") 3) (* (/ (var "LastMove2") 9) 9))) (what at:(+ {(+ (% (var "LastMove2") 3) (* (/ (var "LastMove2") 9) 9)) 3}))) (= (what at:(+ (% (var "LastMove2") 3) (* (/ (var "LastMove2") 9) 9))) (what at:(+ {(+ (% (var "LastMove2") 3) (* (/ (var "LastMove2") 9) 9)) 3 3}))) (!= (state at:(+ (% (var "LastMove2") 3) (* (/ (var "LastMove2") 9) 9))) (state at:(+ {(+ (% (var "LastMove2") 3) (* (/ (var "LastMove2") 9) 9)) 3}))) (!= (state at:(+ (% (var "LastMove2") 3) (* (/ (var "LastMove2") 9) 9))) (state at:(+ {(+ (% (var "LastMove2") 3) (* (/ (var "LastMove2") 9) 9)) 3 3}))) (!= (state at:(+ {(+ (% (var "LastMove2") 3) (* (/ (var "LastMove2") 9) 9)) 3})) (state Vertex at:(+ {(+ (% (var "LastMove2") 3) (* (/ (var "LastMove2") 9) 9)) 3 3})))})) (and {(set Pending (+ (% (var "LastMove2") 3) (* (/ (var "LastMove2") 9) 9))) (set Pending (+ (+ (% (var "LastMove2") 3) (* (/ (var "LastMove2") 9) 9)) 3)) (set Pending (+ (+ (% (var "LastMove2") 3) (* (/ (var "LastMove2") 9) 9)) 6))})) (if (or (and {(= (state at:(% (var "LastMove2") 9)) (state at:(+ {(% (var "LastMove2") 9) 9}))) (= (state at:(% (var "LastMove2") 9)) (state at:(+ {(% (var "LastMove2") 9) 9 9}))) (!= (what at:(% (var "LastMove2") 9)) (what at:(+ {(% (var "LastMove2") 9) 9}))) (!= (what at:(% (var "LastMove2") 9)) (what at:(+ {(% (var "LastMove2") 9) 9 9}))) (!= (what at:(+ {(% (var "LastMove2") 9) 9})) (what at:(+ {(% (var "LastMove2") 9) 9 9})))}) (and {(= (what at:(% (var "LastMove2") 9)) (what at:(+ {(% (var "LastMove2") 9) 9}))) (= (what at:(% (var "LastMove2") 9)) (what at:(+ {(% (var "LastMove2") 9) 9 9}))) (!= (state at:(% (var "LastMove2") 9)) (state at:(+ {(% (var "LastMove2") 9) 9}))) (!= (state at:(% (var "LastMove2") 9)) (state at:(+ {(% (var "LastMove2") 9) 9 9}))) (!= (state at:(+ {(% (var "LastMove2") 9) 9})) (state Vertex at:(+ {(% (var "LastMove2") 9) 9 9})))})) (and {(set Pending (% (var "LastMove2") 9)) (set Pending (+ (% (var "LastMove2") 9) 9)) (set Pending (+ (% (var "LastMove2") 9) 18))}))}) (if (or (or {(or (and {(= (state at:(* (/ (var "LastMove1") 3) 3)) (state at:(+ {(* (/ (var "LastMove1") 3) 3) 1}))) (= (state at:(* (/ (var "LastMove1") 3) 3)) (state at:(+ {(* (/ (var "LastMove1") 3) 3) 1 1}))) (!= (what at:(* (/ (var "LastMove1") 3) 3)) (what at:(+ {(* (/ (var "LastMove1") 3) 3) 1}))) (!= (what at:(* (/ (var "LastMove1") 3) 3)) (what at:(+ {(* (/ (var "LastMove1") 3) 3) 1 1}))) (!= (what at:(+ {(* (/ (var "LastMove1") 3) 3) 1})) (what at:(+ {(* (/ (var "LastMove1") 3) 3) 1 1})))}) (and {(= (what at:(* (/ (var "LastMove1") 3) 3)) (what at:(+ {(* (/ (var "LastMove1") 3) 3) 1}))) (= (what at:(* (/ (var "LastMove1") 3) 3)) (what at:(+ {(* (/ (var "LastMove1") 3) 3) 1 1}))) (!= (state at:(* (/ (var "LastMove1") 3) 3)) (state at:(+ {(* (/ (var "LastMove1") 3) 3) 1}))) (!= (state at:(* (/ (var "LastMove1") 3) 3)) (state at:(+ {(* (/ (var "LastMove1") 3) 3) 1 1}))) (!= (state at:(+ {(* (/ (var "LastMove1") 3) 3) 1})) (state Vertex at:(+ {(* (/ (var "LastMove1") 3) 3) 1 1})))})) (or (and {(= (state at:(+ (% (var "LastMove1") 3) (* (/ (var "LastMove1") 9) 9))) (state at:(+ {(+ (% (var "LastMove1") 3) (* (/ (var "LastMove1") 9) 9)) 3}))) (= (state at:(+ (% (var "LastMove1") 3) (* (/ (var "LastMove1") 9) 9))) (state at:(+ {(+ (% (var "LastMove1") 3) (* (/ (var "LastMove1") 9) 9)) 3 3}))) (!= (what at:(+ (% (var "LastMove1") 3) (* (/ (var "LastMove1") 9) 9))) (what at:(+ {(+ (% (var "LastMove1") 3) (* (/ (var "LastMove1") 9) 9)) 3}))) (!= (what at:(+ (% (var "LastMove1") 3) (* (/ (var "LastMove1") 9) 9))) (what at:(+ {(+ (% (var "LastMove1") 3) (* (/ (var "LastMove1") 9) 9)) 3 3}))) (!= (what at:(+ {(+ (% (var "LastMove1") 3) (* (/ (var "LastMove1") 9) 9)) 3})) (what at:(+ {(+ (% (var "LastMove1") 3) (* (/ (var "LastMove1") 9) 9)) 3 3})))}) (and {(= (what at:(+ (% (var "LastMove1") 3) (* (/ (var "LastMove1") 9) 9))) (what at:(+ {(+ (% (var "LastMove1") 3) (* (/ (var "LastMove1") 9) 9)) 3}))) (= (what at:(+ (% (var "LastMove1") 3) (* (/ (var "LastMove1") 9) 9))) (what at:(+ {(+ (% (var "LastMove1") 3) (* (/ (var "LastMove1") 9) 9)) 3 3}))) (!= (state at:(+ (% (var "LastMove1") 3) (* (/ (var "LastMove1") 9) 9))) (state at:(+ {(+ (% (var "LastMove1") 3) (* (/ (var "LastMove1") 9) 9)) 3}))) (!= (state at:(+ (% (var "LastMove1") 3) (* (/ (var "LastMove1") 9) 9))) (state at:(+ {(+ (% (var "LastMove1") 3) (* (/ (var "LastMove1") 9) 9)) 3 3}))) (!= (state at:(+ {(+ (% (var "LastMove1") 3) (* (/ (var "LastMove1") 9) 9)) 3})) (state Vertex at:(+ {(+ (% (var "LastMove1") 3) (* (/ (var "LastMove1") 9) 9)) 3 3})))})) (or (and {(= (state at:(% (var "LastMove1") 9)) (state at:(+ {(% (var "LastMove1") 9) 9}))) (= (state at:(% (var "LastMove1") 9)) (state at:(+ {(% (var "LastMove1") 9) 9 9}))) (!= (what at:(% (var "LastMove1") 9)) (what at:(+ {(% (var "LastMove1") 9) 9}))) (!= (what at:(% (var "LastMove1") 9)) (what at:(+ {(% (var "LastMove1") 9) 9 9}))) (!= (what at:(+ {(% (var "LastMove1") 9) 9})) (what at:(+ {(% (var "LastMove1") 9) 9 9})))}) (and {(= (what at:(% (var "LastMove1") 9)) (what at:(+ {(% (var "LastMove1") 9) 9}))) (= (what at:(% (var "LastMove1") 9)) (what at:(+ {(% (var "LastMove1") 9) 9 9}))) (!= (state at:(% (var "LastMove1") 9)) (state at:(+ {(% (var "LastMove1") 9) 9}))) (!= (state at:(% (var "LastMove1") 9)) (state at:(+ {(% (var "LastMove1") 9) 9 9}))) (!= (state at:(+ {(% (var "LastMove1") 9) 9})) (state Vertex at:(+ {(% (var "LastMove1") 9) 9 9})))}))}) (or {(or (and {(= (state at:(* (/ (var "LastMove2") 3) 3)) (state at:(+ {(* (/ (var "LastMove2") 3) 3) 1}))) (= (state at:(* (/ (var "LastMove2") 3) 3)) (state at:(+ {(* (/ (var "LastMove2") 3) 3) 1 1}))) (!= (what at:(* (/ (var "LastMove2") 3) 3)) (what at:(+ {(* (/ (var "LastMove2") 3) 3) 1}))) (!= (what at:(* (/ (var "LastMove2") 3) 3)) (what at:(+ {(* (/ (var "LastMove2") 3) 3) 1 1}))) (!= (what at:(+ {(* (/ (var "LastMove2") 3) 3) 1})) (what at:(+ {(* (/ (var "LastMove2") 3) 3) 1 1})))}) (and {(= (what at:(* (/ (var "LastMove2") 3) 3)) (what at:(+ {(* (/ (var "LastMove2") 3) 3) 1}))) (= (what at:(* (/ (var "LastMove2") 3) 3)) (what at:(+ {(* (/ (var "LastMove2") 3) 3) 1 1}))) (!= (state at:(* (/ (var "LastMove2") 3) 3)) (state at:(+ {(* (/ (var "LastMove2") 3) 3) 1}))) (!= (state at:(* (/ (var "LastMove2") 3) 3)) (state at:(+ {(* (/ (var "LastMove2") 3) 3) 1 1}))) (!= (state at:(+ {(* (/ (var "LastMove2") 3) 3) 1})) (state Vertex at:(+ {(* (/ (var "LastMove2") 3) 3) 1 1})))})) (or (and {(= (state at:(+ (% (var "LastMove2") 3) (* (/ (var "LastMove2") 9) 9))) (state at:(+ {(+ (% (var "LastMove2") 3) (* (/ (var "LastMove2") 9) 9)) 3}))) (= (state at:(+ (% (var "LastMove2") 3) (* (/ (var "LastMove2") 9) 9))) (state at:(+ {(+ (% (var "LastMove2") 3) (* (/ (var "LastMove2") 9) 9)) 3 3}))) (!= (what at:(+ (% (var "LastMove2") 3) (* (/ (var "LastMove2") 9) 9))) (what at:(+ {(+ (% (var "LastMove2") 3) (* (/ (var "LastMove2") 9) 9)) 3}))) (!= (what at:(+ (% (var "LastMove2") 3) (* (/ (var "LastMove2") 9) 9))) (what at:(+ {(+ (% (var "LastMove2") 3) (* (/ (var "LastMove2") 9) 9)) 3 3}))) (!= (what at:(+ {(+ (% (var "LastMove2") 3) (* (/ (var "LastMove2") 9) 9)) 3})) (what at:(+ {(+ (% (var "LastMove2") 3) (* (/ (var "LastMove2") 9) 9)) 3 3})))}) (and {(= (what at:(+ (% (var "LastMove2") 3) (* (/ (var "LastMove2") 9) 9))) (what at:(+ {(+ (% (var "LastMove2") 3) (* (/ (var "LastMove2") 9) 9)) 3}))) (= (what at:(+ (% (var "LastMove2") 3) (* (/ (var "LastMove2") 9) 9))) (what at:(+ {(+ (% (var "LastMove2") 3) (* (/ (var "LastMove2") 9) 9)) 3 3}))) (!= (state at:(+ (% (var "LastMove2") 3) (* (/ (var "LastMove2") 9) 9))) (state at:(+ {(+ (% (var "LastMove2") 3) (* (/ (var "LastMove2") 9) 9)) 3}))) (!= (state at:(+ (% (var "LastMove2") 3) (* (/ (var "LastMove2") 9) 9))) (state at:(+ {(+ (% (var "LastMove2") 3) (* (/ (var "LastMove2") 9) 9)) 3 3}))) (!= (state at:(+ {(+ (% (var "LastMove2") 3) (* (/ (var "LastMove2") 9) 9)) 3})) (state Vertex at:(+ {(+ (% (var "LastMove2") 3) (* (/ (var "LastMove2") 9) 9)) 3 3})))})) (or (and {(= (state at:(% (var "LastMove2") 9)) (state at:(+ {(% (var "LastMove2") 9) 9}))) (= (state at:(% (var "LastMove2") 9)) (state at:(+ {(% (var "LastMove2") 9) 9 9}))) (!= (what at:(% (var "LastMove2") 9)) (what at:(+ {(% (var "LastMove2") 9) 9}))) (!= (what at:(% (var "LastMove2") 9)) (what at:(+ {(% (var "LastMove2") 9) 9 9}))) (!= (what at:(+ {(% (var "LastMove2") 9) 9})) (what at:(+ {(% (var "LastMove2") 9) 9 9})))}) (and {(= (what at:(% (var "LastMove2") 9)) (what at:(+ {(% (var "LastMove2") 9) 9}))) (= (what at:(% (var "LastMove2") 9)) (what at:(+ {(% (var "LastMove2") 9) 9 9}))) (!= (state at:(% (var "LastMove2") 9)) (state at:(+ {(% (var "LastMove2") 9) 9}))) (!= (state at:(% (var "LastMove2") 9)) (state at:(+ {(% (var "LastMove2") 9) 9 9}))) (!= (state at:(+ {(% (var "LastMove2") 9) 9})) (state Vertex at:(+ {(% (var "LastMove2") 9) 9 9})))}))})) (moveAgain))})))) (then (set Score Mover (count Pieces in:(sites Hand Mover)))))) (end (if (no Moves Mover) (result Mover Loss))))) 
DROP - On each turn, each player picks any stone of either color, and changes its color. Then, like in Othello, flips all stones of the other color that are between that stone and the next of same color, in any orthogonal or diagonal direction. GOAL - One player wins if it is able to make an horizontal 8 in-a-row of stones of any color. The other player wins by making a vertical 8 in-a-row. If, after a move, there are one horizontal and one vertical 8 in-a-row, the player that made the move losses.
(game "Minefield" (players 2) (equipment {(board (square 8)) (piece "Disc" Neutral (flips 1 2))}) (rules (start {(place "Disc0" (sites Phase 0) state:1) (place "Disc0" (sites Phase 1) state:2)}) (play (move Select (from (sites Board)) (then (flip (last To) (then (custodial (from (last To)) Adjacent (between if:(!= (state at:(between)) (state at:(last To))) (apply (allCombinations (add (piece "Disc0" state:(mover)) (to (last To))) (flip (between))))) (to if:(= (state at:(to)) (state at:(last To)))))))))) (end {(if (and (!= 0 (count Sites in:(forEach (sites Column 0) if:(or (all Sites (sites Row (row of:(site))) if:(= 1 (state at:(site)))) (all Sites (sites Row (row of:(site))) if:(= 2 (state at:(site)))))))) (!= 0 (count Sites in:(forEach (sites Row 0) if:(or (all Sites (sites Column (column of:(site))) if:(= 1 (state at:(site)))) (all Sites (sites Column (column of:(site))) if:(= 2 (state at:(site))))))))) (result Mover Loss)) (if (!= 0 (count Sites in:(forEach (sites Column 0) if:(or (all Sites (sites Row (row of:(site))) if:(= 1 (state at:(site)))) (all Sites (sites Row (row of:(site))) if:(= 2 (state at:(site)))))))) (result P1 Win)) (if (!= 0 (count Sites in:(forEach (sites Row 0) if:(or (all Sites (sites Column (column of:(site))) if:(= 1 (state at:(site)))) (all Sites (sites Column (column of:(site))) if:(= 2 (state at:(site)))))))) (result P2 Win))}))) 
Three concentric squares, with lines connecting the corners and midpoints of the squares. Twelve pieces per player. In the first phase, players take turns placing pieces on an empty spot on the board. If they place three pieces so they are in a line, forming a "meul." they remove one of the opponent's pieces that is not in a "meul." Once all the pieces are placed, the second phase begins, in which players take turns moving one piece to an adjacent empty spot. When a "meul" is formed, the player removes one of the opponent's pieces that is not in a "meul." When one player is reduced to three pieces, they may move their pieces to any empty spot on the board. The player who reduces their opponent to two pieces wins. 
(game "Mlabalaba" (players 2) (equipment {(board (concentric Square rings:3 joinCorners:True) use:Vertex) (hand Each) (piece "Marker" Each (if (= 3 (count Pieces Mover)) (move (from (from)) (to (sites Empty))) (move Step (to if:(is Empty (to)))) (then (if (is Line 3 Orthogonal) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:12)) phases:{(phase "Placement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3 Orthogonal) (moveAgain)))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (forEach Piece))))} (end (forEach NonMover if:(= 2 (count Pieces Player)) (result Player Loss))))) 
Three concentric squares, with lines connecting the midpoints of the squares with the center of the square and four lines connecting the corners of the outer two squares. Twelve pieces per player. In the first phase, players take turns placing pieces on an empty spot on the board. If they place three pieces so they are in a line, forming a "meul." they remove one of the opponent's pieces that is not in a "meul." Once all the pieces are placed, the second phase begins, in which players take turns moving one piece to an adjacent empty spot. When a "meul" is formed, the player removes one fo the opponent's pieces that is not in a "meul." When one player is reduced to three pieces, they may move their pieces to any empty spot on the board. The player who reduces their opponent to two pieces wins. 
(game "Morabaraba" (players 2) (equipment {(board (remove (add (concentric Square rings:3 joinCorners:True) vertices:{{0 0}} edges:{{11 24} {16 24} {7 24} {12 24}}) edges:{{3 6} {8 5} {17 20} {15 18}}) use:Vertex) (hand Each) (piece "Marker" Each (if (> (count Pieces Mover) 3) (move Step (to if:(is Empty (to)))) (move (from) (to (sites Empty))) (then (if (is Line 3) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:12)) phases:{(phase "Placement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 through:(site))))) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3) (moveAgain)))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 through:(site))))) (forEach Piece))))} (end (if (<= (count Pieces Next) 2) (result Next Loss))))) 
According to the given rules, the pieces, eight on each army, start in reserve off the board. A move consists of either: 1) placing a piece from your reserve on any vacant square; 2) moving a piece to any adjacent square, orthogonally or diagonally (as a chess king), or 3) capturing an enemy piece by jumping it, like an 8-directional checker. Multiple jumps are allowed. When a jump is possible, jumping is compulsory, though the player may choose any jumping move available and need not capture the greatest possible number of pieces. The object is either to form a line of three of your pieces, orthogonally or diagonally with no intervening spaces, or to capture six enemy pieces (i.e. reduce your enemy’s forces to two so that he cannot win).
(game "Moxie" (players 2) (equipment {(board (square 4)) (piece "Pawn" Each) (hand Each)}) (rules (start (place "Pawn" "Hand" count:8)) (play (if (is Prev Mover) (move Hop (from (last To)) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))) (priority {(forEach Piece (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))) (or (if (is Occupied (handSite Mover)) (move (from (handSite Mover)) (to (sites Empty)))) (forEach Piece (move Step (to if:(is Empty (to))))))}))) (end {(forEach NonMover if:(<= (count Pieces Player) 2) (result Player Loss)) (if (is Line 3 All) (result Mover Win))}))) 
Three concentric squares, with lines connecting the corners and the midpoints of the sides. Twelve pieces per player. Players alternate turns placing a piece on the board. When a player makes a line of three of their pieces, they may remove one of the opponent's pieces. When all of the pieces have been placed, players alternate turns moving a piece to an empty adjacent spot along the lines of the board. A piece in the four outside corner spaces is allowed to move to any empty spot on the board. The player who captures all of the opponent's pieces wins.
(game "Mulabalaba" (players 2) (equipment {(board (concentric Square rings:3 joinCorners:True) use:Vertex) (hand Each) (piece "Marker" Each (if (is In (from) (sites Corners)) (move (from (from)) (to (sites Empty))) (move Step (to if:(is Empty (to)))) (then (if (is Line 3) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:12)) phases:{(phase "Placement" (play (if (is Prev Mover) (move Remove (sites Occupied by:Enemy container:"Board")) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3) (moveAgain)))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (sites Occupied by:Enemy container:"Board")) (forEach Piece))))} (end (forEach NonMover if:(no Pieces Player) (result Player Loss))))) 
Played on a board of three concentric squares, with a line bisecting the perimeters of each square on each side, but not extending inside the perimeter of the central square. Play occurs on the intersections of the lines and the corners of the squares. Each player has nine pieces. Play begins with each player placing pieces on empty points. If they make three in a row along the lines, they can remove one of the opponent's pieces. They cannot remove an opponent's piece that is in a three-in-a-row formation. Once all pieces are placed, players take turns moving pieces one spot to an adjacent point along the lines. If a player makes three in a row, an opponent's piece is removed as in the first phase of the game. The game is won when the opponent is reduced to two pieces. A player may also win by blocking their opponent from being able to move. 
(game "Mylna" (players 2) (equipment {(board (concentric Square rings:3) use:Vertex) (piece "Marker" Each (move Step Orthogonal (to if:(is Empty (to))) (then (if (is Line 3 Orthogonal) (moveAgain))))) (hand Each)}) (rules (start (place "Marker" "Hand" count:9)) phases:{(phase "Placement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3 Orthogonal) (moveAgain)))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (forEach Piece))))} (end {(if (<= (count Pieces Next) 2) (result Next Loss)) (if (no Moves Next) (result Mover Win))}))) 
Three concentric squares, with lines connecting the midpoints. Nine pieces per player. Players alternate turns placing a piece on the board on an empty spot. When all of the pieces have been placed, the players alternate turns moving a piece to an empty adjacent spot along the lines of the board. During either phase, if a player places three of their pieces in a row along the lines on the board, the player removes one of the opponent's pieces. The player who removes all of the opponent's peices wins.
(game "Nao Guti" (players 2) (equipment {(board (concentric Square rings:3) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to))) (then (if (is Line 3 Orthogonal exact:True) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:9)) phases:{(phase "Placement" (play (if (is Prev Mover) (move Remove (sites Occupied by:Enemy container:"Board")) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3 Orthogonal exact:True) (moveAgain)))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (sites Occupied by:Enemy container:"Board")) (forEach Piece))))} (end (if (no Pieces Next) (result Next Loss))))) 
Three concentric squares with lines connecting the midpoints of the squares. Nine pieces per player. Players alternate turns placing one of their pieces on an empty space. If a player places three of their pieces along one of the straight lines, they take another turn. Once all of the pieces are on the board, players take turns moving a piece to an empty space on the board. When a player creates a line of three in this phase, the player removes one of the opponent's pieces, and receives another turn. The player who reduces the opponent to two pieces wins.
(game "Nerenchi Keliya" (players 2) (equipment {(board (concentric Square rings:3) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to))) (then (if (is Line 3) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:9)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)) (then (if (and (is Line 3) (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))))) (moveAgain))))) (nextPhase (and (all Sites (sites Hand P1) if:(= 0 (count Cell at:(site)))) (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site))))) "Movement")) (phase "Movement" (play (forEach Piece)) (nextPhase Mover (is Line 3) "Capture")) (phase "Capture" (play (move Remove (sites Occupied by:Enemy container:"Board") (then (moveAgain)))) (nextPhase Mover "Movement"))} (end (forEach Player if:(<= (count Pieces Player) 2) (result Player Loss))))) 
3x3 intersecting lines with diagonals. Three pieces per player. Players alternate turns placing a piece on an empty spot on the board. When a player succeeds in making a line of three with their pieces, they win.
(game "Ngre E E" (players 2) (equipment {(board (rectangle 3 3 diagonals:Alternating) use:Vertex) (hand Each) (piece "Marker" Each)}) (rules (start (place "Marker" "Hand" count:3)) (play (move (from (handSite Mover)) (to (sites Empty)))) (end (if (is Line 3) (result Mover Win))))) 
Square with diagonals and lines connecting the midpoints of the sides. Three pieces per player. The first player places their piece in the center. Players alternate turns placing a piece on an empty spot on the board. The first player to make three in a row wins.
(game "Ngrin" (players 2) (equipment {(board (square 3 diagonals:Alternating) use:Vertex) (piece "Marker" Each)}) (rules phases:{(phase "Opening" (play (move Add (to (centrePoint)))) (nextPhase "Playing")) (phase "Playing" (play (move Add (to (sites Empty)))))} (end (if (is Line 3) (result Mover Win))))) 
3x3 intersecting lines. Three pieces per player. Players alternate turns placing pieces on an empty spot on the board. When all pieces are placed, players alternate turns moving a piece to any empty spot on the board. The first player to place their pieces in an orthogonal row along the lines wins.
(game "Nine Holes" (players 2) (equipment {(board (square 3) use:Vertex) (hand Each) (piece "Marker" Each (move (from) (to (sites Empty))))}) (rules (start (place "Marker" "Hand" count:3)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end (if (is Line 3 Orthogonal) (result Mover Win))))) 
Played on a board of three concentric squares, with a line bisecting the perimeters of each square on each side, but not extending inside the perimeter of the central square. Play occurs on the intersections of the lines and the corners of the squares. Each player has nine pieces. Play begins with each player placing pieces on empty points. If they make three in a row along the lines, they can remove one of the opponent's pieces. They cannot remove an opponent's piece that is in a three-in-a-row formation unless there are no other options. Once all pieces are placed, players take turns moving pieces one spot to an adjacent point along the lines. If a player makes three in a row, an opponent's piece is removed as in the first phase of the game. Once a player is reduced to three pieces, that player may move to any open space on the board. The game is won when the opponent is reduced to two pieces.
(game "Nine Men's Morris" (players 2) (equipment {(board (concentric Square rings:3) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to))) (then (if (is Line 3 Orthogonal exact:True) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:9)) phases:{(phase "Placement" (play (if (is Prev Mover) (if (can Move (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site)))))) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (move Remove (sites Occupied by:Enemy container:"Board"))) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3 Orthogonal exact:True) (moveAgain)))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (if (can Move (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site)))))) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (move Remove (sites Occupied by:Enemy container:"Board"))) (if (> (count Pieces Mover) 3) (forEach Piece) (move (from (sites Occupied by:Mover)) (to (sites Empty)))))))} (end (if (<= (count Pieces Next) 2) (result Next Loss))))) 
Three concentric squares, with lines connecting the midpoints and diagonals of the squares. Twelve pieces per player. Players alternate turns placing one of their pieces on the board. When all of the pieces are placed, the pieces may be moved to an empty adjacent spot on the board. One player wins by placing three of their pieces in a row. The other player wins by blocking their opponent from being able to move. Player 1 wins by blocking.
(game "Niranchy" (players 2) (equipment {(board (concentric Square rings:3 joinCorners:True) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to)))))}) (rules (start (place "Marker" "Hand" count:12)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end {(if (no Moves P2) (result P1 Win)) (if (is Line 3 P2) (result P2 Win))}))) 
A board is dead if it contains at least one set of three stones in a straight orthogonal or diagonal line. A board that is not dead is alive. On their turn, a player must place a piece on an empty square of a living board. When all boards are dead, the player who made the last placement loses.
(game "Notakto" (players 2) (equipment {(board (union {(square 3) (shift 0 4 (square 3)) (shift 0 8 (square 3)) (shift 0 12 (square 3)) (shift 4 0 (square 3)) (shift 4 4 (square 3)) (shift 4 8 (square 3)) (shift 4 12 (square 3)) (shift 8 0 (square 3)) (shift 8 4 (square 3)) (shift 8 8 (square 3)) (shift 8 12 (square 3)) (shift 12 0 (square 3)) (shift 12 4 (square 3)) (shift 12 8 (square 3)) (shift 12 12 (square 3))})) (piece "Marker" Each)}) (rules (play (move Add (to (sites Empty) if:(= 0 (state at:(to)))) (then (if (is Line 3) (forEach Site (expand origin:(last To) steps:2) (set State at:(site) 1)))))) (end (if (no Moves Next) (result Mover Loss))))) 
A square is drawn, with diagonals. Three pieces per player. Players alternate turns placing a piece on the board. The corners or the square, the central point, and the midpoint of each side of the square are playing sites. When a player forms a line with their three pieces, they win.
(game "Nzengue (Small)" (players 2) (equipment {(board (add (remove (remove (square 3 diagonals:Solid) vertices:{8 9 3 4}) edges:{{7 4} {4 1} {3 4} {4 5}}) edges:{{6 4} {4 8} {4 2} {4 0}}) use:Vertex) (piece "Marker" Each) (hand Each)}) (rules (start (place "Marker" "Hand" count:3)) (play (move (from (handSite Mover)) (to (sites Empty)))) (end (if (is Line 3) (result Mover Win))))) 
The game starts with the board empty. Order plays first, then turns alternate. On each turn, a player places either an X or an O on any open square. Order aims to get five like pieces in a row either vertically, horizontally, or diagonally. Chaos aims to fill the board without completion of a line of five like pieces.
(game "Order and Chaos" (players 2) (equipment {(board (square 6)) (piece "Disc" Shared) (piece "Cross" Shared) (hand Shared size:2)}) (rules (start {(place "Disc" (handSite Shared)) (place "Cross" (handSite Shared 1))}) (play (move (from (sites Hand Shared)) (to (sites Empty)) copy:True)) (end {(if (is Line 5) (result P1 Win)) (if (no Moves Next) (result P2 Win))}))) 
After placing a marble, the player has to twist one of the grids by 90°, thus changing the board after every turn. The first player to get five marbles in a row wins. In case of both players having five in a row in the same time, the game is a draw.
(game "Pentago" (players 2) (equipment {(board (square 6) use:Vertex) (piece "Ball" Each) (regions "BottomLeft" (expand origin:(coord "B2") All)) (regions "BottomRight" (expand origin:(coord "E2") All)) (regions "TopLeft" (expand origin:(coord "B5") All)) (regions "TopRight" (expand origin:(coord "E5") All))}) (rules phases:{(phase "Place" (play (move Add (to (sites Empty)) (then (moveAgain)))) (end (if (is Line 5 All) (result Mover Win))) (nextPhase Mover "Rotate")) (phase "Rotate" (play (or (move Select (from (sites {"B2" "B5" "E2" "E5"})) (then (if (= (last To) (coord "E5")) (do (and {(set Var "TopLeft" (what at:(coord "D6"))) (set Var "TopRight" (what at:(coord "F6"))) (set Var "BottomRight" (what at:(coord "F4"))) (set Var "BottomLeft" (what at:(coord "D4"))) (set Var "Bottom" (what at:(coord "E4"))) (set Var "Left" (what at:(coord "D5"))) (set Var "Top" (what at:(coord "E6"))) (set Var "Right" (what at:(coord "F5")))}) next:(and {(if (!= 0 (var "TopLeft")) (remove (coord "D6"))) (if (!= 0 (var "TopRight")) (remove (coord "F6"))) (if (!= 0 (var "BottomRight")) (remove (coord "F4"))) (if (!= 0 (var "BottomLeft")) (remove (coord "D4"))) (if (!= 0 (var "Bottom")) (remove (coord "E4"))) (if (!= 0 (var "Left")) (remove (coord "D5"))) (if (!= 0 (var "Top")) (remove (coord "E6"))) (if (!= 0 (var "Right")) (remove (coord "F5"))) (if (!= 0 (var "TopLeft")) (add (piece (var "TopLeft")) (to (coord "F6")))) (if (!= 0 (var "TopRight")) (add (piece (var "TopRight")) (to (coord "F4")))) (if (!= 0 (var "BottomRight")) (add (piece (var "BottomRight")) (to (coord "D4")))) (if (!= 0 (var "BottomLeft")) (add (piece (var "BottomLeft")) (to (coord "D6")))) (if (!= 0 (var "Bottom")) (add (piece (var "Bottom")) (to (coord "D5")))) (if (!= 0 (var "Left")) (add (piece (var "Left")) (to (coord "E6")))) (if (!= 0 (var "Top")) (add (piece (var "Top")) (to (coord "F5")))) (if (!= 0 (var "Right")) (add (piece (var "Right")) (to (coord "E4"))))})) (if (= (last To) (coord "B5")) (do (and {(set Var "TopLeft" (what at:(coord "A6"))) (set Var "TopRight" (what at:(coord "C6"))) (set Var "BottomRight" (what at:(coord "C4"))) (set Var "BottomLeft" (what at:(coord "A4"))) (set Var "Bottom" (what at:(coord "B4"))) (set Var "Left" (what at:(coord "A5"))) (set Var "Top" (what at:(coord "B6"))) (set Var "Right" (what at:(coord "C5")))}) next:(and {(if (!= 0 (var "TopLeft")) (remove (coord "A6"))) (if (!= 0 (var "TopRight")) (remove (coord "C6"))) (if (!= 0 (var "BottomRight")) (remove (coord "C4"))) (if (!= 0 (var "BottomLeft")) (remove (coord "A4"))) (if (!= 0 (var "Bottom")) (remove (coord "B4"))) (if (!= 0 (var "Left")) (remove (coord "A5"))) (if (!= 0 (var "Top")) (remove (coord "B6"))) (if (!= 0 (var "Right")) (remove (coord "C5"))) (if (!= 0 (var "TopLeft")) (add (piece (var "TopLeft")) (to (coord "C6")))) (if (!= 0 (var "TopRight")) (add (piece (var "TopRight")) (to (coord "C4")))) (if (!= 0 (var "BottomRight")) (add (piece (var "BottomRight")) (to (coord "A4")))) (if (!= 0 (var "BottomLeft")) (add (piece (var "BottomLeft")) (to (coord "A6")))) (if (!= 0 (var "Bottom")) (add (piece (var "Bottom")) (to (coord "A5")))) (if (!= 0 (var "Left")) (add (piece (var "Left")) (to (coord "B6")))) (if (!= 0 (var "Top")) (add (piece (var "Top")) (to (coord "C5")))) (if (!= 0 (var "Right")) (add (piece (var "Right")) (to (coord "B4"))))})) (if (= (last To) (coord "B2")) (do (and {(set Var "TopLeft" (what at:(coord "A3"))) (set Var "TopRight" (what at:(coord "C3"))) (set Var "BottomRight" (what at:(coord "C1"))) (set Var "BottomLeft" (what at:(coord "A1"))) (set Var "Bottom" (what at:(coord "B1"))) (set Var "Left" (what at:(coord "A2"))) (set Var "Top" (what at:(coord "B3"))) (set Var "Right" (what at:(coord "C2")))}) next:(and {(if (!= 0 (var "TopLeft")) (remove (coord "A3"))) (if (!= 0 (var "TopRight")) (remove (coord "C3"))) (if (!= 0 (var "BottomRight")) (remove (coord "C1"))) (if (!= 0 (var "BottomLeft")) (remove (coord "A1"))) (if (!= 0 (var "Bottom")) (remove (coord "B1"))) (if (!= 0 (var "Left")) (remove (coord "A2"))) (if (!= 0 (var "Top")) (remove (coord "B3"))) (if (!= 0 (var "Right")) (remove (coord "C2"))) (if (!= 0 (var "TopLeft")) (add (piece (var "TopLeft")) (to (coord "C3")))) (if (!= 0 (var "TopRight")) (add (piece (var "TopRight")) (to (coord "C1")))) (if (!= 0 (var "BottomRight")) (add (piece (var "BottomRight")) (to (coord "A1")))) (if (!= 0 (var "BottomLeft")) (add (piece (var "BottomLeft")) (to (coord "A3")))) (if (!= 0 (var "Bottom")) (add (piece (var "Bottom")) (to (coord "A2")))) (if (!= 0 (var "Left")) (add (piece (var "Left")) (to (coord "B3")))) (if (!= 0 (var "Top")) (add (piece (var "Top")) (to (coord "C2")))) (if (!= 0 (var "Right")) (add (piece (var "Right")) (to (coord "B1"))))})) (do (and {(set Var "TopLeft" (what at:(coord "D3"))) (set Var "TopRight" (what at:(coord "F3"))) (set Var "BottomRight" (what at:(coord "F1"))) (set Var "BottomLeft" (what at:(coord "D1"))) (set Var "Bottom" (what at:(coord "E1"))) (set Var "Left" (what at:(coord "D2"))) (set Var "Top" (what at:(coord "E3"))) (set Var "Right" (what at:(coord "F2")))}) next:(and {(if (!= 0 (var "TopLeft")) (remove (coord "D3"))) (if (!= 0 (var "TopRight")) (remove (coord "F3"))) (if (!= 0 (var "BottomRight")) (remove (coord "F1"))) (if (!= 0 (var "BottomLeft")) (remove (coord "D1"))) (if (!= 0 (var "Bottom")) (remove (coord "E1"))) (if (!= 0 (var "Left")) (remove (coord "D2"))) (if (!= 0 (var "Top")) (remove (coord "E3"))) (if (!= 0 (var "Right")) (remove (coord "F2"))) (if (!= 0 (var "TopLeft")) (add (piece (var "TopLeft")) (to (coord "F3")))) (if (!= 0 (var "TopRight")) (add (piece (var "TopRight")) (to (coord "F1")))) (if (!= 0 (var "BottomRight")) (add (piece (var "BottomRight")) (to (coord "D1")))) (if (!= 0 (var "BottomLeft")) (add (piece (var "BottomLeft")) (to (coord "D3")))) (if (!= 0 (var "Bottom")) (add (piece (var "Bottom")) (to (coord "D2")))) (if (!= 0 (var "Left")) (add (piece (var "Left")) (to (coord "E3")))) (if (!= 0 (var "Top")) (add (piece (var "Top")) (to (coord "F2")))) (if (!= 0 (var "Right")) (add (piece (var "Right")) (to (coord "E1"))))}))))))) (move Select (from (sites {"B2" "B5" "E2" "E5"})) (then (if (= (last To) (coord "E5")) (do (and {(set Var "TopLeft" (what at:(coord "D6"))) (set Var "TopRight" (what at:(coord "F6"))) (set Var "BottomRight" (what at:(coord "F4"))) (set Var "BottomLeft" (what at:(coord "D4"))) (set Var "Bottom" (what at:(coord "E4"))) (set Var "Left" (what at:(coord "D5"))) (set Var "Top" (what at:(coord "E6"))) (set Var "Right" (what at:(coord "F5")))}) next:(and {(if (!= 0 (var "TopLeft")) (remove (coord "D6"))) (if (!= 0 (var "TopRight")) (remove (coord "F6"))) (if (!= 0 (var "BottomRight")) (remove (coord "F4"))) (if (!= 0 (var "BottomLeft")) (remove (coord "D4"))) (if (!= 0 (var "Bottom")) (remove (coord "E4"))) (if (!= 0 (var "Left")) (remove (coord "D5"))) (if (!= 0 (var "Top")) (remove (coord "E6"))) (if (!= 0 (var "Right")) (remove (coord "F5"))) (if (!= 0 (var "TopLeft")) (add (piece (var "TopLeft")) (to (coord "D4")))) (if (!= 0 (var "TopRight")) (add (piece (var "TopRight")) (to (coord "D6")))) (if (!= 0 (var "BottomRight")) (add (piece (var "BottomRight")) (to (coord "F6")))) (if (!= 0 (var "BottomLeft")) (add (piece (var "BottomLeft")) (to (coord "F4")))) (if (!= 0 (var "Bottom")) (add (piece (var "Bottom")) (to (coord "F5")))) (if (!= 0 (var "Left")) (add (piece (var "Left")) (to (coord "E4")))) (if (!= 0 (var "Top")) (add (piece (var "Top")) (to (coord "D5")))) (if (!= 0 (var "Right")) (add (piece (var "Right")) (to (coord "E6"))))})) (if (= (last To) (coord "B5")) (do (and {(set Var "TopLeft" (what at:(coord "A6"))) (set Var "TopRight" (what at:(coord "C6"))) (set Var "BottomRight" (what at:(coord "C4"))) (set Var "BottomLeft" (what at:(coord "A4"))) (set Var "Bottom" (what at:(coord "B4"))) (set Var "Left" (what at:(coord "A5"))) (set Var "Top" (what at:(coord "B6"))) (set Var "Right" (what at:(coord "C5")))}) next:(and {(if (!= 0 (var "TopLeft")) (remove (coord "A6"))) (if (!= 0 (var "TopRight")) (remove (coord "C6"))) (if (!= 0 (var "BottomRight")) (remove (coord "C4"))) (if (!= 0 (var "BottomLeft")) (remove (coord "A4"))) (if (!= 0 (var "Bottom")) (remove (coord "B4"))) (if (!= 0 (var "Left")) (remove (coord "A5"))) (if (!= 0 (var "Top")) (remove (coord "B6"))) (if (!= 0 (var "Right")) (remove (coord "C5"))) (if (!= 0 (var "TopLeft")) (add (piece (var "TopLeft")) (to (coord "A4")))) (if (!= 0 (var "TopRight")) (add (piece (var "TopRight")) (to (coord "A6")))) (if (!= 0 (var "BottomRight")) (add (piece (var "BottomRight")) (to (coord "C6")))) (if (!= 0 (var "BottomLeft")) (add (piece (var "BottomLeft")) (to (coord "C4")))) (if (!= 0 (var "Bottom")) (add (piece (var "Bottom")) (to (coord "C5")))) (if (!= 0 (var "Left")) (add (piece (var "Left")) (to (coord "B4")))) (if (!= 0 (var "Top")) (add (piece (var "Top")) (to (coord "A5")))) (if (!= 0 (var "Right")) (add (piece (var "Right")) (to (coord "B6"))))})) (if (= (last To) (coord "B2")) (do (and {(set Var "TopLeft" (what at:(coord "A3"))) (set Var "TopRight" (what at:(coord "C3"))) (set Var "BottomRight" (what at:(coord "C1"))) (set Var "BottomLeft" (what at:(coord "A1"))) (set Var "Bottom" (what at:(coord "B1"))) (set Var "Left" (what at:(coord "A2"))) (set Var "Top" (what at:(coord "B3"))) (set Var "Right" (what at:(coord "C2")))}) next:(and {(if (!= 0 (var "TopLeft")) (remove (coord "A3"))) (if (!= 0 (var "TopRight")) (remove (coord "C3"))) (if (!= 0 (var "BottomRight")) (remove (coord "C1"))) (if (!= 0 (var "BottomLeft")) (remove (coord "A1"))) (if (!= 0 (var "Bottom")) (remove (coord "B1"))) (if (!= 0 (var "Left")) (remove (coord "A2"))) (if (!= 0 (var "Top")) (remove (coord "B3"))) (if (!= 0 (var "Right")) (remove (coord "C2"))) (if (!= 0 (var "TopLeft")) (add (piece (var "TopLeft")) (to (coord "A1")))) (if (!= 0 (var "TopRight")) (add (piece (var "TopRight")) (to (coord "A3")))) (if (!= 0 (var "BottomRight")) (add (piece (var "BottomRight")) (to (coord "C3")))) (if (!= 0 (var "BottomLeft")) (add (piece (var "BottomLeft")) (to (coord "C1")))) (if (!= 0 (var "Bottom")) (add (piece (var "Bottom")) (to (coord "C2")))) (if (!= 0 (var "Left")) (add (piece (var "Left")) (to (coord "B1")))) (if (!= 0 (var "Top")) (add (piece (var "Top")) (to (coord "A2")))) (if (!= 0 (var "Right")) (add (piece (var "Right")) (to (coord "B3"))))})) (do (and {(set Var "TopLeft" (what at:(coord "D3"))) (set Var "TopRight" (what at:(coord "F3"))) (set Var "BottomRight" (what at:(coord "F1"))) (set Var "BottomLeft" (what at:(coord "D1"))) (set Var "Bottom" (what at:(coord "E1"))) (set Var "Left" (what at:(coord "D2"))) (set Var "Top" (what at:(coord "E3"))) (set Var "Right" (what at:(coord "F2")))}) next:(and {(if (!= 0 (var "TopLeft")) (remove (coord "D3"))) (if (!= 0 (var "TopRight")) (remove (coord "F3"))) (if (!= 0 (var "BottomRight")) (remove (coord "F1"))) (if (!= 0 (var "BottomLeft")) (remove (coord "D1"))) (if (!= 0 (var "Bottom")) (remove (coord "E1"))) (if (!= 0 (var "Left")) (remove (coord "D2"))) (if (!= 0 (var "Top")) (remove (coord "E3"))) (if (!= 0 (var "Right")) (remove (coord "F2"))) (if (!= 0 (var "TopLeft")) (add (piece (var "TopLeft")) (to (coord "D1")))) (if (!= 0 (var "TopRight")) (add (piece (var "TopRight")) (to (coord "D3")))) (if (!= 0 (var "BottomRight")) (add (piece (var "BottomRight")) (to (coord "F3")))) (if (!= 0 (var "BottomLeft")) (add (piece (var "BottomLeft")) (to (coord "F1")))) (if (!= 0 (var "Bottom")) (add (piece (var "Bottom")) (to (coord "F2")))) (if (!= 0 (var "Left")) (add (piece (var "Left")) (to (coord "E1")))) (if (!= 0 (var "Top")) (add (piece (var "Top")) (to (coord "D2")))) (if (!= 0 (var "Right")) (add (piece (var "Right")) (to (coord "E3"))))}))))))))) (end {(if (and (is Line 5 All throughAny:(if (is In (last To) (sites "BottomLeft")) (intersection (sites Occupied by:Mover) (sites "BottomLeft")) (if (is In (last To) (sites "BottomRight")) (intersection (sites Occupied by:Mover) (sites "BottomRight")) (if (is In (last To) (sites "TopLeft")) (intersection (sites Occupied by:Mover) (sites "TopLeft")) (intersection (sites Occupied by:Mover) (sites "TopRight")))))) (is Line 5 All throughAny:(if (is In (last To) (sites "BottomLeft")) (intersection (sites Occupied by:Next) (sites "BottomLeft")) (if (is In (last To) (sites "BottomRight")) (intersection (sites Occupied by:Next) (sites "BottomRight")) (if (is In (last To) (sites "TopLeft")) (intersection (sites Occupied by:Next) (sites "TopLeft")) (intersection (sites Occupied by:Next) (sites "TopRight"))))))) (result Mover Draw)) (if (is Line 5 All throughAny:(if (is In (last To) (sites "BottomLeft")) (intersection (sites Occupied by:Mover) (sites "BottomLeft")) (if (is In (last To) (sites "BottomRight")) (intersection (sites Occupied by:Mover) (sites "BottomRight")) (if (is In (last To) (sites "TopLeft")) (intersection (sites Occupied by:Mover) (sites "TopLeft")) (intersection (sites Occupied by:Mover) (sites "TopRight")))))) (result Mover Win)) (if (is Line 5 All throughAny:(if (is In (last To) (sites "BottomLeft")) (intersection (sites Occupied by:Next) (sites "BottomLeft")) (if (is In (last To) (sites "BottomRight")) (intersection (sites Occupied by:Next) (sites "BottomRight")) (if (is In (last To) (sites "TopLeft")) (intersection (sites Occupied by:Next) (sites "TopLeft")) (intersection (sites Occupied by:Next) (sites "TopRight")))))) (result Next Win))}) (nextPhase Mover "Place"))})) 
The board starts empty. White plays first. Players take turns placing a piece of their colour on an empty cell. Passing is not allowed. After each move, the opponent's pieces with no freedom are captured and removed from the board. A piece has freedom if the group it belongs to touches an empty cell. It is not allowed to place a piece in a space without freedom, unless that move captures the other player's pieces to create freedom. The game ends when one of the players wins a game by making a line of five (or more) stones of their colour. The game is played on the half of a HexHex board of size 7.
(game "Pentalath" (players 2) (equipment {(board (intersect {(hex 7) (shift -5.2 0 (hex Rectangle 7 14))})) (piece "Marker" Each)}) (rules (play (do (move Add (to (sites Empty)) (then (enclose (from (last To)) (between if:(is Enemy (who at:(between))) (apply (remove (between))))))) ifAfterwards:(> (count Liberties Orthogonal) 0))) (end (if (is Line 5) (result Mover Win))))) 
Pente is played on a 19x19 Go board. White goes first, and plays their first move on the centre point (unless playing Freestyle). In the Pro Pente variation, White's second move must be at least 3 points away from the centre. After the opening, players alternate playing one stone of their colour onto any empty point. If their placement results in a pair of enemy stones being sandwiched between two of their own stones, those enemy stones are captured. The first player to form an orthogonal or diagonal line of five (or more) of their stones, or to capture 10 enemy stones, wins the game. Played on a 19x19 board. Open at the centre point.
(game "Pente" (players 2) (equipment {(board (square 19) use:Vertex) (piece "Ball" Each)}) (rules (start (set Score Each 0)) phases:{(phase "Opening" (play (move Add (to (sites "J10")))) (nextPhase "General")) (phase "General" (play (move Add (to (sites Empty)) (then (custodial (from (last To)) All (between if:(is Next (who at:(between))) (apply (remove (between)))) (to if:(and (= 3 (count Steps Vertex All (last To) (to))) (is Mover (who at:(to))))) (then (addScore Mover 1)))))))} (end {(if (is Line 5 All) (result Mover Win)) (if (> (score Mover) 9) (result Mover Win))}))) 
Played on a 3x3 board. Three pieces per player. Players take turns placing the pieces on the board. Once all the pieces are placed, players take turns moving a piece to an adjacent spot. The points where the diagonals of the squares cross are not eligible spots. The first player to align all three of their pieces in a row wins. The board has 9 holes. The pieces can be placed to any empty site.
(game "Picaria" (players 2) (equipment {(board (square 3) use:Vertex) (hand Each) (piece "Marker" Each (move Step All (to if:(is Empty (to)))))}) (rules (start (place "Marker" "Hand" count:3)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end (if (is Line 3 All) (result Mover Win))))) 
MOVE - Players move in turn to place one stone of either color on an empty cell. - However, the dropped stone must be adjacent, at least, to two other stones. - A stone cannot be adjacent to another stone of the same color. GOAL - Wins the player that makes a 4 in-a-row, with stones of his color at both ends (one player has Black and Blue, the other has White and Red).
(game "Plotto" (players 2) (equipment {(boardless Hexagonal) (tile "Hex" Each numSides:6) (tile "SecondHex" Each numSides:6) (hand Each size:2)}) (rules (start {(place "Hex1" (centrePoint)) (place "Hex2" (ahead (centrePoint) E)) (place "Hex1" (handSite P1 0)) (place "Hex2" (handSite P2 0)) (place "SecondHex1" (handSite P1 1)) (place "SecondHex2" (handSite P2 1))}) (play (move (from (sites Hand Mover)) (to (sites Playable) if:(and (<= 2 (count Sites in:(sites Around (to) NotEmpty))) (not (is In (what at:(from)) (results from:(last From) to:(sites Around (to)) (what at:(to))))))) copy:True)) (end (if (and (is Line 4 whats:{(id "Hex" P1) (id "Hex" P2) (id "SecondHex" P1) (id "SecondHex" P2)}) (or {(and {(is Occupied (ahead (last To) steps:1 W)) (is Occupied (ahead (last To) steps:2 W)) (= (what at:(last To)) (what at:(ahead (last To) steps:3 W)))}) (and {(is Occupied (ahead (last To) steps:1 E)) (is Occupied (ahead (last To) steps:2 E)) (= (what at:(last To)) (what at:(ahead (last To) steps:3 E)))}) (and {(is Occupied (ahead (last To) steps:1 NNW)) (is Occupied (ahead (last To) steps:2 NNW)) (= (what at:(last To)) (what at:(ahead (last To) steps:3 NNW)))}) (and {(is Occupied (ahead (last To) steps:1 SSW)) (is Occupied (ahead (last To) steps:2 SSW)) (= (what at:(last To)) (what at:(ahead (last To) steps:3 SSW)))}) (and {(is Occupied (ahead (last To) steps:1 SSE)) (is Occupied (ahead (last To) steps:2 SSE)) (= (what at:(last To)) (what at:(ahead (last To) steps:3 SSE)))}) (and {(is Occupied (ahead (last To) steps:1 NNE)) (is Occupied (ahead (last To) steps:2 NNE)) (= (what at:(last To)) (what at:(ahead (last To) steps:3 NNE)))})})) (result Mover Win))))) 
At the first round of the game, players can only pick a blank face cube. Next round players can play the same cube at the previously. A player cannot return a cube that he/she has played to place on where he/she took it from. A player who creates the line of opponent’s symbol is the person who loses the game, even if he/she has created a line of his/her own symbol at the same time.
(game "Pushing Me XO" (players 2) (equipment {(board (square 5)) (piece "Disc" P1) (piece "Cross" P2) (piece "Square" Neutral) (hand Each)}) (rules (start (place "Square0" (sites Board))) (play (if (is Prev Mover) (or {(move Select (from (difference (intersection (sites Left) (sites Row (row of:(last To)))) (sites {(last To)}))) (then (and {(push (from (last To)) E) (if (or (= (what at:(handSite (mover))) (id "Square0")) (= (what at:(handSite (mover))) (mover))) (add (piece (mover)) (to (last To))) (add (piece (next)) (to (last To)))) (remove (handSite (mover)))}))) (move Select (from (difference (intersection (sites Right) (sites Row (row of:(last To)))) (sites {(last To)}))) (then (and {(push (from (last To)) W) (if (or (= (what at:(handSite (mover))) (id "Square0")) (= (what at:(handSite (mover))) (mover))) (add (piece (mover)) (to (last To))) (add (piece (next)) (to (last To)))) (remove (handSite (mover)))}))) (move Select (from (difference (intersection (sites Bottom) (sites Column (column of:(last To)))) (sites {(last To)}))) (then (and {(push (from (last To)) N) (if (or (= (what at:(handSite (mover))) (id "Square0")) (= (what at:(handSite (mover))) (mover))) (add (piece (mover)) (to (last To))) (add (piece (next)) (to (last To)))) (remove (handSite (mover)))}))) (move Select (from (difference (intersection (sites Top) (sites Column (column of:(last To)))) (sites {(last To)}))) (then (and {(push (from (last To)) S) (if (or (= (what at:(handSite (mover))) (id "Square0")) (= (what at:(handSite (mover))) (mover))) (add (piece (mover)) (to (last To))) (add (piece (next)) (to (last To)))) (remove (handSite (mover)))})))}) (move Select (from (sites Outer)) (then (and (fromTo (from (last To)) (to (handSite (mover)))) (moveAgain)))))) (end {(if (is Line 5 throughAny:(sites LastTo) what:(next)) (result Next Win)) (if (is Line 5 throughAny:(sites LastTo) what:(mover)) (result Mover Win))}))) 
Each piece has four dichotomous attributes – color, height, shape, and consistency – so each piece is either black or white, tall or short, square or round, and hollow or solid. The object is to place the fourth piece in a row in which all four pieces have at least one attribute in common. The twist is that your opponent gets to choose the piece you place on the board each turn.
(game "Quarto" (players 2) (equipment {(board (square 4) use:Vertex) (piece "Disc" Each) (piece "Square" Each) (hand Shared size:16)}) (rules (start {(place "Disc1" (handSite Shared 0)) (place "Disc1" (handSite Shared 1) value:1) (place "Disc1" (handSite Shared 2) state:1) (place "Disc1" (handSite Shared 3) state:1 value:1) (place "Disc2" (handSite Shared 4)) (place "Disc2" (handSite Shared 5) value:1) (place "Disc2" (handSite Shared 6) state:1) (place "Disc2" (handSite Shared 7) state:1 value:1) (place "Square1" (handSite Shared 8)) (place "Square1" (handSite Shared 9) value:1) (place "Square1" (handSite Shared 10) state:1) (place "Square1" (handSite Shared 11) state:1 value:1) (place "Square2" (handSite Shared 12)) (place "Square2" (handSite Shared 13) value:1) (place "Square2" (handSite Shared 14) state:1) (place "Square2" (handSite Shared 15) state:1 value:1)}) phases:{(phase "Select" (play (move Select (from Cell (difference (sites Hand Shared) (sites Empty 1))))) (nextPhase "Place")) (phase "Place" (play (move (from Cell (last From)) (to (sites Empty)) (then (moveAgain)))) (end {(if (is Line 4 All whats:{(id "Disc" P1) (id "Disc" P2)}) (result Mover Win)) (if (is Line 4 All whats:{(id "Square" P1) (id "Square" P2)}) (result Mover Win)) (if (is Line 4 All P1) (result Mover Win)) (if (is Line 4 All P2) (result Mover Win)) (if (is Line 4 All whats:{(id "Disc" P1) (id "Disc" P2) (id "Square" P1) (id "Square" P2)} if:(= 0 (state at:(to)))) (result Mover Win)) (if (is Line 4 All whats:{(id "Disc" P1) (id "Disc" P2) (id "Square" P1) (id "Square" P2)} if:(= 1 (state at:(to)))) (result Mover Win)) (if (is Line 4 All whats:{(id "Disc" P1) (id "Disc" P2) (id "Square" P1) (id "Square" P2)} if:(= 0 (value Piece at:(to)))) (result Mover Win)) (if (is Line 4 All whats:{(id "Disc" P1) (id "Disc" P2) (id "Square" P1) (id "Square" P2)} if:(= 1 (value Piece at:(to)))) (result Mover Win))}) (nextPhase "Select"))})) 
On a turn, the active player takes a cube that is blank or bearing his symbol from the outer ring of the grid, then adds it to the grid by pushing it into one of the rows from which it was removed. Thus, a few pieces of the grid change places each turn, and the cubes slowly go from blank to crosses and circles. Play continues until someone forms an orthogonal or diagonal line of five cubes bearing his symbol, with this person winning the game.
(game "Quixo" (players 2) (equipment {(board (square 5)) (piece "Disc" P1) (piece "Cross" P2) (piece "Square" Neutral) (hand Each)}) (rules (start (place "Square0" (sites Board))) (play (if (is Prev Mover) (or {(move Select (from (difference (intersection (sites Left) (sites Row (row of:(last To)))) (sites {(last To)}))) (then (and {(push (from (last To)) E) (if (or (= (what at:(handSite (mover))) (id "Square0")) (= (what at:(handSite (mover))) (mover))) (add (piece (mover)) (to (last To))) (add (piece (next)) (to (last To)))) (remove (handSite (mover)))}))) (move Select (from (difference (intersection (sites Right) (sites Row (row of:(last To)))) (sites {(last To)}))) (then (and {(push (from (last To)) W) (if (or (= (what at:(handSite (mover))) (id "Square0")) (= (what at:(handSite (mover))) (mover))) (add (piece (mover)) (to (last To))) (add (piece (next)) (to (last To)))) (remove (handSite (mover)))}))) (move Select (from (difference (intersection (sites Bottom) (sites Column (column of:(last To)))) (sites {(last To)}))) (then (and {(push (from (last To)) N) (if (or (= (what at:(handSite (mover))) (id "Square0")) (= (what at:(handSite (mover))) (mover))) (add (piece (mover)) (to (last To))) (add (piece (next)) (to (last To)))) (remove (handSite (mover)))}))) (move Select (from (difference (intersection (sites Top) (sites Column (column of:(last To)))) (sites {(last To)}))) (then (and {(push (from (last To)) S) (if (or (= (what at:(handSite (mover))) (id "Square0")) (= (what at:(handSite (mover))) (mover))) (add (piece (mover)) (to (last To))) (add (piece (next)) (to (last To)))) (remove (handSite (mover)))})))}) (move Select (from (sites Outer) if:(or (is Mover (who at:(from))) (= (who at:(from)) 0))) (then (and (fromTo (from (last To)) (to (handSite (mover)))) (moveAgain)))))) (end {(if (is Line 5 throughAny:(sites LastTo) what:(next)) (result Next Win)) (if (is Line 5 throughAny:(sites LastTo) what:(mover)) (result Mover Win))}))) 
A circle with eight radii. Three pieces per player. Each player has three pieces, which must start on the outer ring adjacent to each other. Players alternate turns moving a piece to an empty point along the lines of the board. The player who makes a line of three through the center of the circle wins.
(game "Ring" (players 2) (equipment {(board (concentric {1 8}) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to)))))}) (rules (start (place "Marker" "Hand" count:3)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (difference (sites Empty) (sites Centre))))) (nextPhase Mover "PlacementAdjacent")) (phase "PlacementAdjacent" (play (move (from (handSite Mover)) (to (difference (sites Empty) (sites Centre)) if:(is In (to) (sites Around (sites Occupied by:Mover)))))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end (if (is Line 3 through:(centrePoint) what:(mover)) (result Mover Win))))) 
Players complete two actions in turns: 1. Place a disc of their colour inside any ring. 2. Pick up the ring in which they placed their disc and move it somewhere else: – It must be placed horizontally or vertically adjacent to at least another ring. – It must be placed on an empty space (i.e. not over a disc or ring that was placed before). - If a player has used up his/her stock of discs, he/she continues by removing one of his/her discs from anywhere on the table and places it in a ring as usual. However rings and discs must always remain (orthogonally or diagonally) connected to form one unique group. The winner is the first player who succeeds in placing four of his/her discs or four of his/her rings in a horizontal, vertical or diagonal row. 
(game "Ringo" (players 2) (equipment {(boardless Square) (piece "Disc" Each (move (from (from) level:(level)) (to (sites Occupied by:All component:"Ring") level:0 if:(= 1 (size Stack at:(to)))) (then (moveAgain)))) (piece "Ring" Each)}) (rules (start {(place "Ring1" (ahead (centrePoint) NE)) (place "Ring1" (ahead (centrePoint) SE)) (place "Ring1" (ahead (centrePoint) SW)) (place "Ring1" (ahead (centrePoint) NW)) (place "Ring2" (ahead (centrePoint) N)) (place "Ring2" (ahead (centrePoint) E)) (place "Ring2" (ahead (centrePoint) S)) (place "Ring2" (ahead (centrePoint) W))}) phases:{(phase "PlacePhase" (play (do (if (not (is Prev Mover)) (move Add (piece (id "Disc" Mover)) (to (sites Occupied by:All component:"Ring") level:0 if:(= 1 (size Stack at:(to)))) stack:True (then (moveAgain))) (move (from (last To)) (to (sites Around (difference (sites Occupied by:All component:"Ring") (last To)) Orthogonal if:(is Empty (to)))))) ifAfterwards:(= 1 (count Groups)))) (nextPhase Mover (and (not (is Prev Mover)) (>= (count Turns) (- (* (count Players) 10) 1))) "MovePhase")) (phase "MovePhase" (play (do (if (not (is Prev Mover)) (forEach Piece) (move (from (last To)) (to (sites Around (difference (sites Occupied by:All component:"Ring") (last To)) Orthogonal if:(is Empty (to)))))) ifAfterwards:(= 1 (count Groups)))))} (end {(if (is Line 4 what:(id "Disc" P1)) (result P1 Win)) (if (is Line 4 what:(id "Ring" P1)) (result P1 Win)) (if (is Line 4 what:(id "Disc" P2)) (result P2 Win)) (if (is Line 4 what:(id "Ring" P2)) (result P2 Win))}))) 
TURNS - At each turn, each player must move one of his stones - A stone moves (orthogonal and diagonal) forward to an empty cell. GOAL - A player wins by making a (orthogonal or diagonal) 4 in-a-row.
(game "Roll-Ing to Four" (players {(player N) (player S)}) (equipment {(board (rectangle 10 4) use:Vertex) (piece "Ball" Each (move Step (directions Forwards of:All) (to if:(is Empty (to)))))}) (rules (start {(place "Ball1" (sites {"A1" "B1" "C1" "B6" "C6" "D6"})) (place "Ball2" (sites {"A5" "B5" "C5" "B10" "C10" "D10"}))}) (play (forEach Piece)) (end (if (is Line 4 All) (result Mover Win))))) 
Three pieces per player. Players take turns placing their pieces on a spot where the lines intersect. They then take turns moving one piece to an adjacent empty spot. The first player to place three pieces in a row wins the game.  The rules are describing with the Blumlein ruleset.
(game "Round Merels" (players 2) (equipment {(board (concentric {1 8}) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to)))))}) (rules (start (place "Marker" "Hand" count:3)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end (if (is Line 3 through:(centrePoint) what:(mover)) (result Mover Win))))) 
Three concentric squares, with lines connecting the corners and the midpoints of the sides. Twelve pieces per player. Players alternate turns placing a piece on the board. When a player places three pieces in a row along the lines of the board, the player places another of their pieces on top of one of the opponent's pieces; the opponent's piece is considered "dead." Once all of the pieces have been placed on the board, all "dead" pieces are removed from the board. Players then alternate moving pieces to an empty adjacent spot along the lines. When three are placed in a row, one of the opponent's pieces is taken. A player wins by capturing all of the opponent's pieces or by blocking them from being able to move.
(game "Sam K'i" (players 2) (equipment {(board (concentric Square rings:3 joinCorners:True) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to))) (then (if (is Line 3 if:(= 1 (size Stack at:(to)))) (moveAgain)))))}) (rules (start {(place Stack "Marker1" (handSite P1) count:12) (place Stack "Marker2" (handSite P2) count:12)}) phases:{(phase "Placement" (play (if (is Prev Mover) (move (from (handSite Mover)) (to (forEach (sites Occupied by:Next container:"Board") if:(= (size Stack at:(site)) 1)))) (if (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site))))) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3 if:(= 1 (size Stack at:(to)))) (moveAgain))))) (then (if (and (not (is Next Mover)) (and (all Sites (sites Hand P1) if:(= 0 (count Cell at:(site)))) (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))))) (and (forEach Site (forEach (sites Occupied by:P1 container:"Board") if:(= (size Stack at:(site)) 2)) (and {(remove (site)) (remove (site)) (add (piece (id "Marker" P1)) (to (site)))})) (forEach Site (forEach (sites Occupied by:P2 container:"Board") if:(= (size Stack at:(site)) 2)) (and {(remove (site)) (remove (site)) (add (piece (id "Marker" P2)) (to (site)))}))))))) (nextPhase (and (not (is Next Mover)) (and (all Sites (sites Hand P1) if:(= 0 (count Cell at:(site)))) (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (sites Occupied by:Enemy container:"Board")) (if (> (count Pieces Mover) 3) (forEach Piece) (move (from (sites Occupied by:Mover)) (to (sites Empty)))))) (end (if (no Moves Next) (result Mover Win))))})) 
3x3 intersecting lines. Three pieces per player. Players alternate turns placing a piece on an empty spot on the board. Once all of the pieces are placed, players move a piece to any empty spot on the board. The first player to make an orthogonal row of three along the lines of the board wins.
(game "San-Noku-Narabe" (players 2) (equipment {(board (square 3) use:Vertex) (hand Each) (piece "Marker" Each (move (from) (to (sites Empty))))}) (rules (start (place "Marker" "Hand" count:3)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end (if (is Line 3 Orthogonal) (result Mover Win))))) 
Place a piece of your colour each turn. Win with 4 in a row of your colour.
(game "Score Four" (players 2) (equipment {(board (skew 0.5 (scale 1 0.5 (square 4)))) (piece "discFlat" Each)}) (rules (play (move Add (to (forEach (sites Board) if:(< (size Stack at:(site)) 4))) stack:True)) (end (if (is Line 4 byLevel:True) (result Mover Win))))) 
3x3 intersecting lines with diagonals in the square. Three pieces per player. Players alternate turns placing a piece on the board. The player who places three pieces in a row along one of the lines of the board wins. 
(game "Selbia" (players 2) (equipment {(board (rectangle 3 3 diagonals:Alternating) use:Vertex) (hand Each) (piece "Marker" Each)}) (rules (start (place "Marker" "Hand" count:3)) (play (move (from (handSite Mover)) (to (sites Empty)))) (end (if (is Line 3) (result Mover Win))))) 
Three concentric squares, with the midpoints of their sides connected with lines. Twelve pieces per player. Players take turns placing one of their pieces on an empty point on the board. The first player to make three in a row obtains the privilege of starting the next phase after all of the stones are placed; if no one makes three in a row the last player to place a stone begins the next phase. Ones all of the stones are placed, the player who has the right to begin the next phase removes any one of the opponent's stones, and the opponent does the same with one of the player's pieces. Then, players alternate turns moving one of their pieces to an empty adjacent space. When a player place three of their pieces in a row, they remove one of the opponent's pieces. If a player moves in such a way that the opponent cannot move, the player must make an extra move to allow the opponent a place to play. A player cannot capture an opponent's piece when this extra move is made. The player who captures all but two of the opponent's pieces wins. Games are usually played in sequence, starting with the winner of the previous game, with the first player to win five games in a row being the winner. 
(game "Shah" (players 2) (equipment {(board (concentric Square rings:3) use:Vertex) (piece "Marker" Each (move Step (to if:(is Empty (to))) (then (if (and (not (is Prev Mover)) (is Line 3)) (moveAgain) (if (no Moves Next) (and (moveAgain) (set Pending))))))) (hand Each)}) (rules (start (place "Marker" "Hand" count:12)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)) (then (and (if (and (< (var) 1) (is Line 3)) (set Var (mover))) (if (and (all Sites (sites Hand P1) if:(= 0 (count Cell at:(site)))) (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site))))) (if (< (var) 1) (moveAgain) (set NextPlayer (player (var))))))))) (nextPhase (and (all Sites (sites Hand P1) if:(= 0 (count Cell at:(site)))) (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site))))) "Remove")) (phase "Remove" (play (move Remove (sites Occupied by:Next container:"Board"))) (nextPhase Mover "Move")) (phase "Move" (play (if (and (not (is Pending)) (is Prev Mover)) (move Remove (sites Occupied by:Next container:"Board") (then (if (no Moves Next) (and (moveAgain) (set Pending))))) (if (is Pending) (do (forEach Piece (move Step (to if:(is Empty (to))))) ifAfterwards:(can Move (forEach Piece Next))) (forEach Piece)) (then (if (= 2 (count Pieces P1)) (addScore P2 1 (then (if (!= (score P2) 5) (and {(remove (sites Occupied by:All)) (add (piece (id "Marker" P1)) (to (handSite P1)) count:12) (add (piece (id "Marker" P2)) (to (handSite P2)) count:12)})))) (if (= 2 (count Pieces P2)) (addScore P1 1 (then (if (!= (score P1) 5) (and {(remove (sites Occupied by:All)) (add (piece (id "Marker" P1)) (to (handSite P1)) count:12) (add (piece (id "Marker" P2)) (to (handSite P2)) count:12)}))))))))) (nextPhase (= 0 (count Sites in:(sites Occupied by:All container:"Board"))) "Placement"))} (end (if (= (score Mover) 5) (result Mover Win))))) 
Each player has three pieces. Pieces are initially placed three-in a row on side nearest the player. Pieces can move to an adjacent space connected to it by a line. The goal is to create three in a row through the central space.
(game "Shisima" (players 2) (equipment {(board (concentric {1 8}) use:Vertex) (piece "Marker" Each (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Marker1" {1 8 7}) (place "Marker2" {3 4 5})}) (play (forEach Piece)) (end (if (and (= (what at:(centrePoint)) (mover)) (is Line 3)) (result Mover Win))))) 
5x6 or 6x6 board. Twelve pieces per player. Players take turns placing pieces on the board. Once all the pieces are on the board, players may move one piece orthogonally one space during their turn. Players cannot create a line of more than three in an orthogonal direction, and cannot make a line of three during the placement phase. If three pieces are in an orthogonal line, they cannot be moved again. If a player makes three rows before the opponent makes one, it is an automatic win.  The game is played on a 5x6 board.
(game "Shiva" (players 2) (equipment {(board (rectangle 5 6)) (hand Each) (piece "Marker" Each (if (not (is Line 3 Orthogonal through:(from))) (move Step Orthogonal (to if:(is Empty (to))) (then (if (is Line 3 Orthogonal) (if (= (value Player Mover) -1) (set Value Mover 1) (set Value Mover (+ (value Player Mover) 1))))))))}) (rules (start (place "Marker" "Hand" count:12)) phases:{(phase "Placement" (play (do (move (from (handSite Mover)) (to (sites Empty))) ifAfterwards:(not (is Line 3 Orthogonal)))) (nextPhase (and (all Sites (sites Hand P1) if:(= 0 (count Cell at:(site)))) (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site))))) "Movement")) (phase "Movement" (play (do (forEach Piece) ifAfterwards:(not (is Line 4 Orthogonal)))))} (end (if (= (value Player Mover) 3) (result Mover Win))))) 
4x4 board. Six pieces per player, which begin on opposite rows of the board and in the two outer squares in the row in front of it. Players alternate turns moving a piece orthogonally to an adjacent space on the board. When a player moves a piece such that it creates three in a row: two of their own pieces (which must be adjacent to one another) and one of the opponent's pieces (which must have a vacant space on the opposite side of it), the opponent's piece is captured. However, when the opponent's piece moves in line with two of the player's piece on the opponent's turn, the player does not capture the opponent's piece. The player who captures all of the opponent's pieces wins. 
(game "Six Insect Game" (players 2) (equipment {(board (square 4)) (piece "Marker" Each (move Step Orthogonal (to if:(is Empty (to))) (then (if (is Line 2 Orthogonal) (or {(if (!= (ahead (last To) N) (last To)) (if (= (mover) (who at:(ahead (last To) N))) (or (if (!= (ahead (last To) steps:2 N) (last To)) (if (= (next) (who at:(ahead (last To) steps:2 N))) (if (!= (ahead (last To) steps:3 N) (last To)) (if (is Empty (ahead (last To) steps:3 N)) (remove (ahead (last To) steps:2 N)))))) (if (!= (ahead (last To) S) (last To)) (if (= (next) (who at:(ahead (last To) S))) (if (!= (ahead (last To) steps:2 S) (last To)) (if (is Empty (ahead (last To) steps:2 S)) (remove (ahead (last To) S))))))))) (if (!= (ahead (last To) S) (last To)) (if (= (mover) (who at:(ahead (last To) S))) (or (if (!= (ahead (last To) steps:2 S) (last To)) (if (= (next) (who at:(ahead (last To) steps:2 S))) (if (!= (ahead (last To) steps:3 S) (last To)) (if (is Empty (ahead (last To) steps:3 S)) (remove (ahead (last To) steps:2 S)))))) (if (!= (ahead (last To) N) (last To)) (if (= (next) (who at:(ahead (last To) N))) (if (!= (ahead (last To) steps:2 N) (last To)) (if (is Empty (ahead (last To) steps:2 N)) (remove (ahead (last To) N))))))))) (if (!= (ahead (last To) E) (last To)) (if (= (mover) (who at:(ahead (last To) E))) (or (if (!= (ahead (last To) steps:2 E) (last To)) (if (= (next) (who at:(ahead (last To) steps:2 E))) (if (!= (ahead (last To) steps:3 E) (last To)) (if (is Empty (ahead (last To) steps:3 E)) (remove (ahead (last To) steps:2 E)))))) (if (!= (ahead (last To) W) (last To)) (if (= (next) (who at:(ahead (last To) W))) (if (!= (ahead (last To) steps:2 W) (last To)) (if (is Empty (ahead (last To) steps:2 W)) (remove (ahead (last To) W))))))))) (if (!= (ahead (last To) W) (last To)) (if (= (mover) (who at:(ahead (last To) W))) (or (if (!= (ahead (last To) steps:2 W) (last To)) (if (= (next) (who at:(ahead (last To) steps:2 W))) (if (!= (ahead (last To) steps:3 W) (last To)) (if (is Empty (ahead (last To) steps:3 W)) (remove (ahead (last To) steps:2 W)))))) (if (!= (ahead (last To) E) (last To)) (if (= (next) (who at:(ahead (last To) E))) (if (!= (ahead (last To) steps:2 E) (last To)) (if (is Empty (ahead (last To) steps:2 E)) (remove (ahead (last To) E)))))))))})))))}) (rules (start {(place "Marker1" (union (intersection (union (sites Right) (sites Left)) (sites Row 1)) (sites Bottom))) (place "Marker2" (union (intersection (union (sites Right) (sites Left)) (sites Row 2)) (sites Top)))}) (play (forEach Piece)) (end (if (no Pieces Next) (result Next Loss))))) 
Each player has six pieces. Play begins with each player placing pieces on empty points. If they make three in a row along the lines, they can remove one of the opponent's pieces. Once all pieces are place, players take turns moving pieces one spot to an adjacent point along the lines. If a player makes three in a row, an opponent's piece is removed as in the first phase of the game. The game is won when the opponent is reduced to two pieces. The game starts with 6 pieces by player. Any Enemy piece can be captured.
(game "Six Men's Morris" (players 2) (equipment {(board (concentric Square rings:2) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to))) (then (if (is Line 3 Orthogonal exact:True) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:6)) phases:{(phase "Placement" (play (if (is Prev Mover) (move Remove (sites Occupied by:Enemy container:"Board")) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3 Orthogonal exact:True) (moveAgain)))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (sites Occupied by:Enemy container:"Board")) (forEach Piece))))} (end (if (<= (count Pieces Next) 2) (result Next Loss))))) 
Three concentric triangles, with lines connecting their corners. Six pieces per player. Pieces can move or be placed where the lines intersect, or in the center of the sides of the triangles. Players alternate turns placing their pieces on an empty space on the board.When all the pieces have been placed, players alternate turns moving their pieces to an empty adjacent space along the lines. During either phase, when a player places three pieces in a row along one of the sides of one of the lines, they remove one of the pieces belonging to the other player. The player who removes all of the opponent's pieces wins.
(game "Six-Penny Madell" (players 2) (equipment {(board (concentric Triangle rings:3 joinMidpoints:False joinCorners:True) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to))) (then (if (is Line 3 Orthogonal exact:True) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:6)) phases:{(phase "Placement" (play (if (is Prev Mover) (move Remove (sites Occupied by:Enemy container:"Board")) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3 Orthogonal exact:True) (moveAgain)))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (sites Occupied by:Enemy container:"Board")) (forEach Piece))))} (end (if (no Pieces Next) (result Next Loss))))) 
Starting with white, each player places a marble on an empty space or platform (2x2 arrangement of marbles). A player wins by making a line of L pieces of their colour orthogonally or diagonally (where L is the layer size) but loses by making a line of L-1 of their colour beforehand (without also making a line of L). Two players. 4x4 square pyramidal board.
(game "Spava" (players 2) (equipment {(board (square 4 pyramidal:True) use:Vertex) (piece "Ball" Each)}) (rules (play (move Add (to (sites Empty) if:(is Flat)))) (end {(if (is Line (- (count Rows) (layer of:(last To))) SameLayer) (result Mover Win)) (if (is Line (- (- (count Rows) (layer of:(last To))) 1) SameLayer) (result Mover Loss))}))) 
Starting with white, each player places a marble on an empty space or platform (2x2 arrangement of marbles). The first player making a full line of his color on any layer wins. Lines may be diagonal. This is, for a 4x4 set, a 4-in-a-row on the first layer, or a 3-in-a-row on the 2nd layer, or a 2-in-a-row on the 3rd layer. The game is played with two players. The game is played on a 4x4 board.
(game "Spline" (players 2) (equipment {(board (square 4 pyramidal:True) use:Vertex) (piece "Ball" Each)}) (rules (play (move Add (to (sites Empty) if:(is Flat)))) (end (if (is Line (- (count Rows) (layer of:(last To))) SameLayer) (result Mover Win))))) 
Players alternate turns placing one of their pieces on the board. The first person to make a line of four, but without first making a line of three, wins.
(game "Squava" (players 2) (equipment {(board (square 5)) (piece "Marker" Each)}) (rules (meta (swap)) (play (move Add (to (sites Empty)))) (end {(if (is Line 4) (result Mover Win)) (if (is Line 3) (result Mover Loss))}))) 
Three concentric squares with lines connecting their midpoints. Nine pieces per player. Players alternate turns placing pieces on the board or moving one piece on the board to an adjacent empty spot. The first player to get three of their pieces in a row wins.
(game "Sujjua" (players 2) (equipment {(board (concentric Square rings:3) use:Vertex) (piece "Marker" Each (move Step Orthogonal (to if:(is Empty (to))))) (hand Each)}) (rules (start (place "Marker" "Hand" count:9)) (play (or (if (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site))))) (move (from (handSite Mover)) (to (sites Empty)))) (forEach Piece))) (end (if (is Line 3 Orthogonal) (result Mover Win))))) 
Same rules as Six Men's Morris.
(game "Symbol S0.2" (players 2) (equipment {(board (graph vertices:{{1 0} {2 0} {0 1} {1 1} {2 1} {3 1} {0 2} {1 2} {2 2} {3 2} {1 3} {2 3}} edges:{{0 2} {0 3} {3 2} {3 4} {1 4} {4 5} {1 5} {3 7} {4 8} {6 7} {7 8} {8 9} {6 10} {11 9} {10 7} {11 8}}) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to))) (then (if (is Line 3) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:4)) phases:{(phase "Placement" (play (if (is Prev Mover) (move Remove (sites Occupied by:Enemy container:"Board")) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3) (moveAgain)))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (sites Occupied by:Enemy container:"Board")) (forEach Piece))))} (end (if (<= (count Pieces Next) 2) (result Next Loss))))) 
3x3 intersecting lines, with diagonals drawn in the square. Three pieces per player, which begin on the three points on opposite sides of the board. Players alternate turns moving a piece to an empty adjacent spot along the lines of the board. The first player to place three of their pieces in a row along one of the lines which is not one of the sides of the square, wins.
(game "T'mbl" (players 2) (equipment {(board (square 3 diagonals:Alternating) use:Vertex) (piece "Marker" Each (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Marker1" (sites Top)) (place "Marker2" (sites Bottom))}) (play (forEach Piece)) (end (if (and (is In (centrePoint) (sites Occupied by:Mover)) (is Line 3)) (result Mover Win))))) 
3x3 intersecting lines with diagonals. Play occurs on the intersections of the lines. Players each have three pieces, initially placed on the sides closest to the player. Players move the pieces to an adjacent unoccupied intersection along the lines. The goal is to make three in a row which cannot be in the starting position. An alternate version requires the three in a row to be diagonal.
(game "Tant Fant" (players 2) (equipment {(board (rectangle 3 diagonals:Alternating) use:Vertex) (piece "Marker" Each (move Step (to if:(is Empty (to))))) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Marker1" (sites P1)) (place "Marker2" (sites P2))}) (play (forEach Piece)) (end (if (and (not (all Sites (sites Occupied by:Mover) if:(is In (site) (sites Mover)))) (is Line 3)) (result Mover Win))))) 
3x3 intersecting lines with diagonals. Play occurs on the intersections of the lines. Three pieces per player. Play begins with each player placing pieces on empty points. If they make three in a row along the lines, they win. Once all pieces are place, players take turns moving pieces one spot to an adjacent point along the lines trying to make three in a row. 
(game "Tapatan" (players 2) (equipment {(board (rectangle 3 3 diagonals:Alternating) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to)))))}) (rules (start (place "Marker" "Hand" count:3)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end (if (is Line 3) (result Mover Win))))) 
5x6 board. Each player has twelve pieces. Players alternate placing their pieces until they are all placed on the board. The goal is to make a line of three, which allows the player to capture one of the opponent's pieces. Once the pieces are all on the board, they may be moved one space orthogonally. In the case that a move creates two lines of three, only one capture is made. The player who makes the last possible capture wins. 
(game "Tauru" (players 2) (equipment {(board (rectangle 5 6)) (hand Each) (piece "Marker" Each (move Step Orthogonal (to if:(is Empty (to))) (then (if (is Line 3) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:12)) phases:{(phase "Placement" (play (if (is Prev Mover) (move Remove (sites Occupied by:Enemy container:"Board")) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3) (moveAgain)))))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (sites Occupied by:Enemy container:"Board")) (forEach Piece))))} (end (if (<= (count Pieces Next) 2) (result Next Loss))))) 
Three concentric pentagons, with lines connecting the corners and the midpoints of each side. Fourteen pieces per player. Players alternate turns placing one of their pieces on an empty spot on the board. When all of the pieces are placed, they alternate turns moving one of their pieces to an empty adjacent spot along the lines of the board. During either phase, when a player places three of their pieces in a row, they may remove one of the opponent's pieces from the board. Pieces which are in a three-in-a-row arrangement cannot be removed from the board. The player who captures all of the opponent's pieces wins. 
(game "Tavan Tal" (players 2) (equipment {(board (add (merge {(shift 2 2 (merge {(rectangle 1 3) (shift -1.31 0.95 (rotate 108 (rectangle 1 3))) (shift -0.81 2.49 (rotate 216 (rectangle 1 3))) (shift 1.31 0.95 (rotate -108 (rectangle 1 3))) (shift 0.81 2.49 (rotate -216 (rectangle 1 3)))})) (shift 1 1 (scale 2 (merge {(rectangle 1 3) (shift -1.31 0.95 (rotate 108 (rectangle 1 3))) (shift -0.81 2.49 (rotate 216 (rectangle 1 3))) (shift 1.31 0.95 (rotate -108 (rectangle 1 3))) (shift 0.81 2.49 (rotate -216 (rectangle 1 3)))}))) (scale 3 (merge {(rectangle 1 3) (shift -1.31 0.95 (rotate 108 (rectangle 1 3))) (shift -0.81 2.49 (rotate 216 (rectangle 1 3))) (shift 1.31 0.95 (rotate -108 (rectangle 1 3))) (shift 0.81 2.49 (rotate -216 (rectangle 1 3)))}))}) edges:{{26 16} {16 6} {5 15} {15 25} {29 19} {19 9} {7 17} {17 27} {28 18} {18 8} {22 12} {12 2} {1 11} {11 21} {20 10} {10 0} {3 13} {13 23} {24 14} {14 4}}) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to))) (then (if (is Line 3) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:14)) phases:{(phase "Placement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3) (moveAgain)))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (forEach Piece))))} (end (if (no Pieces Next) (result Next Loss))))) 
3x3 intersecting lines with diagonals. Play occurs on the intersections of the lines. Each player has three pieces. Play begins with each player placing pieces on empty points. If they make three in a row along the lines, they win. Once all pieces are place, players take turns moving pieces one spot to an adjacent point along the lines trying to make three in a row. The pieces can move to any empty adjacent sites.
(game "Three Men's Morris" (players 2) (equipment {(board (rectangle 3 3 diagonals:Alternating) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to)))))}) (rules (start (place "Marker" "Hand" count:3)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end (if (is Line 3) (result Mover Win))))) 
Players take turns placing a piece of theirs at an empty cell. When all pieces have been placed, players take turns moving one of their pieces. The pieces move like the equivalent Chess pieces but do not capture. Any piece can hop over an adjacent enemy piece to an empty cell beyond (without capturing it). First to make a line of 3 of their pieces, at any time, wins the game.
(game "Tic-Tac-Chess" (players 2) (equipment {(board (square 3)) (hand Each size:3) (piece "Queen" Each (or (move Hop (between if:(is Enemy (who at:(between)))) (to if:(is Empty (to)))) (move Slide All))) (piece "King" Each (or (move Hop (between if:(is Enemy (who at:(between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to)))))) (piece "Rook" Each (or (move Hop (between if:(is Enemy (who at:(between)))) (to if:(is Empty (to)))) (move Slide Orthogonal)))}) (rules (start {(place "Queen" "Hand") (place "King" "Hand") (place "Rook" "Hand")}) phases:{(phase "Placement" (play (move (from (sites Occupied by:Mover container:(mover))) (to (sites Empty)))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end (if (is Line 3 Mover) (result Mover Win))))) 
Play occurs on a 3x3 grid. One player places an X, the other places an O and players take turns placing their marks in the grid, attempting to get three in a row. The die is showing the cell index to place a piece. Players reroll until they roll an empty cell.
(game "Tic-Tac-Die" (players 2) (equipment {(board (square 3)) (piece "Disc" P1) (piece "Cross" P2) (dice d:9 from:0 num:1)}) (rules (play (do (roll) next:(if (is Empty (count Pips)) (move Add (piece (if (is Mover P1) (id "Disc" P1) (id "Cross" P2))) (to (count Pips))) (move Pass (then (moveAgain)))))) (end {(if (is Line 3) (result Mover Win)) (if (is Full) (result Mover Draw))}))) 
The same rules as Tic-Tac-Toe are used with four players in a 5x5 board. The third and fourth players play with "Y" and "Z".
(game "Tic-Tac-Four" (players 4) (equipment {(board (square 5)) (piece "Disc" P1) (piece "Cross" P2) (piece "Y" P3) (piece "Z" P4)}) (rules (play (move Add (to (sites Empty)))) (end (if (is Line 3) (result Mover Win))))) 
Tic-Tac-Mo uses the same rules as Tic-Tac-Toe, but the third player plays with a "y". The first player to make three in a row wins.
(game "Tic-Tac-Mo" (players 3) (equipment {(board (rectangle 3 5)) (piece "Disc" P1) (piece "Cross" P2) (piece "Y" P3)}) (rules (play (move Add (to (sites Empty)))) (end (if (is Line 3) (result Mover Win))))) 
Play occurs on a 3x3 grid. One player places an X, the other places an O and players take turns placing their marks in the grid, losing is they make three in a row of their colour.
(game "Tic-Tac-Toe Misere" (players 2) (equipment {(board (square 3)) (piece "Disc" P1) (piece "Cross" P2)}) (rules (play (move Add (to (sites Empty)))) (end (if (is Line 3) (result Next Win))))) 
Play occurs on a 3x3 grid. One player places an X, the other places an O and players take turns placing their marks in the grid, attempting to get three in a row of their colour.
(game "Tic-Tac-Toe" (players 2) (equipment {(board (square 3)) (piece "Disc" P1) (piece "Cross" P2)}) (rules (play (move Add (to (sites Empty)))) (end (if (is Line 3) (result Mover Win))))) 
The object is to get a line of three of the same color. On each turn, you may do ONE of the following: (1) Put a red counter in an empty square. (2) Replace a red counter with a yellow one. (3) Replace a yellow counter with a green one. The game is played on a 3x4 board.
(game "Traffic Lights" (players 2) (equipment {(board (rectangle 3 4)) (piece "Square" Shared) (piece "Triangle" Shared) (piece "Disc" Shared)}) (rules (play (or {(move Add (piece "Square") (to (sites Empty))) (move Select (from (sites Occupied by:Shared component:"Square")) (then (promote (last To) (piece {"Triangle"}) Shared))) (move Select (from (sites Occupied by:Shared component:"Triangle")) (then (promote (last To) (piece {"Disc"}) Shared)))})) (end (if (is Line 3) (result Mover Win))))) 
TURN - On each turn, each player drops a stone on an empty cell GOAL - A player loses if he has 3 friendly stones on an orthogonal or diagonal line (they don't need to be adjacent to each other).
(game "Trianon" (players 2) (equipment {(board (square 5) use:Vertex) (piece "Ball" Each)}) (rules (play (move Add (to (sites Empty)))) (end (if (or {(= 3 (count Sites in:(forEach (sites Row (row of:(last To))) if:(is Friend (who at:(site)))))) (= 3 (count Sites in:(forEach (sites Column (column of:(last To))) if:(is Friend (who at:(site)))))) (= 3 (count Sites in:(forEach (union (sites Direction from:(last To) NE included:True) (sites Direction from:(last To) SW)) if:(is Friend (who at:(site)))))) (= 3 (count Sites in:(forEach (union (sites Direction from:(last To) NW included:True) (sites Direction from:(last To) SE)) if:(is Friend (who at:(site))))))}) (result Mover Loss))))) 
3x3 intersecting lines. Three pieces per player. Players alternate turns placing a piece on the board. When all of the pieces have been placed, the players alternate turns moving a piece to an empty adjacent spot. A piece which is surrounded on opposite sides by pieces belonging to the opponent cannot be moved. The player who places three of their stones in a row along one of the lines wins.
(game "Triodi (Chios)" (players 2) (equipment {(board (square 3) use:Vertex) (hand Each) (piece "Marker" Each (if (not (or (if (and (!= (ahead (from) N) (from)) (!= (ahead (from) S) (from))) (and (= (next) (who at:(ahead (from) N))) (= (next) (who at:(ahead (from) S))))) (if (and (!= (ahead (from) E) (from)) (!= (ahead (from) W) (from))) (and (= (next) (who at:(ahead (from) E))) (= (next) (who at:(ahead (from) W))))))) (move Step (to if:(is Empty (to))))))}) (rules (start (place "Marker" "Hand" count:3)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end (if (is Line 3) (result Mover Win))))) 
Three concentric squares, the corners and midpoints of the squares connected with lines. Nine pieces per player. Players alternate turns placing a piece on an empty spot on the board. When all of the pieces are placed, the players alternate turns moving a piece to an empty adjacent spot along the lines. During either phase, when a player places three of their pieces in a row along the lines, the player removes any one of the opponent's pieces. The player who reduces the opponent to two pieces wins. 
(game "Triodi (Diagonal)" (players 2) (equipment {(board (concentric Square rings:3 joinCorners:True) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to))) (then (if (is Line 3 Orthogonal exact:True) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:9)) phases:{(phase "Placement" (play (if (is Prev Mover) (move Remove (sites Occupied by:Enemy container:"Board")) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3 Orthogonal exact:True) (moveAgain)))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (sites Occupied by:Enemy container:"Board")) (forEach Piece))))} (end (if (<= (count Pieces Next) 2) (result Next Loss))))) 
Three concentric squares, the midpoints of the squares connected with lines. Nine pieces per player. Players alternate turns placing a piece on an empty spot on the board. When all of the pieces are placed, the players alternate turns moving a piece to an empty adjacent spot along the lines. During either phase, when a player places three of their pieces in a row along the lines, the player removes any one of the opponent's pieces. The player who reduces the opponent to two pieces wins.
(game "Triodi" (players 2) (equipment {(board (concentric Square rings:3) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to))) (then (if (is Line 3 Orthogonal exact:True) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:9)) phases:{(phase "Placement" (play (if (is Prev Mover) (move Remove (sites Occupied by:Enemy container:"Board")) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3 Orthogonal exact:True) (moveAgain)))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (sites Occupied by:Enemy container:"Board")) (forEach Piece))))} (end (if (<= (count Pieces Next) 2) (result Next Loss))))) 
Triangle, with a line from the apex bisecting the base, and a line bisecting this one and the opposite sides. Three pieces per player. Players alternate turns placing a piece on one of the empty points on the board. When all of the pieces have been placed, players alternate turns moving any one of their pieces to the empty point on the board. The first player to make a line of three wins. 
(game "Tsoro Yemutatu (Triangle)" (players 2) (equipment {(board (scale 1 2 (wedge 3)) use:Vertex) (hand Each) (piece "Marker" Each (move (from) (to (sites Empty))))}) (rules (start (place "Marker" "Hand" count:3)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end (if (is Line 3) (result Mover Win))))) 
3x3 intersecting lines, with diagonals drawn in the large square. Three pieces per player. Players alternate turns placing a stone on an empty point on the board. When all of the pieces have been placed, players alternate turns moving one of their pieces to any empty point. The first player to place three of their pieces in a line wins. 
(game "Tsoro Yemutatu" (players 2) (equipment {(board (rectangle 3 3 diagonals:Alternating) use:Vertex) (hand Each) (piece "Marker" Each (move (from) (to (sites Empty))))}) (rules (start (place "Marker" "Hand" count:3)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end (if (is Line 3) (result Mover Win))))) 
Three concentric squares, with lines connecting the diagonals and the midpoints of the sides. Twelve pieces per player. Players alternate turns placing one of their pieces on one of the empty intersections of the board. If a player places three of their stones in a straight line, the player may remove one of the opponent's pieces. When all of the pieces have been placed, the players alternate turns moving one of their pieces to an empty adjacent point along the lines of the board. When a player is reduced to three pieces, they may move one of their stone to any empty space on the board. The player who reduces their opponent to two pieces wins.
(game "Tsoro Yemutwelve" (players 2) (equipment {(board (concentric Square rings:3 joinCorners:True) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to))) (then (if (is Line 3 Orthogonal exact:True) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:12)) phases:{(phase "Placement" (play (if (is Prev Mover) (if (can Move (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site)))))) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (move Remove (sites Occupied by:Enemy container:"Board"))) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3 Orthogonal exact:True) (moveAgain)))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (if (can Move (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site)))))) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (move Remove (sites Occupied by:Enemy container:"Board"))) (if (> (count Pieces Mover) 3) (forEach Piece) (move (from (sites Occupied by:Mover)) (to (sites Empty)))))))} (end (if (<= (count Pieces Next) 2) (result Next Loss))))) 
3x3 board, without the outer edges of the square. Three pieces per player. Players alternate turns placing the pieces on an empty space on the board. When all of the pieces have been placed, players move pieces to an adjacent empty space on the board. the first player to place all three of their pieces in an orthogonal or diagonal line wins. 
(game "Tuk Tak" (players 2) (equipment {(board (square 3)) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to)))))}) (rules (start (place "Marker" "Hand" count:3)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end (if (is Line 3) (result Mover Win))))) 
Three concentric squares, with lines connecting the diagonals and the midpoints of the sides. Twelve pieces per player. Players alternate turns placing a piece on an empty spot on the board. When a player places three pieces in a row along one of the lines on the board, they remove one of the pieces belonging to the opponent. When all of the pieces have been placed, players alternate turns moving a piece to an empty adjacent spot along the lines. The first player to capture all of the opponent's pieces wins.
(game "Tule Paid" (players 2) (equipment {(board (concentric Square rings:3 joinCorners:True) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to))) (then (if (is Line 3) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:12)) phases:{(phase "Placement" (play (if (is Prev Mover) (move Remove (sites Occupied by:Enemy container:"Board")) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3) (moveAgain)))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (sites Occupied by:Enemy container:"Board")) (forEach Piece))))} (end (if (no Pieces Next) (result Next Loss))))) 
Each player uses twelve pieces. Play begins with each player placing pieces on empty points. If they make three in a row along the lines, they can remove one of the opponent's pieces. They cannot remove an opponent's piece that is in a three in a row formation unless there are no other options. Once all pieces are place, players take turns moving pieces one spot to an adjacent point along the lines. If a player makes three in a row, an opponent's piece is removed as in the first phase of the game. Once a player is reduced to three pieces, that player may move to any open space on the board. The game is won when the opponent is reduced to two pieces. The board has some diagonals.
(game "Twelve Men's Morris" (players 2) (equipment {(board (concentric Square rings:3 joinCorners:True) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to))) (then (if (is Line 3 Orthogonal exact:True) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:12)) phases:{(phase "Placement" (play (if (is Prev Mover) (if (can Move (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site)))))) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (move Remove (sites Occupied by:Enemy container:"Board"))) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3 Orthogonal exact:True) (moveAgain)))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (if (can Move (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site)))))) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (move Remove (sites Occupied by:Enemy container:"Board"))) (if (> (count Pieces Mover) 3) (forEach Piece) (move (from (sites Occupied by:Mover)) (to (sites Empty)))))))} (end (if (<= (count Pieces Next) 2) (result Next Loss))))) 
Each small 3x3 Tic-Tac-Toe board is referred to as a local board, and the larger 3x3 board is referred to as the global board. The game starts with X playing wherever they want in any of the 81 empty spots. This move 'sends' their opponent to its relative location. For example, if X played in the top right square of their local board, then O needs to play next in the local board at the top right of the global board. O can then play in any one of the nine available spots in that local board, each move sending X to a different local board. If a move is played so that it is to win a local board by the rules of normal Tic-Tac-Toe, then the entire local board is marked as a victory for the player in the global board. Once a local board is won by a player or it is filled completely, no more moves may be played in that board. If a player is sent to such a board, then that player may play in any other board. Game play ends when either a player wins the global board or there are no legal moves remaining, in which case the game is a draw.
(game "Ultimate Tic-Tac-Toe" (players 2) (equipment {(board (union (square 9) (scale 3 (square 3))) use:Cell) (piece "Disc" P1) (piece "DiscLarge" P1) (piece "Cross" P2) (piece "CrossLarge" P2) (regions "SubGames" (sites {0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80})) (regions "SubGame0" (sites {0 1 2 9 10 11 18 19 20})) (regions "SubGame1" (sites {3 4 5 12 13 14 21 22 23})) (regions "SubGame2" (sites {6 7 8 15 16 17 24 25 26})) (regions "SubGame3" (sites {27 28 29 36 37 38 45 46 47})) (regions "SubGame4" (sites {30 31 32 39 40 41 48 49 50})) (regions "SubGame5" (sites {33 34 35 42 43 44 51 52 53})) (regions "SubGame6" (sites {54 55 56 63 64 65 72 73 74})) (regions "SubGame7" (sites {57 58 59 66 67 68 75 76 77})) (regions "SubGame8" (sites {60 61 62 69 70 71 78 79 80})) (regions "SuperGame" (sites {81 82 83 84 85 86 87 88 89})) (map "SubToSuper" {0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80} {81 81 81 82 82 82 83 83 83 81 81 81 82 82 82 83 83 83 81 81 81 82 82 82 83 83 83 84 84 84 85 85 85 86 86 86 84 84 84 85 85 85 86 86 86 84 84 84 85 85 85 86 86 86 87 87 87 88 88 88 89 89 89 87 87 87 88 88 88 89 89 89 87 87 87 88 88 88 89 89 89}) (map "SubToSub" {0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80} {0 1 2 0 1 2 0 1 2 3 4 5 3 4 5 3 4 5 6 7 8 6 7 8 6 7 8 0 1 2 0 1 2 0 1 2 3 4 5 3 4 5 3 4 5 6 7 8 6 7 8 6 7 8 0 1 2 0 1 2 0 1 2 3 4 5 3 4 5 3 4 5 6 7 8 6 7 8 6 7 8})}) (rules (play (priority {(move Add (piece (if (= (mover) P1) (id "Disc" P1) (id "Cross" P2))) (to (if (= 0 (mapEntry "SubToSub" (last To))) (sites "SubGame0") (if (= 1 (mapEntry "SubToSub" (last To))) (sites "SubGame1") (if (= 2 (mapEntry "SubToSub" (last To))) (sites "SubGame2") (if (= 3 (mapEntry "SubToSub" (last To))) (sites "SubGame3") (if (= 4 (mapEntry "SubToSub" (last To))) (sites "SubGame4") (if (= 5 (mapEntry "SubToSub" (last To))) (sites "SubGame5") (if (= 6 (mapEntry "SubToSub" (last To))) (sites "SubGame6") (if (= 7 (mapEntry "SubToSub" (last To))) (sites "SubGame7") (if (= 8 (mapEntry "SubToSub" (last To))) (sites "SubGame8")))))))))) if:(and (is Empty (to)) (is Empty (mapEntry "SubToSuper" (to)))))) (move Add (piece (if (= (mover) P1) (id "Disc1") (id "Cross2"))) (to (intersection (sites "SubGames") (sites Empty)) if:(and (is Empty (to)) (is Empty (mapEntry "SubToSuper" (to))))))} (then (if (is Line 3 if:(if (is In (last To) (sites "SubGame0")) (is In (to) (sites "SubGame0")) (if (is In (last To) (sites "SubGame1")) (is In (to) (sites "SubGame1")) (if (is In (last To) (sites "SubGame2")) (is In (to) (sites "SubGame2")) (if (is In (last To) (sites "SubGame3")) (is In (to) (sites "SubGame3")) (if (is In (last To) (sites "SubGame4")) (is In (to) (sites "SubGame4")) (if (is In (last To) (sites "SubGame5")) (is In (to) (sites "SubGame5")) (if (is In (last To) (sites "SubGame6")) (is In (to) (sites "SubGame6")) (if (is In (last To) (sites "SubGame7")) (is In (to) (sites "SubGame7")) (is In (to) (sites "SubGame8"))))))))))) (add (piece (if (= (mover) P1) (id "DiscLarge1") (id "CrossLarge2"))) (to (mapEntry "SubToSuper" (last To)))))))) (end (if (is Line 3 throughAny:(sites "SuperGame") Mover) (result Mover Win))))) 
Played on a square grid 11x11 or larger. White goes first and places two pieces every turn, Black places four pieces per turn. White wins if they make an orthogonal line of four pieces; Black wins if they make an orthogonal line of 7 pieces. Played on a size 11 board.
(game "Unfair" (players 2) (equipment {(board (square 11) use:Vertex) (piece "Ball" Each)}) (rules (play (or (move Add (to (sites Empty) if:(= (id P1) (mover))) (then (if (= 0 (count MovesThisTurn)) (moveAgain)))) (move Add (to (sites Empty) if:(= (id P2) (mover))) (then (if (< (count MovesThisTurn) 3) (moveAgain)))))) (end {(if (and (= (id P1) (mover)) (is Line 4 Orthogonal)) (result Mover Win)) (if (and (= (id P2) (mover)) (is Line 7 Orthogonal)) (result Mover Win))}))) 
5x6 board, made in the sand. One player plays with twelve sticks and the other with twelve pebbles. The player with the sticks plays first. Players alternate turns placing one of their pieces on an empty space on the board. Players are not permitted to place more than two of their own pieces in an orthogonal row on the board. When all of the pieces are placed, players alternate turns moving one of their pieces orthogonally one space. When a player successfully places three of their pieces in an orthogonal row of three, the player captures one of the opponent's pieces. The player who captures all of their opponent's pieces wins.
(game "Wali" (players 2) (equipment {(board (rectangle 5 6)) (hand Each) (piece "Stick" P1 (move Step Orthogonal (to if:(is Empty (to))) (then (if (is Line 3 Orthogonal) (moveAgain))))) (piece "Ball" Each (move Step Orthogonal (to if:(is Empty (to))) (then (if (is Line 3 Orthogonal) (moveAgain)))))}) (rules (start {(place "Stick1" (handSite P1) count:12) (place "Ball2" (handSite P2) count:12)}) phases:{(phase "Placement" (play (do (move (from (handSite Mover)) (to (sites Empty))) ifAfterwards:(not (is Line 3 Orthogonal)))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (sites Occupied by:Enemy container:"Board")) (forEach Piece))))} (end (if (no Pieces Next) (result Next Loss))))) 
6x6 board. Twelve pieces per player. Players alternate turns placing a piece on an empty space on the board. No captures may be made in the placement phase. When all of the pieces have been placed, players alternate turns moving a piece orthogonally to an empty adjacent space on the board. When a player places three of their pieces in an orthogonal row, they remove one of the opponent's pieces. Lines of four or more do not capture. Moving a piece out of a line of four or more, making it now a line of three, does not capture. Lines of three made during the placement phase also do not result in capture. The player who captures all of the opponent's pieces wins.
(game "Wari (Alignment)" (players 2) (equipment {(board (square 6)) (hand Each) (piece "Marker" Each (if (is Line 4 Orthogonal through:(from)) (move Step Orthogonal (to if:(is Empty (to)))) (move Step Orthogonal (to if:(is Empty (to))) (then (if (is Line 3 Orthogonal exact:True) (moveAgain))))))}) (rules (start (place "Marker" "Hand" count:12)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (sites Occupied by:Enemy container:"Board")) (forEach Piece))))} (end (if (no Pieces Next) (result Next Loss))))) 
3x3 intersecting lines, with diagonals. Three pieces per player. Players alternate turns placing one of their pieces on the board. Once all of the pieces are placed, players take turns moving one of their pieces to an adjacent empty spot. The first player to make an orthogonal line with their pieces wins.
(game "Wure Dune" (players 2) (equipment {(board (rectangle 3 3 diagonals:Alternating) use:Vertex) (hand Each) (piece "Marker" Each (move Step All (to if:(is Empty (to)))))}) (rules (start (place "Marker" "Hand" count:3)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end (if (is Line 3 Orthogonal) (result Mover Win))))) 
9x9 intersecting lines. Forty pieces per player. Players alternate turns placing a piece on an empty space on the board. When all of the pieces are placed, players alternate turns moving a piece to an empty adjacent spot on the board. When a player places three of their pieces in an orthogonal or diagonal line, they remove one of the opponent's pieces. Players also remove one of the opponent's pieces when they place four pieces so that they are one the four corners of one of the squares on the board. Pieces which are in these patterns cannot be removed from the board. The player who removes all of the opponent's pieces wins.
(game "Xanan Zirge" (players 2) (equipment {(board (square 9) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to))) (then (if (or (is Line 3 All) (is Pattern {F R F R F R F})) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:40)) phases:{(phase "Placement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Next container:"Board") if:(and (not (is Line 3 All through:(site))) (not (is Pattern {F R F R F R F} from:(site)))))) (move (from (handSite Mover)) (to (sites Empty)) (then (if (or (is Line 3 All) (is Pattern {F R F R F R F})) (moveAgain)))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Next container:"Board") if:(and (not (is Line 3 All through:(site))) (not (is Pattern {F R F R F R F} from:(site)))))) (forEach Piece))))} (end (if (no Pieces Next) (result Next Loss))))) 
Three concentric squares, with lines connecting the corners and the midpoints of the sides. Two diamonds drawn, one connecting the midpoints of the outer square and intersecting the corners of the second square; the second connecting the midpoints of the second square and intersecting the corners of the central square. Twelve pieces per plays. Players alternate turns placing a piece on an empty spot on the board. When all of the pieces are placed, players alternate turns moving a piece to an empty adjacent spot along the lines. During either phase, when a player places three of their pieces in a row, they remove one of the opponent's pieces. Pieces which are in a three-in-a-row pattern cannot be removed. The player who removes all of the opponent's pieces wins.
(game "Xonin Shatar (Complex)" (players 2) (equipment {(board (add (remove (merge {(shift 3 3 (remove (square 3) edges:{{1 4} {3 4} {4 7} {4 5}})) (shift 2 2 (scale 2 (remove (square 3) edges:{{1 4} {3 4} {4 7} {4 5}}))) (scale 4 (remove (square 3) edges:{{1 4} {3 4} {4 7} {4 5}}))}) vertices:{4}) edges:{{17 19} {17 20} {20 22} {22 19} {17 9} {19 11} {22 14} {12 20} {21 13} {23 15} {18 10} {16 8} {11 9} {9 12} {12 14} {14 11} {9 1} {11 3} {6 14} {4 12} {0 8} {5 13} {7 15} {10 2}}) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to))) (then (if (is Line 3) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:12)) phases:{(phase "Placement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3) (moveAgain)))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (forEach Piece))))} (end (if (no Pieces Next) (result Next Loss))))) 
Three concentric squares, with lines connecting the corners and the midpoints of the sides. Twelve pieces per player. Players alternate turns placing a piece on an empty spot on the board. When all of the pieces have been placed, players alternate turns moving a piece to an empty adjacent spot along the lines. During either phase, when a player places three of their pieces in a row, they remove one of the opponent's pieces. Pieces which are in a three-in-a-row pattern cannot be removed from the board. The player who removes all of the opponent's pieces wins.
(game "Xonin Shatar (Simple)" (players 2) (equipment {(board (concentric Square rings:3 joinCorners:True) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to))) (then (if (is Line 3) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:12)) phases:{(phase "Placement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3) (moveAgain)))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (forEach Piece))))} (end (if (no Pieces Next) (result Next Loss))))) 
White player takes a red piece and places a white piece on top of it, placing the stack before them. Black player takes a white piece and places a black piece on top of it, placing the stack before them. Red player takes a black piece and places a red piece on top of it, placing the stack before them. Starting with White, players take turns placing a piece of their colour on an empty space of the board until the victory condition is reached. The aim of the game is to create a 5-in-a-row containing both and only both colours of your stack.
(game "Yavalade" (players 3) (equipment {(board (rotate 90 (hex 5))) (piece "Marker" Each)}) (rules (play (move Add (to (sites Empty)))) (end {(if (is Line 5 whats:{1 3}) (result P1 Win)) (if (is Line 5 whats:{1 2}) (result P2 Win)) (if (is Line 5 whats:{2 3}) (result P3 Win))}))) 
Two players play, with white and black pieces, with neutral red pieces as well. Players take turns placing either a red counters on an empty space or a counter of their color on a space adjacent to a red one. Play continues until one player creates five in a row with only their color and red. The player that does so first wins.
(game "Yavalanchor" (players 2) (equipment {(board (rotate 90 (hex 5))) (piece "Marker" Each) (piece "Marker" Shared) (hand Shared)}) (rules (meta (swap)) (start (place "Marker" (handSite Shared))) (play (or (move Add (to (sites Around (sites Occupied by:Shared component:"Marker") if:(is Empty (to))))) (move (from (handSite Shared)) (to (sites Empty)) copy:True))) (end (forEach Player if:(and (or (= (what at:(last To)) (id "Marker" Player)) (= (what at:(last To)) (id "Marker"))) (is Line 5 whats:{(id "Marker" Player) (id "Marker")})) (result Player Win))))) 
Players alternate turns placing pieces on one of the spaces. The first player to place four in a row without first making three in a row wins. The version of game with 2 players. The game is played on a 5x5 board.
(game "Yavalath" (players 2) (equipment {(board (rotate 90 (hex 5))) (piece "Marker" Each)}) (rules (meta (swap)) (play (move Add (to (sites Empty)))) (end {(if (is Line 4) (result Mover Win)) (if (is Line 3) (result Mover Loss))}))) 
Goal: Simultaneously create two or more rows of exactly four stones of your color. Play: White starts by placing a white stone at an empty cell. Players then take turns placing two stones of their color at empty cells, one stone after another. In each placement, players are not allowed to create a single 4-in-a-row of their color, unless that placement simultaneously creates at least one other 4-in-a-row of their color to win the game. This means that players may NOT make a single 4-in-a-row of their color on the first placement of their turn even if they can make a second 4-in-a-row on their second placement. In no event are players allowed to create 5 (or more) -in-a-row of their color. The first player to make simultaneous 4-in-a-rows of their color wins immediately, whether it was their first or second placement. The game is played on a 13x13 board.
(game "Yavalax" (players 2) (equipment {(board (square 13)) (piece "Marker" Each)}) (rules phases:{(phase "Opening" (play (move Add (to (sites Empty)))) (nextPhase "General")) (phase "General" (play (do (move Add (to (sites Empty)) (then (if (not (is Prev Mover)) (moveAgain)))) ifAfterwards:(and (not (is Line 5)) (!= 1 (+ {(if (is Line 4 N exact:True) 1 0) (if (is Line 4 NE exact:True) 1 0) (if (is Line 4 E exact:True) 1 0) (if (is Line 4 SE exact:True) 1 0)}))))))} (end (if (<= 2 (+ {(if (is Line 4 N exact:True) 1 0) (if (is Line 4 NE exact:True) 1 0) (if (is Line 4 E exact:True) 1 0) (if (is Line 4 SE exact:True) 1 0)})) (result Mover Win))))) 
Three concentric hexagons, with lines connecting the corners and midpoints of the sides. Seventeen pieces per player. Players alternate turns placing one of their pieces on an empty spot on the board. When all of the pieces are placed, they alternate turns moving one of their pieces to an empty adjacent spot along the lines of the board. During either phase, when a player places three of their pieces in a row, they may remove one of the opponent's pieces from the board. Pieces which are in a three-in-a-row arrangement cannot be removed from the board. The player who captures all of the opponent's pieces wins.
(game "Zurgaan Tal" (players 2) (equipment {(board (rotate 30 (concentric Hexagon rings:3 joinCorners:True)) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to))) (then (if (is Line 3) (moveAgain)))))}) (rules (start (place "Marker" "Hand" count:17)) phases:{(phase "Placement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (move (from (handSite Mover)) (to (sites Empty)) (then (if (is Line 3) (moveAgain)))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Remove (forEach (sites Occupied by:Enemy container:"Board") if:(not (is Line 3 Orthogonal through:(site))))) (forEach Piece))))} (end (if (no Pieces Next) (result Next Loss))))) 
A game is played in two rounds. In each round, players strive to achieve a particular goal, unique to them. But at the same time, they pursue a general objective. The player who first achieves one of his two objectives wins the round. The purpose of Life: Life wants to expand. To achieve this objective, there must be at least one Life pawn in each segment and in each ring of the Circle of Life. Death's Goal: Death wants to rule. To achieve this goal, at least one complete segment or ring of the Circle of Life must be filled with Death pawns. Overall Goal: Both players are equally striving to fulfill their destiny. To achieve this objective, you must have all of your 14 pawns on the Circle of Life. A game is played in two rounds. In each round, one of the players assumes the role of Life, the other that of Death. After the first round, the players switch roles. The player who assumes the role of Life begins. When it is their turn, the player performs one of two actions: Place a pawn in a free space on the Circle of Life. This location must be vertically or horizontally adjacent to a Life token (same for Death). During the very first turn, the player can place his pawn wherever he wants. Or turn a ring one segment (45 degrees) clockwise. Special power of Life: birth. If, by placing his pawn, the player has finished filling a segment with Life pawns, the player who took on the role of Life has the right to place another Life pawn in any empty space. . In doing so, he must comply with the investment rules. Special power of Death: disintegration. If, after a Death token has been placed, a Life token is completely surrounded by Death tokens (either vertically or horizontally), the Life token must be replaced by a Death token. the death A round ends when a player has achieved one of their two objectives. The winner of this round counts his pawns that are on the Circle of Life. After two rounds, when each of the players has taken on the role of Life and Death once, the game ends. Now it's a matter of determining who the final winner is: If a player wins both rounds, they've won the whole game! If each player wins a round, they compare the number of checkers it took each to win a round. Whoever needed the fewest pawns is the final winner. In the event of a tie, the game ends as in real life: with a draw.
(game "Azteka" (players 2) (equipment {(board (remove (concentric {0 0 8 8 8 8}) cells:{1})) (piece "Pawn" Each) (hand Each) (regions "RingOne" {24 25 26 27 28 29 30 31}) (regions "RingTwo" {16 17 18 19 20 21 22 23}) (regions "RingThree" {8 9 10 11 12 13 14 15}) (regions "RingFour" {0 1 2 3 4 5 6 7}) (regions "SegmentOne" {0 8 16 24}) (regions "SegmentTwo" {2 10 18 26}) (regions "SegmentThree" {3 11 19 27}) (regions "SegmentFour" {4 12 20 28}) (regions "SegmentFive" {5 13 21 29}) (regions "SegmentSix" {6 14 22 30}) (regions "SegmentSeven" {7 15 23 31}) (regions "SegmentEight" {1 9 17 25})}) (rules (start (place "Pawn" "Hand" count:14)) phases:{(phase "FirstPhase" (play (if (is Prev Mover) (move (from (handSite Mover)) (to (sites Around (sites Occupied by:Mover) Orthogonal if:(is Empty (to)))) (then (if (and (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site))))) (if (is In (last To) (sites "SegmentOne")) (all Sites (sites "SegmentOne") if:(= (who at:(site)) P1)) (if (is In (last To) (sites "SegmentTwo")) (all Sites (sites "SegmentTwo") if:(= (who at:(site)) P1)) (if (is In (last To) (sites "SegmentThree")) (all Sites (sites "SegmentThree") if:(= (who at:(site)) P1)) (if (is In (last To) (sites "SegmentFour")) (all Sites (sites "SegmentFour") if:(= (who at:(site)) P1)) (if (is In (last To) (sites "SegmentFive")) (all Sites (sites "SegmentFive") if:(= (who at:(site)) P1)) (if (is In (last To) (sites "SegmentSix")) (all Sites (sites "SegmentSix") if:(= (who at:(site)) P1)) (if (is In (last To) (sites "SegmentSeven")) (all Sites (sites "SegmentSeven") if:(= (who at:(site)) P1)) (all Sites (sites "SegmentEight") if:(= (who at:(site)) P1)))))))))) (moveAgain)))) (or (if (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site))))) (move (from (handSite Mover)) (to (if (< (count Moves) 2) (sites Empty) (sites Around (sites Occupied by:Mover) Orthogonal if:(is Empty (to))))))) (if (>= (count Moves) 2) (or {(move Select (from 27) (to 26) (then (do (set Var (what at:27)) next:(and {(remove 27) (if (is Occupied 28) (move (from 28) (to 27))) (if (is Occupied 29) (move (from 29) (to 28))) (if (is Occupied 30) (move (from 30) (to 29))) (if (is Occupied 31) (move (from 31) (to 30))) (if (is Occupied 25) (move (from 25) (to 31))) (if (is Occupied 24) (move (from 24) (to 25))) (if (is Occupied 26) (move (from 26) (to 24))) (if (!= 0 (var)) (add (piece (var)) (to 26)))})))) (move Select (from 19) (to 18) (then (do (set Var (what at:19)) next:(and {(remove 19) (if (is Occupied 20) (move (from 20) (to 19))) (if (is Occupied 21) (move (from 21) (to 20))) (if (is Occupied 22) (move (from 22) (to 21))) (if (is Occupied 23) (move (from 23) (to 22))) (if (is Occupied 17) (move (from 17) (to 23))) (if (is Occupied 16) (move (from 16) (to 17))) (if (is Occupied 18) (move (from 18) (to 16))) (if (!= 0 (var)) (add (piece (var)) (to 18)))})))) (move Select (from 11) (to 10) (then (do (set Var (what at:11)) next:(and {(remove 11) (if (is Occupied 12) (move (from 12) (to 11))) (if (is Occupied 13) (move (from 13) (to 12))) (if (is Occupied 14) (move (from 14) (to 13))) (if (is Occupied 15) (move (from 15) (to 14))) (if (is Occupied 9) (move (from 9) (to 15))) (if (is Occupied 8) (move (from 8) (to 9))) (if (is Occupied 10) (move (from 10) (to 8))) (if (!= 0 (var)) (add (piece (var)) (to 10)))})))) (move Select (from 3) (to 2) (then (do (set Var (what at:3)) next:(and {(remove 3) (if (is Occupied 4) (move (from 4) (to 3))) (if (is Occupied 5) (move (from 5) (to 4))) (if (is Occupied 6) (move (from 6) (to 5))) (if (is Occupied 7) (move (from 7) (to 6))) (if (is Occupied 1) (move (from 1) (to 7))) (if (is Occupied 0) (move (from 0) (to 1))) (if (is Occupied 2) (move (from 2) (to 0))) (if (!= 0 (var)) (add (piece (var)) (to 2)))}))))})) (then (if (is Mover P1) (if (and (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site))))) (if (is In (last To) (sites "SegmentOne")) (all Sites (sites "SegmentOne") if:(= (who at:(site)) P1)) (if (is In (last To) (sites "SegmentTwo")) (all Sites (sites "SegmentTwo") if:(= (who at:(site)) P1)) (if (is In (last To) (sites "SegmentThree")) (all Sites (sites "SegmentThree") if:(= (who at:(site)) P1)) (if (is In (last To) (sites "SegmentFour")) (all Sites (sites "SegmentFour") if:(= (who at:(site)) P1)) (if (is In (last To) (sites "SegmentFive")) (all Sites (sites "SegmentFive") if:(= (who at:(site)) P1)) (if (is In (last To) (sites "SegmentSix")) (all Sites (sites "SegmentSix") if:(= (who at:(site)) P1)) (if (is In (last To) (sites "SegmentSeven")) (all Sites (sites "SegmentSeven") if:(= (who at:(site)) P1)) (all Sites (sites "SegmentEight") if:(= (who at:(site)) P1)))))))))) (moveAgain)) (surround (from (last To)) Orthogonal (between if:(is Enemy (who at:(between))) (apply (fromTo (from (handSite Mover)) (to (between))))) (to if:(is Friend (who at:(to)))))))) (then (if (is Mover P1) (if (or (= 14 (count Sites in:(sites Occupied by:P1))) (and {(not (all Sites (sites "RingOne") if:(!= (who at:(site)) P1))) (not (all Sites (sites "RingTwo") if:(!= (who at:(site)) P1))) (not (all Sites (sites "RingThree") if:(!= (who at:(site)) P1))) (not (all Sites (sites "RingFour") if:(!= (who at:(site)) P1))) (not (all Sites (sites "SegmentOne") if:(!= (who at:(site)) P1))) (not (all Sites (sites "SegmentTwo") if:(!= (who at:(site)) P1))) (not (all Sites (sites "SegmentThree") if:(!= (who at:(site)) P1))) (not (all Sites (sites "SegmentFour") if:(!= (who at:(site)) P1))) (not (all Sites (sites "SegmentFive") if:(!= (who at:(site)) P1))) (not (all Sites (sites "SegmentSix") if:(!= (who at:(site)) P1))) (not (all Sites (sites "SegmentSeven") if:(!= (who at:(site)) P1))) (not (all Sites (sites "SegmentEight") if:(!= (who at:(site)) P1)))})) (and {(set Score P1 (count Pieces Mover in:(sites Board))) (remove (sites Board)) (remove (sites Hand P1)) (remove (sites Hand P2)) (add (piece (id "Pawn" P1)) (to (handSite P1)) count:14) (add (piece (id "Pawn" P2)) (to (handSite P2)) count:14) (set NextPlayer (player 2)) (set Pending)})) (if (or (= 14 (count Sites in:(sites Occupied by:P2))) (or {(all Sites (sites "RingOne") if:(= (who at:(site)) P2)) (all Sites (sites "RingTwo") if:(= (who at:(site)) P2)) (all Sites (sites "RingThree") if:(= (who at:(site)) P2)) (all Sites (sites "RingFour") if:(= (who at:(site)) P2)) (all Sites (sites "SegmentOne") if:(= (who at:(site)) P2)) (all Sites (sites "SegmentTwo") if:(= (who at:(site)) P2)) (all Sites (sites "SegmentThree") if:(= (who at:(site)) P2)) (all Sites (sites "SegmentFour") if:(= (who at:(site)) P2)) (all Sites (sites "SegmentFive") if:(= (who at:(site)) P2)) (all Sites (sites "SegmentSix") if:(= (who at:(site)) P2)) (all Sites (sites "SegmentSeven") if:(= (who at:(site)) P2)) (all Sites (sites "SegmentEight") if:(= (who at:(site)) P2))})) (and {(set Score P2 (count Pieces Mover in:(sites Board))) (remove (sites Board)) (remove (sites Hand P1)) (remove (sites Hand P2)) (add (piece (id "Pawn" P1)) (to (handSite P1)) count:14) (add (piece (id "Pawn" P2)) (to (handSite P2)) count:14) (set NextPlayer (player 2)) (set Pending)})))))) (nextPhase (or (!= 0 (score P1)) (!= 0 (score P2))) "SecondPhase")) (phase "SecondPhase" (play (if (and (not (is Pending)) (is Prev Mover)) (move (from (handSite Mover)) (to (sites Around (sites Occupied by:Mover) Orthogonal if:(is Empty (to)))) (then (if (and (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site))))) (if (is In (last To) (sites "SegmentOne")) (all Sites (sites "SegmentOne") if:(= (who at:(site)) P2)) (if (is In (last To) (sites "SegmentTwo")) (all Sites (sites "SegmentTwo") if:(= (who at:(site)) P2)) (if (is In (last To) (sites "SegmentThree")) (all Sites (sites "SegmentThree") if:(= (who at:(site)) P2)) (if (is In (last To) (sites "SegmentFour")) (all Sites (sites "SegmentFour") if:(= (who at:(site)) P2)) (if (is In (last To) (sites "SegmentFive")) (all Sites (sites "SegmentFive") if:(= (who at:(site)) P2)) (if (is In (last To) (sites "SegmentSix")) (all Sites (sites "SegmentSix") if:(= (who at:(site)) P2)) (if (is In (last To) (sites "SegmentSeven")) (all Sites (sites "SegmentSeven") if:(= (who at:(site)) P2)) (all Sites (sites "SegmentEight") if:(= (who at:(site)) P2)))))))))) (moveAgain)))) (or (if (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site))))) (move (from (handSite Mover)) (to (if (< (count Sites in:(sites Occupied by:All container:"Board")) 2) (sites Empty) (sites Around (sites Occupied by:Mover) Orthogonal if:(is Empty (to))))))) (if (>= (count Sites in:(sites Occupied by:All container:"Board")) 2) (or {(move Select (from 27) (to 26) (then (do (set Var (what at:27)) next:(and {(remove 27) (if (is Occupied 28) (move (from 28) (to 27))) (if (is Occupied 29) (move (from 29) (to 28))) (if (is Occupied 30) (move (from 30) (to 29))) (if (is Occupied 31) (move (from 31) (to 30))) (if (is Occupied 25) (move (from 25) (to 31))) (if (is Occupied 24) (move (from 24) (to 25))) (if (is Occupied 26) (move (from 26) (to 24))) (if (!= 0 (var)) (add (piece (var)) (to 26)))})))) (move Select (from 19) (to 18) (then (do (set Var (what at:19)) next:(and {(remove 19) (if (is Occupied 20) (move (from 20) (to 19))) (if (is Occupied 21) (move (from 21) (to 20))) (if (is Occupied 22) (move (from 22) (to 21))) (if (is Occupied 23) (move (from 23) (to 22))) (if (is Occupied 17) (move (from 17) (to 23))) (if (is Occupied 16) (move (from 16) (to 17))) (if (is Occupied 18) (move (from 18) (to 16))) (if (!= 0 (var)) (add (piece (var)) (to 18)))})))) (move Select (from 11) (to 10) (then (do (set Var (what at:11)) next:(and {(remove 11) (if (is Occupied 12) (move (from 12) (to 11))) (if (is Occupied 13) (move (from 13) (to 12))) (if (is Occupied 14) (move (from 14) (to 13))) (if (is Occupied 15) (move (from 15) (to 14))) (if (is Occupied 9) (move (from 9) (to 15))) (if (is Occupied 8) (move (from 8) (to 9))) (if (is Occupied 10) (move (from 10) (to 8))) (if (!= 0 (var)) (add (piece (var)) (to 10)))})))) (move Select (from 3) (to 2) (then (do (set Var (what at:3)) next:(and {(remove 3) (if (is Occupied 4) (move (from 4) (to 3))) (if (is Occupied 5) (move (from 5) (to 4))) (if (is Occupied 6) (move (from 6) (to 5))) (if (is Occupied 7) (move (from 7) (to 6))) (if (is Occupied 1) (move (from 1) (to 7))) (if (is Occupied 0) (move (from 0) (to 1))) (if (is Occupied 2) (move (from 2) (to 0))) (if (!= 0 (var)) (add (piece (var)) (to 2)))}))))})) (then (if (is Mover P2) (if (and (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site))))) (if (is In (last To) (sites "SegmentOne")) (all Sites (sites "SegmentOne") if:(= (who at:(site)) P2)) (if (is In (last To) (sites "SegmentTwo")) (all Sites (sites "SegmentTwo") if:(= (who at:(site)) P2)) (if (is In (last To) (sites "SegmentThree")) (all Sites (sites "SegmentThree") if:(= (who at:(site)) P2)) (if (is In (last To) (sites "SegmentFour")) (all Sites (sites "SegmentFour") if:(= (who at:(site)) P2)) (if (is In (last To) (sites "SegmentFive")) (all Sites (sites "SegmentFive") if:(= (who at:(site)) P2)) (if (is In (last To) (sites "SegmentSix")) (all Sites (sites "SegmentSix") if:(= (who at:(site)) P2)) (if (is In (last To) (sites "SegmentSeven")) (all Sites (sites "SegmentSeven") if:(= (who at:(site)) P2)) (all Sites (sites "SegmentEight") if:(= (who at:(site)) P2)))))))))) (moveAgain)) (surround (from (last To)) Orthogonal (between if:(is Enemy (who at:(between))) (apply (fromTo (from (handSite Mover)) (to (between))))) (to if:(is Friend (who at:(to)))))))) (then (if (is Mover P2) (if (or (= 14 (count Sites in:(sites Occupied by:P2))) (and {(not (all Sites (sites "RingOne") if:(!= (who at:(site)) P2))) (not (all Sites (sites "RingTwo") if:(!= (who at:(site)) P2))) (not (all Sites (sites "RingThree") if:(!= (who at:(site)) P2))) (not (all Sites (sites "RingFour") if:(!= (who at:(site)) P2))) (not (all Sites (sites "SegmentOne") if:(!= (who at:(site)) P2))) (not (all Sites (sites "SegmentTwo") if:(!= (who at:(site)) P2))) (not (all Sites (sites "SegmentThree") if:(!= (who at:(site)) P2))) (not (all Sites (sites "SegmentFour") if:(!= (who at:(site)) P2))) (not (all Sites (sites "SegmentFive") if:(!= (who at:(site)) P2))) (not (all Sites (sites "SegmentSix") if:(!= (who at:(site)) P2))) (not (all Sites (sites "SegmentSeven") if:(!= (who at:(site)) P2))) (not (all Sites (sites "SegmentEight") if:(!= (who at:(site)) P2)))})) (if (> (score P2) 0) (set Var "End" 2) (if (> (count Pieces Mover in:(sites Board)) (score P1)) (and (set Var "End" 1) (set Score P2 (count Pieces Mover in:(sites Board)))) (if (< (count Pieces Mover in:(sites Board)) (score P1)) (and (set Var "End" 2) (set Score P2 (count Pieces Mover in:(sites Board)))) (set Var "End" 3))))) (if (or (= 14 (count Sites in:(sites Occupied by:P1))) (or {(all Sites (sites "RingOne") if:(= (who at:(site)) P1)) (all Sites (sites "RingTwo") if:(= (who at:(site)) P1)) (all Sites (sites "RingThree") if:(= (who at:(site)) P1)) (all Sites (sites "RingFour") if:(= (who at:(site)) P1)) (all Sites (sites "SegmentOne") if:(= (who at:(site)) P1)) (all Sites (sites "SegmentTwo") if:(= (who at:(site)) P1)) (all Sites (sites "SegmentThree") if:(= (who at:(site)) P1)) (all Sites (sites "SegmentFour") if:(= (who at:(site)) P1)) (all Sites (sites "SegmentFive") if:(= (who at:(site)) P1)) (all Sites (sites "SegmentSix") if:(= (who at:(site)) P1)) (all Sites (sites "SegmentSeven") if:(= (who at:(site)) P1)) (all Sites (sites "SegmentEight") if:(= (who at:(site)) P1))})) (if (> (score P1) 0) (set Var "End" 1) (if (> (count Pieces Mover in:(sites Board)) (score P2)) (and (set Var "End" 2) (set Score P1 (count Pieces Mover in:(sites Board)))) (if (< (count Pieces Mover in:(sites Board)) (score P2)) (and (set Var "End" 1) (set Score P1 (count Pieces Mover in:(sites Board)))) (set Var "End" 3))))))))) (end {(if (= (var "End") 3) (result Mover Draw)) (if (= (var "End") 2) (result P2 Win)) (if (= (var "End") 1) (result P1 Win))}))})) 
The game begins with an empty Diamond board. Black moves first, then turns alternate. (To offset any advantage Black has in moving first, the pie rule is used: White can choose to switch sides after Black's first move, playing from then on as Black. White has this option only after Black's first move.) The game is executed in two phases: 1) Placement phase. Players take turns placing one of their pieces on any open point on the board. No placements result in a capture in this phase. A player can win the game in this phase if they are able to occupy all four corners of a board square; otherwise, play proceeds to the Movement phase once all 24 pieces have been placed. 2) Movement phase. For their turn, a player may either: - move one of their pieces along a straight line to an adjacent empty point; or, - remove a neutral piece from the board—but only if no white or black piece is adjacent to it. Capturing moves are possible in the Movement phase. If the points of a triangle contain exactly one white and one black piece, either player can capture the opponent piece by occupying the remaining open point ("cornering" the enemy piece on the triangle). If a move simultaneously corners two opponent pieces on two different triangles, then neither enemy piece is captured. A piece can move safely to a triangle point even if the other two points of the triangle are occupied by enemy pieces. A player wins by being the first to occupy all four corners (points) of a board square with their pieces. The game is drawn if any of the following occurs: - The player whose turn it is to move cannot move a piece. - In the last 50 moves (25 moves per player) no capture has been made, nor neutral piece removed.
(game "Diamond" (players 2) (equipment {(board (rotate 90 (tiling T33434 3)) use:Vertex) (piece "Disc" Each (move Step (to if:(is Empty (to))) (then (if (= 1 (count Sites in:(forEach (sites Incident Cell of:Vertex at:(last To)) if:(and {(= 3 (count Sites in:(sites Incident Vertex of:Cell at:(site)))) (= 2 (count Sites in:(forEach (sites Incident Vertex of:Cell at:(site)) if:(is Mover (who at:(site)))))) (= 1 (count Sites in:(forEach (sites Incident Vertex of:Cell at:(site)) if:(is Next (who at:(site))))))})))) (forEach Site (sites Incident Cell of:Vertex at:(last To)) (if (and {(= 3 (count Sites in:(sites Incident Vertex of:Cell at:(site)))) (= 2 (count Sites in:(forEach (sites Incident Vertex of:Cell at:(site)) if:(is Mover (who at:(site)))))) (= 1 (count Sites in:(forEach (sites Incident Vertex of:Cell at:(site)) if:(is Next (who at:(site))))))}) (and (forEach Site (forEach (sites Incident Vertex of:Cell at:(site)) if:(is Next (who at:(site)))) (and (remove (site)) (add (piece (id "Disc" Neutral)) (to (site))))) (set Counter)))))))) (piece "Disc" Neutral) (hand Each) (regions P1 {(sites Side W) (sites Side E)}) (regions P2 {(sites Side N) (sites Side S)})}) (rules (meta (swap)) (start (place "Disc" "Hand" count:12)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)) (then (and (forEach Site (sites Incident Cell of:Vertex at:(last To)) (if (= 4 (count Sites in:(forEach (sites Incident Vertex of:Cell at:(site)) if:(is Mover (who at:(site)))))) (trigger "Win" Mover))) (set Counter))))) (nextPhase Mover (is Empty (handSite Mover)) "Movement")) (phase "Movement" (play (or (forEach Piece) (move Remove (sites Occupied by:Neutral)))))} (end {(if (is Triggered "Win" Mover) (result Mover Win)) (if (or (no Moves Mover) (= (counter) 49)) (result Mover Draw))}))) 
The two players, Red and Blue, alternately place tokens on the intersections of the board until each has placed fifteen. Thereafter they alternate turns sliding a single token along a line to an adjacent vertex. A player who occupies the three vertices of any triangle has formed a mill and may relocate one enemy token. Occupying the four vertices of a square (forming a double mill) allows the player to relocate two enemy tokens. No more than two tokens may be relocated in a single turn, even if a player completes a mill and double mill with the same move. The winner is the first player to occupy all six vertices of either any neutral hexagon or one of his/her own color. A win can be achieved during either the placement or movement phases of the game.
(game "Kensington" (players 2) (equipment {(board (rotate 90 (tiling T3464 2)) use:Vertex) (hand Each) (piece "Marker" Each (move Step (to if:(is Empty (to))))) (regions "HexA" P1 (sites Cell "E4")) (regions "HexB" P1 (sites Cell "I4")) (regions "HexA" P2 (sites Cell "E12")) (regions "HexB" P2 (sites Cell "I12")) (regions "HexNeutral1" (sites Cell "C8")) (regions "HexNeutral2" (sites Cell "G8")) (regions "HexNeutral3" (sites Cell "K8"))}) (rules (start (place "Marker" "Hand" count:15)) (play (if (is Prev Mover) (move (from (sites Occupied by:Next container:"Board")) (to (sites Empty) (apply if:(is Pending) (moveAgain)))) (if (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) (forEach Piece) (move (from (handSite Mover)) (to (sites Empty))) (then (forEach Site (sites Incident Cell of:Vertex at:(last To)) (if (= (count Sites in:(intersection (sites Incident Vertex of:Cell at:(site)) (sites Occupied by:Mover))) (count Sites in:(sites Incident Vertex of:Cell at:(site)))) (if (= 6 (count Sites in:(sites Incident Vertex of:Cell at:(site)))) (if (or {(= (sites Incident Vertex of:Cell at:(site)) (sites Mover "HexA")) (= (sites Incident Vertex of:Cell at:(site)) (sites Mover "HexB")) (= (sites Incident Vertex of:Cell at:(site)) (sites "HexNeutral1")) (= (sites Incident Vertex of:Cell at:(site)) (sites "HexNeutral2")) (= (sites Incident Vertex of:Cell at:(site)) (sites "HexNeutral3"))}) (trigger "Lose" Next)) (and (if (= 4 (count Sites in:(sites Incident Vertex of:Cell at:(site)))) (set Pending)) (moveAgain))))))))) (end (if (is Triggered "Lose" Next) (result Mover Win))))) 
Each turn the players will put one of their pieces on the boardgame. It's forbidden to put a shape in a line, a column or an area on which this same form has already been posed by the opponent. We can only double a shape if we have played the previous one ourself. The first player who places the fourth different form in a row, column or zone wins the game immediately, no matter who owns the other pieces of that winning move.
(game "Quantik" (players 2) (equipment {(board (square 4) use:Vertex) (piece "Disc" Each) (piece "Square" Each) (piece "Triangle" Each) (piece "Hex" Each) (regions "BottomLeft" (expand origin:(coord "A1") All)) (regions "BottomRight" (expand origin:(coord "D1") All)) (regions "TopLeft" (expand origin:(coord "A4") All)) (regions "TopRight" (expand origin:(coord "D4") All)) (hand Each size:4) (map {(pair (id "Disc1") (id "Disc2")) (pair (id "Disc2") (id "Disc1")) (pair (id "Square1") (id "Square2")) (pair (id "Square2") (id "Square1")) (pair (id "Triangle1") (id "Triangle2")) (pair (id "Triangle2") (id "Triangle1")) (pair (id "Hex1") (id "Hex2")) (pair (id "Hex2") (id "Hex1"))})}) (rules (start {(place "Disc1" (handSite P1) count:2) (place "Disc2" (handSite P2) count:2) (place "Square1" (handSite P1 1) count:2) (place "Square2" (handSite P2 1) count:2) (place "Triangle1" (handSite P1 2) count:2) (place "Triangle2" (handSite P2 2) count:2) (place "Hex1" (handSite P1 3) count:2) (place "Hex2" (handSite P2 3) count:2)}) (play (move (from (sites Occupied by:Mover container:(mover))) (to (sites Empty) if:(and {(all Sites (sites Row (row of:(to))) if:(!= (what at:(site)) (mapEntry (what at:(from))))) (all Sites (sites Column (column of:(to))) if:(!= (what at:(site)) (mapEntry (what at:(from))))) (if (is In (to) (sites "BottomLeft")) (all Sites (sites "BottomLeft") if:(!= (what at:(site)) (mapEntry (what at:(from))))) (if (is In (to) (sites "BottomRight")) (all Sites (sites "BottomRight") if:(!= (what at:(site)) (mapEntry (what at:(from))))) (if (is In (to) (sites "TopLeft")) (all Sites (sites "TopLeft") if:(!= (what at:(site)) (mapEntry (what at:(from))))) (all Sites (sites "TopRight") if:(!= (what at:(site)) (mapEntry (what at:(from))))))))})))) (end (if (or {(all Different (sites "BottomLeft") if:(is Occupied (site))) (all Different (sites "BottomRight") if:(is Occupied (site))) (all Different (sites "TopLeft") if:(is Occupied (site))) (all Different (sites "TopRight") if:(is Occupied (site))) (all Different (sites Row 0) if:(is Occupied (site))) (all Different (sites Row 1) if:(is Occupied (site))) (all Different (sites Row 2) if:(is Occupied (site))) (all Different (sites Row 3) if:(is Occupied (site))) (all Different (sites Column 0) if:(is Occupied (site))) (all Different (sites Column 1) if:(is Occupied (site))) (all Different (sites Column 2) if:(is Occupied (site))) (all Different (sites Column 3) if:(is Occupied (site))) (no Moves Next)}) (result Mover Win))))) 
Each player in turn places one of his marbles in an open space on the board, on top of a square (i.e. 4 marbles next to each other). After the placement of each marble, check to see if a square or marbles have been formed. If at least 3 of the 4 marbles that form a square are of the same color, a piece of that color go on top of that square. If as a result other squares are formed, the same rule is applied. The winner is the first player to have at least 27 marbles of his colour on the board. 
(game "Upper Hand" (players 2) (equipment {(board (square 5 pyramidal:True) use:Vertex) (piece "Ball" Each) (piece "Ball" Neutral)}) (rules (start (place "Ball0" (centrePoint))) (play (move Add (to (sites Empty) if:(is Flat)) (then (while (not (all Sites (sites Board) if:(not (can Move (or (and {(if (and (and (is Occupied (site)) (is Empty (ahead (site) UNE))) (and (!= (site) (ahead (site) N)) (!= (site) (ahead (site) E)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) N) (ahead (site) E) (ahead (ahead (site) N) E)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P1) (sites {(site) (ahead (site) N) (ahead (site) E) (ahead (ahead (site) N) E)}))))) (add (piece (id "Ball" P1)) (to (ahead (site) UNE) if:(is Flat))))) (if (and (and (is Occupied (site)) (is Empty (ahead (site) USE))) (and (!= (site) (ahead (site) S)) (!= (site) (ahead (site) E)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) S) (ahead (site) E) (ahead (ahead (site) S) E)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P1) (sites {(site) (ahead (site) S) (ahead (site) E) (ahead (ahead (site) S) E)}))))) (add (piece (id "Ball" P1)) (to (ahead (site) USE) if:(is Flat))))) (if (and (and (is Occupied (site)) (is Empty (ahead (site) USW))) (and (!= (site) (ahead (site) S)) (!= (site) (ahead (site) W)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) S) (ahead (site) W) (ahead (ahead (site) S) W)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P1) (sites {(site) (ahead (site) S) (ahead (site) W) (ahead (ahead (site) S) W)}))))) (add (piece (id "Ball" P1)) (to (ahead (site) USW) if:(is Flat))))) (if (and (and (is Occupied (site)) (is Empty (ahead (site) UNE))) (and (!= (site) (ahead (site) N)) (!= (site) (ahead (site) W)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) N) (ahead (site) W) (ahead (ahead (site) N) W)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P1) (sites {(site) (ahead (site) N) (ahead (site) W) (ahead (ahead (site) N) W)}))))) (add (piece (id "Ball" P1)) (to (ahead (site) UNE) if:(is Flat)))))}) (and {(if (and (and (is Occupied (site)) (is Empty (ahead (site) UNE))) (and (!= (site) (ahead (site) N)) (!= (site) (ahead (site) E)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) N) (ahead (site) E) (ahead (ahead (site) N) E)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P2) (sites {(site) (ahead (site) N) (ahead (site) E) (ahead (ahead (site) N) E)}))))) (add (piece (id "Ball" P2)) (to (ahead (site) UNE) if:(is Flat))))) (if (and (and (is Occupied (site)) (is Empty (ahead (site) USE))) (and (!= (site) (ahead (site) S)) (!= (site) (ahead (site) E)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) S) (ahead (site) E) (ahead (ahead (site) S) E)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P2) (sites {(site) (ahead (site) S) (ahead (site) E) (ahead (ahead (site) S) E)}))))) (add (piece (id "Ball" P2)) (to (ahead (site) USE) if:(is Flat))))) (if (and (and (is Occupied (site)) (is Empty (ahead (site) USW))) (and (!= (site) (ahead (site) S)) (!= (site) (ahead (site) W)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) S) (ahead (site) W) (ahead (ahead (site) S) W)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P2) (sites {(site) (ahead (site) S) (ahead (site) W) (ahead (ahead (site) S) W)}))))) (add (piece (id "Ball" P2)) (to (ahead (site) USW) if:(is Flat))))) (if (and (and (is Occupied (site)) (is Empty (ahead (site) UNE))) (and (!= (site) (ahead (site) N)) (!= (site) (ahead (site) W)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) N) (ahead (site) W) (ahead (ahead (site) N) W)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P2) (sites {(site) (ahead (site) N) (ahead (site) W) (ahead (ahead (site) N) W)}))))) (add (piece (id "Ball" P2)) (to (ahead (site) UNE) if:(is Flat)))))})))))) (forEach Site (sites Board) (and (and {(if (and (and (is Occupied (site)) (is Empty (ahead (site) UNE))) (and (!= (site) (ahead (site) N)) (!= (site) (ahead (site) E)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) N) (ahead (site) E) (ahead (ahead (site) N) E)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P1) (sites {(site) (ahead (site) N) (ahead (site) E) (ahead (ahead (site) N) E)}))))) (add (piece (id "Ball" P1)) (to (ahead (site) UNE) if:(is Flat))))) (if (and (and (is Occupied (site)) (is Empty (ahead (site) USE))) (and (!= (site) (ahead (site) S)) (!= (site) (ahead (site) E)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) S) (ahead (site) E) (ahead (ahead (site) S) E)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P1) (sites {(site) (ahead (site) S) (ahead (site) E) (ahead (ahead (site) S) E)}))))) (add (piece (id "Ball" P1)) (to (ahead (site) USE) if:(is Flat))))) (if (and (and (is Occupied (site)) (is Empty (ahead (site) USW))) (and (!= (site) (ahead (site) S)) (!= (site) (ahead (site) W)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) S) (ahead (site) W) (ahead (ahead (site) S) W)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P1) (sites {(site) (ahead (site) S) (ahead (site) W) (ahead (ahead (site) S) W)}))))) (add (piece (id "Ball" P1)) (to (ahead (site) USW) if:(is Flat))))) (if (and (and (is Occupied (site)) (is Empty (ahead (site) UNE))) (and (!= (site) (ahead (site) N)) (!= (site) (ahead (site) W)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) N) (ahead (site) W) (ahead (ahead (site) N) W)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P1) (sites {(site) (ahead (site) N) (ahead (site) W) (ahead (ahead (site) N) W)}))))) (add (piece (id "Ball" P1)) (to (ahead (site) UNE) if:(is Flat)))))}) (and {(if (and (and (is Occupied (site)) (is Empty (ahead (site) UNE))) (and (!= (site) (ahead (site) N)) (!= (site) (ahead (site) E)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) N) (ahead (site) E) (ahead (ahead (site) N) E)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P2) (sites {(site) (ahead (site) N) (ahead (site) E) (ahead (ahead (site) N) E)}))))) (add (piece (id "Ball" P2)) (to (ahead (site) UNE) if:(is Flat))))) (if (and (and (is Occupied (site)) (is Empty (ahead (site) USE))) (and (!= (site) (ahead (site) S)) (!= (site) (ahead (site) E)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) S) (ahead (site) E) (ahead (ahead (site) S) E)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P2) (sites {(site) (ahead (site) S) (ahead (site) E) (ahead (ahead (site) S) E)}))))) (add (piece (id "Ball" P2)) (to (ahead (site) USE) if:(is Flat))))) (if (and (and (is Occupied (site)) (is Empty (ahead (site) USW))) (and (!= (site) (ahead (site) S)) (!= (site) (ahead (site) W)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) S) (ahead (site) W) (ahead (ahead (site) S) W)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P2) (sites {(site) (ahead (site) S) (ahead (site) W) (ahead (ahead (site) S) W)}))))) (add (piece (id "Ball" P2)) (to (ahead (site) USW) if:(is Flat))))) (if (and (and (is Occupied (site)) (is Empty (ahead (site) UNE))) (and (!= (site) (ahead (site) N)) (!= (site) (ahead (site) W)))) (if (and (= 0 (count Sites in:(intersection (sites Empty) (sites {(site) (ahead (site) N) (ahead (site) W) (ahead (ahead (site) N) W)})))) (<= 3 (count Sites in:(intersection (sites Occupied by:P2) (sites {(site) (ahead (site) N) (ahead (site) W) (ahead (ahead (site) N) W)}))))) (add (piece (id "Ball" P2)) (to (ahead (site) UNE) if:(is Flat)))))}))))))) (end (if (<= 27 (count Sites in:(sites Occupied by:Mover))) (result Mover Win))))) 
The rules are identical to Go, except the winning condition is to be the first to capture a stone. The game is played on a 19x19 board.
(game "Atari Go" (players 2) (equipment {(board (square 19) use:Vertex) (piece "Marker" Each)}) (rules (play (do (move Add (to (sites Empty)) (then (enclose (from (last To)) Orthogonal (between if:(is Enemy (who at:(between))) (apply (and (trigger "CaptureMade" Next) (remove (between)))))))) ifAfterwards:(> (count Liberties Orthogonal) 0))) (end (if (is Triggered "CaptureMade" Next) (result Mover Win))))) 
Each player begins with two pieces on the four corners of the board, with each player's pieces in opposite corners. Players move one piece one or two spaces in any direction orthogonally or diagonally. If the piece is moved on space, another piece is added on the origin space. All of the opponent's pieces adjacent to the space to which the player moved now belong to the player who moved. Play ends when all spaces have been filled or one of the players has no remaining pieces. The player with the most pieces wins.
(game "Ataxx" (players 2) (equipment {(board (square 7)) (piece "Marker" Each (or (move (from) (to (sites Around (from)) if:(is Empty (to))) copy:True) (move (from) (to (difference (expand origin:(from) steps:2) (expand origin:(from))) if:(is Empty (to)))) (then (forEach Site (intersection (sites Around (last To)) (sites Occupied by:Next)) (and (remove (site)) (add (piece (id "Marker" Mover)) (to (site))))))))}) (rules (start {(set Score Each 2) (place "Marker1" {"A1" "G7"}) (place "Marker2" {"A7" "G1"})}) (play (forEach Piece (then (and (set Score P1 (count Sites in:(sites Occupied by:P1))) (set Score P2 (count Sites in:(sites Occupied by:P2))))))) (end (if (or (= (count Sites in:(sites Occupied by:Next)) 0) (is Full)) (byScore))))) 
Played on a square grid. The board begins empty. One player plays as Black, the other as White. Players alternate turns placing a piece of their colour on the board; Black plays first. Passing is not allowed. After a move, all opposing pieces without liberties are captured (a stone or group of stones has no liberties if all adjacent points to that stone are occupied). Stones cannot be placed to recreate a previous position. The game ends when one player captures a number of stones equal to a winning threshold agreed upon at the start of the game. Despite not having an explicit territorial goal, this variant produces final positions quite reminiscent of standard Go. The game is played on a 9x9 board 5 captures to win.
(game "BlooGo" (players 2) (equipment {(board (square 9) use:Vertex) (piece "Ball" Each)}) (rules (meta (no Repeat)) (play (move Add (to (sites Empty)) (then (forEach Site (sites Occupied by:Next) (if (= (count Liberties at:(site) Orthogonal) 0) (move Remove (site) (then (addScore Mover 1)))))))) (end {(if (>= (score Mover) 5) (result Mover Win))}))) 
Definitions: -- A 'bug' is an entire group of connected, same-color stones on the board. A single stone is also a bug. -- The 'size' of a bug is the number of stones it contains. -- The 'type' of a bug is its size and shape. Rotating or reflecting the shape of a bug does not affect its type. -- 'Growing' a bug is the creation of a new bug or the enlargement a single bug, using a single stone. (Merger is never allowed.) -- 'Eating' is the removal of an adjacent bug of the same type. Play: The board starts empty. Black begins the game by placing one black stone on any empty space. Then, starting with White, the players take turns. Each turn starts with a required growth, followed by eating and bonus growth in succession until no more bugs are available to eat. Bug mergers are never allowed. Note! A player who CANNOT move, WINS. Required growth: -- The moving player must place a stone to grow a bug. -- This first growth in a turn must not result in a bug that is larger than all the other bugs on the board. Successive cycles of eating and growth: If there are any bugs that can be eaten, a new Eat-and-Bonus-Growth cycle must be taken. Eating -- A bug is chosen to do the eating. -- It must be able to grow after eating. -- It must then eat every bug that it can. (i.e. all the bugs of the same type that are next to it) Bonus Growth -- The same bug that ate must grow. -- For this bonus growth there is no limit to the size of the bug that results. If there are still bugs that can be eaten on the board, the cycle repeats. If not, the next player's turn starts. Ending the game: If you CANNOT place a stone at the beginning of your turn, you have WON. That is: you win if you’ve filled the ecosystem with your bugs so much you can no longer expand. The winner receives a point for each position where the other player could still place a stone. The more experienced player's score must exceed any handicap agreed at the begining of the game. 3 Hexagon
(game "Bug" (players 2) (equipment {(board (hex Hexagon 3) use:Cell) (piece "Hex" Each maxValue:1023)}) (rules (play (if (not (is Prev Mover)) (if (> 1 (max (union (sizes Group Mover) (sizes Group Next)))) (move Add (to (sites Board))) (move Add (to (sites Empty) if:(and (= (+ 1 (count Sites in:(sites Group from:(sites Around (to) if:(is Mover (who at:(to))))))) (+ 1 (count Sites in:(sites Group at:(regionSite (sites Around (to) if:(is Mover (who at:(to)))) index:0))))) (<= (+ 1 (count Sites in:(sites Group from:(sites Around (to) if:(is Mover (who at:(to))))))) (max (union (sizes Group Mover) (sizes Group Next))))) (apply (set Var "Last2Grow" (mover)))) (then (and (forEach Site (sites Group at:(last To)) (set State at:(site) 0)) (priority (do (and (forget Value All) (set Var "LastRow" (row of:(max (array (sites Group at:(last To))))) (then (set Var "LastCol" (max (results from:(sites Group at:(last To)) to:(from) (column of:(from)))) (then (forEach Site (sites Group at:(last To)) (set Value at:(site) (+ (* 32 (- (var "LastRow") (row of:(site)))) (- (var "LastCol") (column of:(site))))))))))) next:(forEach Group if:(is Next (who at:(to))) (if (and (= (size Array (array (sites))) (size Array (array (sites Group at:(last To))))) (< 0 (size Array (array (intersection (sites) (sites Around (sites Group at:(last To)))))))) (priority {(if (= 0 (size Array (difference (results from:(sites Group at:(last To)) to:(from) (+ (+ (* 32 (/ (value Piece at:(from)) 32)) (% (value Piece at:(from)) 32)) (+ (max (results from:(sites Group at:(last To)) to:(from) (- (* 32 (/ (value Piece at:(from)) 32))))) (max (results from:(sites Group at:(last To)) to:(from) (- (% (value Piece at:(from)) 32))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (forEach Site (sites) (set State at:(site) 1))) (if (= 0 (size Array (difference (results from:(sites Group at:(last To)) to:(from) (+ (+ (* 32 (/ (value Piece at:(from)) 32)) (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(last To)) to:(from) (- (* 32 (/ (value Piece at:(from)) 32))))) (max (results from:(sites Group at:(last To)) to:(from) (- (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (forEach Site (sites) (set State at:(site) 1))) (if (= 0 (size Array (difference (results from:(sites Group at:(last To)) to:(from) (+ (+ (* 32 (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32))) (/ (value Piece at:(from)) 32)) (+ (max (results from:(sites Group at:(last To)) to:(from) (- (* 32 (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(last To)) to:(from) (- (/ (value Piece at:(from)) 32))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (forEach Site (sites) (set State at:(site) 1))) (if (= 0 (size Array (difference (results from:(sites Group at:(last To)) to:(from) (+ (+ (* 32 (% (value Piece at:(from)) 32)) (/ (value Piece at:(from)) 32)) (+ (max (results from:(sites Group at:(last To)) to:(from) (- (* 32 (% (value Piece at:(from)) 32))))) (max (results from:(sites Group at:(last To)) to:(from) (- (/ (value Piece at:(from)) 32))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (forEach Site (sites) (set State at:(site) 1))) (if (= 0 (size Array (difference (results from:(sites Group at:(last To)) to:(from) (+ (+ (* 32 (- (% (value Piece at:(from)) 32))) (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(last To)) to:(from) (- (* 32 (- (% (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(last To)) to:(from) (- (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (forEach Site (sites) (set State at:(site) 1))) (if (= 0 (size Array (difference (results from:(sites Group at:(last To)) to:(from) (+ (+ (* 32 (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32))) (% (value Piece at:(from)) 32)) (+ (max (results from:(sites Group at:(last To)) to:(from) (- (* 32 (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(last To)) to:(from) (- (% (value Piece at:(from)) 32))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (forEach Site (sites) (set State at:(site) 1))) (if (= 0 (size Array (difference (results from:(sites Group at:(last To)) to:(from) (+ (+ (* 32 (- (/ (value Piece at:(from)) 32))) (- (% (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(last To)) to:(from) (- (* 32 (- (/ (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(last To)) to:(from) (- (- (% (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (forEach Site (sites) (set State at:(site) 1))) (if (= 0 (size Array (difference (results from:(sites Group at:(last To)) to:(from) (+ (+ (* 32 (- (/ (value Piece at:(from)) 32))) (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(last To)) to:(from) (- (* 32 (- (/ (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(last To)) to:(from) (- (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (forEach Site (sites) (set State at:(site) 1))) (if (= 0 (size Array (difference (results from:(sites Group at:(last To)) to:(from) (+ (+ (* 32 (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32))) (- (/ (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(last To)) to:(from) (- (* 32 (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(last To)) to:(from) (- (- (/ (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (forEach Site (sites) (set State at:(site) 1))) (if (= 0 (size Array (difference (results from:(sites Group at:(last To)) to:(from) (+ (+ (* 32 (- (% (value Piece at:(from)) 32))) (- (/ (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(last To)) to:(from) (- (* 32 (- (% (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(last To)) to:(from) (- (- (/ (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (forEach Site (sites) (set State at:(site) 1))) (if (= 0 (size Array (difference (results from:(sites Group at:(last To)) to:(from) (+ (+ (* 32 (% (value Piece at:(from)) 32)) (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(last To)) to:(from) (- (* 32 (% (value Piece at:(from)) 32))))) (max (results from:(sites Group at:(last To)) to:(from) (- (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (forEach Site (sites) (set State at:(site) 1))) (if (= 0 (size Array (difference (results from:(sites Group at:(last To)) to:(from) (+ (+ (* 32 (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32))) (- (% (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(last To)) to:(from) (- (* 32 (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(last To)) to:(from) (- (- (% (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (forEach Site (sites) (set State at:(site) 1)))} (then (forEach Site (sites Group at:(last To)) (set State at:(site) 1) (then (moveAgain)))))))) (and (forget Value All) (set Var "LastRow" (row of:(max (array (sites Group at:(last To))))) (then (set Var "LastCol" (max (results from:(sites Group at:(last To)) to:(from) (column of:(from)))) (then (forEach Site (sites Group at:(last To)) (set Value at:(site) (+ (* 32 (- (var "LastRow") (row of:(site)))) (- (var "LastCol") (column of:(site)))))))))))))))) (if (= 0 (size Array (values Remembered))) (do (forEach Group if:(and (is Mover (who at:(to))) (= 1 (state at:(to)))) (move Select (from (max (array (sites)))) (then (forEach Group if:(is Next (who at:(to))) (if (and (= (size Array (array (sites))) (size Array (array (sites Group at:(last To))))) (< 0 (size Array (array (intersection (sites) (sites Around (sites Group at:(last To)))))))) (priority {(if (= 0 (size Array (difference (results from:(sites Group at:(last To)) to:(from) (+ (+ (* 32 (/ (value Piece at:(from)) 32)) (% (value Piece at:(from)) 32)) (+ (max (results from:(sites Group at:(last To)) to:(from) (- (* 32 (/ (value Piece at:(from)) 32))))) (max (results from:(sites Group at:(last To)) to:(from) (- (% (value Piece at:(from)) 32))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (forEach Value (array (sites)) (remember Value (value)))) (if (= 0 (size Array (difference (results from:(sites Group at:(last To)) to:(from) (+ (+ (* 32 (/ (value Piece at:(from)) 32)) (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(last To)) to:(from) (- (* 32 (/ (value Piece at:(from)) 32))))) (max (results from:(sites Group at:(last To)) to:(from) (- (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (forEach Value (array (sites)) (remember Value (value)))) (if (= 0 (size Array (difference (results from:(sites Group at:(last To)) to:(from) (+ (+ (* 32 (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32))) (/ (value Piece at:(from)) 32)) (+ (max (results from:(sites Group at:(last To)) to:(from) (- (* 32 (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(last To)) to:(from) (- (/ (value Piece at:(from)) 32))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (forEach Value (array (sites)) (remember Value (value)))) (if (= 0 (size Array (difference (results from:(sites Group at:(last To)) to:(from) (+ (+ (* 32 (% (value Piece at:(from)) 32)) (/ (value Piece at:(from)) 32)) (+ (max (results from:(sites Group at:(last To)) to:(from) (- (* 32 (% (value Piece at:(from)) 32))))) (max (results from:(sites Group at:(last To)) to:(from) (- (/ (value Piece at:(from)) 32))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (forEach Value (array (sites)) (remember Value (value)))) (if (= 0 (size Array (difference (results from:(sites Group at:(last To)) to:(from) (+ (+ (* 32 (- (% (value Piece at:(from)) 32))) (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(last To)) to:(from) (- (* 32 (- (% (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(last To)) to:(from) (- (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (forEach Value (array (sites)) (remember Value (value)))) (if (= 0 (size Array (difference (results from:(sites Group at:(last To)) to:(from) (+ (+ (* 32 (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32))) (% (value Piece at:(from)) 32)) (+ (max (results from:(sites Group at:(last To)) to:(from) (- (* 32 (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(last To)) to:(from) (- (% (value Piece at:(from)) 32))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (forEach Value (array (sites)) (remember Value (value)))) (if (= 0 (size Array (difference (results from:(sites Group at:(last To)) to:(from) (+ (+ (* 32 (- (/ (value Piece at:(from)) 32))) (- (% (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(last To)) to:(from) (- (* 32 (- (/ (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(last To)) to:(from) (- (- (% (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (forEach Value (array (sites)) (remember Value (value)))) (if (= 0 (size Array (difference (results from:(sites Group at:(last To)) to:(from) (+ (+ (* 32 (- (/ (value Piece at:(from)) 32))) (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(last To)) to:(from) (- (* 32 (- (/ (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(last To)) to:(from) (- (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (forEach Value (array (sites)) (remember Value (value)))) (if (= 0 (size Array (difference (results from:(sites Group at:(last To)) to:(from) (+ (+ (* 32 (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32))) (- (/ (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(last To)) to:(from) (- (* 32 (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(last To)) to:(from) (- (- (/ (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (forEach Value (array (sites)) (remember Value (value)))) (if (= 0 (size Array (difference (results from:(sites Group at:(last To)) to:(from) (+ (+ (* 32 (- (% (value Piece at:(from)) 32))) (- (/ (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(last To)) to:(from) (- (* 32 (- (% (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(last To)) to:(from) (- (- (/ (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (forEach Value (array (sites)) (remember Value (value)))) (if (= 0 (size Array (difference (results from:(sites Group at:(last To)) to:(from) (+ (+ (* 32 (% (value Piece at:(from)) 32)) (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(last To)) to:(from) (- (* 32 (% (value Piece at:(from)) 32))))) (max (results from:(sites Group at:(last To)) to:(from) (- (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (forEach Value (array (sites)) (remember Value (value)))) (if (= 0 (size Array (difference (results from:(sites Group at:(last To)) to:(from) (+ (+ (* 32 (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32))) (- (% (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(last To)) to:(from) (- (* 32 (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(last To)) to:(from) (- (- (% (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (forEach Value (array (sites)) (remember Value (value))))} (then (and {(remove (sites (values Remembered))) (forEach Site (sites Group at:(last To)) (set State at:(site) 0)) (moveAgain)})))))))) ifAfterwards:(< 0 (count Sites in:(difference (intersection (sites Empty) (sites Around (sites Group at:(last To)))) (sites Around (difference (sites Occupied by:Mover) (sites Group at:(last To)))))))) (move Add (to (sites Empty) if:(and (is In (to) (sites Around (sites Group at:(last From)))) (= (+ 1 (count Sites in:(sites Group from:(sites Around (to) if:(is Mover (who at:(to))))))) (+ 1 (count Sites in:(sites Group at:(regionSite (sites Around (to) if:(is Mover (who at:(to)))) index:0))))))) (then (and (forEach Site (sites Group at:(last To)) (set State at:(site) 0)) (priority (do (and (forget Value All) (set Var "LastRow" (row of:(max (array (sites Group at:(last To))))) (then (set Var "LastCol" (max (results from:(sites Group at:(last To)) to:(from) (column of:(from)))) (then (forEach Site (sites Group at:(last To)) (set Value at:(site) (+ (* 32 (- (var "LastRow") (row of:(site)))) (- (var "LastCol") (column of:(site))))))))))) next:(forEach Group if:(is Next (who at:(to))) (if (and (= (size Array (array (sites))) (size Array (array (sites Group at:(last To))))) (< 0 (size Array (array (intersection (sites) (sites Around (sites Group at:(last To)))))))) (priority {(if (= 0 (size Array (difference (results from:(sites Group at:(last To)) to:(from) (+ (+ (* 32 (/ (value Piece at:(from)) 32)) (% (value Piece at:(from)) 32)) (+ (max (results from:(sites Group at:(last To)) to:(from) (- (* 32 (/ (value Piece at:(from)) 32))))) (max (results from:(sites Group at:(last To)) to:(from) (- (% (value Piece at:(from)) 32))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (forEach Site (sites) (set State at:(site) 1))) (if (= 0 (size Array (difference (results from:(sites Group at:(last To)) to:(from) (+ (+ (* 32 (/ (value Piece at:(from)) 32)) (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(last To)) to:(from) (- (* 32 (/ (value Piece at:(from)) 32))))) (max (results from:(sites Group at:(last To)) to:(from) (- (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (forEach Site (sites) (set State at:(site) 1))) (if (= 0 (size Array (difference (results from:(sites Group at:(last To)) to:(from) (+ (+ (* 32 (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32))) (/ (value Piece at:(from)) 32)) (+ (max (results from:(sites Group at:(last To)) to:(from) (- (* 32 (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(last To)) to:(from) (- (/ (value Piece at:(from)) 32))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (forEach Site (sites) (set State at:(site) 1))) (if (= 0 (size Array (difference (results from:(sites Group at:(last To)) to:(from) (+ (+ (* 32 (% (value Piece at:(from)) 32)) (/ (value Piece at:(from)) 32)) (+ (max (results from:(sites Group at:(last To)) to:(from) (- (* 32 (% (value Piece at:(from)) 32))))) (max (results from:(sites Group at:(last To)) to:(from) (- (/ (value Piece at:(from)) 32))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (forEach Site (sites) (set State at:(site) 1))) (if (= 0 (size Array (difference (results from:(sites Group at:(last To)) to:(from) (+ (+ (* 32 (- (% (value Piece at:(from)) 32))) (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(last To)) to:(from) (- (* 32 (- (% (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(last To)) to:(from) (- (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (forEach Site (sites) (set State at:(site) 1))) (if (= 0 (size Array (difference (results from:(sites Group at:(last To)) to:(from) (+ (+ (* 32 (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32))) (% (value Piece at:(from)) 32)) (+ (max (results from:(sites Group at:(last To)) to:(from) (- (* 32 (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(last To)) to:(from) (- (% (value Piece at:(from)) 32))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (forEach Site (sites) (set State at:(site) 1))) (if (= 0 (size Array (difference (results from:(sites Group at:(last To)) to:(from) (+ (+ (* 32 (- (/ (value Piece at:(from)) 32))) (- (% (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(last To)) to:(from) (- (* 32 (- (/ (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(last To)) to:(from) (- (- (% (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (forEach Site (sites) (set State at:(site) 1))) (if (= 0 (size Array (difference (results from:(sites Group at:(last To)) to:(from) (+ (+ (* 32 (- (/ (value Piece at:(from)) 32))) (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(last To)) to:(from) (- (* 32 (- (/ (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(last To)) to:(from) (- (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (forEach Site (sites) (set State at:(site) 1))) (if (= 0 (size Array (difference (results from:(sites Group at:(last To)) to:(from) (+ (+ (* 32 (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32))) (- (/ (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(last To)) to:(from) (- (* 32 (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(last To)) to:(from) (- (- (/ (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (forEach Site (sites) (set State at:(site) 1))) (if (= 0 (size Array (difference (results from:(sites Group at:(last To)) to:(from) (+ (+ (* 32 (- (% (value Piece at:(from)) 32))) (- (/ (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(last To)) to:(from) (- (* 32 (- (% (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(last To)) to:(from) (- (- (/ (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (forEach Site (sites) (set State at:(site) 1))) (if (= 0 (size Array (difference (results from:(sites Group at:(last To)) to:(from) (+ (+ (* 32 (% (value Piece at:(from)) 32)) (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(last To)) to:(from) (- (* 32 (% (value Piece at:(from)) 32))))) (max (results from:(sites Group at:(last To)) to:(from) (- (- (% (value Piece at:(from)) 32) (/ (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (forEach Site (sites) (set State at:(site) 1))) (if (= 0 (size Array (difference (results from:(sites Group at:(last To)) to:(from) (+ (+ (* 32 (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32))) (- (% (value Piece at:(from)) 32))) (+ (max (results from:(sites Group at:(last To)) to:(from) (- (* 32 (- (/ (value Piece at:(from)) 32) (% (value Piece at:(from)) 32)))))) (max (results from:(sites Group at:(last To)) to:(from) (- (- (% (value Piece at:(from)) 32)))))))) (results from:(sites) to:(from) (value Piece at:(from)))))) (forEach Site (sites) (set State at:(site) 1)))} (then (forEach Site (sites Group at:(last To)) (set State at:(site) 1) (then (moveAgain)))))))) (and (forget Value All) (set Var "LastRow" (row of:(max (array (sites Group at:(last To))))) (then (set Var "LastCol" (max (results from:(sites Group at:(last To)) to:(from) (column of:(from)))) (then (forEach Site (sites Group at:(last To)) (set Value at:(site) (+ (* 32 (- (var "LastRow") (row of:(site)))) (- (var "LastCol") (column of:(site)))))))))))))))) (then (and (set Score Mover 0) (set Score Next (count Sites in:(sites To (move Add (to (sites Empty) if:(and (= (+ 1 (count Sites in:(sites Group from:(sites Around (to) if:(is Mover (who at:(to))))))) (+ 1 (count Sites in:(sites Group at:(regionSite (sites Around (to) if:(is Mover (who at:(to)))) index:0))))) (<= (+ 1 (count Sites in:(sites Group from:(sites Around (to) if:(is Mover (who at:(to))))))) (max (union (sizes Group Mover) (sizes Group Next)))))))))))))) (end (if (and (no Moves Mover) (not (is Prev Mover))) (if (= (var "Last2Grow") (mover)) (result Mover Loss)) (result Mover Win))))) 
Like Go, Cavity is played on the points of a square grid, and groups (chains, more precisely) and liberties are defined the same way. An empty region is a group (chain) of empty points, and it is said to be adjacent to a stone if any of its points are. Setup: Starting with Black, place one stone each on any empty point. The setup is over as soon as the players have one stone each on the board. Play: On your turn, place a stone of your color on any point in an empty region that's adjacent to a stone of your color. After placement, first remove all enemy groups that have no liberties, then remove all friendly groups that have no liberties. In this phase, as soon as one player is the only one with stones on the board, the game is over and that player is the winner. The game is balanced with the pie rule. The game is played on an 11x11 board
(game "Cavity" (players 2) (equipment {(board (square 11) use:Vertex) (piece "Marker" Each)}) (rules (meta (swap)) phases:{(phase "Opening" (play (move Add (to (sites Empty)))) (nextPhase (and (= 1 (count Sites in:(sites Occupied by:P1))) (= 1 (count Sites in:(sites Occupied by:P2)))) "Play")) (phase "Play" (play (move Add (to (sites Empty) if:(> Infinity (count Steps Orthogonal (step (to if:(or (is Empty (to)) (is In (to) (sites Occupied by:Mover))))) (to) (sites Occupied by:Mover)))) (then (if (can Move (enclose (from (last To)) Orthogonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))))) (enclose (from (last To)) Orthogonal (between if:(is Enemy (who at:(between))) (apply (remove (between))))) (enclose (from (last To)) Orthogonal (between if:(is Mover (who at:(between))) (apply (remove (between))))))))))} (end (forEach Player if:(and (< 2 (count Moves)) (no Pieces Player)) (result Player Loss))))) 
17x17 intersecting lines, with alternating black and white points, four equally spaced along the third and fifteenth rank and two along the seventh and eleventh rows, forming a large square. Each player has two kinds of piece, six bull-shaped pieces and 144 round pieces. To begin, players place their bull-shaped pieces on the opposite-color marked points on the board. Then, players alternate turns placing one of their pieces in an adjacent space next to one of their bull pieces. Once all of the bull pieces have been surrounded, the main phase of play begins. Players alternate turns placing one of their pieces on the board. The player who encloses the greatest number of empty spaces wins.
(game "Dorvolz" (players 2) (equipment {(board (square 17) use:Vertex) (hand Each size:2) (piece "Bull" Each) (piece "Marker" Each) (regions "BullSites" P1 (sites {"C3" "K3" "O7" "C11" "G15" "O15"})) (regions "BullSites" P2 (sites {"G3" "O3" "C7" "O11" "C15" "K15"}))}) (rules (start {(place "Bull1" (handSite P1) count:6) (place "Bull2" (handSite P2) count:6) (place "Marker1" (handSite P1 1) count:144) (place "Marker2" (handSite P2 1) count:144)}) phases:{(phase "BullPlacement" (play (move (from (handSite Mover)) (to (intersection (sites Empty) (sites Mover))))) (nextPhase Mover (= 6 (count Sites in:(intersection (sites Board) (sites Occupied by:Mover)))) "MarkerPlacementAroundBull")) (phase "MarkerPlacementAroundBull" (play (move (from (handSite Mover 1)) (to (intersection (sites Empty) (sites Around (sites Mover) All))))) (nextPhase Mover (= 54 (count Sites in:(intersection (sites Board) (sites Occupied by:Mover)))) "Playing")) (phase "Playing" (play (move (from (handSite Mover 1)) (to (sites Empty)))) (end (if (and (all Sites (sites Hand P1) if:(= 0 (count Cell at:(site)))) (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site))))) (byScore {(score P1 (size Territory P1 All)) (score P2 (size Territory P2 All))}))))})) 
Flower Shop is played on a hexhex board and uses the 12* placement protocol, that is: barring the first player's first placement, which must be a single piece, players make two placements in a turn. There are two types of pieces: impartial *stalks* (green) and partial *flowers* (pink and yellow). A maximal set of connected stalks is called a *plant*. Rules There are two placement restrictions: 1. Each flower may be adjacent to no more than one stalk and no other flowers. 2. Each plant can only be adjacent to at most one colour of flowers. The game ends when no legal placements can be made. The *worth* of each plant is the number of stalks in it times the number of flowers adjacent to it. The *score* of each player is the total worth of all the plants adjacent to his flowers. Highest score wins. In case of equal scores, no player wins. (Description taken - but slighlty adapted - from mindsports.nl.)
(game "Flower Shop" (players 2) (equipment {(board (hex 7)) (tile "Hex" Each) (piece "Disc" Neutral)}) (rules (play (do (or (move Add (piece (mover)) (to (sites Empty) if:(= 0 (count Sites in:(intersection (sites Occupied by:All component:"Hex") (sites Around (to) Orthogonal)))))) (move Add (piece "Disc0") (to (sites Empty)))) ifAfterwards:(and (all Sites (sites Occupied by:All component:"Hex") if:(> 2 (count Sites in:(intersection (sites Around (site) Orthogonal) (sites Occupied by:Neutral))))) (all Sites (sites Occupied by:Neutral) if:(not (and (< 0 (count Sites in:(sites Around (sites Group at:(site)) Own Orthogonal))) (< 0 (count Sites in:(sites Around (sites Group at:(site)) Enemy Orthogonal))))))) (then (if (= 1 (% (+ 1 (count Moves)) 2)) (moveAgain))))) (end (if (all Passed) (byScore {(score P1 (+ (results from:(intersection (sites Occupied by:P1) (sites Around (sites Occupied by:Neutral) Orthogonal)) to:1 (* (to) (size Group at:(+ (results from:(intersection (sites Around (from) Orthogonal) (sites Occupied by:Neutral)) to:1 (* (from) (to)))) Orthogonal if:(= (id "Disc0") (what at:(to)))))))) (score P2 (+ (results from:(intersection (sites Occupied by:P2) (sites Around (sites Occupied by:Neutral) Orthogonal)) to:1 (* (to) (size Group at:(+ (results from:(intersection (sites Around (from) Orthogonal) (sites Occupied by:Neutral)) to:1 (* (from) (to)))) Orthogonal if:(= (id "Disc0") (what at:(to))))))))}))))) 
Players take turns placing stones of their color on empty squares. If you place orthogonally adjacent to more than 2 stones, regardless of their color, you must place again. You continue until you place orthogonally adjacent to 2 or fewer stones. When the board is full, the player with the most stones on the board is the winner. A 7x7 playing area is currently selected
(game "Flume" (players 2) (equipment {(board (square 9)) (piece "Disc" Each) (piece "Disc" Neutral)}) (rules (meta (swap)) (start (place "Disc0" (sites Outer))) (play (move Add (to (sites Empty)) (then (and (addScore Mover 1) (if (< 2 (count Sites in:(sites Around (last To) NotEmpty Orthogonal))) (moveAgain)))))) (end (if (is Full) (byScore))))) 
Played on a 19x19 board. The board begins empty. One player plays as black, the other as white. The black player begins by placing a piece on one of the intersections on the board. Players alternate turns placing a piece on the board. A player may pass at any time. A piece or a group of pieces are captured when they are completely surrounded on all sides on adjacent intersections by the opposing player. Stones cannot be placed to recreate a previous position. The game ends when both players pass consecutively. Players total the number of intersections their pieces occupy or surround. The player with the highest total wins.  The game is played on a 19x19 board
(game "Go" (players 2) (equipment {(board (square 19) use:Vertex) (piece "Marker" Each)}) (rules (meta (no Repeat)) (play (or (do (move Add (to (sites Empty)) (then (enclose (from (last To)) Orthogonal (between if:(is Enemy (who at:(between))) (apply (and (addScore Mover 1) (remove (between)))))))) ifAfterwards:(> (count Liberties Orthogonal) 0)) (move Pass))) (end (if (all Passed) (byScore {(score P1 (+ (score P1) (size Territory P1))) (score P2 (+ (score P2) (size Territory P2)))}))))) 
--- Goal: Have the warmest goats at end. The warmth of you goats is the total number of contacts they have with other goats. To find the winner, it is only necessary to count goat-to-goat contacts between their own kind. The game start on an empty board. Play alternates. On a turn either: 1. Pass (sometimes this is forced); or 2. Place a goat on an empty cell that is not too close to another goat of its color: -- If they are in line, they need gap of 2 or 3 spaces (as selected in Options.) 3. Move one of your goats one step with the following condition: -- the goat must gain more contacts with adjacent goats of its own kind than before; or 4. Use the following alternate condition to step-move a goat that cannot move using the previous rule: -- the step must reduce your goat's net contact with enemy goats. Exception: Moves using rule 4. are not allowed immediately after the previous player has passed. Capture -- After moving, simultaneously remove all individual enemy goats that have no adjacent space empty. -- Capturing does not happen on a passing turn: to capture one must play a piece. Ending the game -- The game ends with 2 passes. Then the number of connections are compared. -- In the case of a tie, the last to pass loses. Variants not implemented: No capture. / Score simple goat count. Edge 3,4 Hex board Placements must leave a gap of 3 spaces if in sight of a friendly piece Goat graphics - Custom if mountainGoat-alt3.svg is in Ludii directory
(game "Goats Wintering" (players 2) (equipment {(board (hex Limping 3) use:Cell) (piece "Disc" P1) (piece "Disc" P2)}) (rules (start (set Score Each 0)) (play (or {(move Pass) (move Add (to (sites Empty) if:(not (is Within (id "Disc" Mover) in:(intersection (sites LineOfSight Piece at:(to)) (sites Direction from:(to) distance:3))))) (then (do (forEach Site (sites Board) (apply if:(and (is Next (who at:(site))) (= 0 (count Sites in:(intersection (sites Empty) (sites Around (site) includeSelf:True))))) (remove (site)))) next:(and (set Score Mover (/ (+ (results from:(sites Occupied by:Mover) to:(sites Around (from) if:(is Mover (who at:(to)))) 1)) 2)) (set Score Next (/ (+ (results from:(sites Occupied by:Next) to:(sites Around (from) if:(is Next (who at:(to)))) 1)) 2)))))) (forEach Piece (or (move Step (to if:(and (is Empty (to)) (< (count Pieces Mover in:(sites Around (from))) (- (count Pieces Mover in:(sites Around (to))) 1)))) (then (do (forEach Site (sites Board) (apply if:(and (is Next (who at:(site))) (= 0 (count Sites in:(intersection (sites Empty) (sites Around (site) includeSelf:True))))) (remove (site)))) next:(and (set Score Mover (/ (+ (results from:(sites Occupied by:Mover) to:(sites Around (from) if:(is Mover (who at:(to)))) 1)) 2)) (set Score Next (/ (+ (results from:(sites Occupied by:Next) to:(sites Around (from) if:(is Next (who at:(to)))) 1)) 2)))))) (if (and (not (was Pass)) (not (can Move (move Step (to if:(and (is Empty (to)) (< (count Pieces Mover in:(sites Around (from))) (- (count Pieces Mover in:(sites Around (to))) 1)))) (then (do (forEach Site (sites Board) (apply if:(and (is Next (who at:(site))) (= 0 (count Sites in:(intersection (sites Empty) (sites Around (site) includeSelf:True))))) (remove (site)))) next:(and (set Score Mover (/ (+ (results from:(sites Occupied by:Mover) to:(sites Around (from) if:(is Mover (who at:(to)))) 1)) 2)) (set Score Next (/ (+ (results from:(sites Occupied by:Next) to:(sites Around (from) if:(is Next (who at:(to)))) 1)) 2))))))))) (move Step (to if:(and (is Empty (to)) (> (count Pieces Next in:(sites Around (from))) (count Pieces Next in:(sites Around (to)))))) (then (do (forEach Site (sites Board) (apply if:(and (is Next (who at:(site))) (= 0 (count Sites in:(intersection (sites Empty) (sites Around (site) includeSelf:True))))) (remove (site)))) next:(and (set Score Mover (/ (+ (results from:(sites Occupied by:Mover) to:(sites Around (from) if:(is Mover (who at:(to)))) 1)) 2)) (set Score Next (/ (+ (results from:(sites Occupied by:Next) to:(sites Around (from) if:(is Next (who at:(to)))) 1)) 2)))))))))})) (end {(if (and (all Passed) (> (score Mover) (score Next))) (result Mover Win)) (if (and (all Passed) (<= (score Mover) (score Next))) (result Next Win))}))) 
The board begins empty. One player plays as black, the other as white. The black player begins by placing a piece on one of the intersections on the board. Players alternate turns placing a piece on the board. A player may pass at any time. A piece or a group of pieces are captured when they are completely surrounded on all sides on adjacent intersections by the opposing player. Stones cannot be placed to recreate a previous position. The game ends when both players pass consecutively. Players total the number of intersections their pieces occupy or surround. The player with the highest total wins. For more info on this version please google Hexagonal Go. Hex Grid - Standard Order 6 board
(game "HexGo" (players 2) (equipment {(board (tri Hexagon 6) use:Vertex) (piece "Ball" P1) (piece "Ball" P2)}) (rules (meta (no Repeat)) (play (or (do (move Add (to (sites Empty)) (then (enclose (from (last To)) Orthogonal (between if:(is Enemy (who at:(between))) (apply (and (addScore Mover 1) (remove (between)))))))) ifAfterwards:(> (count Liberties Orthogonal) 0)) (move Pass))) (end (if (all Passed) (byScore {(score P1 (+ (score P1) (size Territory P1))) (score P2 (+ (score P2) (size Territory P2)))}))))) 
Play on a hexagonal grid composed of hexagons. Use a neutral pawn and black/white checkers. Players take turns moving a neutral pawn around on the board (passing is not allowed). The neutral pawn can move any number of empty points, in any direction in a straight line, but cannot move onto, or jump over occupied points. When a player moves the pawn, first they place a checker of their own color, onto the destination point. Then they move the pawn on top of it. When the pawn is trapped, the game is over. At the end of the game, each player gets a point for each checker of their own color adjacent to the pawn; if the number of adjacent checkers is equal, the checker under the trapped pawn breaks the tie. The person with the highest score wins. Played on a Hexagonal Board. Played on a size 7 board.
(game "HexTrike" (players 2) (equipment {(board (hex Hexagon 7)) (piece "Ball" Each)}) (rules (meta (swap)) phases:{(phase "Opening" P1 (play (move Add (to (sites Empty)) (then (set Var (last To))))) (nextPhase)) (phase "Play" (play (move Add (to (sites LineOfSight Empty at:(var))) (then (set Var (last To))))))} (end {(if (no Moves Next) {(if (> (count Sites in:(intersection (sites Around (last To)) (sites Occupied by:P1))) (count Sites in:(intersection (sites Around (last To)) (sites Occupied by:P2)))) (result P1 Win)) (if (> (count Sites in:(intersection (sites Around (last To)) (sites Occupied by:P2))) (count Sites in:(intersection (sites Around (last To)) (sites Occupied by:P1)))) (result P2 Win)) (if (and (= (count Sites in:(intersection (sites Around (last To)) (sites Occupied by:P1))) (count Sites in:(intersection (sites Around (last To)) (sites Occupied by:P2)))) (is Mover P1)) (result P1 Win)) (if (and (= (count Sites in:(intersection (sites Around (last To)) (sites Occupied by:P1))) (count Sites in:(intersection (sites Around (last To)) (sites Occupied by:P2)))) (is Mover P2)) (result P2 Win))})}))) 
Start on an empty board. On a turn either enter a piece not in line of sight of your own pieces, or move a piece a number of independant single steps not to exceed the count of that piece's enemy neighbors. If one player passes, to avoid ending the game with a 2nd pass, the opponent must place a piece if possible, or if unable to place, he may move in a way that enables his future placement. Otherwise, he must pass and the game ends. The winner is the player with the most pieces in play. If equal, the last to pass loses. Order 5 board Hex N / N+1 Grid
(game "Infuse" (players 2) (equipment {(board (hex Limping 5) use:Cell) (piece "Disc" Each)}) (rules (start (set Score Each 0)) (play (if (was Pass) (or (move Pass) (priority (move Add (to (sites Empty) if:(not (is Within (id "Disc" Mover) in:(sites LineOfSight Piece at:(to))))) (then (addScore Mover 1))) (forEach Piece (do (or {(if (<= 1 (count Pieces Next in:(sites Around (from)))) (move (from (from)) (to (intersection (sites Empty) (sites Around (from)))))) (if (<= 2 (count Pieces Next in:(sites Around (from)))) (move (from (from)) (to (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (from)))))))) (if (<= 3 (count Pieces Next in:(sites Around (from)))) (move (from (from)) (to (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (from)))))))))) (if (<= 4 (count Pieces Next in:(sites Around (from)))) (move (from (from)) (to (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (from)))))))))))) (if (<= 5 (count Pieces Next in:(sites Around (from)))) (move (from (from)) (to (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (from))))))))))))))}) ifAfterwards:(can Move (add (to (sites Empty) if:(not (is Within (id "Disc" Mover) in:(sites LineOfSight Piece at:(to))))))))))) (or {(move Add (to (sites Empty) if:(not (is Within (id "Disc" Mover) in:(sites LineOfSight Piece at:(to))))) (then (addScore Mover 1))) (forEach Piece (or {(if (<= 1 (count Pieces Next in:(sites Around (from)))) (move (from (from)) (to (intersection (sites Empty) (sites Around (from)))))) (if (<= 2 (count Pieces Next in:(sites Around (from)))) (move (from (from)) (to (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (from)))))))) (if (<= 3 (count Pieces Next in:(sites Around (from)))) (move (from (from)) (to (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (from)))))))))) (if (<= 4 (count Pieces Next in:(sites Around (from)))) (move (from (from)) (to (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (from)))))))))))) (if (<= 5 (count Pieces Next in:(sites Around (from)))) (move (from (from)) (to (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (intersection (sites Empty) (sites Around (from))))))))))))))})) (move Pass)}))) (end {(if (and (all Passed) (> (score Mover) (score Next))) (result Mover Win)) (if (and (all Passed) (<= (score Mover) (score Next))) (result Next Win))}))) 
Play on an equilateral hexagonal triangle-tessellated grid. The board is seeded randomly with a black stone, a white stone, and a neutral stone. Players take turn seeding new groups. Every placement triggers growth of all enemy groups, where growth is defined as adding a stone to all empty cells adjacent to a group. When the board fills up, the person who has more pieces on the board wins. Played on a size 7 board.
(game "Inkblots" (players 2) (equipment {(board (tri Hexagon 7)) (tile "Triangle" Each) (tile "Triangle" Neutral)}) (rules (meta (swap)) (start (place Random {"Triangle1" "Triangle2" "Triangle0"})) (play (move Add (to (sites Empty)) (then (add (piece (id "Triangle" Next)) (to (intersection (expand (sites Occupied by:Next) Orthogonal) (sites Empty))))))) (end (if (no Moves Next) (byScore {(score P1 (count Pieces P1)) (score P2 (count Pieces P2))}))))) 
Lava is a territorial stacking game for two players, Red and Black. Play using a Hexhex board size 4 or 5, and a sufficient supply of Red/Black stacking checkers. To setup, place one Red and one Black checker in opposite corners of the hex hex board. Definitions: Stack: One or more checkers occupying the same cell. Control: You control a stack if your color is on top of it. Players take turns, with Black moving first. Each turn, take N checkers (where N is any number from 1 to stack size) from the top of a stack you control and move them N spaces in a straight line to a destination containing N or less checkers. Then, add a new checker of your color to the destination. Stacks may not jump over enemies, but may land on enemy or friendly stacks, thereby burying them. If you at any point cannot make a move, you must pass. This does not end the game, only your turn. When the board is full, the player controlling more stacks wins the game. A size 4 board is currently selected The number of pieces in a stack is currently not shown on the top piece.
(game "Lava" (players 2) (equipment {(board (rotate 30 (hex 4))) (piece "Disc" Each)}) (rules (start {(place "Disc1" (min (array (sites Board)))) (place "Disc2" (max (array (sites Board))))}) (play (move Select (from (sites Occupied by:Mover top:True)) (to (sites Direction from:(from) Orthogonal stop:(= (next) (who at:(to))) stopIncluded:True distance:(size Stack at:(from))) if:(>= (count Steps (from) (to)) (size Stack at:(to)))) (then (and (fromTo (from (last From)) (to (last To)) count:(count Steps (last From) (last To)) stack:True) (add (to (last To)) stack:True))))) (end (if (is Full) (byScore {(score P1 (count Sites in:(sites Occupied by:P1 top:True))) (score P2 (count Sites in:(sites Occupied by:P2 top:True)))}))))) 
Lifeline is a territorial strategy game for two players (Black and White) that is played on the cells of an initially empty hexhex board. The recommended board sizes are between 3 and 12 cells per side. Definitions: A group is an entire set of connected stones of the same color. A single stone, not connected to others of its color, is also a group. A group is dead if there is no path of connected empty cells between that group and any other of its color. Play: On your turn, perform the following actions in the stated order: 1. Place a stone of your color on an empty cell. If it is your first turn of the game, perform this action twice. 2. Remove all dead enemy groups. 3. Remove all dead friendly groups. The board positions at the start and at the end of your turn must be different. The last player to make a placement wins. Note that, after your first turn, you will always have a placement available unless you have no groups on the board. To make the game fair, White will have the option, on their first turn only, to swap sides with Black instead of making a regular move. Note that, in this implementation, the two stones you place on your first turn are only visible after both cells to place on have been selected. Alternative balancing methods: The balancing method described above is what is called 'strong pie' in the options. This implementation also offers two other methods, for players who would like to explore alternatives. Weak pie: Just like with strong pie, White will have the option, on their first turn only, to swap sides with Black instead of making a regular move. But instead of placing twice on their first move, players alternate placing one piece each (with no removals) until 4 setup stones are placed. Consequently, White's choice will be made after Black has placed only one stone. Komi pie: The first player chooses a whole number of komi (between 1 and 12) and the second player chooses whether to play as White (pass) or as Black (place a stone). The first 4 stones are placed in the same order as with weak pie (Black, White, Black, White). Throughout the game proper, White will have the option to spend a point of komi instead of making a placement. A point of komi is spent by clicking the shield icon next to White's name. The strong pie rule is currently in force. A board of size 7 is currently selected.
(game "Lifeline" (players 2) (equipment {(board (dual (tri Hexagon 7))) (piece "Disc" Each) (piece "Shi_Western" P2) (hand P2)}) (rules (meta (swap)) phases:{(phase "Opening" (play (move Select (from (sites Empty)) (to (sites Empty) if:(not (is In (from) (sites Around (to) includeSelf:True)))) (then (and (add (to (last To))) (add (to (last From))))))) (nextPhase (and (= 2 (count Sites in:(sites Occupied by:P1 component:"Disc"))) (= 2 (count Sites in:(sites Occupied by:P2 component:"Disc")))) "Play")) (phase "Play" (play (or (if (and {(< 0 (size Stack at:(handSite P2))) (= (mover) (id P2)) (< 0 (count Pieces Mover in:(sites Board)))}) (move Remove (handSite P2))) (move Add (to (sites Empty) if:(and (not (no Pieces Mover in:(sites Board))) (> Infinity (count Steps Orthogonal (step (to if:(or (is Empty (to)) (is Mover (who at:(to)))))) (to) (sites Occupied by:Mover))))) (then (forEach Group Orthogonal if:(is Enemy (who at:(to))) (if (not (and (< 0 (count Sites in:(difference (sites Occupied by:Enemy component:"Disc") (sites)))) (not (all Sites (sites) if:(not (> Infinity (count Steps Orthogonal (step (to if:(or (is Empty (to)) (is Enemy (who at:(to)))))) (site) (difference (sites Occupied by:Enemy) (sites))))))))) (remove (sites)) (pass)) (then (forEach Group Orthogonal if:(is Mover (who at:(to))) (if (not (and (< 0 (count Sites in:(difference (sites Occupied by:Mover component:"Disc") (sites)))) (not (all Sites (sites) if:(not (> Infinity (count Steps Orthogonal (step (to if:(or (is Empty (to)) (is Mover (who at:(to)))))) (site) (difference (sites Occupied by:Mover) (sites))))))))) (remove (sites)) (pass))))))))))} (end (if (and (no Moves Next) (< 2 (count Moves))) (result Next Loss))))) 
The game is played on the board of Kensington. It follows the rules of Go except when a capture is made, the pieces captured are flipped.
(game "Lotus" (players 2) (equipment {(board (rotate 90 (tiling T3464 2)) use:Vertex) (piece "Marker" Each)}) (rules (play (or (do (move Add (to (sites Empty)) (then (enclose (from (last To)) Orthogonal (between if:(is Enemy (who at:(between))) (apply (and (remove (between)) (add (to (between))))))))) ifAfterwards:(> (count Liberties) 0)) (move Pass (then (addScore Mover 1))))) (end (if (all Passed) (byScore {(score P1 (+ {(score P1) (size Territory P1) (count Sites in:(sites Occupied by:P1))})) (score P2 (+ {(score P2) (size Territory P2) (count Sites in:(sites Occupied by:P2))}))}))))) 
Reversi is played on a hexhex-6 board with some cells removed. Pieces are double-sided, with each side distinct in some way from the other. Each side designates ownership of that pieces to a certain player when face-up. In Reversi Mode, play begins with the players taking turns placing pieces into the central six hexagons until they are full; in Othello mode, the central six hexagons are pre-filled with alternating Black and White discs. Then players may place their pieces next to an opponent's piece, as long as a straight line can be drawn between the new piece and an existing piece belonging to that player that goes through the opponent's piece. The opponent's pieces between the new piece and the old piece are then flipped and now belong to the player who just played. If a player cannot make a legal move, they pass. Play continues until the board is full or neither player can make a legal move. The player with the most pieces on the board wins. The pieces are placed on the board.
(game "MacBeth" (players 2) (equipment {(board (remove (hex 6) cells:{7 9 11 22 24 26 28 41 43 45 47 49 62 64 66 68 79 81 83})) (piece "Disc" Neutral (flips 1 2))}) (rules phases:{(phase "Placement" (play (move Add (piece "Disc0" state:(mover)) (to (intersection (sites Empty) (sites Centre))))) (nextPhase Mover (>= (count Moves) 5) "Playing")) (phase "Playing" (play (forEach Site (sites Empty) (append (custodial (from (site)) (between if:(is Enemy (state at:(between))) (apply (allCombinations (add (piece "Disc0" state:(mover)) (to (site))) (flip (between))))) (to if:(is Friend (state at:(to))))) (then (and (set Score P1 (count Sites in:(sites State 1))) (set Score P2 (count Sites in:(sites State 2)))))))))} (end (if (all Passed) (byScore))))) 
17x17 intersecting lines. 151 pieces per player. Each player begins with six larger pieces on the board, on the third line from the perimeter on all four sides, one piece on every fourth intersection, alternating between black and white. These pieces are never moved from the board. There is a star marking at each of these points. Players alternate turns placing one of their pieces on an empty intersection of the board. When a player encloses an area with their pieces, it becomes their territory, and any pieces of the opponent inside it are captured. The opponent cannot place one of their pieces inside a territory won on the previous turn. White plays first. When players can no longer play, the number of counters and each territory are counted to determine the winner.
(game "Mig Mang" (players 2) (equipment {(board (square 17) use:Vertex) (piece "Ball" Each)}) (rules (start {(place "Ball1" (sites {"C7" "K15" "C15" "G3" "O11" "O3"}) state:1) (place "Ball2" (sites {"C3" "K3" "C11" "G15" "O15" "O7"}) state:1)}) (play (move Add (to (sites Empty) if:(= (state at:(to)) 0)) (then (and (forEach Site (sites Empty) (if (!= 0 (state at:(site))) (set State at:(site) 0))) (enclose (from (last To)) Orthogonal (between if:(or (is Enemy (who at:(between))) (is Empty (between))) (apply (and (if (is Enemy (who at:(between))) (remove (between))) (set State at:(between) (mover)))))))))) (end (if (and (no Moves P1) (no Moves P2)) (byScore {(score P1 (+ (count Pieces P1) (size Territory P1))) (score P2 (+ (count Pieces P2) (size Territory P2)))}))))) 
Players place one token of their color each turn and the first player unable to do so has lost. You may place on any empty cell unless your opponent has a token closer to that cell than you have along at least 2 of the 3 lines (axes) the cell is on. The game uses the pie rule: One player chooses the first move and the other player chooses whose move it is. A size 5 board is currently selected
(game "Mity" (players 2) (equipment {(board (hex 5)) (piece "Disc" Each)}) (rules (meta (swap)) (play (move Add (to (sites Empty) if:(not (or {(and (> (min (count Sites in:(if (< 0 (count Sites in:(intersection (sites Occupied by:Mover) (sites Direction from:(to) E stop:(= (mover) (who at:(to))) stopIncluded:True)))) (sites Direction from:(to) E stop:(= (mover) (who at:(to)))) (sites Board))) (count Sites in:(if (< 0 (count Sites in:(intersection (sites Occupied by:Mover) (sites Direction from:(to) W stop:(= (mover) (who at:(to))) stopIncluded:True)))) (sites Direction from:(to) W stop:(= (mover) (who at:(to)))) (sites Board)))) (min (count Sites in:(if (< 0 (count Sites in:(intersection (sites Occupied by:Next) (sites Direction from:(to) E stop:(= (next) (who at:(to))) stopIncluded:True)))) (sites Direction from:(to) E stop:(= (next) (who at:(to)))) (sites Board))) (count Sites in:(if (< 0 (count Sites in:(intersection (sites Occupied by:Next) (sites Direction from:(to) W stop:(= (next) (who at:(to))) stopIncluded:True)))) (sites Direction from:(to) W stop:(= (next) (who at:(to)))) (sites Board))))) (> (min (count Sites in:(if (< 0 (count Sites in:(intersection (sites Occupied by:Mover) (sites Direction from:(to) NNW stop:(= (mover) (who at:(to))) stopIncluded:True)))) (sites Direction from:(to) NNW stop:(= (mover) (who at:(to)))) (sites Board))) (count Sites in:(if (< 0 (count Sites in:(intersection (sites Occupied by:Mover) (sites Direction from:(to) SSE stop:(= (mover) (who at:(to))) stopIncluded:True)))) (sites Direction from:(to) SSE stop:(= (mover) (who at:(to)))) (sites Board)))) (min (count Sites in:(if (< 0 (count Sites in:(intersection (sites Occupied by:Next) (sites Direction from:(to) NNW stop:(= (next) (who at:(to))) stopIncluded:True)))) (sites Direction from:(to) NNW stop:(= (next) (who at:(to)))) (sites Board))) (count Sites in:(if (< 0 (count Sites in:(intersection (sites Occupied by:Next) (sites Direction from:(to) SSE stop:(= (next) (who at:(to))) stopIncluded:True)))) (sites Direction from:(to) SSE stop:(= (next) (who at:(to)))) (sites Board)))))) (and (> (min (count Sites in:(if (< 0 (count Sites in:(intersection (sites Occupied by:Mover) (sites Direction from:(to) E stop:(= (mover) (who at:(to))) stopIncluded:True)))) (sites Direction from:(to) E stop:(= (mover) (who at:(to)))) (sites Board))) (count Sites in:(if (< 0 (count Sites in:(intersection (sites Occupied by:Mover) (sites Direction from:(to) W stop:(= (mover) (who at:(to))) stopIncluded:True)))) (sites Direction from:(to) W stop:(= (mover) (who at:(to)))) (sites Board)))) (min (count Sites in:(if (< 0 (count Sites in:(intersection (sites Occupied by:Next) (sites Direction from:(to) E stop:(= (next) (who at:(to))) stopIncluded:True)))) (sites Direction from:(to) E stop:(= (next) (who at:(to)))) (sites Board))) (count Sites in:(if (< 0 (count Sites in:(intersection (sites Occupied by:Next) (sites Direction from:(to) W stop:(= (next) (who at:(to))) stopIncluded:True)))) (sites Direction from:(to) W stop:(= (next) (who at:(to)))) (sites Board))))) (> (min (count Sites in:(if (< 0 (count Sites in:(intersection (sites Occupied by:Mover) (sites Direction from:(to) NNE stop:(= (mover) (who at:(to))) stopIncluded:True)))) (sites Direction from:(to) NNE stop:(= (mover) (who at:(to)))) (sites Board))) (count Sites in:(if (< 0 (count Sites in:(intersection (sites Occupied by:Mover) (sites Direction from:(to) SSW stop:(= (mover) (who at:(to))) stopIncluded:True)))) (sites Direction from:(to) SSW stop:(= (mover) (who at:(to)))) (sites Board)))) (min (count Sites in:(if (< 0 (count Sites in:(intersection (sites Occupied by:Next) (sites Direction from:(to) NNE stop:(= (next) (who at:(to))) stopIncluded:True)))) (sites Direction from:(to) NNE stop:(= (next) (who at:(to)))) (sites Board))) (count Sites in:(if (< 0 (count Sites in:(intersection (sites Occupied by:Next) (sites Direction from:(to) SSW stop:(= (next) (who at:(to))) stopIncluded:True)))) (sites Direction from:(to) SSW stop:(= (next) (who at:(to)))) (sites Board)))))) (and (> (min (count Sites in:(if (< 0 (count Sites in:(intersection (sites Occupied by:Mover) (sites Direction from:(to) NNW stop:(= (mover) (who at:(to))) stopIncluded:True)))) (sites Direction from:(to) NNW stop:(= (mover) (who at:(to)))) (sites Board))) (count Sites in:(if (< 0 (count Sites in:(intersection (sites Occupied by:Mover) (sites Direction from:(to) SSE stop:(= (mover) (who at:(to))) stopIncluded:True)))) (sites Direction from:(to) SSE stop:(= (mover) (who at:(to)))) (sites Board)))) (min (count Sites in:(if (< 0 (count Sites in:(intersection (sites Occupied by:Next) (sites Direction from:(to) NNW stop:(= (next) (who at:(to))) stopIncluded:True)))) (sites Direction from:(to) NNW stop:(= (next) (who at:(to)))) (sites Board))) (count Sites in:(if (< 0 (count Sites in:(intersection (sites Occupied by:Next) (sites Direction from:(to) SSE stop:(= (next) (who at:(to))) stopIncluded:True)))) (sites Direction from:(to) SSE stop:(= (next) (who at:(to)))) (sites Board))))) (> (min (count Sites in:(if (< 0 (count Sites in:(intersection (sites Occupied by:Mover) (sites Direction from:(to) NNE stop:(= (mover) (who at:(to))) stopIncluded:True)))) (sites Direction from:(to) NNE stop:(= (mover) (who at:(to)))) (sites Board))) (count Sites in:(if (< 0 (count Sites in:(intersection (sites Occupied by:Mover) (sites Direction from:(to) SSW stop:(= (mover) (who at:(to))) stopIncluded:True)))) (sites Direction from:(to) SSW stop:(= (mover) (who at:(to)))) (sites Board)))) (min (count Sites in:(if (< 0 (count Sites in:(intersection (sites Occupied by:Next) (sites Direction from:(to) NNE stop:(= (next) (who at:(to))) stopIncluded:True)))) (sites Direction from:(to) NNE stop:(= (next) (who at:(to)))) (sites Board))) (count Sites in:(if (< 0 (count Sites in:(intersection (sites Occupied by:Next) (sites Direction from:(to) SSW stop:(= (next) (who at:(to))) stopIncluded:True)))) (sites Direction from:(to) SSW stop:(= (next) (who at:(to)))) (sites Board))))))}))))) (end (if (no Moves Next) (result Mover Win))))) 
One-Eyed Go follows the same rules as go (e.g. Japanese Rules) with the exception that it is never allowed to place a stone such that your own group has no liberties, even when they would capture other stones. This renders the ko rule superfluous. The game is played on a 19x19 board
(game "One-Eyed Go" (players 2) (equipment {(board (square 19) use:Vertex) (piece "Marker" Each)}) (rules (play (or (do (move Add (to (sites Empty))) ifAfterwards:(> (count Liberties Orthogonal) 0) (then (enclose (from (last To)) Orthogonal (between if:(is Enemy (who at:(between))) (apply (and (addScore Mover 1) (remove (between)))))))) (move Pass))) (end (if (all Passed) (byScore {(score P1 (+ (score P1) (size Territory P1))) (score P2 (+ (score P2) (size Territory P2)))}))))) 
DEFINITION: A group is a maximal set of orthogonally adjacent like-colored pieces. GAMEPLAY: On your turn, flip an enemy group. OBJECTIVE: Eliminate the enemy pieces. An 8x8 board is currently selected. No heuristic is used.
(game "Paintbucket" (players 2) (equipment {(board (square 8)) (tile "Square" Each)}) (rules (start {(place "Square1" (sites Phase 0)) (place "Square2" (sites Phase 1))}) (play (move Select (from (sites Occupied by:Next)) (then (add (to (sites Group at:(last From) Orthogonal) (apply (remove (to)))))))) (end (if (no Pieces Next) (result Next Loss))))) 
Paintscape is a game for two players – Black and White – played on the squares (cells/faces) of a square grid with 8 squares per side (e.g. a Chess board). You also need a large supply of black and white stones and 5 distinguishable (e.g. by color) shared sets of 12 tiles. That is, each of the 5 sets contain 12 tiles, for 60 tiles in total. Setup: Before play begins, all 60 tiles and 2 white and 2 black stones are distributed randomly on the 64 squares of the board. A short balancing phase then ensues: One player swaps the position of any number of stones with a tile. That is, for 0, 1, 2, 3, or 4 of the stones, swap its position with any tile. When all stones have been swapped, or the swapping player passes, indicating that they do not wish to swap any more stones, the other player choses to play first as Black or second as White in the proper playing phase. (To show the button for swapping in Ludii, you might have to click the three dots next to the pass button.) The balancing phase can be skipped by new players, or you can agree on a fixed setup for the 4 initial stones. Play: In this phase (the proper playing phase), players take turns, starting with Black, placing stones of their own color. On your turn, place a stone of your color on a square adjacent to one of your stones already on the board. You may not place a stone on a square occupied by a stone. I.e. the square you place at must be empty or only occupied by a tile. Stones placed on tiles normally just stack on top of them, however: If a placement makes you have a stone on half of the tiles of a certain color, remove all tiles of that color along with the stones stacked on top of them (regardless of whether they're friendly or enemy). The goal: You win if you remove 3 of the 5 colors. The balance protocol is currently in force.
(game "Paintscape" (players 2) (equipment {(board (square 8)) (piece "Disc" Each) (piece "Square" Shared maxState:5)}) (rules (start {(place Random (sites Empty) {"Disc1" "Disc2"} count:2) (place Random (sites Empty) {"Square"} count:12 state:1) (place Random (sites Empty) {"Square"} count:12 state:2) (place Random (sites Empty) {"Square"} count:12 state:3) (place Random (sites Empty) {"Square"} count:12 state:4) (place Random (sites Empty) {"Square"} count:12 state:5)}) phases:{(phase "Swapping" (play (or (move Pass (then (set Var "Passed" 1))) (move Select (from (sites Board) if:(and (!= 3 (who at:(from))) (not (is In (from) (values Remembered))))) (to (sites Board) if:(= 3 (who at:(to)))) (then (and {(remember Value (last To)) (do (add (piece (who at:(last From))) (to (last To) (apply (do (set Var "StateToBeAtLastFrom" (state at:(to))) next:(remove (to)))))) next:(add (piece 3 state:(var "StateToBeAtLastFrom")) (to (last From) (apply (remove (to)))))) (if (!= 3 (size Array (values Remembered))) (moveAgain))}))))) (nextPhase (or (= 1 (var "Passed")) (= 4 (size Array (values Remembered)))) "Choose")) (phase "Choose" (play (or (move Swap Players P1 P2 (then (set NextPlayer (player 1)))) (move Pass))) (nextPhase "Play")) (phase "Play" (play (move Add (to (sites Around (sites Occupied by:Mover) Orthogonal) if:(not (or (= (mover) (who at:(to))) (= (next) (who at:(to)))))) stack:True (then (if (and (= 3 (who at:(last To) level:0)) (= 6 (count Sites in:(forEach (sites Occupied by:Mover) if:(= (state at:(last To) level:0) (state at:(site) level:0)))))) (and (remove (forEach (sites Board) if:(= (state at:(last To) level:0) (state at:(site) level:0))) count:2) (addScore Mover 1)))))))} (end (if (or (= 3 (score P1)) (= 3 (score P2))) (byScore))))) 
19x19 intersecting lines. The central, as well as every third spot, in a square with the corners at the fourth point from the corners of the board, are marked. Players alternate turns placing a piece on the board on one of the marked spaces. When all of the marked spaces have been occupied, players may place a piece on any empty spot on the board. If a player surrounds one or more of the opponent's pieces orthogonally, they capture the opponent's pieces. The edge of the board can be included in such an enclosure. A group of pieces which contain two empty or more enclosures cannot be captured by the opponent. Pieces cannot be placed in an enclosure. When no further pieces can be placed, the players count the number of their pieces on the board and the number of empty spaces they enclose, and the player with the higher score wins.
(game "Patok" (players 2) (equipment {(board (square 19) use:Vertex) (piece "Marker" Each) (regions "MarkedSites" (sites {"D4" "D7" "D10" "D13" "D16" "G4" "G16" "J4" "J10" "J16" "M4" "M16" "P4" "P7" "P10" "P13" "P16"}))}) (rules phases:{(phase "MarkedPlacement" (play (move Add (to (intersection (sites Empty) (sites "MarkedSites"))))) (nextPhase (= 0 (count Sites in:(intersection (sites "MarkedSites") (sites Empty)))) "Playing")) (phase "Playing" (play (do (move Add (to (sites Empty)) (then (enclose (from (last To)) Orthogonal (between if:(is Enemy (who at:(between))) (apply (and (addScore Mover 1) (remove (between))))) numException:1))) ifAfterwards:(> (count Liberties Orthogonal) 0))) (end (if (no Moves Next) (byScore {(score P1 (+ (score P1) (size Territory P1))) (score P2 (+ (score P2) (size Territory P2)))}))))})) 
Each player has his own board, set up so that the opponent cannot see it. The referee has a board of his own on which he plays the moves of both players. He can see both player's boards. To make a move, a player plays a stone on his own board. The referee then checks on his board whether the move is legal and informs both players about the tried move. How exactly the refereee comments on the move depends on the rule variant. As long as a player tries to play an illegal move, it's still his turn and he may try another move. After the player has made a legal move, the referee copies the move to his own board. Then, it's the other player's turn. The game is played on a 9x9 board
(game "Phantom Go" (players 2) (equipment {(board (square 9) use:Vertex) (piece "Marker" Each)}) (rules (play (or (move Select (from (union (sites Empty) (sites Hidden to:Mover))) (then (priority {(if (not (is In (last To) (sites Empty))) (and {(note player:Mover "made an illegal move") (note player:Mover "to play") (moveAgain)})) (do (add (to (last To)) (then (and {(enclose (from (last To)) Orthogonal (between if:(is Enemy (who at:(between))) (apply (and (addScore Mover 1) (remove (between)))))) (set Hidden at:(last To) to:Next) (note player:Mover "has moved") (note player:Next "to play")}))) ifAfterwards:(> (count Liberties Orthogonal) 0)) (and {(note player:Mover "made an illegal move") (note player:Mover "to play") (moveAgain)})}))) (move Pass))) (end (if (all Passed) (byScore {(score P1 (+ (score P1) (size Territory P1))) (score P2 (+ (score P2) (size Territory P2)))}))))) 
White starts by playing any piece on any space. Players take turns to play one of their pieces. Each space of the board can support only one Tower. Each Tower is made of one piece of each kind (Square, Triangle, Circle), and pieces may be played in any order. If the active player cannot play according to the last piece's rule, they may play on any empty space. A Tower is controlled by the player with the most pieces. SQUARES The opponent must play in an orthogonally adjacent space. TRIANGLES The active player selects the orientation, it must point to at least one space. The opponent must play in the line indicated by the Triangle. CIRCLES The opponent must play on the same space. SCORES: The scores show the column counts. For example: 211 means 2 Towers, 1 controlled pair and 1 singleton GAME END The first player to control 3 completed Towers wins (i.e. a score of 300+). If the active player has no possible moves the game ends with tiebreaks: most completed towers, or most two-piece towers, or most one-piece towers. Stack is owned by player with majority of pieces there. Square is placed othogonally - next piece goes on adjacent spaces. Next piece may be placed any distance ahead of triangle but may not be placed around its tails.
(game "Pyrga" (players 2) (equipment {(board (square 4) use:Cell) (hand Each size:15) (piece "Disc" Each) (piece "SquareOrtho" Each) (piece "SquareDiag" Each) (piece "TriangleN" Each) (piece "TriangleS" Each) (piece "TriangleE" Each) (piece "TriangleW" Each)}) (rules (start {(place "Disc1" (handSite P1 0)) (place "Disc1" (handSite P1 1)) (place "Disc1" (handSite P1 2)) (place "Disc1" (handSite P1 3)) (place "Disc1" (handSite P1 4)) (place "SquareOrtho1" (handSite P1 5)) (place "SquareOrtho1" (handSite P1 6)) (place "SquareOrtho1" (handSite P1 7)) (place "SquareOrtho1" (handSite P1 8)) (place "SquareOrtho1" (handSite P1 9)) (place "TriangleN1" (handSite P1 10)) (place "TriangleN1" (handSite P1 11)) (place "TriangleN1" (handSite P1 12)) (place "TriangleN1" (handSite P1 13)) (place "TriangleN1" (handSite P1 14)) (place "Disc2" (handSite P2 0)) (place "Disc2" (handSite P2 1)) (place "Disc2" (handSite P2 2)) (place "Disc2" (handSite P2 3)) (place "Disc2" (handSite P2 4)) (place "SquareOrtho2" (handSite P2 5)) (place "SquareOrtho2" (handSite P2 6)) (place "SquareOrtho2" (handSite P2 7)) (place "SquareOrtho2" (handSite P2 8)) (place "SquareOrtho2" (handSite P2 9)) (place "TriangleN2" (handSite P2 10)) (place "TriangleN2" (handSite P2 11)) (place "TriangleN2" (handSite P2 12)) (place "TriangleN2" (handSite P2 13)) (place "TriangleN2" (handSite P2 14))}) (play (priority (or {(move Add (piece (id "Disc" Mover)) (to (sites (values Remembered)) if:(and {(> 3 (count Stack at:(to))) (!= 1 (state at:(to) level:0)) (!= 1 (state at:(to) level:1)) (< 0 (count Pieces Mover "Disc" in:(sites Hand Mover)))})) stack:True (then (and {(forget Value All) (set State at:(last To) level:(topLevel at:(last To)) 1) (remove (min (array (forEach (sites Hand Mover) if:(= (id "Disc" Mover) (what at:(site))))))) (remember Value (last To))}))) (forEach Value (array {0}) (move Add (piece (if (= 0 (value)) (id "SquareOrtho" Mover) (id "SquareDiag" Mover))) (to (sites (values Remembered)) if:(and {(> 3 (count Stack at:(to))) (!= 2 (state at:(to) level:0)) (!= 2 (state at:(to) level:1)) (< 0 (count Pieces Mover "SquareOrtho" in:(sites Hand Mover)))})) stack:True (then (and {(forget Value All) (set State at:(last To) level:(topLevel at:(last To)) 2) (remove (min (array (forEach (sites Hand Mover) if:(= (id "SquareOrtho" Mover) (what at:(site))))))) (if (= (id "SquareOrtho" Mover) (what at:(last To) level:(topLevel at:(last To)))) (forEach Site (sites Around (last To) Orthogonal) (remember Value (site))) (forEach Site (sites Around (last To) Diagonal) (remember Value (site))))})))) (do (move Add (piece (id "TriangleN" Mover)) (to (sites (values Remembered)) if:(and {(> 3 (count Stack at:(to))) (!= 3 (state at:(to) level:0)) (!= 3 (state at:(to) level:1)) (< 0 (count Pieces Mover "TriangleN" in:(sites Hand Mover)))})) stack:True (then (and {(forget Value All) (set State at:(last To) level:(topLevel at:(last To)) 3) (remove (min (array (forEach (sites Hand Mover) if:(= (id "TriangleN" Mover) (what at:(site)))))))} (then (and (forEach Site (sites Distance (step N (to (sites Board))) from:(last To) (range 1 Infinity)) (remember Value (site))) (forEach Site (sites {}) (remember Value (site)))))))) ifAfterwards:(< 0 (size Array (values Remembered)))) (do (move Add (piece (id "TriangleE" Mover)) (to (sites (values Remembered)) if:(and {(> 3 (count Stack at:(to))) (!= 3 (state at:(to) level:0)) (!= 3 (state at:(to) level:1)) (< 0 (count Pieces Mover "TriangleN" in:(sites Hand Mover)))})) stack:True (then (and {(forget Value All) (set State at:(last To) level:(topLevel at:(last To)) 3) (remove (min (array (forEach (sites Hand Mover) if:(= (id "TriangleN" Mover) (what at:(site)))))))} (then (and (forEach Site (sites Distance (step E (to (sites Board))) from:(last To) (range 1 Infinity)) (remember Value (site))) (forEach Site (sites {}) (remember Value (site)))))))) ifAfterwards:(< 0 (size Array (values Remembered)))) (do (move Add (piece (id "TriangleS" Mover)) (to (sites (values Remembered)) if:(and {(> 3 (count Stack at:(to))) (!= 3 (state at:(to) level:0)) (!= 3 (state at:(to) level:1)) (< 0 (count Pieces Mover "TriangleN" in:(sites Hand Mover)))})) stack:True (then (and {(forget Value All) (set State at:(last To) level:(topLevel at:(last To)) 3) (remove (min (array (forEach (sites Hand Mover) if:(= (id "TriangleN" Mover) (what at:(site)))))))} (then (and (forEach Site (sites Distance (step S (to (sites Board))) from:(last To) (range 1 Infinity)) (remember Value (site))) (forEach Site (sites {}) (remember Value (site)))))))) ifAfterwards:(< 0 (size Array (values Remembered)))) (do (move Add (piece (id "TriangleW" Mover)) (to (sites (values Remembered)) if:(and {(> 3 (count Stack at:(to))) (!= 3 (state at:(to) level:0)) (!= 3 (state at:(to) level:1)) (< 0 (count Pieces Mover "TriangleN" in:(sites Hand Mover)))})) stack:True (then (and {(forget Value All) (set State at:(last To) level:(topLevel at:(last To)) 3) (remove (min (array (forEach (sites Hand Mover) if:(= (id "TriangleN" Mover) (what at:(site)))))))} (then (and (forEach Site (sites Distance (step W (to (sites Board))) from:(last To) (range 1 Infinity)) (remember Value (site))) (forEach Site (sites {}) (remember Value (site)))))))) ifAfterwards:(< 0 (size Array (values Remembered))))}) (or {(move Add (piece (id "Disc" Mover)) (to (sites Empty) if:(< 0 (count Pieces Mover "Disc" in:(sites Hand Mover)))) stack:True (then (and {(forget Value All) (set State at:(last To) level:(topLevel at:(last To)) 1) (remove (min (array (forEach (sites Hand Mover) if:(= (id "Disc" Mover) (what at:(site))))))) (remember Value (last To))}))) (forEach Value (array {0}) (move Add (piece (if (= 0 (value)) (id "SquareOrtho" Mover) (id "SquareDiag" Mover))) (to (sites Empty) if:(< 0 (count Pieces Mover "SquareOrtho" in:(sites Hand Mover)))) stack:True (then (and {(forget Value All) (set State at:(last To) level:(topLevel at:(last To)) 2) (remove (min (array (forEach (sites Hand Mover) if:(= (id "SquareOrtho" Mover) (what at:(site))))))) (if (= (id "SquareOrtho" Mover) (what at:(last To) level:(topLevel at:(last To)))) (forEach Site (sites Around (last To) Orthogonal) (remember Value (site))) (forEach Site (sites Around (last To) Diagonal) (remember Value (site))))})))) (do (move Add (piece (id "TriangleN" Mover)) (to (sites Empty) if:(< 0 (count Pieces Mover "TriangleN" in:(sites Hand Mover)))) stack:True (then (and {(forget Value All) (set State at:(last To) level:(topLevel at:(last To)) 3) (remove (min (array (forEach (sites Hand Mover) if:(= (id "TriangleN" Mover) (what at:(site)))))))} (then (and (forEach Site (sites Distance (step N (to (sites Board))) from:(last To) (range 1 Infinity)) (remember Value (site))) (forEach Site (sites {}) (remember Value (site)))))))) ifAfterwards:(< 0 (size Array (values Remembered)))) (do (move Add (piece (id "TriangleE" Mover)) (to (sites Empty) if:(< 0 (count Pieces Mover "TriangleN" in:(sites Hand Mover)))) stack:True (then (and {(forget Value All) (set State at:(last To) level:(topLevel at:(last To)) 3) (remove (min (array (forEach (sites Hand Mover) if:(= (id "TriangleN" Mover) (what at:(site)))))))} (then (and (forEach Site (sites Distance (step E (to (sites Board))) from:(last To) (range 1 Infinity)) (remember Value (site))) (forEach Site (sites {}) (remember Value (site)))))))) ifAfterwards:(< 0 (size Array (values Remembered)))) (do (move Add (piece (id "TriangleS" Mover)) (to (sites Empty) if:(< 0 (count Pieces Mover "TriangleN" in:(sites Hand Mover)))) stack:True (then (and {(forget Value All) (set State at:(last To) level:(topLevel at:(last To)) 3) (remove (min (array (forEach (sites Hand Mover) if:(= (id "TriangleN" Mover) (what at:(site)))))))} (then (and (forEach Site (sites Distance (step S (to (sites Board))) from:(last To) (range 1 Infinity)) (remember Value (site))) (forEach Site (sites {}) (remember Value (site)))))))) ifAfterwards:(< 0 (size Array (values Remembered)))) (do (move Add (piece (id "TriangleW" Mover)) (to (sites Empty) if:(< 0 (count Pieces Mover "TriangleN" in:(sites Hand Mover)))) stack:True (then (and {(forget Value All) (set State at:(last To) level:(topLevel at:(last To)) 3) (remove (min (array (forEach (sites Hand Mover) if:(= (id "TriangleN" Mover) (what at:(site)))))))} (then (and (forEach Site (sites Distance (step W (to (sites Board))) from:(last To) (range 1 Infinity)) (remember Value (site))) (forEach Site (sites {}) (remember Value (site)))))))) ifAfterwards:(< 0 (size Array (values Remembered))))}) (then (and {(set Score (player (mover)) 0 (then (forEach Site (sites Board) (if (> (+ {(if (= (mover) (who at:(site) level:0)) 1 0) (if (= (mover) (who at:(site) level:1)) 1 0) (if (= (mover) (who at:(site) level:2)) 1 0)}) (/ (+ 1 (topLevel at:(site))) 2)) (addScore (player (mover)) (^ 10 (topLevel at:(site)))))))) (set Score (player (next)) 0 (then (forEach Site (sites Board) (if (> (+ {(if (= (next) (who at:(site) level:0)) 1 0) (if (= (next) (who at:(site) level:1)) 1 0) (if (= (next) (who at:(site) level:2)) 1 0)}) (/ (+ 1 (topLevel at:(site))) 2)) (addScore (player (next)) (^ 10 (topLevel at:(site))))))))})))) (end (if (or {(>= (score Mover) 300) (>= (score Next) 300) (no Moves Next)}) (byScore))))) 
Starting with Black, the two players take turns placing stones onto unoccupied points on the board, subject to restrictions, one stone per turn. Passing is not allowed in Redstone. Players will always have a placement available and must make one. GROUPS AND LIBERTIES: A group is an orthogonally interconnected collection of one or more like-colored stones. Only black groups and white groups will be discussed here, not red groups. A liberty is an unoccupied point adjacent to a (black or white) group CAPTURES: A capturing placement results in one or more groups, of either or both colors, having no liberties. Such a placement can only be made with a red stone. Conversely, a red stone can only be placed if it bounds (completely deprives of liberties) one or more groups of either or both colors. Red stones are permanent. They cannot themselves be captured. Self capture is allowed. When multiple groups without liberties result from a placement, all such groups are removed immediately following said placement, regardless of the groups' colors. Unlike Go, if you unbound your own temporarily bounded group by removing a neighboring enemy group, you must still remove your own temporarily bounded group. PIE RULE: Since Redstone is a game of annihilation, not of point score, Go’s komi can’t be used. Instead, Redstone uses the pie rule for balance. OBJECT OF THE GAME: You must annihilate your opponent, removing all of his stones from the board. If your placement eliminates all black and white stones from the board, you win. If your placement eliminates all of your own stones while enemy stones remain on the board, you lose. A size 13 board is currently selected
(game "Redstone" (players 2) (equipment {(board (square 13) use:Vertex) (piece "Disc" Each) (piece "Disc" Neutral)}) (rules (meta (swap)) (play (or (do (move Add (piece "Disc0") (to (sites Empty))) ifAfterwards:(or (not (all Sites (sites Around (last To) Enemy Orthogonal) if:(not (= 0 (count Liberties at:(site) Orthogonal if:(is Next (who at:(to)))))))) (not (all Sites (sites Around (last To) Own Orthogonal) if:(not (= 0 (count Liberties at:(site) Orthogonal if:(is Mover (who at:(to))))))))) (then (and (forEach Site (sites Around (last To) Enemy Orthogonal) (if (= 0 (count Liberties at:(site) Orthogonal if:(is Next (who at:(to))))) (remove (sites Group at:(site) Orthogonal if:(is Next (who at:(to))))))) (forEach Site (sites Around (last To) Own Orthogonal) (if (= 0 (count Liberties at:(site) Orthogonal if:(is Mover (who at:(to))))) (remove (sites Group at:(site) Orthogonal if:(is Mover (who at:(to)))))))))) (do (move Add (to (sites Empty))) ifAfterwards:(not (or (not (all Sites (sites Around (last To) Enemy Orthogonal) if:(not (= 0 (count Liberties at:(site) Orthogonal if:(is Next (who at:(to)))))))) (not (all Sites (sites Around (last To) Own Orthogonal includeSelf:True) if:(not (= 0 (count Liberties at:(site) Orthogonal if:(is Mover (who at:(to))))))))))))) (end {(if (and (> (count Moves) 2) (no Pieces Next)) (result Next Loss)) (if (and {(> (count Moves) 2) (no Pieces Mover) (not (no Pieces Next))}) (result Mover Loss))}))) 
2 players. Each plays Discs. - --- Goal: Most friendly-stone adjacencies at the end of the game. Ties are broken by comparing piece counts. If it is still a tie, the last player to move loses. --- Play. On your turn you may do one of the following: 1. Pass 2. Place one of your stones on an empty cell of the board is not adjacent to your existing stones. 3. Move to a location with fewer adjacent enemies than the starting location. Moves are made in one of the following ways while keeping the above restriction: -- A. Step to an adjacent empty location. -- B. Hop your opponent's stone and replace it with a mutual enemy piece. -- C. Hop a mutual enemy piece and replace it with a stone from your supply. Note that the number of enemies is based on a count of both the opponent's stones and the mutual-enemy stones combined.  Board & size: Hexhex (27) with edges alternating 3 and 4 Brown Background
(game "Refugia" (players 2) (equipment {(board (hex {3 4 3 4 3})) (piece "Disc" P1) (piece "Disc" P2) (piece "Fan" Neutral)}) (rules (start (set Score Each 0)) (play (or {(forEach Piece (move Step (to (sites Around (from)) if:(and (is Empty (to)) (< (count Sites in:(intersection (sites Around (to)) (union (sites Occupied by:Next) (sites Occupied by:Neutral)))) (count Sites in:(intersection (sites Around (from)) (union (sites Occupied by:Next) (sites Occupied by:Neutral))))))) (then (set Score Mover (/ (+ (results from:(sites Occupied by:Mover) to:(sites Around (from) if:(is Mover (who at:(to)))) 1)) 2)))) Mover) (forEach Piece (move Hop (between if:(is Within (id "Fan" Neutral) at:(between)) (apply (and (remove (between)) (add (piece (id "Disc" Mover)) (to (between)))))) (to if:(and (is Empty (to)) (< (count Sites in:(intersection (sites Around (to)) (union (sites Occupied by:Next) (sites Occupied by:Neutral)))) (count Sites in:(intersection (sites Around (from)) (union (sites Occupied by:Next) (sites Occupied by:Neutral))))))) (then (and (set Score Mover (/ (+ (results from:(sites Occupied by:Mover) to:(sites Around (from) if:(is Mover (who at:(to)))) 1)) 2)) (set Score Next (/ (+ (results from:(sites Occupied by:Next) to:(sites Around (from) if:(is Next (who at:(to)))) 1)) 2))))) Mover) (forEach Piece (move Hop (between if:(is Next (who at:(between))) (apply (and (remove (between)) (add (piece (id "Fan" Neutral)) (to (between)))))) (to if:(and (is Empty (to)) (< (count Sites in:(intersection (sites Around (to)) (union (sites Occupied by:Next) (sites Occupied by:Neutral)))) (count Sites in:(intersection (sites Around (from)) (union (sites Occupied by:Next) (sites Occupied by:Neutral))))))) (then (and (set Score Mover (/ (+ (results from:(sites Occupied by:Mover) to:(sites Around (from) if:(is Mover (who at:(to)))) 1)) 2)) (set Score Next (/ (+ (results from:(sites Occupied by:Next) to:(sites Around (from) if:(is Next (who at:(to)))) 1)) 2))))) Mover) (move Add (piece (id "Disc" Mover)) (to (sites Empty) if:(not (is Within (id "Disc" Mover) in:(sites Around (to)))))) (move Pass)})) (end (if (all Passed) {(if (> (score Mover) (score Next)) (result Mover Win)) (if (< (score Mover) (score Next)) (result Next Win)) (if (> (count Pieces Mover) (count Pieces Next)) (result Mover Win)) (if (< (count Pieces Mover) (count Pieces Next)) (result Next Win))} (result Next Win))))) 
On your turn, you place a hexagonal tile of your color that covers three mutually orthogonally adjacent rhombuses. In Ludii this is done by first selecting one of the rhombuses the tile will cover, then another. The third one is determined by these two selections. When no more placements are possible, the game is over and the winner is the player with the higher score. The general idea behind the scoring is simple: You get 1 point per empty rhombus that ends up adjacent to more of your hexagons than your opponent's hexagons. However, two slight complications are necessary to exclude all draws in as fair a manner as possible: 1: You score 1 point every time you make a placement that closes off an odd number of tied rhombuses. (A rhombus is closed off when it is adjacent to no rhombus that can be filled in on a future turn.) This is equivalent to dividing tied cells between you in a "one for me, one for you, one for me"-fashion as they are closed off. 2: You get 1 bonus point if your opponent has made more placements than you at the end of the game. All scoring is automatic in Ludii.
(game "Residuel" (players 2) (equipment {(board (remove (rotate 30 (dual (tiling T3636 5))) cells:{0 4 5 73 81 97 142 143 152})) (tile "Rhombus" Each)}) (rules (play (move Select (from (sites Empty) if:(not (all Sites (sites Around (from) Empty Orthogonal) if:(not (not (all Sites (sites Around (site) Empty Orthogonal) if:(not (is Related Orthogonal (site) (from))))))))) (to (sites Around (from) Empty Orthogonal) if:(not (all Sites (sites Around (to) Empty Orthogonal) if:(not (is Related Orthogonal (site) (from)))))) (then (do (forEach Site (forEach (sites Empty) if:(and {(= (count Sites in:(sites Around (site) Own Orthogonal)) (count Sites in:(sites Around (site) Enemy Orthogonal))) (not (can Move (move Select (from (sites Around (site) Empty Orthogonal) if:(not (all Sites (sites Around (from) Empty Orthogonal) if:(not (not (all Sites (sites Around (site) Empty Orthogonal) if:(not (is Related Orthogonal (site) (from))))))))))))})) (set State at:(site) 1)) next:(do (add (to (intersection (sites Around (last From) Orthogonal includeSelf:True) (sites Around (last To) Orthogonal includeSelf:True)))) next:(addScore Mover (% (count Sites in:(forEach (forEach (sites Empty) if:(and {(= (count Sites in:(sites Around (site) Own Orthogonal)) (count Sites in:(sites Around (site) Enemy Orthogonal))) (not (can Move (move Select (from (sites Around (site) Empty Orthogonal) if:(not (all Sites (sites Around (from) Empty Orthogonal) if:(not (not (all Sites (sites Around (site) Empty Orthogonal) if:(not (is Related Orthogonal (site) (from))))))))))))})) if:(!= 1 (state at:(site))))) 2))))))) (end (if (no Moves Next) (byScore {(score P1 (+ {(score P1) (- (max (/ (count Sites in:(sites Occupied by:P1)) 3) (/ (count Sites in:(sites Occupied by:P2)) 3)) (/ (count Sites in:(sites Occupied by:P1)) 3)) (count Sites in:(forEach (sites Empty) if:(> (count Sites in:(intersection (sites Around (site) Orthogonal) (sites Occupied by:P1))) (count Sites in:(intersection (sites Around (site) Orthogonal) (sites Occupied by:P2))))))})) (score P2 (+ {(score P2) (- (max (/ (count Sites in:(sites Occupied by:P1)) 3) (/ (count Sites in:(sites Occupied by:P2)) 3)) (/ (count Sites in:(sites Occupied by:P2)) 3)) (count Sites in:(forEach (sites Empty) if:(> (count Sites in:(intersection (sites Around (site) Orthogonal) (sites Occupied by:P2))) (count Sites in:(intersection (sites Around (site) Orthogonal) (sites Occupied by:P1))))))}))}))))) 
Reversi is played on an 8x8 board. Pieces are double-sided, with each side distinct in some way from the other. Each side designates ownership of that pieces to a certain player when face-up. Play begins with the players taking turns placing pieces into the central four squares until they are full. Then players may place their pieces next to an opponent's piece, a long as a straight line can be drawn between the new piece and an existing piece belonging to that player that goes through the opponent's piece. The opponent's pieces between the new piece and the old piece are then flipped and now belong to the player who just played. If a player cannot make a legal move, they pass. Play continues until the board is full or neither player cannot make a legal move. The player with the most pieces on the board wins. The pieces are placed on the board. The board is a square board of size 8x8.
(game "Reversi" (players 2) (equipment {(board (square 8)) (piece "Disc" Neutral (flips 1 2))}) (rules (start {(place "Disc0" (difference (sites Centre) (sites Phase 1)) state:1) (place "Disc0" (difference (sites Centre) (sites Phase 0)) state:2)}) phases:{(phase "Playing" (play (forEach Site (sites Empty) (append (custodial (from (site)) (between if:(is Enemy (state at:(between))) (apply (allCombinations (add (piece "Disc0" state:(mover)) (to (site))) (flip (between))))) (to if:(is Friend (state at:(to))))) (then (and (set Score P1 (count Sites in:(sites State 1))) (set Score P2 (count Sites in:(sites State 2)))))))))} (end (if (all Passed) (byScore))))) 
This is basically 4-player Othello, albeit more "friendly", since you can place a piece of your color even if you have none on the board. It features unique ball-shaped objects that have four colors. You "roll" them to the proper color when converting them, as opposed to flipping in 2-player Othello. The game adds a higher chaos factor in the 3 and 4 player game since you don't have any control over what your opponents do. The game is playing with four players.
(game "Rolit" (players 4) (equipment {(board (square 8)) (piece "Ball" Neutral)}) (rules (start {(place "Ball0" coord:"D5" state:1) (place "Ball0" coord:"E5" state:2) (place "Ball0" coord:"E4" state:3) (place "Ball0" coord:"D4" state:4)}) (play (priority (forEach Site (sites Empty) (append (custodial (from (site)) (between if:(is Enemy (state at:(between))) (apply (allCombinations (add (piece "Ball0" state:(mover)) (to (site))) (set State at:(between) (mover))))) (to if:(is Friend (state at:(to))))))) (move Add (piece "Ball0" state:(mover)) (to (sites Around (sites Occupied by:Neutral) Empty))) (then (forEach Player (set Score Player (count Sites in:(sites State (player)))))))) (end (if (all Passed) (byScore))))) 
Play on an equilateral triangular hexagon-tessellated grid. Use a neutral pawn and black/white checkers. Players take turns moving a neutral pawn around on the board (passing is not allowed). The neutral pawn can move any number of empty points, in any direction in a straight line, but cannot move onto, or jump over occupied points. When a player moves the pawn, first they place a checker of their own color, onto the destination point. Then they move the pawn on top of it. When the pawn is trapped, the game is over. At the end of the game, each player gets a point for each checker of their own color adjacent to, or underneath, the pawn. The person with the highest score wins. Played on a size 13 board.
(game "Trike" (players 2) (equipment {(board (hex Triangle 13)) (piece "Marker" Each)}) (rules (meta (swap)) phases:{(phase "Opening" P1 (play (move Add (to (sites Empty)) (then (set Var (last To))))) (nextPhase)) (phase "Play" (play (move Add (to (sites LineOfSight Empty at:(var))) (then (set Var (last To))))))} (end (if (no Moves Next) (byScore {(score P1 (+ (if (is Mover P1) 1 0) (count Sites in:(intersection (sites Around (last To)) (sites Occupied by:P1))))) (score P2 (+ (if (is Mover P2) 1 0) (count Sites in:(intersection (sites Around (last To)) (sites Occupied by:P2)))))}))))) 
Tumbleweed is played with stackable tokens on a hexhex board. A stack is said to be seen from a hex when they are connected by a straight line, with no stacks in between. The players take turns settling hexes by placing a stack of their tokens on a hex of their choice. The height of a new stack is equal to the number of friendly stacks seen from the settled hex. Removing a stack occupying a hex and re-settling it with a new stack is possible, only as long as the new stack is taller than the previous one. This works with opponent stacks (to capture), or your own stacks (to reinforce). The board is initially empty, except for a central neutral (blue) two-stack. The first player sets up initial one-stacks: White and Red. The second player then chooses which side he wants to play, by clicking on a stone. Red goes first. The game ends when no more moves can be made by either player, or after two successive passes. The player who occupies over half the board wins. The program automatically scores indirectly controlled territory. Played on a size 8 board.
(game "Tumbleweed" (players 2) (equipment {(board (hex 8)) (piece "Disc" Each) (piece "Disc" Neutral)}) (rules (start (place Stack "Disc0" (centrePoint) count:2)) phases:{(phase "Opening" (play (if (= 0 (count Moves)) (move Add (piece "Disc1") (to (sites Empty)) (then (moveAgain))) (if (= 1 (count Moves)) (move Add (piece "Disc2") (to (sites Empty))) (move Select (from (union (sites Occupied by:P1) (sites Occupied by:P2))) (then (if (= 1 (who at:(last From))) (do (swap Players 1 2) next:(set NextPlayer (player 1))) (pass))))))) (nextPhase (= 3 (count Moves)) "Play")) (phase "Play" (play (or (move Select (from (forEach (sites Board) if:(> (count Sites in:(intersection (sites Occupied by:Mover) (sites LineOfSight at:(site)))) (size Stack at:(site))))) (then (add (to (last From)) count:(- (count Sites in:(intersection (sites Occupied by:Mover) (sites LineOfSight at:(last From)))) (size Stack at:(last From))) stack:True))) (move Pass))))} (end (if (all Passed) (byScore {(score P1 (+ (count Sites in:(sites Occupied by:P1)) (count Sites in:(forEach (sites Empty) if:(> (count Sites in:(intersection (sites Occupied by:P1) (sites LineOfSight at:(site)))) (count Sites in:(intersection (sites Occupied by:P2) (sites LineOfSight at:(site))))))))) (score P2 (+ (count Sites in:(sites Occupied by:P2)) (count Sites in:(forEach (sites Empty) if:(> (count Sites in:(intersection (sites Occupied by:P2) (sites LineOfSight at:(site)))) (count Sites in:(intersection (sites Occupied by:P1) (sites LineOfSight at:(site)))))))))}))))) 
Played on a 19x19 board. The board begins empty. One player plays as black, the other as white. The black player begins by placing a piece on one of the intersections on the board. Players alternate turns placing a piece on the board. A player may pass at any time. A piece or a group of pieces are captured when they are completely surrounded on all sides on adjacent intersections by the opposing player. Stones may be placed in a position where they are surrounded. Stones cannot be placed to recreate a previous position. The game ends when both players pass consecutively. Players then fill in the spaces in their captured territory with their own pieces. Players total the number of intersections their pieces occupy. The player with the highest total wins. 
(game "Weiqi" (players 2) (equipment {(board (square 19) use:Vertex) (piece "Marker" Each)}) (rules (meta (no Repeat)) (play (or (move Add (to (sites Empty)) (then (enclose (from (last To)) Orthogonal (between if:(is Enemy (who at:(between))) (apply (remove (between))))))) (move Pass))) (end (if (all Passed) (byScore {(score P1 (+ (count Pieces P1) (size Territory P1))) (score P2 (+ (count Pieces P2) (size Territory P2)))}))))) 
The game begins with the pieces set out as in the diagram. 2. The king's side takes the first move, play then alternating between players. 3. In his turn a player moves one of his pieces along a straight line, horizontally or vertically. 4. No piece may land on another, nor is there any jumping. 5. Only the king can land on the central space, though other pieces can pass through it. 6. Only the king may move to the spaces occupied by the fixed men: see rule 11. 7. The king is captured by surrounding him on all four sides by counts. If he is next to the central square or the edge of the board, he may be captured by surrounding him on the other three sides. 8. Dukes and counts are captured by surrounding them with enemies on two opposite sides, horizontally or vertically. Two or three men may be captured simultaneously if each falls between the moving piece and another enemy. 9. The fixed men in the corners may be used to capture pieces by either player. 10. A piece may come to rest voluntarily between two others, without being captured. 11. If the king moves to one of the squares occupied by the fixed men, he has escaped the board and wins the game. 12. If the king is captured by his opponents, then he has lost the game. The rules are describing with the Cyningstan ruleset.
(game "Alea Evangelii" (players 2) (equipment {(board (square 19)) (regions "Fortresses" (expand (sites Corners))) (piece "Thrall" P1 (move Slide Orthogonal (between if:(and (not (is In (between) (sites "Fortresses"))) (is Empty (between)))) (to (apply if:(!= (to) (centrePoint)))) (then (or {(custodial (from (last To)) Orthogonal (between (max 1) if:(= (what at:(between)) (id "Thrall2" Next)) (apply (remove (between)))) (to if:(or {(is Friend (who at:(to))) (is In (to) (sites "Fortresses")) (and (is In (to) (sites Centre)) (is Empty (to)))}))) (surround (from (last To)) Orthogonal (between if:(and (= (what at:(between)) (id "Jarl" P2)) (is In (between) (expand origin:(centrePoint) Orthogonal))) (apply (trigger "Surrounded" P2))) (to if:(or (is Friend (who at:(to))) (is In (to) (sites Centre))))) (custodial (from (last To)) Orthogonal (between if:(and (= (what at:(between)) (id "Jarl" P2)) (not (is In (between) (expand origin:(centrePoint) Orthogonal)))) (apply (trigger "Surrounded" P2))) (to if:(is Friend (who at:(to)))))})))) (piece "Thrall" P2 (move Slide Orthogonal (between if:(and (not (is In (between) (sites "Fortresses"))) (is Empty (between)))) (to (apply if:(!= (to) (centrePoint)))) (then (custodial (from (last To)) Orthogonal (between (max 1) if:(= (what at:(between)) (id "Thrall1" Next)) (apply (remove (between)))) (to if:(or {(is Friend (who at:(to))) (is In (to) (sites "Fortresses")) (and (is In (to) (sites Centre)) (is Empty (to)))})))))) (piece "Jarl" P2 (move Slide Orthogonal (to (apply if:(!= (to) (centrePoint))))))}) (rules (start {(place "Thrall1" {"C1" "F1" "N1" "Q1" "A3" "F3" "N3" "S3" "H4" "L4" "G5" "I5" "K5" "M5" "A6" "C6" "Q6" "S6" "E7" "O7" "D8" "P8" "E9" "O9" "E11" "O11" "D12" "P12" "E13" "O13" "A14" "C14" "Q14" "S14" "G15" "I15" "K15" "M15" "H16" "L16" "A17" "F17" "N17" "S17" "C19" "F19" "N19" "Q19"}) (place "Thrall2" {"J4" "F6" "N6" "J7" "I8" "K8" "H9" "J9" "L9" "D10" "G10" "I10" "K10" "M10" "P10" "H11" "J11" "L11" "I12" "K12" "J13" "F14" "N14" "J16"}) (place "Jarl2" (centrePoint))}) (play (forEach Piece)) (end {(if (is Within (id "Jarl2") in:(sites "Fortresses")) (result P2 Win)) (if (is Triggered "Surrounded" P2) (result P1 Win))}))) 
Pieces move one space orthogonally. Pieces are captured through the custodial capture move, but a piece moving in between two other pieces is not automatically captured. The goal of the player with the king is to reach the edge of the board. The goal of the other player is to capture the king. The game is played with the common rules.
(game "ArdRi" (players 2) (equipment {(board (square 7)) (piece "Thrall" P1 (move Step Orthogonal (to if:(and (not (is In (to) (sites Centre))) (is Empty (to)))) (then (or {(custodial (from (last To)) Orthogonal (between (max 1) if:(= (what at:(between)) (id "Thrall2" Next)) (apply (remove (between)))) (to if:(is Friend (who at:(to))))) (surround (from (last To)) Orthogonal (between if:(= (what at:(between)) (id "Jarl2")) (apply (trigger "Surrounded" P2))) (to if:(or (is Friend (who at:(to))) (is In (to) (sites Centre)))))})))) (piece "Thrall" P2 (move Step Orthogonal (to if:(and (not (is In (to) (sites Centre))) (is Empty (to)))) (then (custodial (from (last To)) Orthogonal (between (max 1) if:(= (what at:(between)) (id "Thrall1" Next)) (apply (remove (between)))) (to if:(is Friend (who at:(to)))))))) (piece "Jarl" P2 (move Step Orthogonal (to if:(is Empty (to))) (then (custodial (from (last To)) Orthogonal (between (max 1) if:(= (what at:(between)) (id "Thrall1" Next)) (apply (remove (between)))) (to if:(is Friend (who at:(to))))))))}) (rules (start {(place "Thrall1" {"C1" "D1" "E1" "D2" "A3" "A4" "A5" "B4" "G3" "G4" "G5" "F4" "D6" "C7" "D7" "E7"}) (place "Thrall2" (difference (expand (sites Centre)) (sites Centre))) (place "Jarl2" (centrePoint))}) (play (forEach Piece)) (end {(if (is Within (id "Jarl2") in:(sites Outer)) (result P2 Win)) (if (is Triggered "Surrounded" P2) (result P1 Win))}))) 
12x12 board, with a line of six extra squares centered on each side. Diagonals in every square. Pieces are played on the intersections of lines. Played with two or four players; with four players, the top and left players play against the bottom and right players. Six pieces per player, with one larger piece. Each player's six pieces begin on the central intersection of the extra spaces. Pieces move one spot at a time diagonally. When a player surrounds an opponent's piece on two opposite sides, this piece is captured. The piece is then replaced by the larger piece, which may move diagonally or orthogonally. Pieces may not move backward. When all of the players' remaining pieces reach the starting squares of the opponent, the player with the most captured pieces wins.
(game "Awithlaknakwe" (players {(player N) (player E) (player S) (player W)}) (equipment {(board (merge (merge (merge (merge (square 13 diagonals:Solid) (shift 3 -1 (rectangle 2 7 diagonals:Solid))) (shift 3 12 (rectangle 2 7 diagonals:Solid))) (shift -3.5 5.5 (rotate 90 (rectangle 2 7 diagonals:Solid)))) (shift 9.5 5.5 (rotate 90 (rectangle 2 7 diagonals:Solid)))) use:Vertex) (piece "Counter" Each (move Step (directions {FR FL}) (to if:(is Empty (to))))) (piece "DoubleCounter" Each (move Step (directions {Rightward Forwards Leftward}) (to if:(is Empty (to))))) (regions "Home" P1 (sites {"D9" "E8" "F7" "G6" "H5" "I4"})) (regions "Home" P2 (sites {"I22" "H21" "G20" "F19" "E18" "D17"})) (regions "Home" P3 (sites {"Q22" "R21" "S20" "T19" "U18" "V17"})) (regions "Home" P4 (sites {"V9" "U8" "T7" "S6" "R5" "Q4"})) (hand Each)}) (rules (start {(set Team 1 {P1 P4}) (set Team 2 {P2 P3}) (place "Counter1" (sites P1)) (place "Counter2" (sites P2)) (place "Counter3" (sites P3)) (place "Counter4" (sites P4)) (place "DoubleCounter" "Hand")}) (play (forEach Piece (then (custodial (from (last To)) Orthogonal (between (max 1) if:(is Enemy (who at:(between))) (apply (and {(remove (between)) (if (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site))))) (fromTo (from (handSite Mover)) (to (between)))) (addScore Mover 1)}))) (to if:(is Friend (who at:(to)))))))) (end (if (and (all Sites (union (sites Occupied by:P1) (sites Occupied by:P4)) if:(is In (site) (union (sites P2) (sites P3)))) (all Sites (union (sites Occupied by:P2) (sites Occupied by:P3)) if:(is In (site) (union (sites P1) (sites P4))))) {(if (> (+ (score P1) (score P4)) (+ (score P2) (score P3))) (result Team1 Win)) (if (< (+ (score P1) (score P4)) (+ (score P2) (score P3))) (result Team2 Win)) (if (= (+ (score P1) (score P4)) (+ (score P2) (score P3))) (result Mover Draw))})))) 
A player can move a piece to any empty adjacent cell of the same color; so, on an open board, six moves are possible. Throughout the game, a player's pieces are restricted to cells of the same color. A captured piece is immediately removed from the game. A player captures a regular enemy piece by surrounding it on three sides. A player captures an enemy captain by surrounding it on three sides, with the caveat that one of the surrounding pieces must be a captain. (Three regular pieces are insufficient and the enemy captain would be unaffected.) An enemy piece on the edge of the board can be captured by surrounding it on two sides, with the caveat that one of the surrounding pieces must be a captain. (Two regular pieces are insufficient.) If a piece (regular or captain) is moved to a cell already surrounded by three enemy pieces, it is instantly captured, unless the move itself performed a capture. A player wins the game by reducing the opponent to two pieces.
(game "Bizingo" (players 2) (equipment {(board (remove (tri 13) cells:{0 1 13 25 11 12 24 36 165 166 167 168})) (piece "Thrall" Each (move Step (to if:(and (is Empty (to)) (= (phase of:(from)) (phase of:(to))))) (then (and {(if (not (can Move (or {(surround (from (last To)) Orthogonal (between if:(and {(is In (between) (sites Outer)) (= 0 (phase of:(between))) (is Enemy (who at:(between)))}) (apply (remove (between)))) (to if:(is Friend (who at:(to)))) with:(piece (id "Jarl" Mover))) (surround (from (last To)) Orthogonal (between if:(and (or (not (is In (between) (sites Outer))) (and (is In (between) (sites Outer)) (= 1 (phase of:(between))))) (= (what at:(between)) (id "Thrall" Next))) (apply (remove (between)))) (to if:(is Friend (who at:(to))))) (surround (from (last To)) Orthogonal (between if:(and (or (not (is In (between) (sites Outer))) (and (is In (between) (sites Outer)) (= 1 (phase of:(between))))) (= (what at:(between)) (id "Jarl" Next))) (apply (remove (between)))) (to if:(is Friend (who at:(to)))) with:(piece (id "Jarl" Mover)))}))) (if (= 3 (count Sites in:(intersection (sites Around (last To) Orthogonal) (sites Occupied by:Next)))) (remove (last To)))) (surround (from (last To)) Orthogonal (between if:(and {(is In (between) (sites Outer)) (= 0 (phase of:(between))) (is Enemy (who at:(between)))}) (apply (remove (between)))) (to if:(is Friend (who at:(to)))) with:(piece (id "Jarl" Mover))) (surround (from (last To)) Orthogonal (between if:(and (or (not (is In (between) (sites Outer))) (and (is In (between) (sites Outer)) (= 1 (phase of:(between))))) (= (what at:(between)) (id "Thrall" Next))) (apply (remove (between)))) (to if:(is Friend (who at:(to))))) (surround (from (last To)) Orthogonal (between if:(and (or (not (is In (between) (sites Outer))) (and (is In (between) (sites Outer)) (= 1 (phase of:(between))))) (= (what at:(between)) (id "Jarl" Next))) (apply (remove (between)))) (to if:(is Friend (who at:(to)))) with:(piece (id "Jarl" Mover)))})))) (piece "Jarl" Each (move Step (to if:(and (is Empty (to)) (= (phase of:(from)) (phase of:(to))))) (then (and {(if (not (can Move (or {(surround (from (last To)) Orthogonal (between if:(and {(is In (between) (sites Outer)) (= 0 (phase of:(between))) (is Enemy (who at:(between)))}) (apply (remove (between)))) (to if:(is Friend (who at:(to)))) with:(piece (id "Jarl" Mover))) (surround (from (last To)) Orthogonal (between if:(and (or (not (is In (between) (sites Outer))) (and (is In (between) (sites Outer)) (= 1 (phase of:(between))))) (= (what at:(between)) (id "Thrall" Next))) (apply (remove (between)))) (to if:(is Friend (who at:(to))))) (surround (from (last To)) Orthogonal (between if:(and (or (not (is In (between) (sites Outer))) (and (is In (between) (sites Outer)) (= 1 (phase of:(between))))) (= (what at:(between)) (id "Jarl" Next))) (apply (remove (between)))) (to if:(is Friend (who at:(to)))) with:(piece (id "Jarl" Mover)))}))) (if (= 3 (count Sites in:(intersection (sites Around (last To) Orthogonal) (sites Occupied by:Next)))) (remove (last To)))) (surround (from (last To)) Orthogonal (between if:(and {(is In (between) (sites Outer)) (= 0 (phase of:(between))) (is Enemy (who at:(between)))}) (apply (remove (between)))) (to if:(is Friend (who at:(to)))) with:(piece (id "Jarl" Mover))) (surround (from (last To)) Orthogonal (between if:(and (or (not (is In (between) (sites Outer))) (and (is In (between) (sites Outer)) (= 1 (phase of:(between))))) (= (what at:(between)) (id "Thrall" Next))) (apply (remove (between)))) (to if:(is Friend (who at:(to))))) (surround (from (last To)) Orthogonal (between if:(and (or (not (is In (between) (sites Outer))) (and (is In (between) (sites Outer)) (= 1 (phase of:(between))))) (= (what at:(between)) (id "Jarl" Next))) (apply (remove (between)))) (to if:(is Friend (who at:(to)))) with:(piece (id "Jarl" Mover)))}))))}) (rules (start {(place "Thrall1" (sites {32 33 34 35 36 53 54 55 56 57 58 72 74 75 76 78})) (place "Jarl1" (sites {73 77})) (place "Thrall2" (sites {137 138 139 126 127 128 129 113 114 115 116 117 98 100 101 103})) (place "Jarl2" (sites {99 102}))}) (play (forEach Piece)) (end (forEach Player if:(<= (count Pieces Player) 2) (result Player Loss))))) 
Each player has four pieces. Players take turns moving a piece to an empty dot. A player may capture an opponent’s piece by placing a piece on either side of an opponent’s piece. If a player moves their own piece between two of the opponent’s pieces, it is not captured. A player wins by reducing the opponent to one piece.  The game is played according to the rules of the source.
(game "Boseog Gonu" (players 2) (equipment {(board (remove (merge {(rectangle 3 3 diagonals:Alternating) (shift 0 -1 (rotate 180 (wedge 2))) (shift 0 2 (wedge 2)) (shift -1.5 0.5 (rotate 90 (wedge 2))) (shift 1.5 0.5 (rotate -90 (wedge 2)))}) edges:{{{1 1} {0 0}} {{1 1} {2 2}} {{1 1} {2 0}} {{1 1} {0 2}}}) use:Vertex) (piece "Disc" Each (move Step (to if:(is Empty (to))) (then (custodial (from (last To)) (between (max 1) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(= (what at:(to)) (what at:(last To))))))))}) (rules (start {(place "Disc1" {"A3" "B3" "B4" "B2"}) (place "Disc2" {"D2" "D3" "E3" "D4"})}) (play (forEach Piece)) (end (if (<= (count Pieces Next) 1) (result Next Loss))))) 
7x7 board. One player plays as the king and four defenders, the other as eight attackers. The king begins in the center piece, with the defenders placed in the adjacent orthogonal squares. The attackers are placed two in each square extending in the orthogonal direction from the defenders' positions. Attackers move first. Pieces move any distance orthogonally. No piece may land on the central square. Only the king may enter the corner squares. A piece is captured when it is surrounded orthogonally on two sides by an opposing piece. Pieces may also be captured between the central square and an opponent or a corner square and the opponent. When in the central square, the king is captured by surrounding it on four orthogonal sides. When adjacent to the central square, the king is captured by surrounding it on the three other orthogonally adjacent sides. Otherwise, the king is captured as any other piece. The king wins by moving to a corner square. The attackers win by capturing the king. The rules are describing with the Nielsen ruleset.
(game "Brandub" (players 2) (equipment {(board (square 7)) (regions "Fortresses" (sites Corners)) (piece "Thrall" P1 (move Slide Orthogonal (to (apply if:(not (is In (to) (union (sites Centre) (sites "Fortresses")))))) (then (or {(custodial (from (last To)) Orthogonal (between (max 1) if:(= (what at:(between)) (id "Thrall2")) (apply (remove (between)))) (to if:(or {(is Friend (who at:(to))) (is In (to) (sites "Fortresses")) (and (is In (to) (sites Centre)) (is Empty (to)))}))) (surround (from (last To)) Orthogonal (between if:(and (= (what at:(between)) (id "Jarl" P2)) (is In (between) (expand origin:(centrePoint) Orthogonal))) (apply (trigger "Surrounded" P2))) (to if:(or (is Friend (who at:(to))) (is In (to) (sites Centre))))) (custodial (from (last To)) Orthogonal (between (max 1) if:(and (= (what at:(between)) (id "Jarl" P2)) (not (is In (between) (expand origin:(centrePoint) Orthogonal)))) (apply (trigger "Surrounded" P2))) (to if:(or (is Friend (who at:(to))) (is In (to) (sites "Fortresses")))))})))) (piece "Thrall" P2 (move Slide Orthogonal (to (apply if:(not (is In (to) (union (sites Centre) (sites "Fortresses")))))) (then (custodial (from (last To)) Orthogonal (between (max 1) if:(= (what at:(between)) (id "Thrall1")) (apply (remove (between)))) (to if:(or {(is Friend (who at:(to))) (is In (to) (sites "Fortresses")) (and (is In (to) (sites Centre)) (is Empty (to)))})))))) (piece "Jarl" P2 (move Slide Orthogonal (to (apply if:(not (= (to) (centrePoint))))) (then (custodial (from (last To)) Orthogonal (between (max 1) if:(= (what at:(between)) (id "Thrall1")) (apply (remove (between)))) (to if:(or {(is Friend (who at:(to))) (is In (to) (sites "Fortresses")) (and (is In (to) (sites Centre)) (is Empty (to)))}))))))}) (rules (start {(place "Thrall1" {"D1" "D2" "A4" "B4" "F4" "G4" "D6" "D7"}) (place "Thrall2" {"D3" "C4" "E4" "D5"}) (place "Jarl2" (centrePoint))}) (play (forEach Piece)) (end {(if (is Within (id "Jarl2") in:(sites "Fortresses")) (result P2 Win)) (if (is Triggered "Surrounded" P2) (result P1 Win))}))) 
Objectives One player has a gold fleet consisting of one large flagship and twelve escorts, with the objective of evading capture while breaking through his or her opponent's blockade to transport the flagship to the perimeter of the board. The other player has a silver fleet of twenty ships, and forms a blockade to trap the gold flagship and destroy the gold fleet's escorts with the objective of capturing the flagship. Setup Gold player places the flagship on the center square of the game board, and positions the rest of the ships anywhere within the boldly ruled central area of the board. Silver player then positions the silver ships on twenty squares in the lightly ruled peripheral area of the board. Play Gold player chooses who goes first. Players move alternately by making two moves or one capture anywhere on the board. When the flagship is moved, only one move or capture is made (thus only the flagship). Moves A player may move two of the smaller playing pieces any number of vacant squares either horizontally or vertically on the board (as a rook in Chess, except that no captures can be made with this move), although if the flagship is moved, the gold player may not move another playing piece. Captures A player may move any playing piece (including the flagship) one square diagonally to capture one of his opponent's playing pieces. (This move is similar to the capture-move of the pawn in Chess, except that captures can be made on any of the four diagonals.) This game uses displacement capture (like Chess), rather than custodial capture (like Hnefatafl), thus when a capture is made, the captured piece is removed from the board and the vacated square is occupied by the captor. Play continues until one player achieves his or her objective. If the flagship of the gold fleet reaches one of the outermost squares on the board, gold player wins. If the flagship is captured before it reaches the outer edge of the board, silver player wins.
(game "Breakthru" (players 2) (equipment {(board (square 11)) (piece "Disc" Each (or (if (not (is Prev Mover)) (move Step Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (move Slide Orthogonal (then (if (not (is Prev Mover)) (moveAgain)))))) (piece "Commander" P1 (if (not (is Prev Mover)) (or (move Step Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Slide Orthogonal)))) (hand Each) (regions "CentreSites" (expand (sites Centre) steps:2))}) (rules (start {(place "Commander1" (sites Centre)) (place "Disc1" (handSite P1) count:12) (place "Disc2" (handSite P2) count:20)}) phases:{(phase "PlacementP1" (play (move (from (handSite P1)) (to (intersection (sites "CentreSites") (sites Empty))) (then (if (is Occupied (handSite P1)) (moveAgain))))) (nextPhase (is Empty (handSite P1)) "PlacementP2")) (phase "PlacementP2" (play (move (from (handSite P2)) (to (difference (sites Empty) (sites "CentreSites"))) (then (if (is Occupied (handSite P2)) (moveAgain))))) (nextPhase (is Empty (handSite P2)) "Movement")) (phase "Movement" (play (forEach Piece)) (end {(if (is Within (id "Commander1") in:(sites Outer)) (result P1 Win)) (if (= (where "Commander" P1) -1) (result P2 Win))}))})) 
There are 30 game-pieces for each player and eleven castles. The gameboard is divided into three sections: homes and center section. Object of the game is to capture four castles (among those of the central section and the other side) or 28 pawns of your opponent. In a turn a player moves one of their pieces, horizontally, vertically. A pawn can step to an adjacent empty cell. Additionally a pawn can jump over another pawn as long as the square behind that pawn is free. Multiple jumps are allowed and all enemy pawns are captured this way and removed from the deck. A pawn can capture a maximum of five enemy pieces, and his movement ends after the fifth piece is captured. A castle is conquered when it is surrounded by three pawns.
(game "Castello" (players 2) (equipment {(board (rectangle 15 21)) (piece "Pawn" Each (or (move Hop Orthogonal (between if:(and (!= (what at:(between)) (id "Castle0")) (is Occupied (between))) (apply (if (= (who at:(between)) (next)) (remove (between))))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Orthogonal (between if:(if (< (counter) (- 5 1)) (and (!= (what at:(between)) (id "Castle0")) (is Occupied (between))) (is Friend (who at:(between)))) (apply (if (= (who at:(between)) (next)) (remove (between))))) (to if:(and (is Empty (to)) (not (is Visited (to))))))) (moveAgain) (set Counter)))) (move Step Orthogonal (to if:(is Empty (to)))))) (piece "Castle" Neutral) (hand Each size:3) (regions "LeftPart" (expand (sites Left) steps:6)) (regions "RightPart" (expand (sites Right) steps:6)) (regions "Middle" (expand (sites Centre)))}) (rules (start {(place "Pawn1" (expand (sites Left))) (place "Pawn2" (expand (sites Right))) (place "Castle0" (sites {"G2" "F6" "G10" "F14" "K3" "K8" "K13" "P2" "O6" "P10" "O14"}))}) (play (if (is Prev Mover) (or (move Hop (from (last To)) Orthogonal (between if:(if (< (counter) 5) (and (!= (what at:(between)) (id "Castle0")) (is Occupied (between))) (is Friend (who at:(between)))) (apply (if (= (who at:(between)) (next)) (remove (between))))) (to if:(and (is Empty (to)) (not (is Visited (to))))) (then (if (can Move (hop (from (last To)) Orthogonal (between if:(if (< (counter) (- 5 1)) (and (!= (what at:(between)) (id "Castle0")) (is Occupied (between))) (is Friend (who at:(between)))) (apply (if (= (who at:(between)) (next)) (remove (between))))) (to if:(and (is Empty (to)) (not (is Visited (to))))))) (moveAgain) (set Counter)))) (move Pass)) (forEach Piece) (then (and (if (is In (last To) (sites "LeftPart")) (if (< (count Cell at:(handSite Mover)) 3) (surround (from (last To)) Orthogonal (between if:(= (what at:(between)) (id "Castle0")) (apply (fromTo (from (between)) (to (handSite Mover))))) (to if:(is Friend (who at:(to)))) except:1)) (if (is In (last To) (sites "RightPart")) (surround (from (last To)) Orthogonal (between if:(= (what at:(between)) (id "Castle0")) (apply (fromTo (from (between)) (to (handSite Mover 2))))) (to if:(is Friend (who at:(to)))) except:1) (if (is In (last To) (sites "Middle")) (if (> (count Cell at:(handSite Mover 2)) 0) (surround (from (last To)) Orthogonal (between if:(= (what at:(between)) (id "Castle0")) (apply (fromTo (from (between)) (to (handSite Mover 1))))) (to if:(is Friend (who at:(to)))) except:1)) (surround (from (last To)) Orthogonal (between if:(= (what at:(between)) (id "Castle0")) (apply (fromTo (from (between)) (to (handSite Mover 1))))) (to if:(is Friend (who at:(to)))) except:1)))) (set Counter))))) (end {(if (<= (count Pieces Next) 3) (result Next Loss)) (if (> (count in:(sites Hand Mover)) 3) (result Mover Win))}))) 
3x3 intersecting lines, with diagonals in the square. Three pieces per player, which begin on opposite sides of the square. Players alternate turns moving one of their pieces along the lines of the board. When a player surrounds one of the opponent's pieces with two of their pieces, the opponent's piece is captured. The player who captures all of the opponent's pieces wins.
(game "El-Mthaltha" (players 2) (equipment {(board (rectangle 3 3 diagonals:Alternating) use:Vertex) (piece "Marker" Each (move Step (to if:(is Empty (to))) (then (custodial (from (last To)) Orthogonal (between (max 1) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Friend (who at:(to))))))))}) (rules (start {(place "Marker1" (sites Bottom)) (place "Marker2" (sites Top))}) (play (forEach Piece)) (end (if (no Pieces Next) (result Next Loss))))) 
9x9 intersecting lines, pieces are played on the intersections. 16 pieces per player, one player is black, the other white. Pieces begin placed on the edge of the board: Black on the top and right, white on the bottom and left. Sixteen others are held in reserve for each player. Pieces move any distance orthogonally along the lines. Opponent's pieces are captured when they are surrounded by two of a player's pieces. When this is done, the surrounded player's pieces are removed and replaced with the pieces of the player that surrounded them. If multiple opponent's pieces are in a line and the other player places their pieces at either end of the line, all the pieces in between are captured. When a player is reduced to one piece, it gains the ability to capture by jumping. The player that removes all of their opponent's pieces wins.
(game "Gundru" (players 2) (equipment {(board (square 9) use:Vertex) (piece "Marker" Each (or (if (= 1 (+ (count Cell at:(handSite Mover)) (count Pieces Mover))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (move Slide (then (custodial (from (last To)) (between (range 1 (count Rows)) if:(is Enemy (who at:(between))) (apply (and (remove (between)) (fromTo (from (handSite Mover)) (to (between)))))) (to if:(is Friend (who at:(to))))))))) (hand Each)}) (rules (start {(place "Marker" "Hand" count:16) (place "Marker1" (union (sites Top) (difference (sites Right) (sites Bottom)))) (place "Marker2" (union (sites Bottom) (difference (sites Left) (sites Top))))}) (play (forEach Piece)) (end (if (no Moves Next) (result Mover Win))))) 
HeXentafl can be played on a 4x4 or 5x5 hex grid. For the 4x4 version: The King sits on the central space, the throne, surrounded by three defenders. Six attackers sit on the outer corners of the grid. The attackers must capture the King in order to win. The defenders must escort the King to any of the six corners of the board in order to win. All pieces except the King move in a straight line, as many spaces as they like to an unoccupied space (like a rook in Chess). Only one piece at a time can occupy a space. A piece cannot jump over another piece. The King can move into any vacant adjacent space, moving one space at a time (similar to the king in Chess). Pieces are captured by surrounding them on two sides. Except for the corners, the pieces can be captured by surrounding them with two pieces which are not adjacents. You cannot "capture" your own piece by moving between two enemy pieces. The central space of the board is the throne. Only the King may occupy the throne. When the King is on the throne, he is harder to capture. He must be surrounded on three sides which are not adjacents each other. HeXentafl on a 5x5 grid is almost identical to a 4x4 grid, except there are more attackers and defenders, and the King moves just like the other pieces. It is not limited to one space at a time. The game is played on a 4x4 hex board.
(game "HeXentafl" (players 2) (equipment {(board (rotate 90 (hex 4))) (piece "Thrall" P1 (move Slide (between if:(and (!= (between) (centrePoint)) (is Empty (between)))) (then (and (surround (from (last To)) Orthogonal (between if:(and {(is In (between) (sites "Fortresses")) (is Enemy (who at:(between))) (all Sites (sites Around (between) Own) if:(all Sites (sites Around (site) Own) if:(not (is In (to) (sites Around (between) Own)))))}) (apply (remove (between)))) (to if:(is Friend (who at:(to)))) except:1) (custodial (from (last To)) Orthogonal (between (max 1) if:(and (!= (between) (centrePoint)) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Friend (who at:(to))))))))) (piece "Thrall" P2 (move Slide (between if:(and (!= (between) (centrePoint)) (is Empty (between)))) (then (and {(surround (from (last To)) Orthogonal (between if:(and {(= (between) (centrePoint)) (= (what at:(between)) (id "Jarl" P1)) (all Sites (sites Around (between) Own) if:(all Sites (sites Around (site) Own) if:(not (is In (to) (sites Around (between) Own)))))}) (apply (remove (between)))) (to if:(is Friend (who at:(to)))) except:3) (surround (from (last To)) Orthogonal (between if:(and {(is In (between) (sites "Fortresses")) (is Enemy (who at:(between))) (all Sites (sites Around (between) Own) if:(all Sites (sites Around (site) Own) if:(not (is In (to) (sites Around (between) Own)))))}) (apply (remove (between)))) (to if:(is Friend (who at:(to)))) except:1) (custodial (from (last To)) Orthogonal (between (max 1) if:(and (!= (between) (centrePoint)) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Friend (who at:(to)))))})))) (piece "Jarl" P1 (move Step (to if:(is Empty (to))) (then (and (surround (from (last To)) Orthogonal (between if:(and {(is In (between) (sites "Fortresses")) (is Enemy (who at:(between))) (all Sites (sites Around (between) Own) if:(all Sites (sites Around (site) Own) if:(not (is In (to) (sites Around (between) Own)))))}) (apply (remove (between)))) (to if:(is Friend (who at:(to)))) except:1) (custodial (from (last To)) Orthogonal (between (max 1) if:(and (!= (between) (centrePoint)) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Friend (who at:(to))))))))) (regions "Fortresses" (sites Corners))}) (rules (start {(place "Jarl1" (centrePoint)) (place "Thrall2" (sites "Fortresses")) (place "Thrall1" {"D3" "C4" "E5"})}) (play (forEach Piece)) (end {(if (is Within (id "Jarl1") in:(sites "Fortresses")) (result P1 Win)) (if (= (where "Jarl" P1) -1) (result P2 Win))}))) 
Played on an 11x11 board. The defending side comprises twelve soldiers and a king, who start the game in a cross formation in the center of the board. Their objective is for the king to escape by reaching any of the four corner squares. The attackers comprise 24 soldiers positioned in four groups of 6 around the perimeter of the board. The King piece is the only piece that can occupy the central and the four corner squares. All pieces move orthogonally any number of spaces, and pieces are taken by custodial capture (surrounding an enemy piece on either side with two of a player's pieces). The king piece must be captured by surrounding it on all four sides. The game is played with the common rules.
(game "Hnefatafl" (players 2) (equipment {(board (square 11)) (regions "Fortresses" (sites Corners)) (piece "Thrall" P1 (move Slide Orthogonal (between if:(and (not (is In (between) (union (sites Centre) (sites "Fortresses")))) (is Empty (between)))) (then (and {(custodial (from (last To)) Orthogonal (between (max 1) if:(= (what at:(between)) (id "Thrall2" Next)) (apply (remove (between)))) (to if:(or (is Friend (who at:(to))) (is In (to) (union (sites Centre) (sites "Fortresses")))))) (surround (from (last To)) Orthogonal (between if:(= (what at:(between)) (id "Jarl" P2)) (apply (trigger "Surrounded" P2))) (to if:(or (is Friend (who at:(to))) (is In (to) (union (sites Centre) (sites "Fortresses"))))))})))) (piece "Thrall" P2 (move Slide Orthogonal (between if:(and (not (is In (between) (union (sites Centre) (sites "Fortresses")))) (is Empty (between)))) (then (custodial (from (last To)) Orthogonal (between (max 1) if:(= (what at:(between)) (id "Thrall1" Next)) (apply (remove (between)))) (to if:(or (is Friend (who at:(to))) (is In (to) (union (sites Centre) (sites "Fortresses"))))))))) (piece "Jarl" P2 (move Slide Orthogonal (then (custodial (from (last To)) Orthogonal (between (max 1) if:(= (what at:(between)) (id "Thrall1" Next)) (apply (remove (between)))) (to if:(or (is Friend (who at:(to))) (is In (to) (union (sites Centre) (sites "Fortresses")))))))))}) (rules (start {(place "Thrall1" {"D1" "E1" "F1" "G1" "H1" "F2" "A4" "A5" "A6" "A7" "A8" "B6" "K4" "K5" "K6" "K7" "K8" "J6" "F10" "D11" "E11" "F11" "G11" "H11" "F10"}) (place "Thrall2" {"F4" "E5" "F5" "G5" "D6" "E6" "G6" "H6" "E7" "F7" "G7" "F8"}) (place "Jarl2" (centrePoint))}) (play (forEach Piece)) (end {(if (is Within (id "Jarl2") in:(sites "Fortresses")) (result P2 Win)) (if (is Triggered "Surrounded" P2) (result P1 Win))}))) 
7x7 board. 24 pieces per player. Players alternate turns placing two pieces on the board. The first piece of each player must be placed on a spot adjacent to the central spot. The central spot cannot be filled. When both players have placed their pieces, they move their pieces orthogonally to an empty adjacent space. When an opponent's piece is surrounded on two opposite sides by pieces belonging to the player, the opponent's piece is captured. The player who made the capture may move the same piece they moved to make a capture another time if another capture is possible by doing so. The player who captures all of their opponent's pieces, or which blocks the opponent from being able to move, wins. In a case where the second player has created a blockade of their pieces containing one or more of only their own pieces which can move infinitely without possibility of being taken, the second player player may declare H'ajeb in order to regain the possibility of winning. The second player declares H'ajeb on their turn, and then the first player gains the ability to move any distance orthogonally or diagonally. The first player may also make multiple captures not just with the same piece, but with more than one. The second player may rescind the H'ajeb declaration at any time and the captures must stop. If the second player allows the first player to continue until the first player cannot capture, the second player captures any two of the first player's pieces, and the first player captures one of the second player's pieces that is able to move infinitely. 
(game "Khamousiyya" (players 2) (equipment {(board (square 7)) (piece "Marker" Each (move Step Orthogonal (to if:(is Empty (to))) (then (custodial (from (last To)) Orthogonal (between (max 1) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Friend (who at:(to)))) (then (if (can Move (step (from (last To)) Orthogonal (to if:(and (is Empty (to)) (or {(and (is Enemy (who at:(ahead (to) W))) (is Friend (who at:(ahead (to) steps:2 W)))) (and (is Enemy (who at:(ahead (to) E))) (is Friend (who at:(ahead (to) steps:2 E)))) (and (is Enemy (who at:(ahead (to) N))) (is Friend (who at:(ahead (to) steps:2 N)))) (and (is Enemy (who at:(ahead (to) S))) (is Friend (who at:(ahead (to) steps:2 S))))}))))) (moveAgain))))))) (hand Each)}) (rules (start (place "Marker" "Hand" count:24)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (if (no Pieces Mover in:(sites Board)) (forEach (sites Around (centrePoint) Orthogonal) if:(is Empty (site))) (difference (sites Board) (centrePoint))) if:(is Empty (to))) (then (if (not (is Prev Mover)) (moveAgain))))) (nextPhase Mover (is Empty (handSite Mover)) "Capture")) (phase "Capture" (play (if (is Prev Mover) (or (move Step (from (last To)) Orthogonal (to if:(and (is Empty (to)) (or {(and (is Enemy (who at:(ahead (to) W))) (is Friend (who at:(ahead (to) steps:2 W)))) (and (is Enemy (who at:(ahead (to) E))) (is Friend (who at:(ahead (to) steps:2 E)))) (and (is Enemy (who at:(ahead (to) N))) (is Friend (who at:(ahead (to) steps:2 N)))) (and (is Enemy (who at:(ahead (to) S))) (is Friend (who at:(ahead (to) steps:2 S))))}))) (then (custodial (from (last To)) Orthogonal (between (max 1) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Friend (who at:(to)))) (then (if (can Move (step (from (last To)) Orthogonal (to if:(and (is Empty (to)) (or {(and (is Enemy (who at:(ahead (to) W))) (is Friend (who at:(ahead (to) steps:2 W)))) (and (is Enemy (who at:(ahead (to) E))) (is Friend (who at:(ahead (to) steps:2 E)))) (and (is Enemy (who at:(ahead (to) N))) (is Friend (who at:(ahead (to) steps:2 N)))) (and (is Enemy (who at:(ahead (to) S))) (is Friend (who at:(ahead (to) steps:2 S))))}))))) (moveAgain)))))) (move Pass)) (forEach Piece))))} (end (if (no Moves Next) (result Mover Win))))) 
5x5 board. Twelve pieces per player. Players alternate turns placing two pieces on an empty space on the board, except in the central space. Captures cannot be made during the placement phase. When all of the pieces have been placed, players alternate turns moving a piece orthogonally any distance. When an opponent's piece is between two of a player's pieces, it is captured. If a player is unable to make a move, they pass their turn and the opponent plays again. The player who captures all of the opponent's pieces wins.
(game "Kharebga (5x5)" (players 2) (equipment {(board (square 5)) (piece "Marker" Each (move Slide Orthogonal (then (custodial (from (last To)) Orthogonal (between (max 1) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Friend (who at:(to)))))))) (hand Each)}) (rules (start (place "Marker" "Hand" count:12)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (difference (sites Board) (centrePoint)) if:(is Empty (to))) (then (if (not (is Prev Mover)) (moveAgain))))) (nextPhase Mover (is Empty (handSite Mover)) "Capture")) (phase "Capture" (play (forEach Piece)))} (end (if (no Pieces Next) (result Next Loss))))) 
7x7 board. 24 pieces per player. Players alternate turns placing two pieces on an empty space on the board, except in the central space. Captures cannot be made during the placement phase. When all of the pieces have been placed, players alternate turns moving a piece orthogonally any distance. When an opponent's piece is between two of a player's pieces, it is captured. If a player is unable to make a move, they pass their turn and the opponent plays again. The player who captures all of the opponent's pieces wins. 
(game "Kharebga (7x7)" (players 2) (equipment {(board (square 7)) (piece "Marker" Each (move Slide Orthogonal (then (custodial (from (last To)) Orthogonal (between (max 1) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Friend (who at:(to)))))))) (hand Each)}) (rules (start (place "Marker" "Hand" count:24)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (difference (sites Board) (centrePoint)) if:(is Empty (to))) (then (if (not (is Prev Mover)) (moveAgain))))) (nextPhase Mover (is Empty (handSite Mover)) "Capture")) (phase "Capture" (play (forEach Piece)))} (end (if (no Pieces Next) (result Next Loss))))) 
The players take turns placing one piece on any vacant square. In this phase no captures are made. When all the pieces have been placed, the players take turns moving pieces on the board. The pieces can be moved orthogonally to any adjacent square. A piece can leap over any single piece of either color, if the square behind is unoccupied. Several leaps in one turn are possible (as in Draughts). If a player can trap an enemy piece between two friendly pieces, the enemy piece is blocked and cannot be moved. On the next turn, instead of moving a piece, the player can capture the trapped piece by removing it from the board, provided his own two surrounding pieces are still free. The trapped piece is immediately free if one of its two enemies is itself surrounded. A player reduced to only one piece left on the board has lost the game.  States can not be repeated. Rules suggested by Ulrich Schadler in 1994.
(game "Ludus Latrunculorum" (players 2) (equipment {(board (square 8)) (hand Each) (piece "Vagi" Each (flips 0 1) (if (= 0 (state at:(from))) (or (move Step Orthogonal (to if:(is Empty (to)))) (move Hop Orthogonal (between if:(is Occupied (between))) (to if:(and (is Empty (to)) (not (is Visited (to))))) (then (if (can Move (move Hop (from (last To)) Orthogonal (between if:(is Occupied (between))) (to if:(and (is Empty (to)) (not (is Visited (to))))))) (moveAgain)))) (then (and (custodial (from (last From)) Orthogonal (between (max 1) if:(and (= (what at:(between)) (next)) (= 1 (state at:(between)))) (apply (flip (between)))) (to if:(and (is Friend (who at:(to))) (= 0 (state at:(to)))))) (custodial (from (last To)) Orthogonal (between (max 1) if:(and (= (what at:(between)) (next)) (= 0 (state at:(between)))) (apply (and (flip (between)) (custodial (from (between)) Orthogonal (between (max 1) if:(and (= (what at:(between)) (mover)) (= 1 (state at:(between)))) (apply (flip (between)))) (to if:(and (is Enemy (who at:(to))) (= 0 (state at:(to))))))))) (to if:(and (is Friend (who at:(to))) (= 0 (state at:(to)))))))))))}) (rules (meta (no Repeat)) (start (place "Vagi" "Hand" count:16)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (or (move Hop (from (last To)) Orthogonal (between if:(is Occupied (between))) (to if:(and (is Empty (to)) (not (is Visited (to))))) (then (and {(if (can Move (move Hop (from (last To)) Orthogonal (between if:(is Occupied (between))) (to if:(and (is Empty (to)) (not (is Visited (to))))))) (moveAgain)) (custodial (from (last From)) Orthogonal (between (max 1) if:(and (= (what at:(between)) (next)) (= 1 (state at:(between)))) (apply (flip (between)))) (to if:(and (is Friend (who at:(to))) (= 0 (state at:(to)))))) (custodial (from (last To)) Orthogonal (between (max 1) if:(and (= (what at:(between)) (next)) (= 0 (state at:(between)))) (apply (and (flip (between)) (custodial (from (between)) Orthogonal (between (max 1) if:(and (= (what at:(between)) (mover)) (= 1 (state at:(between)))) (apply (flip (between)))) (to if:(and (is Enemy (who at:(to))) (= 0 (state at:(to))))))))) (to if:(and (is Friend (who at:(to))) (= 0 (state at:(to))))))}))) (move Pass)) (or (forEach Piece) (move Remove (forEach (sites Occupied by:Next) if:(= 1 (state at:(site)))))))))} (end (if (= (count Pieces Next) 1) (result Mover Win))))) 
8x8 board. Sixteen pieces per player. The pieces begin on the first and third rank or squares with respect to each player. Pieces move orthogonally any distance. Pieces are captured when surrounded on both sides by an enemy piece. Enemy pieces may also be taken if a piece moves into a space such that the enemy pieces are on either side of it. The goal is to capture all of the enemy's pieces.
(game "Maak Yek" (players 2) (equipment {(board (square 8)) (piece "Marker" Each (move Slide Orthogonal (then (and (intervene (from (last To)) Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (custodial (from (last To)) Orthogonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Friend (who at:(to)))))))))}) (rules (start {(place "Marker1" (union (sites Row 0) (sites Row 2))) (place "Marker2" (union (sites Row 5) (sites Row 7)))}) (play (forEach Piece)) (end (if (no Pieces Next) (result Next Loss))))) 
17x17 board. 144 pieces per player. Players alternate turns placing two pieces on an empty space on the board, except in the central space. Captures cannot be made during the placement phase. When all of the pieces have been placed, players alternate turns moving a piece orthogonally any distance. When an opponent's piece is between two of a player's pieces, it is captured. If a player in unable to make a move, they pass their turn and the opponent plays again. The player who captures all of the opponent's pieces wins.  States can not be repeated. Kharebga rules applied to a 17x17 board.
(game "Poprad Game" (players 2) (equipment {(board (square 17)) (piece "Marker" Each (move Slide Orthogonal (then (custodial (from (last To)) Orthogonal (between (max 1) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Friend (who at:(to)))))))) (hand Each)}) (rules (meta (no Repeat)) (start (place "Marker" "Hand" count:144)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (difference (sites Board) (centrePoint)) if:(is Empty (to))) (then (if (and (is Occupied (handSite Mover)) (not (is Prev Mover))) (moveAgain))))) (nextPhase Mover (is Empty (handSite Mover)) "Capture")) (phase "Capture" (play (forEach Piece)))} (end (if (<= (count Pieces Next) 1) (result Next Loss))))) 
5x5 board. Twelve pieces per player. Players alternate turns placing two pieces on the board. The first piece of each player must be placed on a spot adjacent to the central spot. The central spot cannot be filled. When both players have placed their pieces, they move their pieces orthogonally to an empty adjacent space. When an opponent's piece is surrounded on two opposite sides by pieces belonging to the player, the opponent's piece is captured. The player who made the capture may move the same piece they moved to make a capture another time if another capture is possible by doing so. The player who captures all of their opponent's pieces, or which blocks the opponent from being able to move, wins. In a case where the second player has created a blockade of their pieces containing one or more of only their own pieces which can move infinitely without possibility of being taken, the second player player may declare H'ajeb in order to regain the possibility of winning. The second player declares H'ajeb on their turn, and then the first player gains the ability to move any distance orthogonally or diagonally. The first player may also make multiple captures not just with the same piece, but with more than one. The second player may rescind the H'ajeb declaration at any time and the captures must stop. If the second player allows the first player to continue until the first player cannot capture, the second player captures any two of the first player's pieces, and the first player captures one of the second player's pieces that is able to move infinitely. 
(game "Sabou'iyya" (players 2) (equipment {(board (square 5)) (piece "Marker" Each (move Step Orthogonal (to if:(is Empty (to))) (then (custodial (from (last To)) Orthogonal (between (max 1) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Friend (who at:(to)))) (then (if (can Move (step (from (last To)) Orthogonal (to if:(and (is Empty (to)) (or {(and (is Enemy (who at:(ahead (to) W))) (is Friend (who at:(ahead (to) steps:2 W)))) (and (is Enemy (who at:(ahead (to) E))) (is Friend (who at:(ahead (to) steps:2 E)))) (and (is Enemy (who at:(ahead (to) N))) (is Friend (who at:(ahead (to) steps:2 N)))) (and (is Enemy (who at:(ahead (to) S))) (is Friend (who at:(ahead (to) steps:2 S))))}))))) (moveAgain))))))) (hand Each)}) (rules (start (place "Marker" "Hand" count:12)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (if (= 0 (count Pieces Mover in:(sites Board))) (forEach (sites Around (centrePoint) Orthogonal) if:(is Empty (site))) (difference (sites Board) (centrePoint))) if:(is Empty (to))) (then (if (not (is Prev Mover)) (moveAgain))))) (nextPhase Mover (is Empty (handSite Mover)) "Capture")) (phase "Capture" (play (if (is Prev Mover) (or (move Step (from (last To)) Orthogonal (to if:(and (is Empty (to)) (or {(and (is Enemy (who at:(ahead (to) W))) (is Friend (who at:(ahead (to) steps:2 W)))) (and (is Enemy (who at:(ahead (to) E))) (is Friend (who at:(ahead (to) steps:2 E)))) (and (is Enemy (who at:(ahead (to) N))) (is Friend (who at:(ahead (to) steps:2 N)))) (and (is Enemy (who at:(ahead (to) S))) (is Friend (who at:(ahead (to) steps:2 S))))}))) (then (custodial (from (last To)) Orthogonal (between (max 1) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Friend (who at:(to)))) (then (if (can Move (step (from (last To)) Orthogonal (to if:(and (is Empty (to)) (or {(and (is Enemy (who at:(ahead (to) W))) (is Friend (who at:(ahead (to) steps:2 W)))) (and (is Enemy (who at:(ahead (to) E))) (is Friend (who at:(ahead (to) steps:2 E)))) (and (is Enemy (who at:(ahead (to) N))) (is Friend (who at:(ahead (to) steps:2 N)))) (and (is Enemy (who at:(ahead (to) S))) (is Friend (who at:(ahead (to) steps:2 S))))}))))) (moveAgain)))))) (move Pass)) (forEach Piece))))} (end (if (no Moves Next) (result Mover Win))))) 
5x5 board. Players begin by placing their pieces in prescribed spaces, and then alternating two-by-two in places as they see fit, except for the central space. Once all the spaces except the central one are filled, the first player moves a piece one space orthogonally to the empty space. Pieces are captured by surrounding them on either side by a player's own pieces. The player to capture all of the opponent's pieces wins. The game is played on a 5x5 board.
(game "Seega" (players 2) (equipment {(board (square 5)) (hand Each) (piece "Marker" Each (move Step Orthogonal (to if:(is Empty (to))) (then (custodial (from (last To)) Orthogonal (between (max 1) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Friend (who at:(to))))))))}) (rules (start (place "Marker" "Hand" count:12)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (difference (sites Empty) (centrePoint))) (then (if (not (is Prev Mover)) (moveAgain))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end (if (no Pieces Next) (result Next Loss))))) 
5x5 board. Players begin by placing their pieces two-by-two in places as they see fit, except for the central space. Once all the spaces except the central one are filled, the player who placed their pieces last moves a piece one space orthogonally to the empty space. Pieces are captured by surrounding them on either side by a player's own pieces. Multiple captures are allowed, and multiple pieces can be captured in a single move. A player may move their piece between two of the opponent's pieces without it resulting in a capture. Pieces in the central spot cannot be captured. If a player cannot move, the opponent must move so that the player can move on their next turn. The player to capture all of the opponent's pieces wins. 
(game "Shantarad" (players 2) (equipment {(board (square 5)) (hand Each) (piece "Marker" Each (move Step Orthogonal (to if:(is Empty (to))) (then (custodial (from (last To)) Orthogonal (between (max 1) if:(and (is Enemy (who at:(between))) (!= (centrePoint) (between))) (apply (and (remove (between)) (if (or {(can Move (custodial (from (ahead (last To) N)) Orthogonal (between (max 1) if:(and (is Enemy (who at:(between))) (!= (centrePoint) (between)))) (to if:(is Friend (who at:(to)))))) (can Move (custodial (from (ahead (last To) E)) Orthogonal (between (max 1) if:(and (is Enemy (who at:(between))) (!= (centrePoint) (between)))) (to if:(is Friend (who at:(to)))))) (can Move (custodial (from (ahead (last To) W)) Orthogonal (between (max 1) if:(and (is Enemy (who at:(between))) (!= (centrePoint) (between)))) (to if:(is Friend (who at:(to)))))) (can Move (custodial (from (ahead (last To) S)) Orthogonal (between (max 1) if:(and (is Enemy (who at:(between))) (!= (centrePoint) (between)))) (to if:(is Friend (who at:(to))))))}) (moveAgain) (if (no Moves Next) (and (set Pending) (moveAgain))))))) (to if:(is Friend (who at:(to))))))))}) (rules (start (place "Marker" "Hand" count:12)) phases:{(phase "Placement" (play (if (= (count Moves) 24) (forEach Piece) (move (from (handSite Mover)) (to (difference (sites Empty) (centrePoint))) (then (if (or (= (count Moves) 24) (not (is Prev Mover))) (moveAgain)))))) (nextPhase (= (count Moves) 25) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Step (from (last To)) Orthogonal (to if:(and (is Empty (to)) (or {(and (is Enemy (who at:(ahead (to) W))) (is Friend (who at:(ahead (ahead (to) W) W)))) (and (is Enemy (who at:(ahead (to) E))) (is Friend (who at:(ahead (ahead (to) E) E)))) (and (is Enemy (who at:(ahead (to) N))) (is Friend (who at:(ahead (ahead (to) N) N)))) (and (is Enemy (who at:(ahead (to) S))) (is Friend (who at:(ahead (ahead (to) S) S))))}))) (then (custodial (from (last To)) Orthogonal (between (max 1) if:(and (is Enemy (who at:(between))) (!= (centrePoint) (between))) (apply (and (remove (between)) (if (or {(can Move (custodial (from (ahead (last To) N)) Orthogonal (between (max 1) if:(and (is Enemy (who at:(between))) (!= (centrePoint) (between)))) (to if:(is Friend (who at:(to)))))) (can Move (custodial (from (ahead (last To) E)) Orthogonal (between (max 1) if:(and (is Enemy (who at:(between))) (!= (centrePoint) (between)))) (to if:(is Friend (who at:(to)))))) (can Move (custodial (from (ahead (last To) W)) Orthogonal (between (max 1) if:(and (is Enemy (who at:(between))) (!= (centrePoint) (between)))) (to if:(is Friend (who at:(to)))))) (can Move (custodial (from (ahead (last To) S)) Orthogonal (between (max 1) if:(and (is Enemy (who at:(between))) (!= (centrePoint) (between)))) (to if:(is Friend (who at:(to))))))}) (moveAgain) (if (no Moves Next) (and (set Pending) (moveAgain))))))) (to if:(is Friend (who at:(to))))))) (do (forEach Piece) ifAfterwards:(not (no Moves Next))))))} (end (if (no Pieces Next) (result Next Loss))))) 
The central square is the castle, which cannot be entered by pieces or by the king once it has left. There are two sides: one with the king and 8 pieces, another with 16 undifferentiated pieces. The king begins on the castle space, and his associated pieces are arranged with two pieces on each orthogonal side of the king. The opposing side is arranged on the sides of the board, one piece on each of the three central squares on each of the four sides, and one further piece on the next row in on the central square of the row. Pieces move orthogonally any number of squares. Pieces cannot jump. If a piece is caught between two opposing pieces, it is removed from play. A piece may also be captured by trapping it between an enemy piece and the castle. The king, when in the castle, can only be captured when surrounded on four sides. If it is in a space adjacent to one of the sides, it can be captured when the opponent surrounds it on the remaining three sides. Otherwise, it is captured like any other piece. If the king moves to the edge of the board, the player controlling the king wins. If the opposing side captures the king, they win. The king is captured if the enemy flanks him, except on the castle where he should be surrounded.
(game "Tablut" (players 2) (equipment {(board (square 9)) (piece "Thrall" P1 (move Slide Orthogonal (between if:(and (!= (between) (centrePoint)) (is Empty (between)))) (then (or {(custodial (from (last To)) Orthogonal (between (max 1) if:(= (what at:(between)) (id "Thrall2")) (apply (remove (between)))) (to if:(or (is Friend (who at:(to))) (= (to) (centrePoint))))) (surround (from (last To)) Orthogonal (between if:(and (= (what at:(between)) (id "Jarl2")) (or (= (between) (centrePoint)) (is In (between) (sites "OrthogonalSitesCentre")))) (apply (trigger "Surrounded" P2))) (to if:(or (is Friend (who at:(to))) (= (to) (centrePoint))))) (custodial (from (last To)) Orthogonal (between (max 1) if:(and (= (what at:(between)) (id "Jarl2")) (and (!= (between) (centrePoint)) (not (is In (between) (sites "OrthogonalSitesCentre"))))) (apply (trigger "Surrounded" P2))) (to if:(is Friend (who at:(to)))))})))) (piece "Thrall" P2 (move Slide Orthogonal (between if:(and (!= (between) (centrePoint)) (is Empty (between)))) (then (custodial (from (last To)) Orthogonal (between (max 1) if:(= (what at:(between)) (id "Thrall1")) (apply (remove (between)))) (to if:(or (is Friend (who at:(to))) (= (to) (centrePoint)))))))) (piece "Jarl" P2 (move Slide Orthogonal (between if:(and (!= (between) (centrePoint)) (is Empty (between)))) (then (custodial (from (last To)) Orthogonal (between (max 1) if:(= (what at:(between)) (id "Thrall1")) (apply (remove (between)))) (to if:(or (is Friend (who at:(to))) (= (to) (centrePoint)))))))) (regions "OrthogonalSitesCentre" (difference (expand origin:(centrePoint) Orthogonal) (centrePoint)))}) (rules (start {(place "Thrall1" {"D1" "E1" "F1" "E2" "A4" "A5" "A6" "B5" "I4" "I5" "I6" "H5" "E8" "D9" "E9" "F9" "E8"}) (place "Thrall2" {"E3" "E4" "E6" "E7" "C5" "D5" "F5" "G5"}) (place "Jarl2" (centrePoint))}) (play (forEach Piece)) (end {(if (is Within (id "Jarl2") in:(sites Outer)) (result P2 Win)) (if (is Triggered "Surrounded" P2) (result P1 Win))}))) 
11x11 board. The king is placed in the centre of the board, with his defenders around him and the attackers at the edge of the board. The attackers move first. Pieces move orthogonally any number of spaces. A pieces is captured by surrounding it on two opposite sides, by an opponent's piece. It is possible to capture two or three pieces at once by so surrounding them. It is not possible to capture a row of pieces. The defending player wins the game by moving the king to any square on the edge of the board. The attacking player wins by capturing the king. The rules are describing with the Cyningstan ruleset.
(game "Tawlbwrdd" (players 2) (equipment {(board (square 11)) (regions "Fortresses" (sites Corners)) (piece "Thrall" P1 (move Slide Orthogonal (between if:(and (not (is In (between) (union (sites Centre) (sites "Fortresses")))) (is Empty (between)))) (then (or {(custodial (from (last To)) Orthogonal (between (max 1) if:(= (what at:(between)) (id "Thrall2")) (apply (remove (between)))) (to if:(or (is Friend (who at:(to))) (is In (to) (union (sites Centre) (sites "Fortresses")))))) (custodial (from (last To)) Orthogonal (between (max 1) if:(= (what at:(between)) (id "Jarl" P2)) (apply (trigger "Surrounded" P2))) (to if:(or (is Friend (who at:(to))) (is In (to) (union (sites Centre) (sites "Fortresses"))))))})))) (piece "Thrall" P2 (move Slide Orthogonal (between if:(and (not (is In (between) (union (sites Centre) (sites "Fortresses")))) (is Empty (between)))) (then (custodial (from (last To)) Orthogonal (between (max 1) if:(= (what at:(between)) (id "Thrall1")) (apply (remove (between)))) (to if:(or (is Friend (who at:(to))) (is In (to) (union (sites Centre) (sites "Fortresses"))))))))) (piece "Jarl" P2 (move Slide Orthogonal (then (custodial (from (last To)) Orthogonal (between (max 1) if:(= (what at:(between)) (id "Thrall1")) (apply (remove (between)))) (to if:(or (is Friend (who at:(to))) (is In (to) (union (sites Centre) (sites "Fortresses")))))))))}) (rules (start {(place "Thrall1" {"D1" "E1" "F1" "G1" "H1" "F2" "A4" "A5" "A6" "A7" "A8" "B6" "K4" "K5" "K6" "K7" "K8" "J6" "F10" "D11" "E11" "F11" "G11" "H11" "F10"}) (place "Thrall2" {"F3" "F4" "F5" "C6" "D6" "E6" "G6" "H6" "I6" "F7" "F8" "F9"}) (place "Jarl2" (centrePoint))}) (play (forEach Piece)) (end {(if (is Within (id "Jarl2") in:(sites Outer)) (result P2 Win)) (if (is Triggered "Surrounded" P2) (result P1 Win))}))) 
Fanorona-Tsivy is played on a board of 9x5 intersecting lines with diagonals. Each player has 22 pieces, starting on the intersections of the lines except in the centre position, placed on opposite rows of the board, but alternating in the central row.. Pieces move to an adjacent intersection along the lines. Players must capture pieces when possible. Capturing is accomplished by moving to an adjacent intersection to an opposing piece in the continuing direction of the capturing stones movement, or by moving away from an adjacent opposing pieces in such a direction. When an opponent's piece is captured, all other of the opponent's pieces in that line are also captured. Multiple captures can be made, but cannot be done by moving twice in the same direction. Multiple captures are optional. A player wins by capturing all of the other player's pieces. The game is played on a 5x9 board
(game "Fanorona" (players 2) (equipment {(board (rectangle 5 9 diagonals:Alternating) use:Vertex) (piece "Marker" Each)}) (rules (start {(place "Marker1" (union {(union (expand (sites Bottom)) (sites {"B3" "D3" "G3" "I3"}))})) (place "Marker2" (union {(union (sites {"A3" "C3" "F3" "H3"}) (expand (sites Top)))}))}) (play (if (is Prev Mover) (or (if (is Occupied (last To)) (or (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (to) SameDirection)))})) (then (and {(fromTo (from (last From)) (to (last To))) (directional (from (last To)) (directions Vertex from:(last From) to:(last To)) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (if (can Move (or (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (to) SameDirection)))}))) (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (from) OppositeDirection)))}))))) (moveAgain))}))) (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (from) OppositeDirection)))})) (then (and {(fromTo (from (last From)) (to (last To))) (directional (from (last From)) (directions Vertex from:(last To) to:(last From)) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (if (can Move (or (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (to) SameDirection)))}))) (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (from) OppositeDirection)))}))))) (moveAgain))})))) (or (move Select (from (last From)) (to (sites Around (last From)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (to) SameDirection)))})) (then (and {(fromTo (from (last From)) (to (last To))) (directional (from (last To)) (directions Vertex from:(last From) to:(last To)) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (if (can Move (or (move Select (from (last From)) (to (sites Around (last From)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (to) SameDirection)))}))) (move Select (from (last From)) (to (sites Around (last From)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (from) OppositeDirection)))}))))) (moveAgain))}))) (move Select (from (last From)) (to (sites Around (last From)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (from) OppositeDirection)))})) (then (and {(fromTo (from (last From)) (to (last To))) (directional (from (last From)) (directions Vertex from:(last To) to:(last From)) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (if (can Move (or (move Select (from (last From)) (to (sites Around (last From)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (to) SameDirection)))}))) (move Select (from (last From)) (to (sites Around (last From)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (from) OppositeDirection)))}))))) (moveAgain))}))))) (move Pass)) (priority {(or (forEach Piece (move Select (from) (to (sites Around (from)) if:(and (is Empty (to)) (is Enemy (who at:(ahead (to) SameDirection))))) (then (and (fromTo (from (last From)) (to (last To))) (directional (from (last To)) (directions Vertex from:(last From) to:(last To)) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))))) (then (if (can Move (or (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (to) SameDirection)))})) (then (and {(fromTo (from (last From)) (to (last To))) (directional (from (last To)) (directions Vertex from:(last From) to:(last To)) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (if (can Move (or (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (to) SameDirection)))}))) (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (from) OppositeDirection)))}))))) (moveAgain))}))) (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (from) OppositeDirection)))})) (then (and {(fromTo (from (last From)) (to (last To))) (directional (from (last From)) (directions Vertex from:(last To) to:(last From)) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (if (can Move (or (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (to) SameDirection)))}))) (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (from) OppositeDirection)))}))))) (moveAgain))}))))) (moveAgain)))) (forEach Piece (move Select (from) (to (sites Around (from)) if:(and (is Empty (to)) (is Enemy (who at:(ahead (from) OppositeDirection))))) (then (and (fromTo (from (last From)) (to (last To))) (directional (from (last From)) (directions Vertex from:(last To) to:(last From)) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))))) (then (if (can Move (or (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (to) SameDirection)))})) (then (and {(fromTo (from (last From)) (to (last To))) (directional (from (last To)) (directions Vertex from:(last From) to:(last To)) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (if (can Move (or (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (to) SameDirection)))}))) (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (from) OppositeDirection)))}))))) (moveAgain))}))) (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (from) OppositeDirection)))})) (then (and {(fromTo (from (last From)) (to (last To))) (directional (from (last From)) (directions Vertex from:(last To) to:(last From)) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (if (can Move (or (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (to) SameDirection)))}))) (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (from) OppositeDirection)))}))))) (moveAgain))}))))) (moveAgain))))) (forEach Piece (move Step (to if:(is Empty (to)))))}))) (end (if (no Pieces Mover) (result Next Win))))) 
9x5 intersecting lines with diagonals in each square formed by 3x3 intersecting lines. Each player has 22 pieces, starting on the intersections of the lines except in the centre position, placed on opposite rows of the board, but alternating in the central row. Pieces move to an adjacent intersection along the lines. In the first phase of play, one player cannot capture until they have been reduced to five pieces. The opponent may only capture, according to the following rules, but only one piece at a time is captured, even when multiple would normally be allowed. When the one player is reduced to five pieces, play continues as follows. Players must capture pieces when possible. Capturing is accomplished by moving to an adjacent intersection to an opposing piece in the continuing direction of the capturing stones movement, or by moving away from an adjacent opposing pieces in such a direction. When an opponent's piece is captured, all other of the opponent's pieces in that line are also captured. Multiple captures can be made, but cannot be done by moving twice in the same direction. Multiple captures are optional. A player wins by capturing all of the other player's pieces.
(game "Vela" (players 2) (equipment {(board (rectangle 5 9 diagonals:Alternating) use:Vertex) (piece "Marker" Each)}) (rules (start {(place "Marker1" (union (expand (sites Bottom)) (sites {"B3" "D3" "G3" "I3"}))) (place "Marker2" (union (sites {"A3" "C3" "F3" "H3"}) (expand (sites Top))))}) phases:{(phase "CapturingFirstPhase" (play (priority {(if (is Mover P1) (or (forEach Piece (move Select (from) (to (sites Around (from)) if:(and (is Empty (to)) (is Enemy (who at:(ahead (to) SameDirection))))) (then (and (fromTo (from (last From)) (to (last To))) (directional (from (last To)) (directions Vertex from:(last From) to:(last To)) (to if:(is Enemy (who at:(to))) (apply (remove (to))))))))) (forEach Piece (move Select (from) (to (sites Around (from)) if:(and (is Empty (to)) (is Enemy (who at:(ahead (from) OppositeDirection))))) (then (and (fromTo (from (last From)) (to (last To))) (directional (from (last From)) (directions Vertex from:(last To) to:(last From)) (to if:(is Enemy (who at:(to))) (apply (remove (to))))))))))) (forEach Piece (move Step (to if:(is Empty (to)))))})) (nextPhase (<= (count Pieces P2) 5) "FanoronaPhase")) (phase "FanoronaPhase" (play (if (is Prev Mover) (or (if (is Occupied (last To)) (or (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (to) SameDirection)))})) (then (and {(fromTo (from (last From)) (to (last To))) (directional (from (last To)) (directions Vertex from:(last From) to:(last To)) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (if (can Move (or (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (to) SameDirection)))}))) (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (from) OppositeDirection)))}))))) (moveAgain))}))) (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (from) OppositeDirection)))})) (then (and {(fromTo (from (last From)) (to (last To))) (directional (from (last From)) (directions Vertex from:(last To) to:(last From)) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (if (can Move (or (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (to) SameDirection)))}))) (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (from) OppositeDirection)))}))))) (moveAgain))})))) (or (move Select (from (last From)) (to (sites Around (last From)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (to) SameDirection)))})) (then (and {(fromTo (from (last From)) (to (last To))) (directional (from (last To)) (directions Vertex from:(last From) to:(last To)) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (if (can Move (or (move Select (from (last From)) (to (sites Around (last From)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (to) SameDirection)))}))) (move Select (from (last From)) (to (sites Around (last From)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (from) OppositeDirection)))}))))) (moveAgain))}))) (move Select (from (last From)) (to (sites Around (last From)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (from) OppositeDirection)))})) (then (and {(fromTo (from (last From)) (to (last To))) (directional (from (last From)) (directions Vertex from:(last To) to:(last From)) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (if (can Move (or (move Select (from (last From)) (to (sites Around (last From)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (to) SameDirection)))}))) (move Select (from (last From)) (to (sites Around (last From)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (from) OppositeDirection)))}))))) (moveAgain))}))))) (move Pass)) (priority {(or (forEach Piece (move Select (from) (to (sites Around (from)) if:(and (is Empty (to)) (is Enemy (who at:(ahead (to) SameDirection))))) (then (and (fromTo (from (last From)) (to (last To))) (directional (from (last To)) (directions Vertex from:(last From) to:(last To)) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))))) (then (if (can Move (or (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (to) SameDirection)))})) (then (and {(fromTo (from (last From)) (to (last To))) (directional (from (last To)) (directions Vertex from:(last From) to:(last To)) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (if (can Move (or (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (to) SameDirection)))}))) (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (from) OppositeDirection)))}))))) (moveAgain))}))) (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (from) OppositeDirection)))})) (then (and {(fromTo (from (last From)) (to (last To))) (directional (from (last From)) (directions Vertex from:(last To) to:(last From)) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (if (can Move (or (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (to) SameDirection)))}))) (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (from) OppositeDirection)))}))))) (moveAgain))}))))) (moveAgain)))) (forEach Piece (move Select (from) (to (sites Around (from)) if:(and (is Empty (to)) (is Enemy (who at:(ahead (from) OppositeDirection))))) (then (and (fromTo (from (last From)) (to (last To))) (directional (from (last From)) (directions Vertex from:(last To) to:(last From)) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))))) (then (if (can Move (or (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (to) SameDirection)))})) (then (and {(fromTo (from (last From)) (to (last To))) (directional (from (last To)) (directions Vertex from:(last From) to:(last To)) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (if (can Move (or (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (to) SameDirection)))}))) (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (from) OppositeDirection)))}))))) (moveAgain))}))) (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (from) OppositeDirection)))})) (then (and {(fromTo (from (last From)) (to (last To))) (directional (from (last From)) (directions Vertex from:(last To) to:(last From)) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (if (can Move (or (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (to) SameDirection)))}))) (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (from) OppositeDirection)))}))))) (moveAgain))}))))) (moveAgain))))) (forEach Piece (move Step (to if:(is Empty (to)))))}))) (end (if (no Pieces Mover) (result Next Win))))})) 
Your turn is in two parts. First, a player may move one of their stones up to two spaces in any direction, including diagonally, in what is called a passive (or set up) move. Second, they take a more aggressive move, which must be the same direction and number of spaces as the first move. It is this second move that allows you to push stones across the board - or off the board's edge. A passive move can be done only if it can be followed by an aggressive move. Remove all four of your opponent's stones from just one of the four boards to win.
(game "Shobu" (players 2) (equipment {(board (merge {(square 4) (shift 5 0 (square 4)) (shift 0 5 (square 4)) (shift 5 5 (square 4))})) (piece "Ball" Each) (regions "BottomDark" (expand origin:(coord "A1") steps:3)) (regions "TopDark" (expand origin:(coord "A5") steps:3)) (regions "BottomLight" (expand origin:(coord "E1") steps:3)) (regions "TopLight" (expand origin:(coord "E5") steps:3)) (regions "Home" P1 (union (sites "BottomDark") (sites "BottomLight"))) (regions "Home" P2 (union (sites "TopLight") (sites "TopDark"))) (regions "Light" (expand (sites Right) steps:3)) (regions "Dark" (expand (sites Left) steps:3))}) (rules (start {(place "Ball1" (union (sites Bottom) (sites Row 4))) (place "Ball2" (union (sites Top) (sites Row 3)))}) phases:{(phase "Passive" (play (do (forEach Piece (if (is In (from) (sites Mover "Home")) (move Slide (between (max 2) if:(is Empty (between))))) (then (moveAgain))) ifAfterwards:(can Move (forEach Piece (if (is In (from) (if (is In (last To) (sites "Dark")) (sites "Light") (sites "Dark"))) (or (move Slide (directions Cell from:(last From) to:(last To)) (between (exact (count Steps (last From) (last To))) if:(is Empty (between))) (to if:(or (is Empty (to)) (and (is Enemy (who at:(to))) (or (is Empty (ahead (to) (directions Cell from:(last From) to:(last To)))) (= (ahead (to) (directions Cell from:(last From) to:(last To))) (to))))) (apply (if (is Enemy (who at:(to))) (if (= (ahead (to) (directions Cell from:(last From) to:(last To))) (to)) (remove (to)) (fromTo (from (to)) (to (ahead (to) (directions Cell from:(last From) to:(last To)))))))))) (if (and {(= (count Steps (last From) (last To)) 2) (is Enemy (who at:(ahead (from) (directions Cell from:(last From) to:(last To))))) (is Empty (ahead (from) steps:2 (directions Cell from:(last From) to:(last To)))) (if (= (from) (ahead (from) steps:3 (directions Cell from:(last From) to:(last To)))) True (is Empty (ahead (from) steps:3 (directions Cell from:(last From) to:(last To)))))}) (move (from (from)) (to (ahead (from) steps:2 (directions Cell from:(last From) to:(last To)))) (then (if (= (ahead (last To) (directions Cell from:(last From) to:(last To))) (last To)) (remove (ahead (last From) (directions Cell from:(last From) to:(last To)))) (fromTo (from (ahead (last From) (directions Cell from:(last From) to:(last To)))) (to (ahead (last To) (directions Cell from:(last From) to:(last To))))))))))))))) (nextPhase Mover "Agressive")) (phase "Agressive" (play (forEach Piece (if (is In (from) (if (is In (last To) (sites "Dark")) (sites "Light") (sites "Dark"))) (or (move Slide (directions Cell from:(last From) to:(last To)) (between (exact (count Steps (last From) (last To))) if:(is Empty (between))) (to if:(or (is Empty (to)) (and (is Enemy (who at:(to))) (or (is Empty (ahead (to) (directions Cell from:(last From) to:(last To)))) (= (ahead (to) (directions Cell from:(last From) to:(last To))) (to))))) (apply (if (is Enemy (who at:(to))) (if (= (ahead (to) (directions Cell from:(last From) to:(last To))) (to)) (remove (to)) (fromTo (from (to)) (to (ahead (to) (directions Cell from:(last From) to:(last To)))))))))) (if (and {(= (count Steps (last From) (last To)) 2) (is Enemy (who at:(ahead (from) (directions Cell from:(last From) to:(last To))))) (is Empty (ahead (from) steps:2 (directions Cell from:(last From) to:(last To)))) (if (= (from) (ahead (from) steps:3 (directions Cell from:(last From) to:(last To)))) True (is Empty (ahead (from) steps:3 (directions Cell from:(last From) to:(last To)))))}) (move (from (from)) (to (ahead (from) steps:2 (directions Cell from:(last From) to:(last To)))) (then (if (= (ahead (last To) (directions Cell from:(last From) to:(last To))) (last To)) (remove (ahead (last From) (directions Cell from:(last From) to:(last To)))) (fromTo (from (ahead (last From) (directions Cell from:(last From) to:(last To)))) (to (ahead (last To) (directions Cell from:(last From) to:(last To))))))))))))) (nextPhase Mover "Passive"))} (end (if (or {(all Sites (sites Occupied by:Next) if:(not (is In (site) (sites "BottomDark")))) (all Sites (sites Occupied by:Next) if:(not (is In (site) (sites "TopDark")))) (all Sites (sites Occupied by:Next) if:(not (is In (site) (sites "BottomLight")))) (all Sites (sites Occupied by:Next) if:(not (is In (site) (sites "TopLight"))))}) (result Mover Win))))) 
8x8 board. Twelve pieces per player. Pieces move forward diagonally to an empty space on the board. A piece may capture an opponent's adjacent piece by hopping over it to an empty space immediately on the opposite side of the opponent's piece. Multiple captures are allowed. Captures can be made in a forward or backward direction. Captures are compulsory, but it is not required to choose a capture sequence that captures the most pieces. A piece which reaches the opposite edge of the board from where it started is promoted to a king. Kings move any number of spaces forward or backward. They also may capture a single piece if there is at least one empty space beyond it, and can change direction after a capture. Kings must also make all possible captures in a sequence. The player who captures all of the opponent's pieces wins.
(game "American Pool Checkers" (players 2) (equipment {(board (square 8)) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (difference (expand (sites Bottom) steps:(- 3 1)) (sites Phase 1))) (place "Counter2" (difference (expand (sites Top) steps:(- 3 1)) (sites Phase 1)))}) (play (if (is Prev Mover) (if (= (what at:(last To)) (id "Counter" Mover)) (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover))))) (max Moves (move Hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))))) (priority {(or (forEach Piece "Counter" (move Hop (from) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))))) (max Moves (forEach Piece "DoubleCounter" (move Hop Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))))) (or (forEach Piece "Counter" (move Step (directions {FR FL}) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))) (forEach Piece "DoubleCounter" (move Slide Diagonal)))}))) (end (if (no Moves Next) (result Mover Win))))) 
8x8 board. Twelve pieces per player. Pieces begin on the dark spaces. White plays first. Players alternate turns moving their pieces diagonally one space forward to an empty space. A piece may capture an opponent's piece by hopping over it to an empty space on the opposite side of the opponent's piece, in a forward direction only. When pieces are captured, they are placed underneath the piece making the capture, forming a stack, controlled by the player whose piece is on top, the "commander." When a stack is captured, the commander is captured and the capturing piece becomes the commander, thus reducing the stack by one. The piece which is now on top of the stack now becomes the commander of that stack. Stacks always move together and cannot be broken apart. Capturing is compulsory when it is possible. There is no obligation to capture the maximum number of pieces. A player who captures the commmander of a stack can only capture from the same stack in the same turn again if there is another intervening capture between the two captures from the stack. When a piece reaches the opposite end of the board from where it started, it becomes a king immediately. If it its promoted in the midst of a sequence of captures, it may begin to capture as a king immediately when it is promoted. Kings move any number of spaces in either direction. Kings may capture by hopping over any distance, as long as there are no intervening pieces, and may land on any space beyond the captured piece, as long as the move is in a straight line and the captured piece is the only piece in the line. When a king is capturing and there is a choice for where it ends its capturing leap, an option which allows further captures must be taken if possible. Kings retain their rank when in a stack. Stacks move according to the rank of its commander. Play continues until one player cannot make a legal move; the opponent wins.
(game "Bashni" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Counter" Each) (piece "CounterStar" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (difference (expand (sites Bottom) steps:(- 3 1)) (sites Phase 1))) (place "Counter2" (difference (expand (sites Top) steps:(- 3 1)) (sites Phase 1)))}) (play (if (is Prev Mover) (if (= (what at:(last To) level:(topLevel at:(last To))) (id "Counter" Mover)) (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (fromTo (from (between)) (to)))) (to if:(and (is In (from) (sites Occupied by:Mover)) (is Empty (to)))) stack:True (then (if (is In (last To) (sites Next)) (promote (last To) (piece "CounterStar") Mover) (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (fromTo (from (between)) (to)))) (to if:(and (is In (from) (sites Occupied by:Mover)) (is Empty (to)))) stack:True)) (moveAgain))))) (move Hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (last Between))) (is Enemy (who at:(between)))) (apply (fromTo (from (between)) (to)))) (to if:(and (is In (from) (sites Occupied by:Mover)) (is Empty (to)))) stack:True (then (if (can Move (hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (last Between))) (is Enemy (who at:(between)))) (apply (fromTo (from (between)) (to)))) (to if:(and (is In (from) (sites Occupied by:Mover)) (is Empty (to)))) stack:True)) (moveAgain))))) (priority {(or {(forEach Piece "Counter" (move Hop (from) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (fromTo (from (between)) (to)))) (to if:(and (is In (from) (sites Occupied by:Mover)) (is Empty (to)))) stack:True (then (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (fromTo (from (between)) (to)))) (to if:(and (is In (from) (sites Occupied by:Mover)) (is Empty (to)))) stack:True)) (moveAgain)))) top:True (then (if (is In (last To) (sites Next)) (promote (last To) (piece "CounterStar") Mover)))) (forEach Piece "CounterStar" (move Hop (from) Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (fromTo (from (between)) (to)))) (to if:(and (is In (from) (sites Occupied by:Mover)) (is Empty (to)))) stack:True (then (if (can Move (hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (last Between))) (is Enemy (who at:(between)))) (apply (fromTo (from (between)) (to)))) (to if:(and (is In (from) (sites Occupied by:Mover)) (is Empty (to)))) stack:True)) (moveAgain)))) top:True)}) (or {(forEach Piece "Counter" (move Step (directions {FR FL}) (to if:(and (is In (from) (sites Occupied by:Mover)) (is Empty (to)))) stack:True) top:True (then (if (is In (last To) (sites Next)) (promote (last To) (piece "CounterStar") Mover)))) (forEach Piece "CounterStar" (move Slide Diagonal stack:True) top:True)})}))) (end (if (no Moves Next) (result Mover Win))))) 
Played on an 8x8 board with 12 pieces per side. Pieces move one space diagonally. Capturing occurs when an opponent's piece is adjacent to a player's piece and there is an open space on the other side of the opponent and the player's piece jumps the opponent's. Capturing can happen either forwards or backwards. Capturing must happen if it is possible. Multiple jumps can be made in a turn, and the maximum number of jumps must be made. Pieces become kings when they reach the opposite side of the board from which they started at the end of its turn. Kings can move multiple spaces in one direction.
(game "Brazilian Draughts" (players 2) (equipment {(board (square 8)) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (difference (expand (sites Bottom) steps:(- 3 1)) (sites Phase 1))) (place "Counter2" (difference (expand (sites Top) steps:(- 3 1)) (sites Phase 1)))}) (play (if (is Prev Mover) (if (= (what at:(last To)) (id "Counter" Mover)) (max Moves (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))))) (max Moves (move Hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))))) (priority {(max Moves (or (forEach Piece "Counter" (move Hop (from) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))))) (forEach Piece "DoubleCounter" (move Hop Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))))) (or (forEach Piece "Counter" (move Step (directions {FR FL}) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))) (forEach Piece "DoubleCounter" (move Slide Diagonal)))}))) (end (if (no Moves Next) (result Mover Win))))) 
Played on a 12x12 board with 30 pieces per player, arranged on the dark squares. Pieces move diagonally one or can jump an opponent's adjacent player to capture it. Pieces can move forward or backwards. When a piece reaches the opposite edge of the board from its starting position, it becomes a king and can may move and jump over any number of spaces diagonally. Captures are compulsory and the maximum number of jumps must be made. Winning is achieved by capturing all the opponent's pieces or by blocking them from moving. The rules are the standard ones.
(game "Canadian Draughts" (players 2) (equipment {(board (square 12)) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (difference (expand (sites Bottom) steps:(- 5 1)) (sites Phase 1))) (place "Counter2" (difference (expand (sites Top) steps:(- 5 1)) (sites Phase 1)))}) (play (if (is Prev Mover) (if (= (what at:(last To)) (id "Counter" Mover)) (max Moves (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))))) (max Moves (move Hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))))) (priority {(max Moves (or (forEach Piece "Counter" (move Hop (from) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))))) (forEach Piece "DoubleCounter" (move Hop Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))))) (or (forEach Piece "Counter" (move Step (directions {FR FL}) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))) (forEach Piece "DoubleCounter" (move Slide Diagonal)))}))) (end (if (no Moves Next) (result Mover Win))))) 
8x8 Draughts board. Twelve pieces per player, arranged on the three rows closest to the players. Players alternate turns moving a piece forward diagonally to an adjacent empty space. Pieces capture an opponent's piece by hopping over it to an empty space on the opposite side of it, in a forward direction only. Captures are mandatory, and the maximum number of captures is required. Kings are made when a piece reaches the opposite edge of the board from where it started. Kings may move one space diagonally in either direction, and capture rules are the same as for pieces, except when different capturing routes are available with the same number of captures, the one which takes the most kings must be taken. In addition, if a sequence of captures can be made by a king or a regular piece, it must be made with the king. Kings cannot be captured by regular pieces. The first player to force the opponent to capture all of their pieces wins.
(game "Coc-Inbert" (players 2) (equipment {(board (square 8)) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (difference (expand (sites Bottom) steps:(- 3 1)) (sites Phase 1))) (place "Counter2" (difference (expand (sites Top) steps:(- 3 1)) (sites Phase 1)))}) (play (if (is Prev Mover) (if (= (what at:(last To)) (id "Counter" Mover)) (max Moves (move Hop (from (last To)) (directions {FR FL}) (between if:(= (what at:(between)) (id "Counter" Next)) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover) (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(= (what at:(between)) (id "Counter" Next)) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))) (max Moves (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))))) (priority {(max Moves (priority {(forEach Piece "DoubleCounter" (move Hop Diagonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))) (forEach Piece "Counter" (move Hop (from) (directions {FR FL}) (between if:(= (what at:(between)) (id "Counter" Next)) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover) (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(= (what at:(between)) (id "Counter" Next)) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))))})) (or (forEach Piece "Counter" (move Step (directions {FR FL}) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))) (forEach Piece "DoubleCounter" (move Step Diagonal (to if:(is Empty (to))))))}))) (end (forEach Player if:(no Pieces Player) (result Player Win))))) 
12x12 checkered board. Thirty pieces per player, placed on the white spaces in the first five ranks on each player's side. Pieces move diagonally forward or backward. The opponent's pieces are captured by hopping over them. Multiple hops by one piece are allowed in one turn if they are possible. When they reach the opposite edge of the board from where they started, they become Kings. Kings may move diagonally any number of spaces. They may capture pieces proceeding along its diagonal in one direction, as long as the next space beyond the piece to be captured is empty. It may not hop over any pieces which belong to the same player, or those belonging to the opponent except to capture them. Multiple captures for the King can only be made along the same diagonal, except when it makes a capture that brings it to the edge of the board, it can make another capture along the next available diagonal, if possible. The player who captures all of the opponent's pieces wins. 
(game "Dam" (players 2) (equipment {(board (square 12)) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (difference (expand (sites Bottom) steps:(- 5 1)) (sites Phase 0))) (place "Counter2" (difference (expand (sites Top) steps:(- 5 1)) (sites Phase 0)))}) (play (if (is Prev Mover) (or (if (= (what at:(last To)) (id "Counter" Mover)) (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Hop (from (last To)) (if (is In (last To) (sites Outer)) (difference Diagonal OppositeDirection) SameDirection) (between before:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (if (is In (last To) (sites Outer)) (difference Diagonal OppositeDirection) SameDirection) (between before:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))) (move Pass)) (or (forEach Piece "Counter" (or (move Hop Diagonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Step Diagonal (to if:(is Empty (to)))))) (forEach Piece "DoubleCounter" (or (move Hop Diagonal (between before:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (if (is In (last To) (sites Outer)) (difference Diagonal OppositeDirection) SameDirection) (between before:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))) (move Slide (directions Diagonal))))) (then (if (and (= (what at:(last To)) (id "Counter" Mover)) (is In (last To) (sites Next))) (promote (last To) (piece "DoubleCounter") Mover))))) (end (if (no Moves Next) (result Mover Win))))) 
8x8 Draughts board. Twelve pieces per player, arranged on the three rows closest to the players. Players alternate turns moving a piece forward diagonally to an adjacent empty space. Pieces capture an opponent's piece by hopping over it to an empty space on the opposite side of it, in a forward direction only. Captures are mandatory, and the maximum number of captures is required. Kings are made when a piece reaches the opposite edge of the board from where it started. Kings may move one space diagonally in either direction, and capture rules are the same as for pieces, except when different capturing routes are available with the same number of captures, the one which takes the most kings must be taken. In addition, if a sequence of captures can be made by a king or a regular piece, it must be made with the king. Kings cannot be captured by regular pieces. When a piece does not capture the maximum number of captures and the opponent catches it, the opponent captures the opponent's piece. The first player to capture all of the opponent's pieces wins.
(game "Dama (Italy)" (players 2) (equipment {(board (square 8)) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (difference (expand (sites Bottom) steps:(- 3 1)) (sites Phase 1))) (place "Counter2" (difference (expand (sites Top) steps:(- 3 1)) (sites Phase 1)))}) (play (if (is Prev Mover) (if (= (what at:(last To)) (id "Counter" Mover)) (max Moves (move Hop (from (last To)) (directions {FR FL}) (between if:(= (what at:(between)) (id "Counter" Next)) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover) (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(= (what at:(between)) (id "Counter" Next)) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))) (max Moves (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))))) (priority {(max Moves (priority {(forEach Piece "DoubleCounter" (move Hop Diagonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))) (forEach Piece "Counter" (move Hop (from) (directions {FR FL}) (between if:(= (what at:(between)) (id "Counter" Next)) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover) (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(= (what at:(between)) (id "Counter" Next)) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))))})) (or (forEach Piece "Counter" (move Step (directions {FR FL}) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))) (forEach Piece "DoubleCounter" (move Step Diagonal (to if:(is Empty (to))))))}))) (end (if (no Moves Next) (result Mover Win))))) 
5x5 grid of points, four point in each row, each alternating position with an end point on the left or right edge. Points are connecting with diagonal lines. Twelve pieces per player, positioned on the first three rows closest to the player. Players alternate turns moving a piece forward to an empty adjacent spot along the lines. A player may capture an opponent's piece by hopping over it to an empty spot on the opposite side of it along the lines. Multiple captures are allowed, if possible. When a player's piece reaches the opposite edge of the board from which it started, it becomes a king. Kings may move any distance diagonally forward or backward, and may capture any number of opponent's pieces it leaps over. The king cannot take in multiple directions in one turn. The first player to capture all of the opponent's pieces wins. 
(game "Dama (Philippines)" (players 2) (equipment {(board (rotate 45 (merge {(rectangle 5 4) (shift -1 1 (rectangle 3 6)) (shift -2 2 (rectangle 1 8)) (shift 1 -1 (rectangle 7 2))})) use:Vertex) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (expand (sites Bottom) steps:(- 3 1))) (place "Counter2" (expand (sites Top) steps:(- 3 1)))}) (play (if (is Prev Mover) (or (if (= (what at:(last To)) (id "Counter" Mover)) (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover))))) (move Hop (from (last To)) SameDirection (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) SameDirection (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))) (move Pass)) (or {(forEach Piece "Counter" (move Hop (from (from)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))))) (forEach Piece "DoubleCounter" (move Hop (from) Orthogonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) SameDirection (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))) (forEach Piece "Counter" (move Step (directions {FR FL}) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))) (forEach Piece "DoubleCounter" (move Slide))}))) (end (if (no Moves Next) (result Mover Win))))) 
8x8 checkered board. twelve pieces per player, placed on the first three rows closest to the players. Players alternate turns moving a piece forward diagonally to an empty space. Pieces may capture an opponent's piece by hopping over it to an empty adjacent space. Captures are compulsory, multiple captures are possible, the maximum capture possible is required, and failure to do so is penalized by the huff, where the piece that should have made the capture is itself captured. When a piece reaches the opposite edge of the board from where it started, it becomes a king. Kings may move any distance diagonally forward or backward, and may capture any number of opponent's pieces it leaps over. The player who captures all of the opponent's pieces wins.
(game "Damas" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (difference (expand (sites Bottom) steps:(- 3 1)) (sites Phase 1))) (place "Counter2" (difference (expand (sites Top) steps:(- 3 1)) (sites Phase 1)))}) (play (if (is Prev Mover) (if (= (what at:(last To)) (id "Counter" Mover)) (max Moves (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (and (promote (last To) (piece "DoubleCounter") Mover) (if (can Move (move Hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))) (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))) (max Moves (move Hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))) (do (set Pending (sites From (max Moves (or (forEach Piece "Counter" (move Hop (from) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (and (promote (last To) (piece "DoubleCounter") Mover) (if (can Move (move Hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))) (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))) (forEach Piece "DoubleCounter" (move Hop (from) Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))))))) next:(or {(forEach Piece "Counter" (max Moves (move Hop (from) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (and (set Value Mover (last To)) (if (is In (last To) (sites Next)) (and (promote (last To) (piece "DoubleCounter") Mover) (if (can Move (move Hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))) (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))))) (forEach Piece "DoubleCounter" (max Moves (move Hop (from) Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (and (set Value Mover (last To)) (if (can Move (move Hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))))) (forEach Piece "Counter" (move Step (directions {FR FL}) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover))))) (forEach Piece "DoubleCounter" (move Slide Diagonal))}) (then (and (if (and (!= (value Player Mover) (last To)) (not (is In (last To) (sites Pending)))) (remove (sites Pending))) (if (and (!= (value Player Mover) (last To)) (is In (last From) (sites Pending))) (remove (last To)))))))) (end (forEach Player if:(no Moves Player) (result Player Loss))))) 
8x8 checkered board, the dark spaces placed so that the bottom right corner is a dark space. Twelve pieces per player, placed on the dark spaces of the first three rows closest to the players. Players alternate turns moving a piece forward diagonally to an empty space. Pieces may capture an opponent's piece by hopping over it to an empty adjacent space. Captures are compulsory, multiple captures are possible, the maximum capture possible is not required. When a piece reaches the opposite edge of the board from where it started, it stops moving (if in a capture sequence), becomes a king, and the turn ends. Kings may move any distance diagonally forward or backward, and may capture any number of opponent's pieces it leaps over. The player who captures all of the opponent's pieces wins. 
(game "Damenspiel" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (difference (expand (sites Bottom) steps:(- 3 1)) (sites Phase 0))) (place "Counter2" (difference (expand (sites Top) steps:(- 3 1)) (sites Phase 0)))}) (play (if (is Prev Mover) (if (= (what at:(last To)) (id "Counter" Mover)) (move Hop (from (last To)) Diagonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover) (if (can Move (move Hop (from (last To)) Diagonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))) (move Hop (from (last To)) Diagonal (between before:(count Rows) (range 1 (count Rows)) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) Diagonal (between before:(count Rows) (range 1 (count Rows)) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))) (priority {(or (forEach Piece "Counter" (move Hop (from) Diagonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover) (if (can Move (move Hop (from (last To)) Diagonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))) (forEach Piece "DoubleCounter" (move Hop (from) Diagonal (between before:(count Rows) (range 1 (count Rows)) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) Diagonal (between before:(count Rows) (range 1 (count Rows)) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))) (or (forEach Piece "Counter" (move Step (directions {FR FL}) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover))))) (forEach Piece "DoubleCounter" (move Slide Diagonal)))}))) (end (if (no Pieces Next) (result Next Loss))))) 
8x8 checkered board, the dark spaces placed so that the bottom right corner is a dark space. Twelve pieces per player, placed on the dark spaces of the first three rows closest to the players. Players alternate turns moving a piece forward diagonally to an empty space. Pieces may capture an opponent's piece by hopping over it to an empty adjacent space, in a forwards or backwards direction. Captures are not compulsory, multiple captures are possible, the maximum capture possible is not required. When a piece reaches the opposite edge of the board from where it started at the end of its turn, it it promoted. If it lands on the edge of the board in the middle of a capturing sequence, it is not promoted. Promoted pieces may move any distance diagonally forward or backward, and may capture any number of opponent's pieces it leaps over. The player who captures all of the opponent's pieces wins. 
(game "Damspel" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (difference (expand (sites Bottom) steps:(- 3 1)) (sites Phase 0))) (place "Counter2" (difference (expand (sites Top) steps:(- 3 1)) (sites Phase 0)))}) (play (if (is Prev Mover) (if (= (what at:(last To)) (id "Counter" Mover)) (or (move Pass (then (forEach Site (sites Next) (if (= (what at:(site)) (id "Counter" Mover)) (promote (site) (piece "DoubleCounter") Mover))))) (move Hop (from (last To)) Diagonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) Diagonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))))) (or (move Pass) (move Hop (from (last To)) Diagonal (between before:(count Rows) (range 1 (count Rows)) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) Diagonal (between before:(count Rows) (range 1 (count Rows)) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))) (or (forEach Piece "Counter" (or (move Step (directions {FR FL}) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))) (move Hop (from) Diagonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) Diagonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover))))))) (forEach Piece "DoubleCounter" (or (move Slide Diagonal) (move Hop (from) Diagonal (between before:(count Rows) (range 1 (count Rows)) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) Diagonal (between before:(count Rows) (range 1 (count Rows)) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))))))) (end (if (no Pieces Next) (result Next Loss))))) 
10x10 board, 20 pieces per player, arranged on the dark squares, leaving the diagonal from bottom left to top right empty, with each player's pieces on opposite sides of it. Pieces move diagonally one or can jump an opponent's adjacent player to capture it. Pieces can move forward or backwards. When a piece reaches the opposite edge of the board from its starting position, it becomes a king and can may move and jump over any number of spaces diagonally. Captures are compulsory and the maximum number of jumps must be made. Winning is achieved by capturing all the opponent's pieces or by blocking them from moving. 
(game "Diagonal Draughts" (players 2) (equipment {(board (square 10)) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (difference (expand (intersection (sites Right) (sites Bottom)) steps:8 Orthogonal) (sites Phase 1))) (place "Counter2" (difference (expand (intersection (sites Left) (sites Top)) steps:8 Orthogonal) (sites Phase 1)))}) (play (if (is Prev Mover) (if (= (what at:(last To)) (id "Counter" Mover)) (max Moves (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))))) (max Moves (move Hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))))) (priority {(max Moves (or (forEach Piece "Counter" (move Hop (from) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))))) (forEach Piece "DoubleCounter" (move Hop Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))))) (or (forEach Piece "Counter" (move Step Diagonal (to if:(is Empty (to)))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))) (forEach Piece "DoubleCounter" (move Slide Diagonal)))}))) (end (if (no Moves Next) (result Mover Win))))) 
8x8 board. Eight pieces per player, which begin on alternating squares in the first two rows on opposing sides of the board. Players alternate turns moving one of their pieces to an adjacent space. Pieces move diagonally forward only. A piece may capture one of the opponent's adjacent pieces by hopping over it to an empty adjacent space immediately on the opposite side of the opponent's piece. Multiple captures are not allowed. When a piece arrives at the opposite edge of the board from where it began, it is promoted and may move diagonally forward or backward. The player who captures all of the opponent's pieces wins.
(game "Doov" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (difference (expand (sites Bottom) steps:(- 2 1)) (sites Phase 1))) (place "Counter2" (difference (expand (sites Top) steps:(- 2 1)) (sites Phase 1)))}) (play (or (or (forEach Piece "Counter" (move Hop (from) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover))))) (forEach Piece "DoubleCounter" (move Hop Diagonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))))) (or (forEach Piece "Counter" (move Step (directions {FR FL}) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))) (forEach Piece "DoubleCounter" (move Step Diagonal (to if:(is Empty (to)))))))) (end (if (no Moves Next) (result Mover Win))))) 
10x10 board, with red and white checkeres squares. Twenty pieces per player, which are arranged on the first four ranks closest to the player. Pieces move diagonally one space forward. Pieces may capture an opponent's piece by hopping over it diagonally to an empty adjacent square immediately on the other side of it. Pieces cannot capture in a backwards direction. The maximum number of pieces must be captured. If a player does not capture the maximum number of pieces, the other player may huff this piece, removing it from play. When a piece reaches the opposite edge of the board from where it started, it is promoted to king. Kings may move any distance diagonally, in a forward or backward direction. The player who captures all of their opponent's pieces wins.
(game "Dum Blas" (players {(player N) (player S)}) (equipment {(board (square 10)) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (difference (expand (sites Bottom) steps:(- 4 1)) (sites Phase 1))) (place "Counter2" (difference (expand (sites Top) steps:(- 4 1)) (sites Phase 1)))}) (play (if (is Prev Mover) (if (= (what at:(last To)) (id "Counter" Mover)) (max Moves (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))))) (max Moves (move Hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))))) (priority {(max Moves (or (forEach Piece "Counter" (move Hop (from) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))))) (forEach Piece "DoubleCounter" (move Hop Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))))) (or (forEach Piece "Counter" (move Step (directions {FR FL}) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))) (forEach Piece "DoubleCounter" (move Slide Diagonal)))}))) (end (if (no Moves Next) (result Mover Win))))) 
Played on an 8x8 board with each player having twelve pieces. Pieces move diagonally one space forward, and can capture opponent's pieces by jumping them in a forward direction if they are adjacent. Capturing must happen if it is possible. Multiple captures are allowed. Once pieces reach the opposite side of the board from their starting position, they become kings and can move diagonally either forwards or backwards. The goal is to capture all of the opponent's pieces.
(game "English Draughts" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (difference (expand (sites Bottom) steps:(- 3 1)) (sites Phase 1))) (place "Counter2" (difference (expand (sites Top) steps:(- 3 1)) (sites Phase 1)))}) (play (if (is Prev Mover) (if (= (what at:(last To)) (id "Counter" Mover)) (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover) (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))) (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))) (priority {(or (forEach Piece "Counter" (move Hop (from) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover) (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))) (forEach Piece "DoubleCounter" (move Hop Diagonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))))) (or (forEach Piece "Counter" (move Step (directions {FR FL}) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))) (forEach Piece "DoubleCounter" (move Step Diagonal (to if:(is Empty (to))))))}))) (end (if (no Moves Next) (result Mover Win))))) 
10x10 board. Twenty pieces per player, arrayed on the dark-colored spaces. The square in the left-hand corner closest to the player is a dark square. Pieces move one space forward diagonally. When a piece arrives at the furthest rank opposite their starting position, it becomes a king. Kings may move diagonally, forward or backward, any number of spaces (like a bishop in Chess). Captures are made by hopping over an adjacent piece in a diagonal or orthogonal direction, including backwards. Multiple captures are allowed, in which the player may change direction. Kings capture by flying leap. Captures are mandatory, and the maximum capture should be made based on the value of pieces. Kings are worth less than twice the number of regular pieces, but more than twice the number of pieces minus one. (e.g., three kings are worth less than six pieces, but more than five pieces). If more than one maximum capture has the same value, the one that captures more kings takes precedence. It is permitted to use the same space more than once, but not to hop over the same piece twice. Captured pieces are removed after the turn is complete. The maximum capture can be enforced when the opponent catches it, though the opponent may opt not to point it out. A king cannot make three non-capturing moves in a row without moving another king or piece. This rule does not apply if the player only has one king remaining. If one player has only two kings remaining and the opponent has only one king remaining, the player with two kings must win in seven turns. If they do not, the game is a draw. If both players have only one king remaining and neither of them is able to capture or will be forced into a position where their king will be captured on the next turn, the game is a draw. The player who captures all of their opponent's pieces wins, or if they cannot make a legal move. Standard Frisian draughts
(game "Frisian Draughts" (players 2) (equipment {(board (square 10)) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each maxState:128) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (difference (expand (sites Bottom) steps:(- 4 1)) (sites Phase 1)) value:10) (place "Counter2" (difference (expand (sites Top) steps:(- 4 1)) (sites Phase 1)) value:10)}) (play (if (is Prev Mover) (if (= (what at:(last To)) (id "Counter" Mover)) (max Moves withValue:True (or (do (move Hop (from (last To)) Orthogonal (between before:1 after:1 if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (and (if (can Move (or (do (move Hop (from (last To)) Orthogonal (between before:1 after:1 if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to)))) ifAfterwards:(is In (last To) (sites Phase 0))) (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to)))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover) (then (set Value at:(last To) 19)))) (forEach Site (sites Occupied by:Mover) (if (!= 0 (state at:(site))) (set State at:(site) 0)))))) ifAfterwards:(is In (last To) (sites Phase 0))) (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (and (if (can Move (or (do (move Hop (from (last To)) Orthogonal (between before:1 after:1 if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to)))) ifAfterwards:(is In (last To) (sites Phase 0))) (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to)))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover) (then (set Value at:(last To) 19)))) (forEach Site (sites Occupied by:Mover) (if (!= 0 (state at:(site))) (set State at:(site) 0)))))))) (max Moves withValue:True (do (move Hop (from (last To)) All (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (and (if (can Move (do (hop (from (last To)) All (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to)))) ifAfterwards:(is In (last To) (sites Phase 0)))) (moveAgain)) (forEach Site (sites Occupied by:Mover) (if (!= 0 (state at:(site))) (set State at:(site) 0)))))) ifAfterwards:(is In (last To) (sites Phase 0))))) (priority {(max Moves withValue:True (or {(forEach Piece "DoubleCounter" (do (move Hop All (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (and (if (can Move (do (hop (from (last To)) All (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to)))) ifAfterwards:(is In (last To) (sites Phase 0)))) (moveAgain)) (forEach Site (sites Occupied by:Mover) (if (!= 0 (state at:(site))) (set State at:(site) 0)))))) ifAfterwards:(is In (last To) (sites Phase 0)))) (forEach Piece "Counter" (or (do (move Hop (from (from)) Orthogonal (between before:1 after:1 if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (and (if (can Move (or (do (move Hop (from (last To)) Orthogonal (between before:1 after:1 if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to)))) ifAfterwards:(is In (last To) (sites Phase 0))) (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to)))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover) (then (set Value at:(last To) 19)))) (forEach Site (sites Occupied by:Mover) (if (!= 0 (state at:(site))) (set State at:(site) 0)))))) ifAfterwards:(is In (last To) (sites Phase 0))) (move Hop (from (from)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (and (if (can Move (or (do (move Hop (from (last To)) Orthogonal (between before:1 after:1 if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to)))) ifAfterwards:(is In (last To) (sites Phase 0))) (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to)))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover) (then (set Value at:(last To) 19)))) (forEach Site (sites Occupied by:Mover) (if (!= 0 (state at:(site))) (set State at:(site) 0))))))))})) (or (forEach Piece "Counter" (move Step (directions {FR FL}) (to if:(is Empty (to)))) (then (and (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover) (then (set Value at:(last To) 19))) (forEach Site (sites Occupied by:Mover) (if (!= 0 (state at:(site))) (set State at:(site) 0)))))) (forEach Piece "DoubleCounter" (if (if (> 2 (state at:(from))) True (not (can Move (forEach Piece "Counter" (move Step (directions {FR FL}) (to if:(is Empty (to)))))))) (move Slide Diagonal)) (then (if (!= (where "Counter" Mover) -1) (and (set State at:(last To) (+ 1 (state at:(last To)))) (forEach Site (sites Occupied by:Mover) (if (and (!= (site) (last To)) (!= 0 (state at:(site)))) (set State at:(site) 0))))))))}) (then (and (if (and (and {(= (where "Counter" P1) -1) (= (where "Counter" P2) -1) (= 1 (count Pieces Next)) (= 2 (count Pieces Mover))}) (= -1 (value Player Mover))) (set Value Mover 0)) (if (and (not (is Prev Mover)) (!= -1 (value Player Mover))) (set Value Mover (+ 1 (value Player Mover)))))))) (end {(if (no Moves Next) (result Mover Win)) (if (= 7 (value Player Mover)) (result Mover Draw))}))) 
This game is played on an empty 8x8 square chess board. Use 6 checkers and 66 Go stones. The Counterinsurgent (COIN) player places his checkers on black squares in the middle of the board. The Guerrilla player starts with no pieces on the board, but begins by placing one stone anywhere on the board, then a second stone orthogonally adjacent to the first. The Guerrilla player does not move his pieces. Instead, he places two and only two stones per turn on the board, on the intersections of the squares. The first stone must be orthogonally adjacent to any stone on the board; the second stone must be orthogonally adjacent to the first stone placed. He may not place stones on the board edge points. He captures an enemy checker by surrounding it. COIN player moves one checker per turn, one square diagonally as a King in regular checkers, or makes captures by jumping over the point between two squares. He is not forced to capture if he does not want to, but if he does he must take all possible captures. Captured stones are removed from the board. GOAL - The player who clears the board of all enemy pieces at the end of his turn wins. The Guerrilla player loses if he runs out of stones
(game "Guerrilla Checkers" (players 2) (equipment {(board (square 9) use:Vertex) (hand P1) (piece "Marker" P1) (piece "Counter" P2 (move Step (from Cell) Diagonal (to Cell if:(is Empty Cell (to))) (then (forEach Site (intersection (sites Incident Vertex of:Cell at:(last From)) (sites Incident Vertex of:Cell at:(last To))) (if (is Enemy (who at:(site))) (remove (site) (then (if (can Move (move (from Cell (last To)) (to Cell (forEach (sites Around Cell (from) Diagonal) if:(and (is Empty Cell (site)) (!= 0 (count Sites in:(forEach (intersection (sites Incident Vertex of:Cell at:(site)) (sites Incident Vertex of:Cell at:(from))) if:(is Enemy (who at:(site))))))))) (then (forEach Site (intersection (sites Incident Vertex of:Cell at:(last From)) (sites Incident Vertex of:Cell at:(last To))) (if (is Enemy (who at:(site))) (remove (site))))))) (moveAgain)))))))))}) (rules (start {(place "Counter2" Cell {"E3" "D4" "C5" "D6" "E5" "F4"}) (place "Marker1" "Hand1" count:66)}) phases:{(phase "InitGuerrilla" P1 (play (move (from (handSite Mover)) (to Vertex (difference (sites Empty Vertex) (sites Outer))) (then (moveAgain)))) (nextPhase (is Next Mover) "GuerrillaMove")) (phase "GuerrillaMove" P1 (play (if (is Prev Mover) (move (from (handSite Mover)) (to Vertex (difference (sites Around (last To) Orthogonal if:(is Empty (to))) (sites Outer))) (then (forEach Site (forEach (sites Occupied by:P2 on:Cell) if:(all Sites (sites Incident Vertex of:Cell at:(site)) if:(is Occupied Vertex (site)))) (remove Cell (site))))) (move (from (handSite Mover)) (to Vertex (difference (sites Empty Vertex) (sites Outer)) if:(not (= (count Sites in:(sites Around (to) Own Orthogonal)) 0))) (then (and (forEach Site (forEach (sites Occupied by:P2 on:Cell) if:(all Sites (sites Incident Vertex of:Cell at:(site)) if:(is Occupied Vertex (site)))) (remove Cell (site))) (moveAgain))))))) (phase "CoinMove" P2 (play (if (is Prev Mover) (move (from Cell (last To)) (to Cell (forEach (sites Around Cell (from) Diagonal) if:(and (is Empty Cell (site)) (!= 0 (count Sites in:(forEach (intersection (sites Incident Vertex of:Cell at:(site)) (sites Incident Vertex of:Cell at:(from))) if:(is Enemy (who at:(site))))))))) (then (forEach Site (intersection (sites Incident Vertex of:Cell at:(last From)) (sites Incident Vertex of:Cell at:(last To))) (if (is Enemy (who at:(site))) (remove (site) (then (if (can Move (move (from Cell (last To)) (to Cell (forEach (sites Around Cell (from) Diagonal) if:(and (is Empty Cell (site)) (!= 0 (count Sites in:(forEach (intersection (sites Incident Vertex of:Cell at:(site)) (sites Incident Vertex of:Cell at:(from))) if:(is Enemy (who at:(site))))))))) (then (forEach Site (intersection (sites Incident Vertex of:Cell at:(last From)) (sites Incident Vertex of:Cell at:(last To))) (if (is Enemy (who at:(site))) (remove (site))))))) (moveAgain)))))))) (forEach Piece))))} (end (if (no Moves Next) (result Mover Win))))) 
10x10 board, 20 pieces per player. Pieces move diagonally one or can jump an opponent's adjacent player to capture it. Pieces can move forward or backwards. When a piece reaches the opposite edge of the board from its starting position, it becomes a king and can may move and jump over any number of spaces diagonally. Captures are compulsory and the maximum number of jumps must be made. Winning is achieved by capturing all the opponent's pieces or by blocking them from moving.
(game "International Draughts" (players {(player N) (player S)}) (equipment {(board (square 10)) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (difference (expand (sites Bottom) steps:(- 4 1)) (sites Phase 1))) (place "Counter2" (difference (expand (sites Top) steps:(- 4 1)) (sites Phase 1)))}) (play (if (is Prev Mover) (if (= (what at:(last To)) (id "Counter" Mover)) (max Moves (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))))) (max Moves (move Hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))))) (priority {(max Moves (or (forEach Piece "Counter" (move Hop (from) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))))) (forEach Piece "DoubleCounter" (move Hop Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))))) (or (forEach Piece "Counter" (move Step (directions {FR FL}) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))) (forEach Piece "DoubleCounter" (move Slide Diagonal)))}))) (end (if (no Moves Next) (result Mover Win))))) 
8x8 board, twelve pieces per player. Pieces placed on the dark squares of the first three rows of each side, with the empty corner to the right of each player. Pieces move one space forward diagonally. They may capture pieces of the opponent by hopping over them. Captures may happen in any direction. Multiple captures are allowed in the same turn, but they may not hop over the same piece or a player's own piece. Captures are compulsory, but if more than one option exists the player may choose which capture to make. When a piece reaches the opposite edge of the board, it becomes a king, even if this is in the middle of a turn. Kings may move any number of spaces forward or backwards, and may capture by flying leap. Kings must take all possible pieces in a sequence. The player to capture all of the other player's pieces wins.
(game "Jekab" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (difference (expand (sites Bottom) steps:(- 3 1)) (sites Phase 1))) (place "Counter2" (difference (expand (sites Top) steps:(- 3 1)) (sites Phase 1)))}) (play (if (is Prev Mover) (if (= (what at:(last To)) (id "Counter" Mover)) (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (and (if (can Move (move Hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))) (moveAgain)) (promote (last To) (piece "DoubleCounter") Mover)) (if (can Move (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))))) (moveAgain))))) (max Moves (move Hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))))) (priority {(or (forEach Piece "Counter" (move Hop (from) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (and (if (can Move (move Hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))) (moveAgain)) (promote (last To) (piece "DoubleCounter") Mover)) (if (can Move (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))))) (moveAgain)))))) (max Moves (forEach Piece "DoubleCounter" (move Hop Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))))) (or (forEach Piece "Counter" (move Step (directions {FR FL}) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))) (forEach Piece "DoubleCounter" (move Slide Diagonal)))}))) (end (if (no Moves Next) (result Mover Win))))) 
Played on a 7x7 board. Each player has 11 pieces. they move diagonally one space or can capture opposing pieces by jumping. When captured, a piece is placed underneath the capturing piece, creating columns. When columns are captured, only the piece at the top of the column is taken. Columns are controlled by the player whose piece is on top of the column. When a piece or column reaches the opposite side of the board they become promoted to officer and can move backwards. A player wins by capturing all of the opponent's pieces. The game is played in a Chess board.
(game "Lasca" (players {(player N) (player S)}) (equipment {(board (square 7)) (piece "Counter" Each) (piece "CounterStar" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (difference (expand (sites Bottom) steps:2) (sites Phase 1))) (place "Counter2" (difference (expand (sites Top) steps:2) (sites Phase 1)))}) (play (if (is Prev Mover) (if (= (what at:(last To) level:(topLevel at:(last To))) (id "Counter" Mover)) (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (fromTo (from (between)) (to)))) (to if:(and (is In (from) (sites Occupied by:Mover)) (is Empty (to)))) stack:True (then (if (is In (last To) (sites Next)) (promote (last To) (piece "CounterStar") Mover) (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (fromTo (from (between)) (to)))) (to if:(and (is In (from) (sites Occupied by:Mover)) (is Empty (to)))) stack:True)) (moveAgain))))) (move Hop (from (last To)) Diagonal (between if:(is Enemy (who at:(between))) (apply (fromTo (from (between)) (to)))) (to if:(and (is In (from) (sites Occupied by:Mover)) (is Empty (to)))) stack:True (then (if (can Move (move Hop (from (last To)) Diagonal (between if:(is Enemy (who at:(between))) (apply (fromTo (from (between)) (to)))) (to if:(and (is In (from) (sites Occupied by:Mover)) (is Empty (to)))) stack:True)) (moveAgain))))) (priority {(or {(forEach Piece "Counter" (move Hop (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (fromTo (from (between)) (to)))) (to if:(and (is In (from) (sites Occupied by:Mover)) (is Empty (to)))) stack:True (then (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (fromTo (from (between)) (to)))) (to if:(and (is In (from) (sites Occupied by:Mover)) (is Empty (to)))) stack:True)) (moveAgain)))) top:True (then (if (is In (last To) (sites Next)) (promote (last To) (piece "CounterStar") Mover)))) (forEach Piece "CounterStar" (move Hop Diagonal (between if:(is Enemy (who at:(between))) (apply (fromTo (from (between)) (to)))) (to if:(and (is In (from) (sites Occupied by:Mover)) (is Empty (to)))) stack:True (then (if (can Move (move Hop (from (last To)) Diagonal (between if:(is Enemy (who at:(between))) (apply (fromTo (from (between)) (to)))) (to if:(and (is In (from) (sites Occupied by:Mover)) (is Empty (to)))) stack:True)) (moveAgain)))) top:True)}) (or {(forEach Piece "Counter" (move Step (directions {FR FL}) (to if:(and (is In (from) (sites Occupied by:Mover)) (is Empty (to)))) stack:True) top:True (then (if (is In (last To) (sites Next)) (promote (last To) (piece "CounterStar") Mover)))) (forEach Piece "CounterStar" (move Step Diagonal (to if:(and (is In (from) (sites Occupied by:Mover)) (is Empty (to)))) stack:True) top:True)})}))) (end (if (no Moves Next) (result Mover Win))))) 
8x8 board. Twelve pieces per player. Pieces move diagonally one space forward, and can capture opponent's pieces by jumping them in a forward direction if they are adjacent. Capturing must happen if it is possible. Multiple captures are allowed. Once pieces reach the opposite side of the board from their starting position, they become kings and can move diagonally either forwards or backwards, and can capture by jumping over any number of pieces, any distance. The goal is to capture all of the opponent's pieces.
(game "Main Dam" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (difference (expand (sites Bottom) steps:(- 3 1)) (sites Phase 1))) (place "Counter2" (difference (expand (sites Top) steps:(- 3 1)) (sites Phase 1)))}) (play (if (is Prev Mover) (if (= (what at:(last To)) (id "Counter" Mover)) (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover) (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))) (move Hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))) (priority {(or (forEach Piece "Counter" (move Hop (from) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover) (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))) (forEach Piece "DoubleCounter" (move Hop Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))))) (or (forEach Piece "Counter" (move Step (directions {FR FL}) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))) (forEach Piece "DoubleCounter" (move Slide Diagonal)))}))) (end (if (no Moves Next) (result Mover Win))))) 
8x8 board, twelve pieces per player, arranged on the black spaces. Pieces move diagonally one space, or may hop an opponent's piece to capture it. Pieces may also capture orthogonally, but must remain on the black spaces. When a piece reaches the opponent's edge of the board, the piece becomes a "Dam," and may move diagonally or orthogonally any number of spaces, including to jump over one piece. The player who captures all the opponent's pieces wins. 
(game "Makvoer" (players 2) (equipment {(board (square 8)) (piece "Counter" Each (or {(move Step Diagonal (to if:(is Empty (to)))) (move Hop Diagonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (do (move Hop Orthogonal (between before:1 after:2 if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) ifAfterwards:(is In (last To) (sites Phase 0)))} (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover))))) (piece "DoubleCounter" Each (or (move Slide) (move Hop (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))))) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (difference (expand (sites Bottom) steps:(- 3 1)) (sites Phase 1))) (place "Counter2" (difference (expand (sites Top) steps:(- 3 1)) (sites Phase 1)))}) (play (forEach Piece)) (end (if (no Pieces Next) (result Next Loss))))) 
10x10 board. Twenty pieces per player, which begin in the four rows closest to the players. Pieces move diagonally forward one space. Pieces capture orthogonally or diagonally, in any direction, when there is one empty space between the piece and the opponent's piece, and an empty space immediately on the opposite side of the opponent's piece. Pieces are promoted to Queen when they reach the edge of the board opposite from where they start. Queens may capture orthogonally or diagonally in any direction over any distance, as long as there are no other pieces intervening and there is an empty spot immediately after the piece to be captured, which is where the Queen lands to make the capture. Multiple captures are allowed for Queens and regular pieces. Queens move orthogonally or diagonally any distance. The player who captures all of the opponent's pieces wins.
(game "Maleys" (players {(player N) (player S)}) (equipment {(board (square 10)) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (difference (expand (sites Bottom) steps:(- 4 1)) (sites Phase 1))) (place "Counter2" (difference (expand (sites Top) steps:(- 4 1)) (sites Phase 1)))}) (play (if (is Prev Mover) (or (if (= (what at:(last To)) (id "Counter" Mover)) (or (move Hop (from (last To)) Diagonal (between before:1 if:(and (= 2 (count Steps (from) (between))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (and (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)) (if (can Move (or (move Hop (from (last To)) Diagonal (between before:1 if:(and (= 2 (count Steps (from) (between))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to)))) (do (move Hop (from (last To)) Orthogonal (between before:3 after:1 if:(and (= 4 (count Steps (from) (between))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to)))) ifAfterwards:(is In (last To) (sites Phase 0))))) (moveAgain))))) (do (move Hop (from (last To)) Orthogonal (between before:3 after:1 if:(and (= 4 (count Steps (from) (between))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to)))) ifAfterwards:(is In (last To) (sites Phase 0)) (then (and (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)) (if (can Move (or (move Hop (from (last To)) Diagonal (between before:1 if:(and (= 2 (count Steps (from) (between))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to)))) (do (move Hop (from (last To)) Orthogonal (between before:3 after:1 if:(and (= 4 (count Steps (from) (between))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to)))) ifAfterwards:(is In (last To) (sites Phase 0))))) (moveAgain)))))) (or (move Hop (from (last To)) Diagonal (between before:1 if:(and (= 2 (count Steps (from) (between))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (or (move Hop (from (last To)) Diagonal (between before:1 if:(and (= 2 (count Steps (from) (between))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to)))) (do (move Hop (from (last To)) Orthogonal (between before:3 after:1 if:(and (= 4 (count Steps (from) (between))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to)))) ifAfterwards:(is In (last To) (sites Phase 0))))) (moveAgain)))) (do (move Hop (from (last To)) Orthogonal (between before:3 after:1 if:(and (= 4 (count Steps (from) (between))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to)))) ifAfterwards:(is In (last To) (sites Phase 0)) (then (if (can Move (or (move Hop (from (last To)) Diagonal (between before:1 if:(and (= 2 (count Steps (from) (between))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to)))) (do (move Hop (from (last To)) Orthogonal (between before:3 after:1 if:(and (= 4 (count Steps (from) (between))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to)))) ifAfterwards:(is In (last To) (sites Phase 0))))) (moveAgain)))))) (move Pass)) (or (forEach Piece "Counter" (or {(move Step (directions {FR FL}) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))) (move Hop (from) Diagonal (between before:1 if:(and (= 2 (count Steps (from) (between))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (and (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)) (if (can Move (or (move Hop (from (last To)) Diagonal (between before:1 if:(and (= 2 (count Steps (from) (between))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to)))) (do (move Hop (from (last To)) Orthogonal (between before:3 after:1 if:(and (= 4 (count Steps (from) (between))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to)))) ifAfterwards:(is In (last To) (sites Phase 0))))) (moveAgain))))) (do (move Hop (from) Orthogonal (between before:3 after:1 if:(and (= 4 (count Steps (from) (between))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to)))) ifAfterwards:(is In (last To) (sites Phase 0)) (then (and (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)) (if (can Move (or (move Hop (from (last To)) Diagonal (between before:1 if:(and (= 2 (count Steps (from) (between))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to)))) (do (move Hop (from (last To)) Orthogonal (between before:3 after:1 if:(and (= 4 (count Steps (from) (between))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to)))) ifAfterwards:(is In (last To) (sites Phase 0))))) (moveAgain)))))})) (forEach Piece "DoubleCounter" (or {(do (move Slide) ifAfterwards:(is In (last To) (sites Phase 0))) (move Hop (from) Diagonal (between before:1 if:(and (= 2 (count Steps (from) (between))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (or (move Hop (from (last To)) Diagonal (between before:1 if:(and (= 2 (count Steps (from) (between))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to)))) (do (move Hop (from (last To)) Orthogonal (between before:3 after:1 if:(and (= 4 (count Steps (from) (between))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to)))) ifAfterwards:(is In (last To) (sites Phase 0))))) (moveAgain)))) (do (move Hop (from) Orthogonal (between before:3 after:1 if:(and (= 4 (count Steps (from) (between))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to)))) ifAfterwards:(is In (last To) (sites Phase 0)) (then (if (can Move (or (move Hop (from (last To)) Diagonal (between before:1 if:(and (= 2 (count Steps (from) (between))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to)))) (do (move Hop (from (last To)) Orthogonal (between before:3 after:1 if:(and (= 4 (count Steps (from) (between))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to)))) ifAfterwards:(is In (last To) (sites Phase 0))))) (moveAgain))))}))))) (end (if (no Pieces Next) (result Next Loss))))) 
8x8 board, every other square marked with an X in a checkered pattern. Twelve pieces per player, positioned on the first three rows closest to the player on the marked squares. Players alternate turns moving a piece diagonally forward. A player may capture an opponent's piece by hopping over it to an empty spot on the opposite side of it along the lines. Multiple captures are allowed, if possible. When a player's piece reaches the opposite edge of the board from which it started, it becomes a king. It may move over any distance, diagonally, and may capture by leaping any distance over any number of opponent's pieces, capturing all of them in that line. The king cannot take in multiple directions in one turn. The first player to capture all of the opponent's pieces wins. 
(game "Moo" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (regions "MarkedCell" (sites Phase 0))}) (rules (start {(place "Counter1" (difference (expand (sites Bottom) steps:(- 3 1)) (sites Phase 1))) (place "Counter2" (difference (expand (sites Top) steps:(- 3 1)) (sites Phase 1)))}) (play (if (is Prev Mover) (or (if (= (what at:(last To)) (id "Counter" Mover)) (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover))))) (move Hop (from (last To)) SameDirection (between before:(count Rows) (range 1 9) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) SameDirection (between before:(count Rows) (range 1 (count Rows)) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))) (move Pass)) (or (forEach Piece "Counter" (or (move Hop (from (from)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover))))) (move Step (directions {FR FL}) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover))))) (forEach Piece "DoubleCounter" (or (move Hop (from) Diagonal (between before:(count Rows) (range 1 9) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) SameDirection (between before:(count Rows) (range 1 (count Rows)) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))) (move Slide Diagonal)))))) (end (if (no Pieces Next) (result Next Loss))))) 
Played on an 8x8 board with each player having twelve pieces. Pieces move diagonally one space forward, and can capture opponent's pieces by jumping them if they are adjacent. Capturing is not mandatory. Multiple captures are allowed. Once pieces reach the opposite side of the board from their starting position, they become kings and can move diagonally either forwards or backwards. The goal is to capture all of the opponent's pieces. 
(game "Pleasant Draughts" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (difference (expand (sites Bottom) steps:(- 3 1)) (sites Phase 1))) (place "Counter2" (difference (expand (sites Top) steps:(- 3 1)) (sites Phase 1)))}) (play (if (is Prev Mover) (or (if (= (what at:(last To)) (id "Counter" Mover)) (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover) (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))) (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))) (move Pass)) (or (forEach Piece "Counter" (or (move Hop (from) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover) (if (can Move (move Hop (from (last To)) (directions {FR FL}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))) (move Step (directions {FR FL}) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover))))) (forEach Piece "DoubleCounter" (or (move Step Diagonal (to if:(is Empty (to)))) (move Hop Diagonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))))))) (end (if (no Pieces Next) (result Next Loss))))) 
In Seesaw Draughts, when a man reaches the rank farthest away in its stepping direction, its capture range is increased and it changes the direction it steps in. It can thereby promote again if it reaches the opposite rank. The mechanism is implemented like this: All men are stacks. Single pieces are stacks of size 1. Every time a man promotes a piece is added to it, so it's stack size increases by 1. The following two-fold meaning of stack size is the key idea: 1) Odd stacks step forwards and even stacks step backwards. 2) A stack of size n can capture a piece up to n steps away in a straight line provided that there are no pieces between the capturing piece and its target, and that the square immediately behind the target in the capture direction is empty. The capturing piece must land there. Thus, the men gradually acquire the capturing power of a king in Thai Checkers as they seesaw up and down the board. There is no obligation to choose the capture sequence that maximizes the number of pieces captured. We deem this calculation a bit too demanding when a stack's range is a function of its size. Other than this, the rules are as in Brazillian Draughts/Checkers, which is like International Draughts, but on 8x8.
(game "Seesaw Draughts" (players 2) (equipment {(board (square 8)) (piece "Disc" P1 N) (piece "Disc" P2 S) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Disc1" (difference (expand (sites Bottom) steps:2) (sites Phase 1))) (place "Disc2" (difference (expand (sites Top) steps:2) (sites Phase 1)))}) (play (priority (forEach Piece "Disc" (move (from if:(= (* (from) (if (< 0 (count MovesThisTurn)) 1 0)) (* (last To) (if (< 0 (count MovesThisTurn)) 1 0)))) (to (sites Direction from:(from) Diagonal distance:(+ 1 (size Stack at:(from)))) if:(and {(is Empty (to)) (= 1 (count Sites in:(intersection (sites Occupied by:Enemy) (sites Between from:(from) to:(to))))) (= 0 (count Sites in:(intersection (sites Occupied by:Mover) (sites Between from:(from) to:(to))))) (= 1 (count Steps (to) (+ (array (intersection (sites Occupied by:Enemy) (sites Between from:(from) to:(to))))))) (not (is In (+ (array (intersection (sites Occupied by:Enemy) (sites Between from:(from) to:(to))))) (values Remembered)))}) (apply (remember Value (+ (array (intersection (sites Occupied by:Enemy) (sites Between from:(from) to:(to)))))))) count:(size Stack at:(from)) stack:True (then (if (can Move (move (from (last To)) (to (sites Direction from:(from) (difference Diagonal (directions Cell from:(last To) to:(last From))) distance:(+ 1 (size Stack at:(from)))) if:(and {(is Empty (to)) (= 1 (count Sites in:(intersection (sites Occupied by:Enemy) (sites Between from:(from) to:(to))))) (= 0 (count Sites in:(intersection (sites Occupied by:Mover) (sites Between from:(from) to:(to))))) (= 1 (count Steps (to) (+ (array (intersection (sites Occupied by:Enemy) (sites Between from:(from) to:(to))))))) (not (is In (+ (array (intersection (sites Occupied by:Enemy) (sites Between from:(from) to:(to))))) (values Remembered)))})))) (moveAgain) (do (forEach Site (sites (values Remembered)) (remove (site) count:(size Stack at:(site)))) next:(and (if (or (and (is Odd (size Stack at:(last To))) (is In (last To) (sites (player (+ 1 (% (mover) 2)))))) (and (is Even (size Stack at:(last To))) (is In (last To) (sites (player (mover)))))) (add (to (last To)) stack:True)) (forget Value All)))))) top:True) (forEach Piece "Disc" (move Step (from) (if (is Odd (size Stack at:(from))) (directions {FL FR}) (directions {BL BR})) (to if:(is Empty (to))) stack:True (then (if (or (and (is Odd (size Stack at:(last To))) (is In (last To) (sites (player (+ 1 (% (mover) 2)))))) (and (is Even (size Stack at:(last To))) (is In (last To) (sites (player (mover)))))) (add (to (last To)) stack:True)))) top:True))) (end (if (no Moves Next) (result Next Loss))))) 
Played on an 8x8 board with each player having twelve pieces. Pieces move diagonally one space forward, and can capture opponent's pieces by jumping them if they are adjacent. Capturing must happen if it is possible, multiple captures are allowed, and can happen in a forward or backward direction. Once pieces reach the opposite side of the board from their starting position, they become kings and can move diagonally either forwards or backwards. A piece may become a king in the midst of a sequence of captures, and then capture as a king in the same turn. Kings may capture over any distance, leaping over all opponent's pieces in a line. The goal is to capture all of the opponent's pieces. 
(game "Shashki" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (difference (expand (sites Bottom) steps:(- 3 1)) (sites Phase 1))) (place "Counter2" (difference (expand (sites Top) steps:(- 3 1)) (sites Phase 1)))}) (play (if (is Prev Mover) (if (= (what at:(last To)) (id "Counter" Mover)) (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (and (promote (last To) (piece "DoubleCounter") Mover) (if (can Move (move Hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))) (moveAgain))) (if (can Move (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))) (move Hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))) (priority {(or (forEach Piece "Counter" (move Hop (from (from)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (and (promote (last To) (piece "DoubleCounter") Mover) (if (can Move (move Hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))) (moveAgain))) (if (can Move (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))) (forEach Piece "DoubleCounter" (move Hop Diagonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))))) (or (forEach Piece "Counter" (move Step (directions {FR FL}) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))) (forEach Piece "DoubleCounter" (move Slide Diagonal)))}))) (end (if (no Pieces Next) (result Next Loss))))) 
10x10 checkered board. Twenty pieces per player, arranged on the four rows closest to the player. Pieces move orthogonally or diagonally in any direction, only on the white spaces. Pieces may capture by jumping over an enemy piece to an empty space on the other side of it. Multiple captures in one turn are allowed. The player to capture all of the opponent's pieces wins.
(game "The Babylonian" (players 2) (equipment {(board (square 10)) (piece "Counter" Each (or {(move Step Diagonal (to if:(is Empty (to)))) (move Slide Orthogonal (between (exact 2))) (move Hop (from) Diagonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (or (move Hop (from (last To)) Diagonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (do (move Hop (from (last To)) Orthogonal (between before:2 after:2 if:(and (= 2 (count Steps (from) (between))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to)))) ifAfterwards:(is In (last To) (sites Phase 1))))) (moveAgain)))) (do (move Hop (from) Orthogonal (between before:2 after:2 if:(and (= 2 (count Steps (from) (between))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to)))) ifAfterwards:(is In (last To) (sites Phase 1)) (then (if (can Move (or (move Hop (from (last To)) Diagonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (do (move Hop (from (last To)) Orthogonal (between before:2 after:2 if:(and (= 2 (count Steps (from) (between))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to)))) ifAfterwards:(is In (last To) (sites Phase 1))))) (moveAgain))))})) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (difference (expand (sites Bottom) steps:(- 4 1)) (sites Phase 0))) (place "Counter2" (difference (expand (sites Top) steps:(- 4 1)) (sites Phase 0)))}) (play (if (is Prev Mover) (or {(move Hop (from (last To)) Diagonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (or (move Hop (from (last To)) Diagonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (do (move Hop (from (last To)) Orthogonal (between before:2 after:2 if:(and (= 2 (count Steps (from) (between))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to)))) ifAfterwards:(is In (last To) (sites Phase 1))))) (moveAgain)))) (do (move Hop (from (last To)) Orthogonal (between before:2 after:2 if:(and (= 2 (count Steps (from) (between))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to)))) ifAfterwards:(is In (last To) (sites Phase 1)) (then (if (can Move (or (move Hop (from (last To)) Diagonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (do (move Hop (from (last To)) Orthogonal (between before:2 after:2 if:(and (= 2 (count Steps (from) (between))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to)))) ifAfterwards:(is In (last To) (sites Phase 1))))) (moveAgain)))) (move Pass)}) (forEach Piece))) (end (if (no Pieces Next) (result Next Loss))))) 
10x10 board. Twenty pieces per player, which begin on the four rows closest to the player. The row of pieces on the edge of the board closest to each player begins with the pieces already as Queens. Pieces move diagonally one space forward, or can jump an adjacent piece belonging to the opponent to capture it. Captures are mandatory, and the maximum number of captures possible must be taken. When pieces reach the opposite edge of the board from where they started, they are promoted to Queen. Queens move any number of spaces diagonally, and jump over any number of opponents' pieces over any distance. When a Queen reaches that edge of the board a second time (or, for the first time if one of those which began the game as a Queen), they are further promoted, gaining the power to move and take orthogonally over any distance. The player who captures all of the opponent's pieces wins. 
(game "Unnamed Dutch Draughts Game" (players {(player N) (player S)}) (equipment {(board (square 10)) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (piece "CounterStar" Each)}) (rules (start {(place "Counter1" (difference (expand (sites Bottom) steps:3) (union (sites Bottom) (sites Phase 1)))) (place "Counter2" (difference (expand (sites Top) steps:3) (union (sites Top) (sites Phase 1)))) (place "DoubleCounter1" (difference (sites Bottom) (sites Phase 1))) (place "DoubleCounter2" (difference (sites Top) (sites Phase 1)))}) (play (if (is Prev Mover) (if (= (what at:(last To)) (id "Counter" Mover)) (max Moves (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))))) (if (= (what at:(last To)) (id "DoubleCounter" Mover)) (max Moves (move Hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "CounterStar") Mover)))))) (max Moves (move Hop (from (last To)) (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))))) (priority {(max Moves (or {(forEach Piece "Counter" (move Hop (from) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) Diagonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))))) (forEach Piece "DoubleCounter" (move Hop (from) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Diagonal (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "CounterStar") Mover)))))) (forEach Piece "CounterStar" (move Hop (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))))})) (or {(forEach Piece "Counter" (move Step (directions {FR FL}) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))) (forEach Piece "DoubleCounter" (move Slide Diagonal) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "CounterStar") Mover)))) (forEach Piece "CounterStar" (move Slide))})}))) (end (if (no Moves Next) (result Mover Win))))) 
5x5 intersecting lines, with diagonals in each quadrant. Two triangles, the apexes of which intersect with the square at the midpoint of opposite sides. One line bisecting the base of the triangle, and another bisecting this line. Eighteen pieces per player, each side arranged on one side of the board, with the central point empty and the player's pieces on the points to the right of it. Players alternate turns moving one of their pieces to an empty point. A piece may jump an opponent's piece to capture it. Multiple captures are allowed. The player who captures all of the opponent's pieces wins.
(game "Ahtarah Guti" (players 2) (equipment {(board (merge {(square 5 diagonals:Alternating) (shift 0 4 (rotate 180 (wedge 3))) (shift 0 -2 (wedge 3))}) use:Vertex) (piece "Marker" Each (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Step (to if:(is Empty (to))))))}) (rules (start {(place "Marker1" (union {(sites Row 0) (sites Row 1) (sites Row 2) (sites Row 3) (sites {13 14})})) (place "Marker2" (union {(sites Row 5) (sites Row 6) (sites Row 7) (sites Row 8) (sites {10 11})}))}) (play (if (is Prev Mover) (or (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Pass)) (forEach Piece))) (end (if (no Pieces Next) (result Next Loss))))) 
The board consists of 5x5 intersecting lines with diagonals. Pieces are placed on the intersections and can move along the lines. Each player has 12 pieces. Pieces can move to one adjacent point. Captures can be made by hopping over an opponent's piece. The goal is to capture all of the opponent's pieces. No force capture, no sequence.
(game "Alquerque" (players 2) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (piece "Counter" Each)}) (rules (start {(place "Counter1" (union {(expand (sites Bottom)) (sites {"D3" "E3"})})) (place "Counter2" (union {(sites {"A3" "B3"}) (expand (sites Top))}))}) (play (forEach Piece "Counter" (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to))))))) (end (if (no Moves Next) (result Next Loss))))) 
A series of three parallel lines are drawn, with diagonals connecting the outer lines at intervals, crossing each other at the central line. Eight in the outer rows, nine in the central. Pieces are moved along the intersections, and they are placed on the board on opposing sides, leaving the central spot empty. The first player moves to this spot along one of the lines, and the opponent jumps this pieces, thereby capturing it.
(game "Awithlaknan Mosona" (players 2) (equipment {(board (merge {(repeat 1 1 step:{{0.5 0} {1 0}} (poly {{0.5 0} {0 0} {0 0.5}})) (repeat 1 1 step:{{0.5 0} {1 0}} (poly {{0.5 0} {0 0} {0 -0.5}})) (repeat 7 1 step:{{0.5 0} {1 0}} (poly {{0.5 0} {0 0.5} {1 0.5}})) (repeat 7 1 step:{{0.5 0} {1 0}} (poly {{0.5 0} {0 -0.5} {1 -0.5}})) (shift (- 7 1) 0 (repeat 1 1 step:{{0.5 0} {1 0}} (poly {{0.5 0} {1 0.5} {1 0}}))) (shift (- 7 1) 0 (repeat 1 1 step:{{0.5 0} {1 0}} (poly {{0.5 0} {1 0} {1 -0.5}}))) (shift 0.5 0 (rectangle 1 7))}) use:Vertex) (piece "Counter" Each (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to))))))}) (rules (start {(place "Counter1" (union (sites Bottom) (sites Direction from:(centrePoint) W))) (place "Counter2" (union (sites Direction from:(centrePoint) E) (sites Top)))}) (play (forEach Piece)) (end (if (no Moves Next) (result Next Loss))))) 
Three concentric circles, with four diameters dividing it into eight equal sections. Twelve pieces per player, placed on the points on one half of the circle, leaving the central point open. Players alternate turns moving one of their pieces to an empty adjacent spot along the lines. A piece may capture an opponent's piece by hopping over it to an empty spot immediately on the opposite side of the opponent's piece along the lines. The player who captures all of the opponent's pieces wins.
(game "Bara Guti (Bihar)" (players 2) (equipment {(board (concentric {1 8 8 8}) use:Vertex) (piece "Counter" Each (or (move Hop Rotational (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step Rotational (to if:(is Empty (to))))))}) (rules (start {(place "Counter1" (sites {2 3 4 5 10 11 12 13 18 19 20 21})) (place "Counter2" (sites {1 9 17 6 7 8 14 15 16 22 23 24}))}) (play (forEach Piece)) (end (if (no Pieces Next) (result Next Loss))))) 
The board consists of 5x5 intersecting lines with diagonals of each quadrant. Pieces are placed on the intersections and can move along the lines. Each player has 12 pieces. Pieces can move to one adjacent point. Captures can be made by hopping over an opponent's piece. The goal is to capture all of the opponent's pieces. 
(game "Bara Guti" (players 2) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (piece "Marker" Each (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to))))))}) (rules (start {(place "Marker1" (forEach (sites Board) if:(< (site) (centrePoint)))) (place "Marker2" (forEach (sites Board) if:(> (site) (centrePoint))))}) (play (forEach Piece)) (end (if (no Pieces Next) (result Next Loss))))) 
5x5 intersecting lines, with diagonals in each square formed by the lines. Twenty pieces per player, which each player places on the points on their side of the board, as well as the two points to the left of the central space. The central spot remains empty. Players alternate turns by moving a piece to an adjacent empty spot along the lines on the board. A player may capture an opponent's piece by hopping over one adjacent piece if there is an empty spot behind it along a line on the board. The player who captures all of the opponent's pieces wins.
(game "Bis Gutiya" (players 2) (equipment {(board (square 5 diagonals:Solid) use:Vertex) (piece "Marker" Each (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))))}) (rules (start {(place "Marker1" (forEach (sites Board) if:(< (site) (centrePoint)))) (place "Marker2" (forEach (sites Board) if:(> (site) (centrePoint))))}) (play (forEach Piece)) (end (if (no Pieces Next) (result Next Loss))))) 
3x3 intersecting lines, with diagonals in the four squares formed. Six pieces per player. Players alternate turns placing one of their pieces on the board. when all of the pieces have been placed, players alternate turns moving a piece by jumping over an adjacent spot to the next spot, along the lines of the board, which must be empty. If an opponent's piece is in the spot which was jumped, that piece is captured. The player who captures all of the opponent's pieces wins.
(game "Buudal" (players 2) (equipment {(board (square 3 diagonals:Solid) use:Vertex) (hand Each) (piece "Marker" Each (move Hop (between if:True (apply (if (is Enemy (who at:(between))) (remove (between))))) (to if:(is Empty (to)))))}) (rules (start (place "Marker" "Hand" count:6)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end (if (no Pieces Next) (result Next Loss))))) 
9x9 board played on the intersections, with diagonals for each 3x3 square. Typically played with 24 pieces, but any number up to 40 is possible. Pieces are arranged on the spots in the rows closest to the player, with those unable to fill a row placed on the right points of the next available row. Players alternate turns by moving a piece to an adjacent empty spot along the lines on the board. A player may capture an opponent's piece by hopping over one adjacent piece if there is an empty spot behind it along a line on the board. The player who captures all of the opponent's pieces wins. The game starts with 24 pieces by player.
(game "Challis Ghutia (Titagarh)" (players {(player N) (player S)}) (equipment {(board (rectangle 9 9 diagonals:Alternating) use:Vertex) (piece "Marker" Each (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))))}) (rules (start {(place "Marker1" (union (expand (sites Bottom) steps:1) (expand origin:(coord "I3") steps:5 W))) (place "Marker2" (union (expand (sites Top) steps:1) (expand origin:(coord "A7") steps:5 E)))}) (play (forEach Piece)) (end (if (no Pieces Next) (result Next Loss))))) 
Claim Jumpers is a 2-player strategy game It may be played: -- on a hex grid -- on a square grid -- on a square plus diagonal grid The goal is to maximize your pieces when the board is full. A new piece is placed at the beginning of each turn. Followed, if possible, by a chain of forced jumps made by a different piece, that capture by 'flipping' the jumped opponent to your own color. The board starts empty. Turns alternate starting with White. Game ends when the board is full. No passing. Maximum captures are not required, but the piece choen to capture must capture at least one, and maynot stop capturing as long as it is able to capture the next adjacent opponent's piece. Board & size: Equiversi Hexhex with edges alternating 3 and 5
(game "Claim Jumpers" (players 2) (equipment {(board (tri {3 5 3 5 3}) use:Vertex) (piece "Disc" Each)}) (rules (start (set Score Each 0)) (play (if (is Prev Mover) (if (= 0 (size Array (values Remembered))) (forEach Piece (move Hop (from if:(!= (from) (last To))) Orthogonal (between if:(is In (between) (difference (sites Occupied by:Next) (sites (values Remembered)))) (apply (set Pending (between)))) (to if:(is Empty (to))) (then (and {(remember Value (value Pending)) (remove (value Pending)) (add (piece (id "Disc" Mover)) (to (value Pending)))} (then (and {(set Pending) (if (can Move (forEach Piece (move Hop (from (last To)) Orthogonal (between if:(is In (between) (difference (sites Occupied by:Next) (sites (values Remembered))))) (to if:(is Empty (to)))))) (moveAgain))})))))) (forEach Piece (move Hop (from if:(= (from) (last To))) Orthogonal (between if:(is In (between) (difference (sites Occupied by:Next) (sites (values Remembered)))) (apply (set Pending (between)))) (to if:(is Empty (to))) (then (and {(remember Value (value Pending)) (remove (value Pending)) (add (piece (id "Disc" Mover)) (to (value Pending)))} (then (and {(set Pending) (if (can Move (forEach Piece (move Hop (from (last To)) Orthogonal (between if:(is In (between) (difference (sites Occupied by:Next) (sites (values Remembered))))) (to if:(is Empty (to)))))) (moveAgain))}))))))) (do (forget Value All) next:(move Add (piece (id "Disc" Mover)) (to (sites Empty)) (then (if (can Move (forEach Piece (move Hop (from if:(!= (from) (last To))) Orthogonal (between if:(is In (between) (difference (sites Occupied by:Next) (sites (values Remembered)))) (apply (set Pending (between)))) (to if:(is Empty (to))) (then (and {(remember Value (value Pending)) (remove (value Pending)) (add (piece (id "Disc" Mover)) (to (value Pending)))} (then (and {(set Pending) (if (can Move (forEach Piece (move Hop (from (last To)) Orthogonal (between if:(is In (between) (difference (sites Occupied by:Next) (sites (values Remembered))))) (to if:(is Empty (to)))))) (moveAgain))}))))))) (moveAgain))))) (then (and (set Score Mover (count Pieces Mover)) (set Score Next (count Pieces Next)))))) (end {(if (and (or {(no Moves Next) (all Passed)}) (= (score Mover) (score Next))) (result Mover Win)) (if (and (or {(no Moves Next) (all Passed)}) (!= (score Mover) (score Next))) (byScore))}))) 
9x9 intersecting lines, with diagonals drawn in the large square. Forty pieces per player, arranged on the points closest to the player and to the right of the central spot, with the central spot remaining empty. Players alternate turns moving their pieces forward along the lines of the board. They cannot move sideways or backwards, except to capture. A piece may capture an adjacent opponent's piece by hopping over it to an empty spot immediately on the opposite side of the opponent's piece, along the lines of the board. When a player's piece reaches the line on the opposite side of the board from which it started, it is promoted to Sultan, and it may move in all directions along the lines of the board and over any unobstructed distance. The player who captures all of the opponent's pieces wins. 
(game "Crand" (players {(player N) (player S)}) (equipment {(board (add (square 9) edges:{{0 10} {10 20} {20 30} {30 40} {40 50} {50 60} {60 70} {70 80} {72 64} {64 56} {56 48} {48 40} {40 32} {32 24} {16 24} {16 8}}) use:Vertex) (piece "Counter" Each (or (move Step (difference Forwards Diagonal) (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover))))) (piece "DoubleCounter" Each (or (move Slide) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))))) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (union (sites {41 42 43 44}) (expand (sites Bottom) steps:3))) (place "Counter2" (union (sites {36 37 38 39}) (expand (sites Top) steps:3)))}) (play (forEach Piece)) (end (if (no Pieces Next) (result Next Loss))))) 
6x7 lines forming a grid. Diagonals in each small square, with a point where the diagonals cross. 28 pieces, which begin on opposite sides of the board. In addition, each player has a Prince piece, which begins on the rightmost point immediately in front of the other pieces, and a King piece, which begins on the rightmost point in the line in front of the Prince. All pieces move one space to an empty adjacent spot along the lines. A piece may capture an adjacent opponent's piece by hopping over it to an empty adjacent spot on the opposite side of it. Multiple captures are allowed. Captures are not compulsory and neither are the maximum number of captures. Pieces may only capture other pieces of the same rank or lower. A player wins when they capture all of the opponent's pieces, or by blocking a higher ranking piece from being able to move if it is the only remaining piece belonging to the opponent. If players are left with only one piece each of the same rank, one player may declare single combat, and both pieces must move toward one another until one captures the other. If only the Kings are left on the board the game is a draw. 
(game "Dablot Prejjesne" (players {(player S) (player N)}) (equipment {(board (rectangle 7 6 diagonals:Solid) use:Vertex) (piece "Cone" Each (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(and (is Enemy (who at:(between))) (>= (value Piece at:(from)) (value Piece at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (is Enemy (who at:(between))) (>= (value Piece at:(from)) (value Piece at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))) (piece "Prince" Each (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(and (is Enemy (who at:(between))) (>= (value Piece at:(from)) (value Piece at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (is Enemy (who at:(between))) (>= (value Piece at:(from)) (value Piece at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))) (piece "King" Each (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(and (is Enemy (who at:(between))) (>= (value Piece at:(from)) (value Piece at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (is Enemy (who at:(between))) (>= (value Piece at:(from)) (value Piece at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))) (regions P1 (sites Top)) (regions P2 (sites Bottom))}) (rules (start {(place "Cone1" (expand (sites Bottom) steps:2)) (place "Cone2" (expand (sites Top) steps:2)) (place "Prince1" coord:"H4" value:1) (place "Prince2" coord:"E9" value:1) (place "King1" coord:"I4" value:2) (place "King2" coord:"D9" value:2)}) (play (if (is Prev Mover) (or (move Hop (from (last To)) (between if:(and (is Enemy (who at:(between))) (>= (value Piece at:(from)) (value Piece at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (is Enemy (who at:(between))) (>= (value Piece at:(from)) (value Piece at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))) (move Pass)) (if (and {(= 1 (count Pieces P1)) (= 1 (count Pieces P2)) (= (max (results from:(sites Occupied by:P1) to:(sites Occupied by:P1) (value Piece at:(to)))) (max (results from:(sites Occupied by:P2) to:(sites Occupied by:P2) (value Piece at:(to)))))}) (forEach Piece (priority (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(and (is Empty (to)) (< (count Steps (to) (regionSite (sites Occupied by:Next) index:0)) (count Steps (from) (regionSite (sites Occupied by:Next) index:0)))))))) (forEach Piece)))) (end {(if (no Pieces Next) (result Next Loss)) (if (and {(< (max (results from:(sites Occupied by:Mover) to:(sites Occupied by:Mover) (value Piece at:(to)))) (max (results from:(sites Occupied by:Next) to:(sites Occupied by:Next) (value Piece at:(to))))) (= 1 (count Pieces Next)) (no Moves Next)}) (result Mover Win)) (if (and {(= 1 (count Pieces P1)) (!= (where "King" P1) -1) (= 1 (count Pieces P2)) (!= (where "King" P2) -1)}) (result Mover Draw))}))) 
5x5 intersecting lines, with diagonals in each quadrant. Two triangles, the apexes of which intersect with the square at the midpoint of opposite sides. One line bisecting the base of the triangle, and another bisecting this line. Each player has sixteen pieces, which begin on the points of one triangle and the two rows of points in front of it, thus leaving the central row of points empty. Players alternate turns moving a piece to an empty adjacent spot along the lines. A piece may capture an opponent's piece by hopping over it to an empty space immediately on the opposite side of the piece, along the lines of the board. The first player to capture all of the opponent's pieces wins.
(game "Dam (Singapore)" (players 2) (equipment {(board (merge {(square 5 diagonals:Alternating) (shift 0 4 (rotate 180 (wedge 3))) (shift 0 -2 (wedge 3))}) use:Vertex) (piece "Marker" Each (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to))))))}) (rules (start {(place "Marker1" (union {(sites Row 0) (sites Row 1) (sites Row 2) (sites Row 3)})) (place "Marker2" (union {(sites Row 5) (sites Row 6) (sites Row 7) (sites Row 8)}))}) (play (forEach Piece)) (end (if (no Pieces Next) (result Next Loss))))) 
5x5 intersecting lines and with a triangular appendage on either side. Each player has sixteen pieces, which are placed on the intersections and move along the lines to the next open intersection. Players can hop opponents pieces to capture them. Multiple captures in one turn are allowed. A player wins when they capture all of the opponent's pieces or block them from being able to move. 
(game "Dam Hariman" (players 2) (equipment {(board (merge {(square 5 diagonals:Alternating) (shift 0 4 (rotate 180 (wedge 3))) (shift 0 -2 (wedge 3))}) use:Vertex) (piece "Marker" Each (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Step (to if:(is Empty (to))))))}) (rules (start {(place "Marker1" (union {(sites Row 0) (sites Row 1) (sites Row 2) (sites Row 3)})) (place "Marker2" (union {(sites Row 5) (sites Row 6) (sites Row 7) (sites Row 8)}))}) (play (if (is Prev Mover) (or (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Pass)) (forEach Piece))) (end (if (no Moves Next) (result Next Loss))))) 
5x5 intersecting lines with diagonals drawn in the four quadrants. Twelve pieces per player. which begin on two rows closest to the player and the two spaces in the central row on the player's right. Players alternate turns moving a piece to an empty adjacent point on the board, along the lines in a forward or sideways direction. A player may capture an opponent's piece by hopping over it to an empty space on immediately on the opposite side of it along the lines on the board. Captures are compulsory, and if the opponent realizes that the player did not make a possible capture, the opponent immediately captures the player's piece that could have captured but didn't. Regular pieces cannot capture backwards. When a piece reaches the farthest row on the opposite side of the board from where they started, it is promoted to a king, which can move and capture any distance along the lines of the board. The player who captures all of their opponent's pieces wins.
(game "Dama (Alquerque)" (players {(player N) (player S)}) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (piece "Counter" Each (or (move Hop (directions {Forwards Rightward Leftward}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (and (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)) (set Value Mover 0)))) (move Step (directions {Forwards Rightward Leftward}) (to if:(is Empty (to))) (then (set Value Mover 1))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover))))) (piece "DoubleCounter" Each (or (move Hop (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (set Value Mover 0))) (move Slide (then (set Value Mover 1))))) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (union {(expand (sites Bottom)) (sites {"D3" "E3"})})) (place "Counter2" (union {(sites {"A3" "B3"}) (expand (sites Top))}))}) (play (or (if (= (value Player Prev) 1) (or (if (and (is In (last From) (sites Pending)) (is In (last From) (sites Empty))) (move Select (from (last To) if:(is Occupied (from))) (then (and {(remove (last To)) (moveAgain) (set Value Prev 0)})))) (move Select (from (sites Pending) if:(is Occupied (from))) (then (and {(remove (last To)) (moveAgain) (set Value Prev 0)}))))) (do (set Pending (sites From (or (forEach Piece "Counter" (move Hop (directions {Forwards Rightward Leftward}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (and (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)) (set Value Mover 0))))) (forEach Piece "DoubleCounter" (move Hop (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))))))) next:(forEach Piece)))) (end (if (no Pieces Mover) (result Mover Loss))))) 
Each player lays out the pieces on the board on the intersections of the lines, each filling all the intersections of the triangle closest to the player, plus the extra intersection to their right. Play moves to the next adjacent intersection connected by a line. Opponent's pieces can be captured by hopping over them. The player who captures all of the opponent's pieces wins.
(game "Dash Guti" (players 2) (equipment {(board (add (merge {(wedge 4) (shift 0 3 (rotate 180 (wedge 4)))}) vertices:{{0 3} {6 3}} edges:{{7 19} {19 18} {0 19} {0 20} {20 16} {20 9}}) use:Vertex) (piece "Counter" Each (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to))))))}) (rules (start {(place "Counter1" (union {(sites Row 0) (sites Row 1) (sites Row 2) (intersection (sites Row 3) (sites Left))})) (place "Counter2" (union {(sites Row 6) (sites Row 5) (sites Row 4) (intersection (sites Row 3) (sites Right))}))}) (play (forEach Piece)) (end (if (no Moves Next) (result Next Loss))))) 
Each player begins with their eleven pieces arrayed on the intersections of the lines in one of the triangles. Pieces move to an adjacent point along one of the lines connecting it to its present location. Captures are made by hopping over an opponent's piece. The player who captures all of the opponent's pieces wins.
(game "Egara Guti" (players 2) (equipment {(board (graph vertices:{{0 0} {2 0} {4 0} {6 0} {8 0} {2 2} {4 2} {6 2} {3 3} {4 3} {5 3} {4 4} {3 5} {4 5} {5 5} {2 6} {4 6} {6 6} {0 8} {2 8} {4 8} {6 8} {8 8}} edges:{{0 1} {0 5} {1 2} {1 5} {2 3} {2 6} {3 4} {3 7} {4 7} {5 6} {5 8} {5 15} {6 7} {6 9} {7 10} {7 17} {8 9} {8 11} {9 10} {9 11} {10 11} {11 12} {11 13} {11 14} {12 13} {12 15} {13 14} {13 16} {14 17} {15 16} {15 18} {15 19} {16 17} {16 20} {17 21} {17 22} {18 19} {19 20} {20 21} {21 22}}) use:Vertex) (piece "Counter" Each (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to))))))}) (rules (start {(place "Counter1" (union (expand (sites Bottom)) (sites Row 2))) (place "Counter2" (union (expand (sites Top)) (sites Row 4)))}) (play (forEach Piece)) (end (if (no Moves Next) (result Next Loss))))) 
5x5 intersecting lines, with diagonals in the four quadrants. Twelve pieces per player, arranged on the two rows closest to the player and the two spots in the central row to the player's right, leaving the central space empty. Players alternate turns moving a piece to an empty adjacent spot along the lines of the board. A piece belonging to the opponent may be captured when a piece hops over it to an empty adjacent spot immediately on the opposite side of the piece, along the lines of the board. The player who reduces the opponent to five pieces wins.
(game "Ethiopian Capture Game" (players 2) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (piece "Marker" Each (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to))))))}) (rules (start {(place "Marker1" (union {(expand (sites Bottom)) (sites {"D3" "E3"})})) (place "Marker2" (union {(sites {"A3" "B3"}) (expand (sites Top))}))}) (play (forEach Piece)) (end (if (<= (count Pieces Next) 5) (result Next Loss))))) 
Two triangles, joined at the apex, with a line running through the apices bisecting the bases of each triangle, and another line bisecting this line and the sides of the triangle in each triangle. Six pieces per player, which begin on the six points in the triangle closest to the player. The apex remains empty. Players alternate turns moving a piece to an empty adjacent spot on the board. A player may capture an opponent's piece by hopping over it to an empty space immediately on the opposite side of the opponent's piece, according to the lines on the board. When a player moves their piece to one of the corners of the opponent's triangle, the piece is promoted. The promoted piece can move any distance along the lines. Capturing is optional but pieces can promote.
(game "Felli" (players 2) (equipment {(board (graph vertices:{{0 0} {2 0} {4 0} {1 1} {2 1} {3 1} {2 2} {1 3} {2 3} {3 3} {0 4} {2 4} {4 4}} edges:{{0 1} {0 3} {1 2} {1 4} {2 5} {3 4} {3 6} {4 5} {4 6} {5 6} {6 7} {6 8} {6 9} {7 8} {7 10} {8 9} {8 11} {9 12} {10 11} {11 12}}) use:Vertex) (piece "Counter" Each) (piece "DoubleCounter" Each) (regions P1 (intersection (sites Corners) (sites Bottom))) (regions P2 (intersection (sites Corners) (sites Top)))}) (rules (start {(place "Counter1" (expand (sites Bottom))) (place "Counter2" (expand (sites Top)))}) (play (or {(forEach Piece "Counter" (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))) (forEach Piece "Counter" (move Step (to if:(is Empty (to)))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))) (forEach Piece "DoubleCounter" (move Slide)) (forEach Piece "DoubleCounter" (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))))})) (end (if (no Moves Next) (result Next Loss))))) 
5x5 intersecting lines with diagonals drawn in each quadrant. Twelve pieces per player, which begin on the rows closest to the player and the two spots to the right of the central point, leaving the central point open. Players alternate turns moving the pieces along the lines of the board. The first play is from one of the pieces directly above or below the central point. Pieces cannot move backwards. A player may capture an opponent's piece by hopping over it to an empty spot immediately adjacent to the opponent's piece on the opposite side, along the lines of the board. Pieces which reach the opposite edge of the board from where they started are promoted and can move and capture any distance along the two large diagonals of the board. The player who captures all of the opponent's pieces wins.
(game "Fetach" (players {(player N) (player S)}) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (piece "Counter" Each (or {(move Step (if (!= 0 (count Moves)) (difference Adjacent Backwards) Forwards) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))) (move Hop (difference Adjacent Backwards) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover))))})) (piece "DoubleCounter" Each (or {(move Step Adjacent (to if:(is Empty (to)))) (move Hop Adjacent (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Hop (from (from) if:(is In (from) (union (sites Direction from:4 NW included:True) (sites Direction from:0 NE included:True)))) Adjacent (between before:(count Rows) after:(count Rows) if:(and (is Enemy (who at:(between))) (is In (between) (union (sites Direction from:4 NW included:True) (sites Direction from:0 NE included:True)))) (apply (remove (between)))) (to if:(and (is Empty (to)) (is In (to) (union (sites Direction from:4 NW included:True) (sites Direction from:0 NE included:True))))))})) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (union {(expand (sites Bottom)) (sites {"D3" "E3"})})) (place "Counter2" (union {(sites {"A3" "B3"}) (expand (sites Top))}))}) (play (forEach Piece)) (end (if (no Pieces Next) (result Next Loss))))) 
Players take turns moving one of their pieces to an adjacent empty point, forwards or sideways. A piece can hop over an adjacent enemy piece to an empty point immeidately beyond it, forwards or sideways, and must do so if possible. Only one hope per turn is allowed. If a piece reaches the far point of the board, it is promoted to a king which can also move and hop backwards. Win by eliminating all enemy pieces. The game is drawn if both players are reduced to a single king.
(game "Game of Solomon" (players {(player N) (player S)}) (equipment {(board (renumber (splitCrossings (add (regular Star 6) edges:{{0 5} {1 4} {2 3}}))) use:Vertex) (piece "Counter" Each) (piece "DoubleCounter" Each) (regions "Palace1" P1 (sites {"E7"})) (regions "Palace2" P2 (sites {"E1"}))}) (rules (start {(place "Counter1" (sites {"E1" "A2" "D2" "E2" "F2" "I2"})) (place "Counter2" (sites {"E7" "A6" "D6" "E6" "F6" "I6"}))}) (play (priority {(or (forEach Piece "Counter" (move Hop (directions {Forwards Rightward Leftward} bySite:True) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Mover)) (promote (last To) (piece "DoubleCounter") Mover)))) (forEach Piece "DoubleCounter" (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))))) (or (forEach Piece "Counter" (move Step (directions {Forwards Rightward Leftward} bySite:True) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Mover)) (promote (last To) (piece "DoubleCounter") Mover)))) (forEach Piece "DoubleCounter" (move Step (to if:(is Empty (to))))))})) (end {(if (no Moves Next) (result Mover Win)) (if (and {(= 1 (count Pieces P1)) (= 1 (count Pieces P2)) (= 1 (count Pieces P1 "DoubleCounter")) (= 1 (count Pieces P2 "DoubleCounter"))}) (result Mover Draw))}))) 
Each player begins with 21 pieces, arranges on the 21 intersections of three consecutive radii. Players alternate turns moving to an empty adjacent spot. Captures are made by hopping over an opponent's piece. The player who captures all of the other player's pieces wins.
(game "Gol Ekuish" (players 2) (equipment {(board (concentric {1 6 6 6 6 6 6 6}) use:Vertex) (piece "Counter" Each (or (move Hop Rotational (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step Rotational (to if:(is Empty (to))))))}) (rules (start {(place "Counter1" (sites {2 3 4 8 9 10 14 15 16 20 21 22 26 27 28 32 33 34 38 39 40})) (place "Counter2" (sites {1 7 13 19 25 31 37 5 6 11 12 17 18 23 24 29 30 35 36 41 42}))}) (play (forEach Piece)) (end (if (no Moves Next) (result Next Loss))))) 
Played on an Alquerque board with triangular appendages at the top and bottom. Sixteen pieces per player. Each player moves one spot along the lines on the board. Captures are made by hopping over an opponent's piece. Multiple hops are allowed per turn if possible. Captures are not compulsory. The player who captures all of the opponent's pieces wins.
(game "Hewakam Keliya" (players 2) (equipment {(board (merge {(square 5 diagonals:Alternating) (shift 0 4 (rotate 180 (wedge 3))) (shift 0 -2 (wedge 3))}) use:Vertex) (piece "Marker" Each (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Step (to if:(is Empty (to))))))}) (rules (start {(place "Marker1" (union {(sites Row 0) (sites Row 1) (sites Row 2) (sites Row 3)})) (place "Marker2" (union {(sites Row 5) (sites Row 6) (sites Row 7) (sites Row 8)}))}) (play (if (is Prev Mover) (or (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Pass)) (forEach Piece))) (end (if (no Moves Next) (result Next Loss))))) 
Two isosceles triangles, which meet at the apices with the height of each triangle drawn and a line perpendicular to it in each triangle at its midpoint intersecting with the sides. Another line, bisected by the point where the spices of the triangles meet, with a shot line extending down on either end of the line, and a matching short line next to it at either end. Eight pieces per player, lined up with six on the two rows of the triangle closest to the player and two on the ends of the short lines to the left of the player. Players alternate turns moving a piece to an empty adjacent spot along the lines of the board. A piece can capture an opponent's piece by hopping over it to an empty adjacent point immediately on the opposite side of the opponent's piece along the lines on the board. The player who captures all of the opponent's pieces wins.
(game "Kaua Dorki" (players 2) (equipment {(board (merge {(scale 1 2 (wedge 3)) (shift 0 4 (rotate 180 (scale 1 2 (wedge 3)))) (shift 0 4 (rectangle 1 5))}) use:Vertex) (piece "Marker" Each (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to))))))}) (rules (start {(place "Marker1" (expand (union (sites Bottom) (sites {"A3"})))) (place "Marker2" (expand (union (sites Top) (sites {"E3"}))))}) (play (forEach Piece)) (end (if (no Pieces Next) (result Next Loss))))) 
Players decide which colors to play, and who starts first. The board is filled in the beginning with all the players pieces. The only point vacant on the board is the middle point. Each player's pieces are placed on their half of the board, and lined up on the right-hand side of the fifth rank (the middle horizontal line of the grid board). Players alternate turns. Pieces move forward only (straight forward or diagonally forward) one space per turn following the pattern on the board until they are crowned Mullah by reaching the last rank. A non-Mullah piece may capture an enemy piece by hopping over it. The capture can be in any direction. When a piece reaches the other player's rank, it is promoted to Mullah. The Mullah can move and capture in any direction. It can also move any number of spaces. The Mullah can also capture an enemy piece from any distance, and land anywhere behind the captured piece provided there are no other pieces (friendly or not) within the spaces of the leap. If a piece piece reaches the other player's rank as an intermediate step of a capturing sequence, the piece does not get promoted to Mullah. The player to capture all of the opponent's pieces wins.
(game "Kharbaga" (players {(player S) (player N)}) (equipment {(board (square 5 diagonals:Solid) use:Vertex) (piece "Counter" Each (or (move Step Forwards (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover))))) (piece "DoubleCounter" Each (or (move Hop (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Slide))) (regions P1 (sites Top)) (regions P2 (sites Bottom))}) (rules (start {(place "Counter2" (forEach (sites Board) if:(< (site) (centrePoint)))) (place "Counter1" (forEach (sites Board) if:(> (site) (centrePoint))))}) (play (forEach Piece)) (end (if (no Moves Mover) (result Next Win))))) 
5x5 intersecting lines with diagonals in the four quadrants. Twelve pieces per player, arranged on the intersections of the lines, on the first two ranks in front of each player and the two to the right of the player in the central rank. Pieces move in any direction one space. A piece may capture an opponent's piece by hopping over it to an empty space in a straight line. Captures are obligatory. If a player does not capture when they are supposed to, the opponent may remove that piece immediately and then play as normal. Once pieces reach the opposite side of the board from their starting position at the end of their turn, they are promoted and can move in any direction and over any distance. The player who captures all of their opponent's pieces or blocks them from being able to move wins.
(game "Kharberg" (players 2) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (piece "Counter" Each (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (and (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)) (set Value Mover 0)))) (move Step (to if:(is Empty (to))) (then (set Value Mover 1))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover))))) (piece "DoubleCounter" Each (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (and (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)) (set Value Mover 0)))) (move Slide (then (set Value Mover 1)))))}) (rules (start {(place "Counter1" (union {(expand (sites Bottom)) (sites {"D3" "E3"})})) (place "Counter2" (union {(sites {"A3" "B3"}) (expand (sites Top))}))}) (play (or (if (= (value Player Prev) 1) (or (if (and (is In (last From) (sites Pending)) (is In (last From) (sites Empty))) (move Select (from (last To) if:(is Occupied (from))) (then (and {(remove (last To)) (moveAgain) (set Value Prev 0)})))) (move Select (from (sites Pending) if:(is Occupied (from))) (then (and {(remove (last To)) (moveAgain) (set Value Prev 0)}))))) (do (set Pending (sites From (or (forEach Piece "Counter" (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (and (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)) (set Value Mover 0))))) (forEach Piece "DoubleCounter" (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (and (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)) (set Value Mover 0)))))))) next:(forEach Piece)))) (end (if (no Moves Next) (result Mover Win))))) 
A series of three parallel lines are drawn, with diagonals connecting the outer lines at intervals, crossing each other at the central line. Sixteen spaces each row. Pieces begin on all of the points on the board, except the central point and the leftmost point of the central row. Pieces are moved along the intersections, and they are placed on the board on opposing sides, leaving the central spot empty. The first player moves to this spot along one of the lines, and the opponent jumps this pieces, thereby capturing it.
(game "Kolowis Awithlaknannai" (players 2) (equipment {(board (merge {(repeat 1 1 step:{{0.5 0} {1 0}} (poly {{-0.5 0} {0.5 0} {0 0.5}})) (repeat 1 1 step:{{0.5 0} {1 0}} (poly {{-0.5 0} {0.5 0} {0 -0.5}})) (repeat 15 1 step:{{0.5 0} {1 0}} (poly {{0.5 0} {0 0.5} {1 0.5}})) (repeat 15 1 step:{{0.5 0} {1 0}} (poly {{0.5 0} {0 -0.5} {1 -0.5}})) (shift 0.5 0 (rectangle 1 15))}) use:Vertex) (piece "Counter" Each (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to))))))}) (rules (start {(place "Counter1" (difference (union (sites Bottom) (sites Direction from:(centrePoint) W)) (coord "A2"))) (place "Counter2" (union (sites Direction from:(centrePoint) E) (sites Top)))}) (play (forEach Piece)) (end (if (no Moves Next) (result Next Loss))))) 
From the starting position, each player takes turns moving one piece to an adjacent point connected to its current position by a line. Captures are made by hopping over an adjacent piece. The player who captures all the opponent's pieces wins.
(game "Kotu Ellima" (players 2) (equipment {(board (merge {(shift 2 2 (square 5 diagonals:Alternating)) (shift 2 0 (wedge 3)) (shift 5 3 (rotate 90 (wedge 3))) (shift 2 6 (rotate 180 (wedge 3))) (shift -1 3 (rotate 270 (wedge 3)))}) use:Vertex) (piece "Marker" Each (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to))))))}) (rules (start {(place "Marker1" (union {(expand (sites Bottom) steps:2) (expand (sites Right) steps:3) (sites {"F3" "G3" "E4" "F4" "F6" "F7" "G7"})})) (place "Marker2" (union {(expand (sites Top) steps:2) (expand (sites Left) steps:3) (sites {"C3" "D3" "D4" "D6" "E6" "D7" "C7"})}))}) (play (forEach Piece)) (end (if (no Moves Next) (result Next Loss))))) 
5x5 holes. Twelve pieces per player, which begin in the two rows closest to each player and in the two holes to the right of the central hole. The central hole remains empty. Players alternate turns moving a piece to an empty adjacent hole sideways or forward diagonally or orthogonally. Unpromoted pieces cannot move or capture backwards. A player may capture an opponent's piece by hopping over it to an empty space immediately on the opposite side of it, in one of the allowed directions. The huff rules applies: when a player does not make a capture that they should, the opponent removes the piece that should have captured. When a piece reaches a corner space on the opposite side of the board from where it starts, it is promoted to Dama. The Dama can move and capture any distance orthogonally or diagonally, and may also move backwards. The player who captures all of the opponent's pieces wins.
(game "La Dama" (players {(player N) (player S)}) (equipment {(board (square 5) use:Vertex) (piece "Disc" Each (or (move Hop (directions {Rightward Leftward Forwards} of:All) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (and (if (is In (last To) (sites Next)) (promote (last To) (piece "DiscDouble") Mover)) (set Value Mover 0)))) (move Step (directions {Rightward Leftward Forwards} of:All) (to if:(is Empty (to))) (then (set Value Mover 1))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DiscDouble") Mover))))) (piece "DiscDouble" Each (or (move Hop All (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (set Value Mover 0))) (move Slide All (then (set Value Mover 1))))) (regions P1 (intersection (sites Corners) (sites Bottom))) (regions P2 (intersection (sites Corners) (sites Top)))}) (rules (start {(place "Disc1" (union {(expand (sites Bottom)) (sites {"D3" "E3"})})) (place "Disc2" (union {(sites {"A3" "B3"}) (expand (sites Top))}))}) (play (or (if (= (value Player Prev) 1) (or (if (and (is In (last From) (sites Pending)) (is In (last From) (sites Empty))) (move Select (from (last To) if:(is Occupied (from))) (then (and {(remove (last To)) (moveAgain) (set Value Prev 0)})))) (move Select (from (sites Pending) if:(is Occupied (from))) (then (and {(remove (last To)) (moveAgain) (set Value Prev 0)}))))) (do (set Pending (sites From (or (forEach Piece "Disc" (move Hop (directions {Rightward Leftward Forwards} of:All) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (and (if (is In (last To) (sites Next)) (promote (last To) (piece "DiscDouble") Mover)) (set Value Mover 0))))) (forEach Piece "DiscDouble" (move Hop All (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))))))) next:(forEach Piece)))) (end (if (no Pieces Mover) (result Mover Loss))))) 
5x5 intersecting lines, with diagonals in each quadrant. Two triangles, the apexes of which intersect with the square at the midpoint of opposite sides. One line bisecting the base of the triangle, and another bisecting this line. Eighteen pieces per player, each side arranged on one side of the board, with the central point empty and the player's pieces on the points to the right of it. Players alternate turns moving one of their pieces to an empty point. A piece may jump an opponent's piece to capture it. Multiple captures are allowed. The player who captures all of the opponent's pieces wins. 
(game "Lam Pusri" (players 2) (equipment {(board (merge {(square 5 diagonals:Alternating) (shift 0 4 (rotate 180 (wedge 3))) (shift 0 -2 (wedge 3))}) use:Vertex) (piece "Marker" Each (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Step (to if:(is Empty (to))))))}) (rules (start {(place "Marker1" (union {(sites Row 0) (sites Row 1) (sites Row 2) (sites Row 3) (expand (sites {"E5"}) W)})) (place "Marker2" (union {(sites Row 5) (sites Row 6) (sites Row 7) (sites Row 8) (expand (sites {"A5"}) E)}))}) (play (if (is Prev Mover) (or (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Pass)) (forEach Piece))) (end (if (no Pieces Next) (result Next Loss))))) 
Play begins with each player's pieces on the pieces occupying the points of one of the triangles, leaving the shared apex empty. Pieces move to the next adjacent point connected by a line. Captures are made by hopping over an opponent's piece. The player who captures all of the opponent's pieces wins. The player loses when he has no piece.
(game "Lau Kata Kati" (players 2) (equipment {(board (merge (wedge 4) (shift 0 3 (rotate 180 (wedge 4)))) use:Vertex) (piece "Counter" Each (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to))))))}) (rules (start {(place "Counter1" (expand (sites Bottom) steps:2)) (place "Counter2" (expand (sites Top) steps:2))}) (play (forEach Piece)) (end (if (no Pieces Next) (result Next Loss))))) 
9x9 intersecting lines, with diagonals drawn in every 4x4 square formed. Forty pieces per player, placed on the board with the central space unoccupied. Players alternate turns moving one piece to an empty adjacent spot. They may capture an opponent's piece by hopping over it. Multiple hops in one turn are allowed, but not required. The first person to capture all of the opponent's pieces wins.
(game "Meurimueng-rimueng Peuet Ploh" (players 2) (equipment {(board (rectangle 9 9 diagonals:Alternating) use:Vertex) (piece "Marker" Each (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Step (to if:(is Empty (to))))))}) (rules (start {(place "Marker1" (forEach (sites Board) if:(< (site) (centrePoint)))) (place "Marker2" (forEach (sites Board) if:(> (site) (centrePoint))))}) (play (if (is Prev Mover) (or (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Pass)) (forEach Piece))) (end (forEach Player if:(no Pieces Player) (result Player Loss))))) 
Game is played on an Alquerque board with 5x5 intersecting lines and with a triangular appendage on either side. Each player has sixteen pieces, which are placed on the intersections and move along the lines to the next open intersection. Players can hop opponents pieces to capture them. Multiple captures in one turn are allowed. A player wins when they capture all of the opponent's pieces or block them from being able to move. The game is played with sixteen pieces.
(game "Mogul Putt'han" (players 2) (equipment {(board (merge {(square 5 diagonals:Alternating) (shift 0 4 (rotate 180 (wedge 3))) (shift 0 -2 (wedge 3))}) use:Vertex) (piece "Marker" Each (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Step (to if:(is Empty (to))))))}) (rules (start {(place "Marker1" (union {(sites Row 0) (sites Row 1) (sites Row 2) (sites Row 3)})) (place "Marker2" (union {(sites Row 5) (sites Row 6) (sites Row 7) (sites Row 8)}))}) (play (if (is Prev Mover) (or (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Pass)) (forEach Piece))) (end (if (no Moves Next) (result Next Loss))))) 
7x7 lines, intersecting to form a square. Diagonals are drawn in the four quadrants of the board. Two triangles, their apices intersecting the main board at opposite midpoints. The base of the triangle is bisected by a line drawn from the apex, and this line is bisected and intersects with the other two sides of the triangle. Twenty pieces per player, which begin on the points in the triangles and the first two rows of points in the square on the side closest to the player. Players alternate turns moving a piece to an empty adjacent spot along the lines of the board. A piece may capture an opponent's piece by hopping over it to an empty point on the opposite side of the opponent's piece along the lies of the board. Multiple captures are allowed. The player who captures all of the opponent's peices wins.
(game "Mughal Pathan" (players 2) (equipment {(board (add (merge {(square 7) (shift 1 6 (rotate 180 (wedge 3))) (shift 1 -2 (wedge 3))}) edges:{{0 8} {8 16} {16 24} {24 32} {32 40} {40 48} {6 12} {12 18} {18 24} {24 30} {30 36} {36 42} {3 9} {9 15} {15 21} {21 29} {29 37} {37 45} {45 39} {39 33} {33 27} {27 19} {19 11} {11 3}}) use:Vertex) (piece "Marker" Each (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Step (to if:(is Empty (to))))))}) (rules (start {(place "Marker1" (union (sites Bottom) (expand (sites Row 2)))) (place "Marker2" (union (sites Top) (expand (sites Row 8))))}) (play (if (is Prev Mover) (or (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Pass)) (forEach Piece))) (end (if (no Pieces Next) (result Next Loss))))) 
4x4 board, eight pieces each player. Pieces move orthogonally by either jumping a player's own piece to capture an opponent's piece or by moving one space into an empty hole. Captures are not compulsory. The goal is to reduce the opponents pieces to 1 or blocking them so they can no longer move. The game is played on a 4x4 board. The game starts with half the board owned by each player.
(game "Nei-Pat-Kono" (players 2) (equipment {(board (square 4) use:Vertex) (piece "Marker" Each (or (move Step Orthogonal (to if:(is Empty (to)))) (move Hop Orthogonal (between if:(is Friend (who at:(between)))) (to if:(is Enemy (who at:(to)))))))}) (rules (start {(place "Marker1" (expand (sites Bottom) steps:(- (/ (count Rows) 2) 1))) (place "Marker2" (expand (sites Top) steps:(- (/ (count Rows) 2) 1)))}) (play (forEach Piece)) (end (if (or (no Moves Next) (<= (count Pieces Next) 1)) (result Mover Win))))) 
5x5 intersecting lines. Triangles on each side, with the apex intersecting with the midpoint of the side of the square. A line is drawn from the apex to the base of each triangle, and a line bisecting it and the two opposite sides. A diamond is drawn within the square, the corners of which intersect with the apices of the triangles and the midpoint of each side is the center point of each quadrant of the square. 24 pieces per player, which begin on the points of the board closest to the player and in the triangle to their right and the right half of the central row. The central point is vacant. Players alternate turns moving a piece to an empty adjacent spot on the board. A piece may capture an opponent's piece by hopping over it to an empty adjacent spot immediately on the opposite side of the opponent's pieces along the lines on the board. The player who captures all of the opponent's pieces wins.
(game "Padaivettu" (players 2) (equipment {(board (remove (merge {(shift 2 2 (square 5 diagonals:Alternating)) (shift 2 0 (wedge 3)) (shift 5 3 (rotate 90 (wedge 3))) (shift 2 6 (rotate 180 (wedge 3))) (shift -1 3 (rotate 270 (wedge 3)))}) edges:{{20 16} {16 12} {12 8} {8 4} {0 6} {6 12} {12 18} {18 24}}) use:Vertex) (piece "Marker" Each (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))))}) (rules (start {(place "Marker1" (difference (union (expand (sites Right)) (expand (sites Bottom) steps:4)) (expand (sites Centre) steps:2 W))) (place "Marker2" (difference (union (expand (sites Left)) (expand (sites Top) steps:4)) (expand (sites Centre) steps:2 E)))}) (play (forEach Piece)) (end (if (no Pieces Next) (result Next Loss))))) 
3x5 lines, intersecting one another and forming a square. Diagonals are drawn in the four quadrants of the board. Two triangles, their apices intersecting the main board at opposite midpoints. The base of the triangle is bisected by a line drawn from the apex, and this line is bisected and intersects with the other two sides of the triangle. Fourteen pieces per player, which begin on the points in the triangle and the first two rows of the square closest to each player. The central line remains empty. Players alternate turns moving to an empty adjacent point along the lines. A player may capture an opponent's piece by hopping over it to an empty space on the opposite side of the opponent's piece along the lines of the board. The player who captures all of the opponent's pieces wins.
(game "Pam Pait" (players 2) (equipment {(board (add (remove (merge {(square 5 diagonals:Alternating) (shift 0 4 (rotate 180 (wedge 3))) (shift 0 -2 (wedge 3))}) vertices:{1 11 21 23 13 3}) edges:{{0 1} {1 2} {8 9} {9 10} {16 17} {17 18}}) use:Vertex) (piece "Marker" Each (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to))))))}) (rules (start {(place "Marker1" (union (sites {"A4" "E4"}) (expand (sites Bottom) steps:3))) (place "Marker2" (union (sites {"A6" "E6"}) (expand (sites Top) steps:3)))}) (play (forEach Piece)) (end (if (no Pieces Next) (result Next Loss))))) 
11x11 intersecting lines, with the central nine points out of play. Diagonal lines connect the corners of the central square of the board to the outer corners. Played with two to four players. Black and white stones fill the board, alternating color, with black in the corners of the board. The first player captures one of the stones on one of the corners of the board. Subsequent moves involve capturing a stone by hopping over it with an adjacent stone to an empty space. Multiple captures are possible, but only one, three, five, or seven are allowed in a turn. If an even number of captures is possible, the final capture cannot be taken. Players are not required to capture as many as may be possible. The game ends when no more captures are possible. The player with the highest score wins: black stones count as one, white as two. 2 Players.
(game "Pasang" (players 2) (equipment {(board (add (remove (square 11) vertices:{48 49 50 59 60 61 70 71 72}) edges:{{0 12} {12 24} {24 36} {10 20} {20 30} {30 40} {75 87} {87 99} {99 111} {71 81} {81 91} {91 101}}) use:Vertex) (piece "Marker" Shared (move Hop (from) (between if:(and (is Occupied (between)) (!= 1 (state at:(between))))) (to if:(is Empty (to)) (apply (if (is Even (count MovesThisTurn)) (and {(remove (between)) (if (= (what at:(between)) (id "Marker" Shared)) (addScore Mover 1) (addScore Mover 2)) (forEach Site (sites Board) (if (= 1 (state at:(site))) (and (remove (site)) (if (= (what at:(site)) (id "Marker" Shared)) (addScore Mover 1) (addScore Mover 2)))))}) (set State at:(between) 1)))) (then (if (and (< (count MovesThisTurn) 6) (can Move (move Hop (from (last To)) (between if:(and (is Occupied (between)) (!= 1 (state at:(between))))) (to if:(is Empty (to)) (apply (if (is Even (count MovesThisTurn)) (and {(remove (between)) (if (= (what at:(between)) (id "Marker" Shared)) (addScore Mover 1) (addScore Mover 2)) (forEach Site (sites Board) (if (= 1 (state at:(site))) (and (remove (site)) (if (= (what at:(site)) (id "Marker" Shared)) (addScore Mover 1) (addScore Mover 2)))))}) (set State at:(between) 1))))))) (moveAgain) (forEach Site (sites Board) (if (= 1 (state at:(site))) (set State at:(site) 0))))))) (piece "Disc" Shared (move Hop (from) (between if:(and (is Occupied (between)) (!= 1 (state at:(between))))) (to if:(is Empty (to)) (apply (if (is Even (count MovesThisTurn)) (and {(remove (between)) (if (= (what at:(between)) (id "Marker" Shared)) (addScore Mover 1) (addScore Mover 2)) (forEach Site (sites Board) (if (= 1 (state at:(site))) (and (remove (site)) (if (= (what at:(site)) (id "Marker" Shared)) (addScore Mover 1) (addScore Mover 2)))))}) (set State at:(between) 1)))) (then (if (and (< (count MovesThisTurn) 6) (can Move (move Hop (from (last To)) (between if:(and (is Occupied (between)) (!= 1 (state at:(between))))) (to if:(is Empty (to)) (apply (if (is Even (count MovesThisTurn)) (and {(remove (between)) (if (= (what at:(between)) (id "Marker" Shared)) (addScore Mover 1) (addScore Mover 2)) (forEach Site (sites Board) (if (= 1 (state at:(site))) (and (remove (site)) (if (= (what at:(site)) (id "Marker" Shared)) (addScore Mover 1) (addScore Mover 2)))))}) (set State at:(between) 1))))))) (moveAgain) (forEach Site (sites Board) (if (= 1 (state at:(site))) (set State at:(site) 0)))))))}) (rules (start {(place "Marker" (forEach (sites {0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 56 57 58 59 60 61 62 63}) if:(is Even (site)))) (place "Disc" (forEach (sites {0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 56 57 58 59 60 61 62 63}) if:(is Odd (site)))) (place "Marker" (forEach (sites {48 49 50 51 52 53 54 55 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111}) if:(is Odd (site)))) (place "Disc" (forEach (sites {48 49 50 51 52 53 54 55 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111}) if:(is Even (site))))}) phases:{(phase "InitPhase" (play (move Remove (sites Corners) (then (set Score Mover 1)))) (nextPhase "MainPhase")) (phase "MainPhase" (play (if (is Prev Mover) (and (move Pass (then (forEach Site (sites Board) (if (= 1 (state at:(site))) (set State at:(site) 0))))) (move Hop (from (last To)) (between if:(and (is Occupied (between)) (!= 1 (state at:(between))))) (to if:(is Empty (to)) (apply (if (is Even (count MovesThisTurn)) (and {(remove (between)) (if (= (what at:(between)) (id "Marker" Shared)) (addScore Mover 1) (addScore Mover 2)) (forEach Site (sites Board) (if (= 1 (state at:(site))) (and (remove (site)) (if (= (what at:(site)) (id "Marker" Shared)) (addScore Mover 1) (addScore Mover 2)))))}) (set State at:(between) 1)))) (then (if (and (< (count MovesThisTurn) 6) (can Move (move Hop (from (last To)) (between if:(and (is Occupied (between)) (!= 1 (state at:(between))))) (to if:(is Empty (to)) (apply (if (is Even (count MovesThisTurn)) (and {(remove (between)) (if (= (what at:(between)) (id "Marker" Shared)) (addScore Mover 1) (addScore Mover 2)) (forEach Site (sites Board) (if (= 1 (state at:(site))) (and (remove (site)) (if (= (what at:(site)) (id "Marker" Shared)) (addScore Mover 1) (addScore Mover 2)))))}) (set State at:(between) 1))))))) (moveAgain) (forEach Site (sites Board) (if (= 1 (state at:(site))) (set State at:(site) 0))))))) (forEach Piece Shared))))} (end (if (no Moves Next) (byScore))))) 
Each player has 24 pieces, which are placed on the intersections of the lines and move along the lines to an adjacent intersection. Players may capture opponents' pieces by jumping them. Captures are not obligatory. Multiple captures can be made. A player wins by capturing all of the opponent's pieces.
(game "Peralikatuma" (players 2) (equipment {(board (merge {(shift 2 2 (square 5 diagonals:Alternating)) (shift 2 0 (wedge 3)) (shift 5 3 (rotate 90 (wedge 3))) (shift 2 6 (rotate 180 (wedge 3))) (shift -1 3 (rotate 270 (wedge 3)))}) use:Vertex) (piece "Marker" Each)}) (rules (start {(place "Marker1" (union {(expand (sites Bottom) steps:2) (expand (sites Right) steps:3) (sites {"F3" "G3" "F4" "F6" "F7" "G7"})})) (place "Marker2" (union {(expand (sites Top) steps:2) (expand (sites Left) steps:3) (sites {"C3" "D3" "D4" "D6" "D7" "C7"})}))}) (play (if (is Prev Mover) (or (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Pass)) (forEach Piece "Marker" (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Step (to if:(is Empty (to)))))))) (end (if (no Moves Next) (result Next Loss))))) 
Players alternate their turns using one piece to either move or capture exclusively per turn. Pieces may only move one space per turn either straight forward, diagonally forward, or sideways along a line onto a vacant adjacent intersection point. They cannot move backwards in any direction until they are promoted to Kings. However, pieces can make capturing moves backward. Captures are compulsory. Captured pieces are removed from the board. For pieces that have not yet been promoted to King, their captures are done by the short leap as in draughts and Alquerque. A piece leaps over an adjacent enemy piece onto a vacant adjacent intersection point on the other side. The leap must be in a straight line following the pattern on the board. Even pieces that are not yet promoted to King can capture enemy pieces backwards. A player's piece must continue to capture within a turn provided each capture meets the criteria of the short leap. A piece is promoted to King when it reaches the other player's first rank. Kings can move any number of unoccupied spaces in any available direction following the pattern of the board like the King in international draughts. Kings can leap over an enemy piece (and only one enemy piece per leap) from any distance and land any distance behind it onto a vacant intersection point as in the King in international draughts. The King must continue to capture within the turn if it is able to do so. The player who captures all of their opponent's pieces is the winner.
(game "Permainan-Tabal" (players {(player N) (player S)}) (equipment {(board (merge {(square 5 diagonals:Alternating) (shift 0 4 (rotate 180 (wedge 3))) (shift 0 -2 (wedge 3))}) use:Vertex) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (difference (expand (sites Bottom) steps:4) (sites Row 4))) (place "Counter2" (difference (expand (sites Top) steps:4) (sites Row 4)))}) (play (if (is Prev Mover) (if (= (what at:(last To)) (id "Counter" Mover)) (move Hop (from (last To)) Adjacent (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) Adjacent (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover))))) (move Hop (from (last To)) Adjacent (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Adjacent (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))) (priority {(or (forEach Piece "Counter" (move Hop (from) Adjacent (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) Adjacent (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))))) (forEach Piece "DoubleCounter" (move Hop Adjacent (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Adjacent (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))))) (or (forEach Piece "Counter" (move Step (directions {Forwards Rightward Leftward}) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))) (forEach Piece "DoubleCounter" (move Slide Adjacent)))}))) (end (if (no Moves Next) (result Mover Win))))) 
Each player begins with nine pieces. Pieces moves along the lines to the next intersection point. Players may hop an opponent's piece to capture it. Captures can be made in sequence if another capture is available after the previous one is made. The player who captures all of their opponent's pieces wins. The player loses when he has no piece.
(game "Pretwa" (players 2) (equipment {(board (concentric {1 6 6 6}) use:Vertex) (piece "Counter" Each (or (move Hop Rotational (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Rotational (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Step Rotational (to if:(is Empty (to))))))}) (rules (start {(place "Counter1" (sites {2 3 4 8 9 10 14 15 16})) (place "Counter2" (sites {1 6 5 7 12 11 13 18 17}))}) (play (if (is Prev Mover) (or (move Hop (from (last To)) Rotational (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Rotational (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Pass)) (forEach Piece))) (end (if (no Pieces Next) (result Next Loss))))) 
9x9 board played on the intersections, diagonals for the four quadrants of the board. Forty pieces per player, one playing as white, the other as red, arranged on opposite sides of the board, each player's pieces taking up the first through fourth ranks of spaces, plus their right half of the fifth rank. The central spot remains empty. Players alternate turns by moving a piece to an adjacent empty spot along the lines on the board. A player may capture an opponent's piece by hopping over one adjacent piece if there is an empty spot behind it along a line on the board. The player who captures all of the opponent's pieces wins.
(game "Ram Tir" (players 2) (equipment {(board (add (square 9) edges:{{0 10} {10 20} {20 30} {30 40} {40 50} {50 60} {60 70} {70 80} {8 16} {16 24} {24 32} {32 40} {40 48} {48 56} {56 64} {64 72} {4 12} {12 20} {20 28} {28 36} {36 46} {46 56} {56 66} {66 76} {76 68} {68 60} {60 52} {52 44} {44 34} {34 24} {24 14} {14 4}}) use:Vertex) (piece "Marker" Each (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to)))))) (hand P2)}) (rules (start {(place "Marker1" (difference (expand (sites Bottom) steps:4) (sites {36 37 38 39 40}))) (place "Marker2" (difference (expand (sites Top) steps:4) (sites {40 41 42 43 44})))}) (play (forEach Piece)) (end (if (no Pieces Next) (result Next Loss))))) 
9x9 board played on the intersections, with diagonals for each 3x3 square. Forty pieces per player, one playing as white, the other as red, arranged on opposite sides of the board, each player's pieces taking up the first through fourth ranks of spaces, plus their right half of the fifth rank. The central spot remains empty. Players alternate turns by moving a piece to an adjacent empty spot along the lines on the board. A player may capture an opponent's piece by hopping over one adjacent piece if there is an empty spot behind it along a line on the board. The player who captures all of the opponent's pieces wins.
(game "Ratti-Chitti-Bakri" (players 2) (equipment {(board (rectangle 9 9 diagonals:Alternating) use:Vertex) (piece "Marker" Each (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to))))))}) (rules (start {(place "Marker1" (forEach (sites Board) if:(< (site) (centrePoint)))) (place "Marker2" (forEach (sites Board) if:(> (site) (centrePoint))))}) (play (forEach Piece)) (end (forEach Player if:(no Pieces Player) (result Player Loss))))) 
9x9 intersecting lines, with diagonals in each 3x3 square. Two triangles on opposite sides, the apices of which intersect the central point on that side of the square. A line from the apex bisects the base, and this line is bisected with another line which intersects with the other two sides of the triangle. Forty pieces per player, which start on the four rows closest to the player, and on half of the central row. The central space remains empty. Players alternate turns moving a piece to an empty adjacent spot along the lines. Pieces may capture the adjacent piece of an opponent by hopping over it to an empty space directly behind it in a straight line. Multiple hops can be made in one turn if possible, with direction changes allowed. The player who captures all of their opponent's pieces wins.
(game "Satoel" (players 2) (equipment {(board (merge {(square 9 diagonals:Alternating) (shift 2 8 (rotate 180 (wedge 3))) (shift 2 -2 (wedge 3))}) use:Vertex) (piece "Marker" Each (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Step (to if:(is Empty (to))))))}) (rules (start {(place "Marker1" (forEach (sites Board) if:(< (site) (centrePoint)))) (place "Marker2" (forEach (sites Board) if:(and (> (site) (centrePoint)) (< (site) (* 9 9)))))}) (play (if (is Prev Mover) (or (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Pass)) (forEach Piece))) (end (if (no Pieces Next) (result Next Loss))))) 
5x5 intersecting lines, with diagonals drawn in each quadrant. Eleven pieces per player, which begin on the two rows closest to the player, with the eleventh on the outer spot of the middle of to the left of the player. Players alternate turns moving a piece to an empty adjacent spot along the lines. A piece may capture an opponent's piece next to it by hopping over it to an empty spot immediately on the opposite side of the opponent's piece along the lines of the board. The player who captures all of the opponent's pieces wins.
(game "Sumi Naga Game (War)" (players 2) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (piece "Marker" Each (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))))}) (rules (start {(place "Marker1" (union (expand (sites Bottom)) (sites {"A3"}))) (place "Marker2" (union (expand (sites Top)) (sites {"E3"})))}) (play (forEach Piece)) (end (if (no Pieces Next) (result Next Loss))))) 
13x13 intersecting lines. Two players. Each player has 26 pieces. Pieces begin on the two lines closest to each player, opposite sides of the board. Pieces move along the lines of the board to an adjacent spot. A piece can be captured by hopping over an opponent's adjacent piece to an empty spot immediately on the opposite side of it. Multiple captures are allowed. The player who captures all of the opponent's pieces wins.
(game "Tavelspel" (players 2) (equipment {(board (square 13) use:Vertex) (piece "Marker" Each)}) (rules (start {(place "Marker1" (expand (sites Bottom))) (place "Marker2" (expand (sites Top)))}) (play (if (is Prev Mover) (or (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Pass)) (forEach Piece "Marker" (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Step (to if:(is Empty (to)))))))) (end (if (no Pieces Next) (result Next Loss))))) 
5x5 intersecting lines, with diagonals drawn in each quadrant. Ten pieces per player, which begin on the two rows closes to the player. Players alternate turns moving a piece to an empty adjacent spot along the lines. A piece may capture an opponent's piece by hopping over it along the lines of the board to an empty spot immediately on the opposite side of the opponent's piece. The player who captures all of the opponent's pieces wins. Each player has 10 pieces.
(game "Terhuchu (Small)" (players 2) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (piece "Marker" Each (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))))}) (rules (start {(place "Marker1" (expand (sites Bottom))) (place "Marker2" (expand (sites Top)))}) (play (forEach Piece)) (end (if (no Pieces Next) (result Next Loss))))) 
Played on a board similar to Perali Kotuma, with the addition of triangular extensions on the four corners. Play begins with nine pieces for each player. Pieces move along the lines to the next open space. Opponent's pieces can be captured by hopping over them. Within the triangular extensions, pieces may move two places at a time, in a straight line. The player to capture all of the opponent's pieces wins.
(game "Terhuchu" (players 2) (equipment {(board (merge {(shift 2 2 (square 5 diagonals:Alternating)) (shift 2 0 (wedge 3)) (shift 5 3 (rotate 90 (wedge 3))) (shift 2 6 (rotate 180 (wedge 3))) (shift -1 3 (rotate 270 (wedge 3))) (shift 0.65 1.15 (scale 0.5 (rotate -45 (wedge 3)))) (shift 5.35 1.15 (scale 0.5 (rotate 45 (wedge 3)))) (shift 5.35 5.85 (scale 0.5 (rotate 135 (wedge 3)))) (shift 0.65 5.85 (scale 0.5 (rotate -135 (wedge 3))))}) use:Vertex) (piece "Marker" Each (or {(move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to)))) (if (not (is In (from) (difference (expand (sites Centre) steps:2) (sites {"F6" "I6" "L6" "F9" "L9" "F12" "I12" "L12"})))) (move Slide (between (exact 2) if:(and (is Empty (between)) (not (is In (between) (difference (expand (sites Centre) steps:2) (sites {"F6" "I6" "L6" "F9" "L9" "F12" "I12" "L12"}))))))))}))}) (rules (start {(place "Marker1" (sites {"H3" "F6" "G6" "H6" "I6" "J6" "L6" "H8" "I8" "J8"})) (place "Marker2" (sites {"H10" "I10" "J10" "F12" "H12" "I12" "J12" "L12" "J15"}))}) (play (forEach Piece)) (end (if (no Moves Next) (result Next Loss))))) 
5x5 intersecting lines, forming a grid. Diagonals in each of the quadrants. Twelve pieces per player, which begin on the points closest to the player, and the two points to the right of the center point. Players alternate turns moving a piece to an empty adjacent point along the lines of the board. A player may hop over an adjacent opponent's pieces to an empty space immediately on the opposite side of it along the lines of the board to capture it. Multiple captures are allowed. A player wins if they capture all of their opponent's pieces, or reduces the opponent to one piece and blocks them from being able to move.
(game "Tsukkalavde" (players 2) (equipment {(board (rectangle 5 5 diagonals:Alternating) use:Vertex) (piece "Marker" Each (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Step (to if:(is Empty (to))))))}) (rules (start {(place "Marker1" (union (expand (sites Bottom)) (sites {"D3" "E3"}))) (place "Marker2" (union (expand (sites Top)) (sites {"A3" "B3"})))}) (play (if (is Prev Mover) (or (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Pass)) (forEach Piece))) (end (if (and (no Moves Next) (>= 1 (count Pieces Next))) (result Mover Win))))) 
Played on a grid of 4x4 squares, each square with both diagonals. Pieces are played on the intersections of the lines, moving to an empty point along one of the lines. Play begins with 20 pieces per player. Players take turns moving the pieces, and capture the opponent's pieces by hopping over them. When the back line on a player's side of the board is vacated, it is no longer in play. The player who captures the other player's pieces wins.
(game "Tuknanavuhpi" (players 2) (equipment {(board (square 5 diagonals:Solid) use:Vertex) (piece "Counter" Each (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step (to if:(is Empty (to))))))}) (rules (start {(place "Counter1" (union (difference (expand (sites Bottom) steps:2) (sites {"E5" "G5" "I5"})) (sites {"B2" "B4" "D2" "D4" "F2" "F4" "H2" "H4"}))) (place "Counter2" (union (difference (expand (sites Top) steps:2) (sites {"E5" "A5" "C5"})) (sites {"B6" "B8" "D6" "D8" "F6" "F8" "H6" "H8"})))}) (play (forEach Piece)) (end (if (no Moves Next) (result Next Loss))))) 
Played on a square Alquerque board with 9x9 intersecting lines with diagonals. Each player has 40 pieces. Pieces are placed on the intersections of the lines, and move forward along the lines to an adjacent unoccupied intersection. Once pieces reach the opposite side of the board from their starting position at the end of their turn, they are promoted and can move in any direction and over any distance. Opponent's pieces are captured by jumping them. Captures are obligatory if possible. If a player does not capture when they are supposed to, the opponent may remove that piece immediately and then play as normal. The player who captures all of their opponent's pieces or blocks them from being able to move wins.
(game "Zamma" (players {(player N) (player S)}) (equipment {(board (rectangle 9 9 diagonals:Alternating) use:Vertex) (piece "Disc" Each (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (and (if (is In (last To) (sites Next)) (promote (last To) (piece "DiscDouble") Mover)) (set Value Mover 0)))) (move Step Forwards (to if:(is Empty (to))) (then (set Value Mover 1))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DiscDouble") Mover))))) (piece "DiscDouble" Each (or (move Hop (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (set Value Mover 0))) (move Slide (then (set Value Mover 1))))) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Disc1" (forEach (sites Board) if:(< (site) (centrePoint)))) (place "Disc2" (forEach (sites Board) if:(> (site) (centrePoint))))}) (play (or (if (= (value Player Prev) 1) (or (if (and (is In (last From) (sites Pending)) (is In (last From) (sites Empty))) (move Select (from (last To) if:(is Occupied (from))) (then (and {(remove (last To)) (moveAgain) (set Value Prev 0)})))) (move Select (from (sites Pending) if:(is Occupied (from))) (then (and {(remove (last To)) (moveAgain) (set Value Prev 0)}))))) (do (set Pending (sites From (or (forEach Piece "Disc" (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (and (if (is In (last To) (sites Next)) (promote (last To) (piece "DiscDouble") Mover)) (set Value Mover 0))))) (forEach Piece "DiscDouble" (move Hop (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))))))) next:(forEach Piece)))) (end (if (no Moves Mover) (result Next Win))))) 
Cage is a checkers variant for two players played on a square 10x10 board. In this implementation you also have the option of playing on smaller boards. In the initial position, 50 checkers of one color and 50 checkers of a different color fill up the board in a checkered pattern. The goal of the game is to capture all your opponent's checkers. On your turn, if you can, you must choose one of two different kinds of moves to perform: • a single step, or • a sequence of jumps. Note: A single jump is considered a jump sequence of length 1. Universal restriction: All moves are subject to the following restriction: • At no time may a checker be orthogonally adjacent to a checker of the same color. Stepping: Stepping is moving one of your checkers to an orthogonally or diagonally adjacent empty square, and this kind of move is subject to the following two additional restrictions: • A step my never bring the number of orthogonal enemy neighbors of the moved checker down to 0. • The only condition under which a step may fail to bring the moved checker closer to the center of the line you are moving along is if it brings its number of orthogonal enemy neighbors up from 0. (Some elaboration on this last restriction: In general, a step must decrease the moved checker's straight line distance to the board's central intersection. That's the same as bringing it closer to the center of the orthogonal or diagonal line you are moving along. (Note: The center of a diagonal line is an intersection if it is an even number of squares long, and a square otherwise. The center of an orthogonal line is an edge if it is an even number of squares long, and a square otherwise.) Here is a different way of putting it: Whatever diagonal or orthogonal line you are stepping along, the largest distance to an edge square on this line before the step must be bigger than the largest distance to an edge square on the same line after the step. The only exception to this rule, as explained in the last restriction, is if your checker has no orthogonal neighbors and can step into such a relationship – then you may step in any direction.) Jumping sequences: If a checker of your color is orthogonally adjacent to an enemy checker, and immediately on the opposite side of that enemy checker is either an empty square or the outside of the board, your checker may initiate a sequence of jumps. You do this by jumping your checker over to the opposite side of the enemy checker and immediately removing the jumped piece. If your checker lands outside the board, it too is removed from the board. Note: If your last checker is removed when you capture your opponent's last checker, you still win. If the jumping checker lands in a position where it can jump again, your turn does not end, and the checker must make yet a jump. If there are several ways to continue the sequence, you may choose freely between these. The sequence of jumps only ends when the checker lands on a square where it can make no further jump. A 10x10 board is currently selected
(game "Cage" (players 2) (equipment {(board (square 12)) (piece "Disc" Each)}) (rules (start {(place "Disc1" (difference (sites Phase 0) (sites Outer))) (place "Disc2" (difference (sites Phase 1) (sites Outer)))}) (play (forEach Piece (if (!= 1 (var)) (or (move Hop (from) Orthogonal (between if:(is Occupied (between)) (apply (remove (between)))) (to if:(and {(is Empty (to)) (= 0 (count Sites in:(sites Around (to) Own Orthogonal)))})) (then (and {(remove (sites Outer)) (set Var 1) (if (can Move (move Hop (from (last To)) Orthogonal (between if:(is Occupied (between)) (apply (remove (between)))) (to if:(and {(is Empty (to)) (= 0 (count Sites in:(sites Around (to) Own Orthogonal)))})))) (moveAgain) (set Var 0))}))) (move Step (from) (to if:(and {(is Empty (to)) (= 0 (count Sites in:(difference (sites Around (to) Own Orthogonal) (sites {(from)})))) (not (and (< 0 (count Sites in:(sites Around (from) Enemy Orthogonal))) (= 0 (count Sites in:(sites Around (to) Enemy Orthogonal))))) (or {(and (= 0 (count Sites in:(sites Around (from) Enemy Orthogonal))) (< 0 (count Sites in:(sites Around (to) Enemy Orthogonal)))) (or {(and (or (= (from) (+ (to) 12)) (= (from) (- (to) 12))) (> (max (count Sites in:(sites Direction from:(from) N)) (count Sites in:(sites Direction from:(from) S))) (max (count Sites in:(sites Direction from:(to) N)) (count Sites in:(sites Direction from:(to) S))))) (and (or (= (from) (+ (to) 1)) (= (from) (- (to) 1))) (> (max (count Sites in:(sites Direction from:(from) E)) (count Sites in:(sites Direction from:(from) W))) (max (count Sites in:(sites Direction from:(to) E)) (count Sites in:(sites Direction from:(to) W))))) (and (or (= (from) (+ (to) (+ 12 1))) (= (from) (- (to) (+ 12 1)))) (> (max (count Sites in:(sites Direction from:(from) SW)) (count Sites in:(sites Direction from:(from) NE))) (max (count Sites in:(sites Direction from:(to) SW)) (count Sites in:(sites Direction from:(to) NE))))) (and (or (= (from) (+ (to) (- 12 1))) (= (from) (- (to) (- 12 1)))) (> (max (count Sites in:(sites Direction from:(from) SE)) (count Sites in:(sites Direction from:(from) NW))) (max (count Sites in:(sites Direction from:(to) SE)) (count Sites in:(sites Direction from:(to) NW)))))})})})))) (move Hop (from if:(= (from) (last To))) Orthogonal (between if:(is Occupied (between)) (apply (remove (between)))) (to if:(and {(is Empty (to)) (= 0 (count Sites in:(sites Around (to) Own Orthogonal)))})) (then (and {(remove (sites Outer)) (set Var 1) (if (can Move (move Hop (from (last To)) Orthogonal (between if:(is Occupied (between)) (apply (remove (between)))) (to if:(and {(is Empty (to)) (= 0 (count Sites in:(sites Around (to) Own Orthogonal)))})))) (moveAgain) (set Var 0))})))))) (end (if (or (= 0 (count Sites in:(sites Occupied by:P1))) (= 0 (count Sites in:(sites Occupied by:P2)))) (result Mover Win))))) 
3x8 board. The second space from the left and from the right in the center row are marked with an X. Eight pieces per player, which begin in the row closest to the player. Players alternate turns moving a piece to an empty adjacent space in an orthogonal direction. On the first move of a piece, that piece may move two spaces in one direction. A player may capture an opponent's piece in the central row by hopping over it to an empty space on the opposite side of it. The player who reduces their opponent to fewer than four pieces wins.
(game "Caturvimsatikosthakatmiki Krida" (players 2) (equipment {(board (rectangle 3 8)) (piece "Marker" Each (or {(move Hop Orthogonal (between if:(and (is Enemy (who at:(between))) (not (is In (between) (union (sites Bottom) (sites Top))))) (apply (remove (between)))) (to if:(is Empty (to)))) (move Step Orthogonal (to if:(is Empty (to)))) (if (= 1 (state at:(from))) (move Slide Orthogonal (between (exact 2) if:(is Empty (between))) (then (set State at:(last To) 0))))}))}) (rules (start {(place "Marker1" (sites Bottom) state:1) (place "Marker2" (sites Top) state:1)}) (play (forEach Piece)) (end (if (<= (count Pieces Next) 3) (result Next Loss))))) 
9x9 intersecting lines forming a square. Forty pieces per player, lined up on the intersections on the rows closest to them, and the right half of the central line. Players alternate turns moving pieces to an empty adjacent spot along the lines. A piece may capture an opponent's piece by hopping over it to the empty spot immediately on the opposite side of it, following the lines of the board. Multiple captures are allowed. The player who captures all of the opponent's pieces wins.
(game "Challis Ghutia" (players 2) (equipment {(board (square 9) use:Vertex) (piece "Marker" Each (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Step (to if:(is Empty (to))))))}) (rules (start {(place "Marker1" (union (expand (sites Bottom) steps:3) (sites {"F5" "G5" "H5" "I5"}))) (place "Marker2" (union (expand (sites Top) steps:3) (sites {"A5" "B5" "C5" "D5"})))}) (play (if (is Prev Mover) (or (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Pass)) (forEach Piece))) (end (if (no Pieces Next) (result Next Loss))))) 
Five rows of five holes. Each player has twelve sticks; one player's sticks are longer than the other player's. Players alternate turns placing one of their sticks in an empty hole on the board. A player may, on their turn, move a stick to an empty adjacent hole in an orthogonal direction instead of placing a stick. Players do not have to place all of their sticks before moving, but if they wish to place a stick after they have already moved, the opponent must also place a stick on their following turn. A player captures an opponent's stick by hopping over it in an orthogonal direction to an empty hole immediately on the opposite side of the opponent's stick. The player who captures all of the opponent's pieces wins.
(game "Choko" (players 2) (equipment {(board (square 5) use:Vertex) (piece "Stick" Each (or (move Step Orthogonal (to if:(is Empty (to)))) (move Hop Orthogonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))))) (hand Each) (regions "AllSites" (sites Board))}) (rules (start (place "Stick" "Hand" count:12)) (play (if (is Pending) (move (from (handSite Mover)) (to (sites Empty))) (or (if (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site))))) (move (from (handSite Mover)) (to (sites Empty)) (then (set Pending)))) (forEach Piece)))) (end (if (no Pieces Next) (result Next Loss))))) 
8x8 board. 16 pieces per player, lined up in the second and third rows (first row on each side is empty). Pieces move forward or horizontally one space, and capture opponents' pieces by jumping in these directions. When they reach the opposite side, they become a king and can jump opponents' pieces from any distance orthogonally. Multiple captures cannot be made by moving 180 degrees from the previous jump. Pieces can be promoted to king mid-jump. Winning is achieved by capturing all of the other player's pieces or by blocking them so they cannot move. 
(game "Dama (Comoros)" (players 2) (equipment {(board (square 8)) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (union (sites Row 1) (sites Row 2))) (place "Counter2" (union (sites Row 5) (sites Row 6)))}) (play (if (is Prev Mover) (or (if (= (what at:(last To)) (id "Counter" Mover)) (move Hop (from (last To)) (directions {Forward Rightward Leftward}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) (directions {Forward Rightward Leftward}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover))))) (move Hop (from (last To)) (difference Orthogonal OppositeDirection) (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) (difference Orthogonal OppositeDirection) (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))) (move Pass)) (or {(forEach Piece "Counter" (move Hop (from (from)) (directions {Forward Rightward Leftward}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) (directions {Forward Rightward Leftward}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))))) (forEach Piece "DoubleCounter" (move Hop (from) Orthogonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) (difference Orthogonal OppositeDirection) (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))) (forEach Piece "Counter" (move Step (directions {Forward Rightward Leftward}) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))) (forEach Piece "DoubleCounter" (move Slide Orthogonal))}))) (end (if (no Moves Next) (result Mover Win))))) 
8x8 board. 16 pieces per player, lined up in the second and third rows (first row on each side is empty). Pieces move forward or horizontally one space, and capture opponents' pieces by jumping in these directions. When they reach the opposite side, they become a king and can jump opponents' pieces from any distance orthogonally. Captures must be taken if possible, and the maximum number of jumps must be made. In a situation where two pieces are able to make the maximum number of captures and one of them is a king, the king must make the captures. Multiple captures cannot be made by moving 180 degrees from the previous jump. Pieces can be promoted to king mid-jump. Winning is achieved by capturing all of the other player's pieces or by blocking them so they cannot move.
(game "Dama (Kenya)" (players 2) (equipment {(board (square 8)) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (union (sites Row 1) (sites Row 2))) (place "Counter2" (union (sites Row 5) (sites Row 6)))}) (play (if (is Prev Mover) (if (= (what at:(last To)) (id "Counter" Mover)) (max Moves (move Hop (from (last To)) (directions {Forward Rightward Leftward}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) (directions {Forward Rightward Leftward}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))))) (max Moves (move Hop (from (last To)) (difference Orthogonal OppositeDirection) (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) (difference Orthogonal OppositeDirection) (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))) (priority {(max Moves (priority {(forEach Piece "DoubleCounter" (move Hop (from) Orthogonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) (difference Orthogonal OppositeDirection) (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))) (forEach Piece "Counter" (move Hop (from (from)) (directions {Forward Rightward Leftward}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) (directions {Forward Rightward Leftward}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover))))))})) (or (forEach Piece "Counter" (move Step (directions {Forward Rightward Leftward}) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))) (forEach Piece "DoubleCounter" (move Slide Orthogonal)))}))) (end (if (no Moves Next) (result Mover Win))))) 
Played on an 8x8 board. 16 pieces per player, lined up in the second and third rows (first row on each side is empty). Pieces move forward or horizontally one space, and capture opponents' pieces by jumping in these directions. When they reach the opposite side, they become a king and can jump opponents' pieces from any distance orthogonally. Captures must be taken if possible, and the maximum number of jumps must be made. Multiple captures cannot be made by moving 180 degrees from the previous jump. Pieces can be promoted to king mid-jump. Winning is achieved by capturing all of the other player's pieces or by blocking them so they cannot move.
(game "Dama" (players 2) (equipment {(board (square 8)) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (union (sites Row 1) (sites Row 2))) (place "Counter2" (union (sites Row 5) (sites Row 6)))}) (play (if (is Prev Mover) (if (= (what at:(last To)) (id "Counter" Mover)) (max Moves (move Hop (from (last To)) (directions {Forward Rightward Leftward}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) (directions {Forward Rightward Leftward}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))))) (max Moves (move Hop (from (last To)) (difference Orthogonal OppositeDirection) (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) (difference Orthogonal OppositeDirection) (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))) (priority {(max Moves (or (forEach Piece "Counter" (move Hop (from (from)) (directions {Forward Rightward Leftward}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) (directions {Forward Rightward Leftward}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))))) (forEach Piece "DoubleCounter" (move Hop (from) Orthogonal (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) (difference Orthogonal OppositeDirection) (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))))) (or (forEach Piece "Counter" (move Step (directions {Forward Rightward Leftward}) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))) (forEach Piece "DoubleCounter" (move Slide Orthogonal)))}))) (end (if (no Moves Next) (result Mover Win))))) 
Each player, on their first five turns, uses some of their own pieces to create one King and three Generals, in any preferred order. A General is made by placing any single piece on top of an orthogonally adjacent piece, and a King is made by placing any single piece on top of an orthogonally adjacent General. - Soldiers move orthogonally one step to an adjacent square. - Generals move any distance in a straight line orthogonally, like a Chess Rook. - The King moves one step to any adjacent square, like a Chess King Capture is compulsory if possible. - A Soldier or King captures by jumping over an enemy piece occupying a square to which it can legally move and landing on the square immediately beyond it in the same direction, provided that the landing square is vacant. - A General captures in the same way, but may move any number of vacant squares before the captured piece, and may land on any successive vacant square in line of travel beyond the captured piece. If the capturing piece can then make another capture, it must, and it must continue doing so until all possible consecutive captures have been made. An enemy piece can only be jumped once in a single turn. If it is reached a second time it forms a block and ends the turn. At the end of a capturing turn all captured pieces must be removed from the board before the next player moves. If more than one capture is possible you must choose that which captures the greatest number of pieces, counting a King as three, a General as two, and a Soldier as one. If two possible capturing moves offer an equal number of pieces, you may freely choose between them. If one or more of your Generals is captured in one turn, you may create just one General (not more) from two orthogonally adjacent Soldiers anywhere on the board. If your King is captured you must, if possible, use your next turn to create another King by placing a Soldier on top of an adjacent General. If you are unable to create another King, when your King is captured, you lose the game. The game is played on a 9x9 square board.
(game "Fenix" (players 2) (equipment {(board (square 9)) (piece "Fenix" Each)}) (rules (start {(place "Fenix1" (expand (intersection (sites Bottom) (sites Right)) steps:6 Orthogonal) value:1) (place "Fenix2" (expand (intersection (sites Top) (sites Left)) steps:6 Orthogonal) value:1)}) phases:{(phase "Setup" (play (move (from (sites Occupied by:Mover) if:(= 1 (size Stack at:(from)))) (to (sites Around (from) Own Orthogonal) if:(and {(!= (from) (to)) (< (size Stack at:(to)) 3) (if (all Sites (sites Occupied by:Mover) if:(!= 3 (size Stack at:(site)))) True (< (size Stack at:(to)) 2)) (if (!= 3 (count Sites in:(forEach (sites Occupied by:Mover) if:(= 2 (size Stack at:(site)))))) True (not (= 1 (size Stack at:(to)))))})))) (nextPhase Mover (and (not (all Sites (sites Occupied by:Mover) if:(!= 3 (size Stack at:(site))))) (not (!= 3 (count Sites in:(forEach (sites Occupied by:Mover) if:(= 2 (size Stack at:(site)))))))) "Play")) (phase "Play" (play (if (is Prev Mover) (max Moves withValue:True (if (= 1 (size Stack at:(last To))) (move Hop (from (last To)) Orthogonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn count:(size Stack at:(between))))) (to if:(is Empty (to))) stack:True (then (if (can Move (move Hop (from (last To)) Orthogonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn count:(size Stack at:(between))))) (to if:(is Empty (to))) stack:True)) (moveAgain)))) (if (= 3 (size Stack at:(last To))) (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn count:(size Stack at:(between))))) (to if:(is Empty (to))) stack:True (then (if (can Move (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn count:(size Stack at:(between))))) (to if:(is Empty (to))) stack:True)) (moveAgain)))) (if (= 2 (size Stack at:(last To))) (move Hop (from (last To)) Orthogonal (between before:(count Columns) after:(count Columns) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn count:(size Stack at:(between))))) (to if:(is Empty (to))) stack:True (then (if (can Move (hop (from (last To)) Orthogonal (between before:(count Columns) after:(count Columns) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))))))) (if (all Sites (sites Occupied by:Mover) if:(!= 3 (size Stack at:(site)))) (forEach Piece (if (= 1 (size Stack at:(from))) (move Step Orthogonal (to if:(and (is Friend (who at:(to))) (= 2 (size Stack at:(to))))) stack:True))) (priority {(max Moves withValue:True (forEach Piece (if (= 1 (size Stack at:(from))) (move Hop (from (from)) Orthogonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn count:(size Stack at:(between))))) (to if:(is Empty (to))) stack:True (then (if (can Move (move Hop (from (last To)) Orthogonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn count:(size Stack at:(between))))) (to if:(is Empty (to))) stack:True)) (moveAgain)))) (if (= 3 (size Stack at:(from))) (move Hop (from (from)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn count:(size Stack at:(between))))) (to if:(is Empty (to))) stack:True (then (if (can Move (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn count:(size Stack at:(between))))) (to if:(is Empty (to))) stack:True)) (moveAgain)))) (if (= 2 (size Stack at:(from))) (move Hop (from) Orthogonal (between before:(count Columns) after:(count Columns) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn count:(size Stack at:(between))))) (to if:(is Empty (to))) stack:True (then (if (can Move (hop (from (last To)) Orthogonal (between before:(count Columns) after:(count Columns) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))))))) (forEach Piece (if (= 1 (size Stack at:(from))) (or (move Step Orthogonal (to if:(is Empty (to))) stack:True) (if (!= 3 (count Sites in:(forEach (sites Occupied by:Mover) if:(= 2 (size Stack at:(site)))))) (move Step Orthogonal (to if:(and (is Friend (who at:(to))) (= 1 (size Stack at:(to))))) stack:True))) (if (= 2 (size Stack at:(from))) (move Slide Orthogonal stack:True) (if (= 3 (size Stack at:(from))) (move Step (to if:(is Empty (to))) stack:True)))))})))) (end (if (all Sites (sites Occupied by:Mover) if:(!= 3 (size Stack at:(site)))) (result Mover Loss))))})) 
Pieces move one step forward. Otherwise, the rules are the same as International Draughts: Pieces can jump an opponent's adjacent player to capture it. Pieces can move forward or backwards. When a piece reaches the opposite edge of the board from its starting position, it becomes a king and can may move and jump over any number of spaces diagonally. Captures are compulsory and the maximum number of jumps must be made. Winning is achieved by capturing all the opponent's pieces or by blocking them from moving.
(game "HexDame" (players 2) (equipment {(board (rotate 90 (hex 5))) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (union (sites Side SW) (sites Side SE))) (regions P2 (union (sites Side NW) (sites Side NE)))}) (rules (start {(place "Counter1" (expand (sites Bottom) steps:3)) (place "Counter2" (expand (sites Top) steps:3))}) (play (if (is Prev Mover) (if (= (what at:(last To)) (id "Counter" Mover)) (max Moves (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))))) (max Moves (move Hop (from (last To)) (between before:10 after:10 if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between before:10 after:10 if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))))) (priority {(max Moves (or (forEach Piece "Counter" (move Hop (from (from)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))))) (forEach Piece "DoubleCounter" (move Hop (between before:10 after:10 if:(is Enemy (who at:(between))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between before:10 after:10 if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))))) (or (forEach Piece "Counter" (move Step (directions {Forward FL FR}) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))) (forEach Piece "DoubleCounter" (move Slide)))}))) (end (if (no Moves Next) (result Mover Win))))) 
MOVE - Stones may move to an adjacent (orthogonal or diagonal) empty cell. CAPTURE - Stones capture by jumping over an enemy stone and landing in the immediate opposite empty cell. - Captures are mandatory. - Captures are multiple and the player must choose the jumping sequence that captures more enemy stones. GOAL - A player wins when it captures all enemy stones, or when he moves his last remaining stone to the center cell.
(game "Jumping Beans" (players 2) (equipment {(board (square 7)) (piece "Bean" Each (move Step (to if:(is Empty (to)))))}) (rules (start {(place "Bean1" (forEach (sites Board) if:(< (site) (centrePoint)))) (place "Bean2" (forEach (sites Board) if:(> (site) (centrePoint))))}) (play (if (is Prev Mover) (max Moves (move Hop (from (last To)) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))) (priority {(max Moves (forEach Piece (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))) (forEach Piece)}))) (end (if (or (no Pieces Next) (and (= 1 (count Pieces Mover)) (= (centrePoint) (where "Bean" Mover)))) (result Mover Win))))) 
TURNS - At each turn, each player must move one of his stones (called Kangaroos): - A stone must jump over one (orthogonal or diagonal) adjacent stone landing on the immediate next empty cell. - If the jumped enemy stones are captured and removed from the board. - Jumps can be multiple but are not mandatory. GOAL - The game ends when one player cannot move. The winner is the one with more stones.
(game "Kanguruh" (players 2) (equipment {(board (square 8)) (piece "Kangaroo" Each (move Hop (between if:(is Occupied (between))) (to if:(is Empty (to)) (apply (and {(if (is Enemy (who at:(between))) (remove (between))) (remember Value (from)) (remember Value (to))}))) (then (if (can Move (hop (from (last To)) (between if:(is Occupied (between))) (to if:(and (is Empty (to)) (not (is In (to) (values Remembered))))))) (moveAgain) (forget Value All)))))}) (rules (start {(place "Kangaroo1" (expand (sites Bottom))) (place "Kangaroo2" (expand (sites Top)))}) (play (if (is Prev Mover) (or (move Pass (then (forget Value All))) (move Hop (from (last To)) (between if:(is Occupied (between))) (to if:(and (is Empty (to)) (not (is In (to) (values Remembered)))) (apply (and (if (is Enemy (who at:(between))) (remove (between))) (remember Value (to))))) (then (if (can Move (hop (from (last To)) (between if:(is Occupied (between))) (to if:(and (is Empty (to)) (not (is In (to) (values Remembered))))))) (moveAgain) (forget Value All))))) (forEach Piece))) (end (if (no Moves Next) (byScore {(score P1 (count Pieces P1)) (score P2 (count Pieces P2))}))))) 
10x10 board. The black player starts by removing one black piece either from one of the central four spaces of the board or from one of the four corners. The white player then must remove a white piece that is orthogonally adjacent to the empty space. Play proceeds by orthogonally jumping an opposing piece and capturing it. All moves must be capturing moves. Multiple captures can be made only by continuing in the same direction. The first player unable to move loses. The game is played on a 10x10 board.
(game "Konane" (players 2) (equipment {(board (square 10)) (piece "Marker" Each)}) (rules (start {(place "Marker1" (sites Phase 1)) (place "Marker2" (sites Phase 0))}) phases:{(phase "OpeningP1" P1 (play (move Remove (intersection (union (sites Corners) (sites Centre)) (sites Phase 1)))) (nextPhase Mover "Movement")) (phase "OpeningP2" P2 (play (move Remove (sites Around (last To) Own))) (nextPhase Mover "Movement")) (phase "Movement" (play (if (is Prev Mover) (or (move Hop (from (last To)) SameDirection (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) SameDirection (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))) (move Pass)) (forEach Piece "Marker" (move Hop (from (from)) Orthogonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) SameDirection (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))))))} (end (if (no Moves Next) (result Next Loss))))) 
5x5 board. Twelve pieces per player, arranged in the two rows in front of each player, and in the right two squares in the central row (the central space is empty). Players alternate turns moving a piece to an adjacent orthogonal space. The player may capture an opponent's piece by hopping over it in an orthogonal direction. Multiple hops are allowed in the same turn, but captures are not compulsory, The player who captures all of their opponent's pieces wins.
(game "Koruboddo" (players 2) (equipment {(board (square 5)) (piece "Marker" Each (or (move Hop Orthogonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Orthogonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Step Orthogonal (to if:(is Empty (to))))))}) (rules (start {(place "Marker1" (union {(sites Row 0) (sites Row 1) (sites {"A3" "B3"})})) (place "Marker2" (union {(sites Row 3) (sites Row 4) (sites {"D3" "E3"})}))}) (play (if (is Prev Mover) (or (move Hop (from (last To)) Orthogonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Orthogonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Pass)) (forEach Piece))) (end (if (no Pieces Next) (result Next Loss))))) 
Cross-shaped board, with any number of squares in the arm with a central square, and a number of pieces per player equal to the number of spaces in two arms. Three squares in each arm with six pieces per player is common. Players alternate turns placing pieces on the board. Players may not place pieces in the central space. When the pieces are placed, players alternate turns move a piece to am empty adjacent square, or hopping over an adjacent opponent's piece or an unbroken line of opponent's pieces with an empty space behind it. The player who captures all of the opponent's pieces wins.  The game is played on a cross board of arm size of 3.
(game "Laram Wali" (players 2) (equipment {(board (merge (shift 0 (/ (- (* 3 3) 3) 2) (rectangle 3 (* 3 3))) (shift (/ (- (* 3 3) 3) 2) 0 (rectangle (* 3 3) 3))) use:Cell) (hand Each) (piece "Marker" Each (or (move Step Orthogonal (to if:(is Empty (to)))) (move Hop Orthogonal (between (range 1 6) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))))}) (rules (start (place "Marker" "Hand" count:6)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (difference (sites Empty) (expand (sites Centre) steps:(- (/ 3 2) (if (is Even 3) 1 0))))))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end (if (no Pieces Next) (result Next Loss))))) 
Played on a 8x8 board. Each player has two stones, who can jump over any other stone. Enemy stones jumped over are captured. First player unable to move loses.
(game "Leap Frog" (players 2) (equipment {(board (square 8)) (piece "Marker" Each (move Hop (between if:(is Occupied (between)) (apply (if (is Enemy (who at:(between))) (remove (between))))) (to if:(is Empty (to)))))}) (rules (start {(place "Marker1" {"B4" "C5" "C6" "D2" "D4" "D6" "E3" "E5" "E7" "F3" "F4" "G5"}) (place "Marker2" {"B5" "C3" "C4" "D3" "D5" "D7" "E2" "E4" "E6" "F5" "F6" "G4"})}) (play (forEach Piece)) (end (if (no Moves Next) (result Mover Win))))) 
The king player receives one king piece and an army of 18. The mob player gets 26 pieces. Play is set on a star shape board. Captures are done by jumping adjacent enemy pieces and are compulsory but not multiple. Only the King can move to one of the star point cells (the blue cells). If no possible capture, a player moves a pawn to an adjacent empty cell. The mob wins if the king is captured and the king player wins by getting the king piece to any of the points of the star.
(game "Louis XVI" (players 2) (equipment {(board (remove (hex 7) cells:{0 1 2 4 5 6 7 8 9 12 13 14 15 16 22 23 57 45 70 34 58 82 46 71 69 81 56 44 68 92 55 80 120 121 122 124 125 126 112 113 114 117 118 119 103 104 110 111})) (piece "Pawn" Each) (piece "King" P2) (regions "GoalKing" (difference (sites Corners) (expand (sites Centre) steps:4)))}) (rules (start {(place "Pawn1" (difference (expand (sites Centre) steps:4) (expand (sites Centre) steps:3))) (place "Pawn2" (difference (expand (sites Centre) steps:2) (sites Centre))) (place "Pawn1" (difference (expand (sites Centre) steps:4) (expand (sites Centre) steps:3))) (place "King2" (sites Centre))}) (play (priority {(or (forEach Piece "Pawn" (move Hop (between if:(is Enemy (who at:(between)))) (to if:(and (not (is In (to) (sites "GoalKing"))) (is Empty (to))) (apply (remove (between)))))) (forEach Piece "King" (move Hop (between if:(is Enemy (who at:(between)))) (to if:(is Empty (to)))))) (or (forEach Piece "Pawn" (move Step (to if:(and (not (is In (to) (sites "GoalKing"))) (is Empty (to))) (apply (remove (between)))))) (forEach Piece "King" (move Step (to if:(is Empty (to))))))})) (end {(if (= (where "King" P2) -1) (result P1 Win)) (if (is Within (id "King2") in:(sites "GoalKing")) (result P2 Win))}))) 
5x5 board. Twelve pieces per player. Players alternate turns placing two pieces on the board, leaving the central space empty. Once all the pieces have been placed, players alternate turns moving one space orthogonally to an empty space. An opponent's piece may be captured by hopping over it to an empty space immediately on the opposite side of it in an orthogonal direction. Multiple captures are allowed, and a player is allowed to land on a space already landed on during the chain of captures. Captures are not compulsory. A player wins when they capture all of their opponent's pieces or the opponent cannot move.
(game "Mraha wa Bwe" (players 2) (equipment {(board (square 5)) (piece "Counter" Each) (hand Each)}) (rules (start (place "Counter" "Hand" count:12)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (difference (sites Empty) (sites Centre))) (then (if (not (is Prev Mover)) (moveAgain))))) (nextPhase Mover (is Empty (handSite Mover)) "Play")) (phase "Play" (play (if (is Prev Mover) (or (move Hop (from (last To)) Orthogonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) Orthogonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))) (move Pass)) (or (forEach Piece "Counter" (move Hop (from (from)) Orthogonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) Orthogonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))) (forEach Piece "Counter" (move Step Orthogonal (to if:(is Empty (to)))))))))} (end (if (no Moves Mover) (result Mover Loss))))) 
5x5 board, the central square marked with an X. Twelve pieces per player. Pieces begin the game on the first two rows in front of the player, and in the two squares to the player's right in the central row. Players alternate turns moving a piece orthogonally to an adjacent empty space. Players may capture an opponent's piece by hopping over it. The player who captures all of the opponent's pieces wins.
(game "Natt Klab ash-Shawk" (players 2) (equipment {(board (square 5)) (piece "Marker" Each (or (move Step Orthogonal (to if:(is Empty (to)))) (move Hop Orthogonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))))}) (rules (start {(place "Marker1" (union {(expand (sites Bottom)) (sites {"D3" "E3"})})) (place "Marker2" (union {(sites {"A3" "B3"}) (expand (sites Top))}))}) (play (forEach Piece)) (end (if (no Pieces Next) (result Next Loss))))) 
Men can move one step forwards orthogonally or diagonally, or can jump an opponent's adjacent piece to capture it, in any direction. When a man ends its turn on the opposite edge of the board from its starting position, it becomes a king and may move or jump over any number of spaces in any direction. Captures are compulsory and the maximum number of jumps must be made. The first player unable to move, loses. The game is played on a 8x8 board
(game "Omnidirectional Draughts" (players 2) (equipment {(board (square 8)) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (expand (sites Bottom) steps:(- (/ 8 2) 2))) (place "Counter2" (expand (sites Top) steps:(- (/ 8 2) 2)))}) (play (if (is Prev Mover) (if (= (what at:(last To)) (id "Counter" Mover)) (max Moves (move Hop (from (last To)) All (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) All (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))))) (max Moves (move Hop (from (last To)) (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))))) (priority {(max Moves (or (forEach Piece "Counter" (move Hop (from (from)) All (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) All (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))))) (forEach Piece "DoubleCounter" (move Hop (between before:(count Rows) after:(count Rows) if:(is Enemy (who at:(between))) (apply (remove (between) at:EndOfTurn))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between before:(count Rows) after:(count Rows) if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain))))))) (or (forEach Piece "Counter" (move Step (directions Forwards) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))) (forEach Piece "DoubleCounter" (move Slide)))}))) (end (if (no Moves Next) (result Mover Win))))) 
Played on a board with two rows of five spaces forming an "X," with an extra space diagonally adjacent to the central space. Ten sticks per player. Each player begins with one stick in each of the rightmost four spaces on the edge of the board closest to them. Players alternate turns moving a stick to an adjacent space. A player may capture one of the opponent's sticks by jumping over it to an empty space beyond it. The opponent replaces the captured stick with one of those remaining in their reserve, until there are no sticks remaining. The player who captures all of the opponent's sticks wins. 
(game "Queah Game" (players 2) (equipment {(board (rotate 45 (merge (shift 1 -1 (rectangle 5 1)) (merge (shift -1 1 (rectangle 1 5)) (square 3))))) (piece "Stick" Each (or (move Step Orthogonal (to if:(is Empty (to)))) (move Hop Orthogonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))))) (hand Each)}) (rules (start {(place "Stick1" {"A1" "B2" "A3" "B4"}) (place "Stick2" {"E5" "D4" "E3" "D2"}) (place "Stick" "Hand" count:6)}) (play (if (and (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site))))) (< (count Sites in:(sites Occupied by:Mover container:"Board")) 4)) (move (from (handSite Mover)) (to (sites Empty)) (then (moveAgain))) (forEach Piece))) (end (if (no Pieces Next) (result Next Loss))))) 
Overview: In Seesaw the players (North and South) command opposing armies with soldiers that can promote. Your army starts out as a single soldier and your promotion area evolves as you deploy more soldiers. Every time a soldier promotes it grows - first into a 2-stack, then a 3-stack, and so on. The central idea of Seesaw is the 2-fold significance of stack-size: (i) Odd-sized stacks move forwards and even-sized stacks move backwards, and (ii) on any given turn, a stack can take as many steps as it likes from 1 up to its size. This results in soldiers seesawing up and down the board as their strength increases to the point where the game is forced to conclude in one side completely eliminating the other. How to play: On your turn, you must either make a stack-move, or place a new stack. 1. Placing a new stack: A newly placed stack will always be of size 1. You may only place a stack on an empty cell next to a cell of your color. These cells are promotion cells, and each cell you place a new stack on automatically turns into a promotion cell of your color. 2. Stackmoves: You only ever move one stack per turn, but that stack may be able to move several steps or capture several enemiy stacks, depending on its size. The number of steps a stack may take is the number of pieces in it, i.e. its size. 2.1 Noncapturing moves: On turns where you do not have to capture an enemy (see below) all the steps a stack takes is either constrained to the 3 upward directions or to the 3 downward directions, depending on the size and the owner of the stack. South's forward directions are the 3 upward directions, and North's forward directions are the 3 downward directions. 2.2 Capturing moves: If one or more of your stacks can reach an enemy by lifting the restraint on direction, you must capture such a reachable enemy by replacement. If that stack did not spend all its steps reaching the captured enemy, you can, before you end your turn, spend the left-over steps by making a noncapturing move. However, if yet an enemy is in range immediately after you have captured (counting only the steps left over), you must capture again. 3. Promoting: Your odd-sized stacks promote when they end up on a promotion cell belonging to your opponent at the end of your turn. Your even-sized stacks promote when they end up on a promotion cell belonging to you at the end of your turn. The object of Seesaw is to capture all your opponent's soldiers. More precisely: If, at the end of your turn, your opponent has no stacks on the board, you have won the game. A base 4 board is currently selected
(game "Seesaw" (players {(player N) (player S)}) (equipment {(board (rotate 30 (hex 4))) (piece "Disc" Each) (tile "Hex" Each)}) (rules (start {(place Stack "Hex1" 0) (place Stack "Disc1" 0) (place Stack "Hex2" (* 4 (* 3 (- 4 1)))) (place Stack "Disc2" (* 4 (* 3 (- 4 1))))}) (play (if (can Move (forEach Piece "Disc" (do (if (= 0 (count MovesThisTurn)) (set Var (count Stack at:(from) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))))) next:(move (from if:(= (* (from) (if (< 0 (count MovesThisTurn)) 1 0)) (* (last To) (if (< 0 (count MovesThisTurn)) 1 0)))) (to (if (> (var) 1) (intersection (sites Around (intersection (sites Distance (step (to if:(= 0 (count Stack at:(to) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover))))))) from:(from) (range 1 (- (var) 1))) (sites Around (sites Occupied by:Enemy component:"Disc")))) (sites Occupied by:Enemy component:"Disc")) (intersection (sites Around (from)) (sites Occupied by:Enemy component:"Disc"))) (apply (remove (to) count:(count Stack at:(to) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover))))))) count:(count Stack at:(from) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))) stack:True)) top:True)) (forEach Piece "Disc" (do (if (= 0 (count MovesThisTurn)) (set Var (count Stack at:(from) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))))) next:(move (from if:(= (* (from) (if (< 0 (count MovesThisTurn)) 1 0)) (* (last To) (if (< 0 (count MovesThisTurn)) 1 0)))) (to (if (> (var) 1) (intersection (sites Around (intersection (sites Distance (step (to if:(= 0 (count Stack at:(to) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover))))))) from:(from) (range 1 (- (var) 1))) (sites Around (sites Occupied by:Enemy component:"Disc")))) (sites Occupied by:Enemy component:"Disc")) (intersection (sites Around (from)) (sites Occupied by:Enemy component:"Disc"))) (apply (remove (to) count:(count Stack at:(to) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover))))))) count:(count Stack at:(from) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))) stack:True)) top:True (then (set Var (- (var) (count Steps (step (to if:(or (= (last To) (to)) (= 0 (count Stack at:(to) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))))))) (last From) (last To))) (then (if (< 0 (var)) (moveAgain) (if (= (+ (* 1 (% (count Stack at:(last To) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))) 2)) (% (mover) (- 3 (% (count Stack at:(last To) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))) 2)))) (* (who at:(last To) level:0) (count Stack at:(last To) if:(or (= (id "Hex" Next) (what at:(to) level:(level))) (= (id "Hex" Mover) (what at:(to) level:(level))))))) (add (piece (id "Disc" Mover)) (to (last To)) stack:True))))))) (if (< 0 (count MovesThisTurn)) (or (forEach Piece "Disc" (do (if (= 0 (count MovesThisTurn)) (set Var (count Stack at:(from) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))))) next:(move (from if:(= (* (from) (if (< 0 (count MovesThisTurn)) 1 0)) (* (last To) (if (< 0 (count MovesThisTurn)) 1 0)))) (to (if (is Odd (count Stack at:(from) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover))))) (sites Distance (step Forwards (to if:(= 0 (count Stack at:(to) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover))))))) from:(from) (range 1 (var))) (sites Distance (step Backwards (to if:(= 0 (count Stack at:(to) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover))))))) from:(from) (range 1 (var))))) count:(count Stack at:(from) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))) stack:True)) top:True) (move Pass) (then (if (= (+ (* 1 (% (count Stack at:(last To) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))) 2)) (% (mover) (- 3 (% (count Stack at:(last To) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))) 2)))) (* (who at:(last To) level:0) (count Stack at:(last To) if:(or (= (id "Hex" Next) (what at:(to) level:(level))) (= (id "Hex" Mover) (what at:(to) level:(level))))))) (add (piece (id "Disc" Mover)) (to (last To)) stack:True)))) (or (forEach Piece "Disc" (do (if (= 0 (count MovesThisTurn)) (set Var (count Stack at:(from) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))))) next:(move (from if:(= (* (from) (if (< 0 (count MovesThisTurn)) 1 0)) (* (last To) (if (< 0 (count MovesThisTurn)) 1 0)))) (to (if (is Odd (count Stack at:(from) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover))))) (sites Distance (step Forwards (to if:(= 0 (count Stack at:(to) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover))))))) from:(from) (range 1 (var))) (sites Distance (step Backwards (to if:(= 0 (count Stack at:(to) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover))))))) from:(from) (range 1 (var))))) count:(count Stack at:(from) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))) stack:True)) top:True (then (if (= (+ (* 1 (% (count Stack at:(last To) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))) 2)) (% (mover) (- 3 (% (count Stack at:(last To) if:(or (= (what at:(to) level:(level)) (id "Disc" Next)) (= (what at:(to) level:(level)) (id "Disc" Mover)))) 2)))) (* (who at:(last To) level:0) (count Stack at:(last To) if:(or (= (id "Hex" Next) (what at:(to) level:(level))) (= (id "Hex" Mover) (what at:(to) level:(level))))))) (add (piece (id "Disc" Mover)) (to (last To)) stack:True)))) (move Add (piece (id "Hex" Mover)) (to (sites Around (sites Occupied by:Mover component:"Hex" top:False)) if:(is Empty (to))) (then (add (piece (id "Disc" Mover)) (to (last To)) stack:True))))))) (end (if (= 0 (count Sites in:(sites Occupied by:Next component:"Disc"))) (result Next Loss))))) 
5x5 board. Twenty pieces per player. Players alternate turns placing pieces on the board, two at a time into the same square. At any time, a player may move one piece from a square one spot in an orthogonal direction. Pieces may capture opponent's pieces when either a single square or an unbroken line of squares with opponent's pieces has an empty space beyond it; the player's piece hops over the opponent's pieces and captures them all. When the unbroken line ends at the edge of the board, it is treated as though there were an empty square beyond the edge of the board, and the capturing piece is placed on the last space on the board in that line. Players may enter any reserved pieces on any turn as they see fit. The player to capture all of the opponent's pieces wins.
(game "T'oki" (players 2) (equipment {(board (square 5)) (piece "Marker" Each (or (move Step Orthogonal (to if:(is Empty (to)))) (move Hop Orthogonal (between (range 1 (count Rows)) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(or (and (is In (to) (sites Outer)) (is Enemy (who at:(to)))) (is Empty (to))))))) (hand Each)}) (rules (start (place "Marker" "Hand" count:20)) (play (or (move (from (handSite Mover)) (to (sites Empty)) count:2) (forEach Piece))) (end (if (and (all Sites (sites Hand Next) if:(= 0 (count Cell at:(site)))) (no Pieces Next)) (result Mover Win))))) 
7x7 lines, forming a grid. 21 pieces per player. The pieces begin on the three rows closest to the player. Pieces move forward orthogonally or sideways, never backwards. A piece may capture an adjacent opponent's piece by hopping over it to an empty adjacent spot immediately on the opposite side of it along the lines of the board. Multiple captures are allowed. Captures can only be made in the forward orthogonal or sideways directions also. The player who captures all of their opponent's pieces or who blocks them from being able to move wins.
(game "Tablo" (players {(player N) (player S)}) (equipment {(board (square 7) use:Vertex) (piece "Marker" Each (or {(move Step (directions {Forward Rightward Leftward}) (to if:(is Empty (to)))) (move Hop (directions {Forward Rightward Leftward}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) (directions {Forward Rightward Leftward}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain))))}))}) (rules (start {(place "Marker1" (expand (sites Bottom) steps:2)) (place "Marker2" (expand (sites Top) steps:2))}) (play (if (is Prev Mover) (and (move Hop (from (last To)) (directions {Forward Rightward Leftward}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) (directions {Forward Rightward Leftward}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))) (move Pass)) (forEach Piece))) (end (if (no Moves Next) (result Mover Win))))) 
8x8 checkered board, with a black space on the bottom left corner. Sixteen pieces per player. Pieces begin on the second and third rows. Pieces move orthogonally or diagonally forwards or sideways. Pieces may capture only in an orthogonal direction, but not backwards, by hopping over an adjacent piece belonging to the opponent to an empty space on the opposite adjacent side of the opponent's piece. Multiple captures are allowed, and the maximum number of possible captures must be taken. When a piece lands on the last row opposite from the one where they began the game, it is promoted and may move in any direction and capture in any orthogonal direction. A piece may be promoted in the middle of its turn if further captures are possible. The player who captures all of the opponent's pieces wins.  The rules come from Schmidt.
(game "Tama" (players 2) (equipment {(board (square 8)) (piece "Counter" P1 N) (piece "Counter" P2 S) (piece "DoubleCounter" Each) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Counter1" (union (sites Row 1) (sites Row 2))) (place "Counter2" (union (sites Row 5) (sites Row 6)))}) (play (if (is Prev Mover) (if (= (what at:(last To)) (id "Counter" Mover)) (max Moves (move Hop (from (last To)) (directions {Forward Rightward Leftward}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) (directions {Forward Rightward Leftward}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))))) (max Moves (move Hop (from (last To)) (difference Orthogonal OppositeDirection) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) (difference Orthogonal OppositeDirection) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))) (priority {(max Moves (or {(forEach Piece "Counter" (move Hop (from (from)) (directions {Forward Rightward Leftward}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) (directions {Forward Rightward Leftward}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain) (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))))) (forEach Piece "DoubleCounter" (move Hop (from) Orthogonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (move Hop (from (last To)) Orthogonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))) (moveAgain)))))})) (or (forEach Piece "Counter" (move Step (directions {Forwards Rightward Leftward}) (to if:(is Empty (to)))) (then (if (is In (last To) (sites Next)) (promote (last To) (piece "DoubleCounter") Mover)))) (forEach Piece "DoubleCounter" (move Step (to if:(is Empty (to))))))}))) (end (if (no Pieces Next) (result Next Loss))))) 
5x5 board. Twelve pieces per player. Players alternate turns placing a piece on the board, leaving the central space empty. Once all of the pieces have been placed, players alternate turns moving a piece to an empty adjacent space in an orthogonal or diagonal direction. A player may capture an opponent's piece adjacent to one of their own by hopping over it to an empty space immediately on the opposite side of the opponent's piece. Multiple captures are allowed. The player who captures all of their opponent's pieces wins.
(game "Tides" (players 2) (equipment {(board (square 5)) (piece "Marker" Each (or (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Step (to if:(is Empty (to)))))) (hand Each)}) (rules (start (place "Marker" "Hand" count:12)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (difference (sites Board) (centrePoint)) if:(is Empty (to))))) (nextPhase Mover (is Empty (handSite Mover)) "Move")) (phase "Move" (play (if (is Prev Mover) (or (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Pass)) (forEach Piece))) (end (if (no Pieces Next) (result Next Loss))))})) 
3x3 crossed lines, pieces move on the intersections and along the lines. Three pieces per player. In the placement phase, players alternate turns placing one of their pieces on an empty spot. When all of the pieces are placed, Players attempt to capture their opponent's pieces by hopping over them. The player who captures all of the opponent's pieces wins.
(game "Tre Guti" (players 2) (equipment {(board (square 3) use:Vertex) (hand Each) (piece "Marker" Each (or (move Step (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))))}) (rules (start (place "Marker" "Hand" count:3)) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (forEach Piece)))} (end (if (no Pieces Next) (result Next Loss))))) 
3x5 intersecting lines. Six pieces per player, arranged on the two short rows on opposite sides of the board. Players alternate turns moving a piece to an empty adjacent spot. Pieces move orthogonally in a horizontal or forward direction only. To capture, a piece may jump over an adjacent opponent's piece to an empty spot immediately on the opposite side of the piece along the lines of the board. Pieces may capture in a backwards direction. The player who captures all of the opponent's pieces wins.
(game "Xarajlt" (players {(player N) (player S)}) (equipment {(board (rectangle 5 3) use:Vertex) (piece "Marker" Each (or (move Step (directions {Forward FR FL}) (to if:(is Empty (to)))) (move Hop Orthogonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))))}) (rules (start {(place "Marker1" (expand (sites Bottom))) (place "Marker2" (expand (sites Top)))}) (play (forEach Piece)) (end (if (no Pieces Next) (result Next Loss))))) 
5x5 board. Twelve pieces per player. Players alternate turns placing a piece on the board or moving a piece already on the board. Pieces move one space in any orthogonal direction. A player may capture an opponent's piece by hopping over it to an empty space on the other side of it. When a capture is made in this fashion, the player chooses another piece belonging to the opponent to capture in addition. The player who captures all of the opponent's pieces wins.
(game "Yote" (players 2) (equipment {(board (square 5)) (piece "Marker" Each (or (move Step Orthogonal (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (moveAgain))))) (hand Each)}) (rules (start (place "Marker" "Hand" count:12)) (play (if (is Prev Mover) (move Remove (sites Occupied by:Next container:"Board")) (or (if (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site))))) (move (from (handSite Mover)) (to (sites Empty)))) (forEach Piece)))) (end (if (no Pieces Next) (result Next Loss))))) 
5x5 board. Twelve pieces per player. Pieces begin in the rows closest to the player, and the two spaces to the right of the central space. Players alternate turns moving a piece orthogonally any distance. A player may capture an opponent's adjacent piece by hopping over it in an orthogonal direction to an empty space immediately on the opposite side of the opponent's piece. Multiple captures are allowed. The player who captures all of the opponent's pieces wins.
(game "Zuz Mel (5x5)" (players 2) (equipment {(board (square 5)) (piece "Marker" Each (or (move Hop Orthogonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Orthogonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Slide Orthogonal)))}) (rules (start {(place "Marker1" (union (expand (sites Bottom)) (sites {"D3" "E3"}))) (place "Marker2" (union (expand (sites Top)) (sites {"A3" "B3"})))}) (play (if (is Prev Mover) (or (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Pass)) (forEach Piece))) (end (if (no Pieces Next) (result Next Loss))))) 
7x7 board. 24 pieces per player. Pieces begin in the rows closest to the player, and the three spaces to the right of the central space. Players alternate turns moving a piece orthogonally any distance. A player may capture an opponent's adjacent piece by hopping over it in an orthogonal direction to an empty space immediately on the opposite side of the opponent's piece. Multiple captures are allowed. The player who captures all of the opponent's pieces wins.
(game "Zuz Mel (7x7)" (players 2) (equipment {(board (square 7)) (piece "Marker" Each (or (move Hop Orthogonal (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) Orthogonal (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Slide Orthogonal)))}) (rules (start {(place "Marker1" (union (expand (sites Bottom) steps:2) (sites {"F4" "G4" "E4"}))) (place "Marker2" (union (expand (sites Top) steps:2) (sites {"A4" "B4" "C4"})))}) (play (if (is Prev Mover) (or (move Hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (moveAgain)))) (move Pass)) (forEach Piece))) (end (if (no Pieces Next) (result Next Loss))))) 
Played on an 8x8 board with pieces with specialized moves: Pawns (8): can move one space orthogonally forward, or two steps orthogonally forward only if it is the first move of any of that player's pawns, capture one space diagonally forward; Rooks (2): can move any number of spaces orthogonally; Bishops (2): can move any number of spaces diagonally; Knight (2): moves in any direction, one space orthogonally with one space forward diagonally; Queens (1): can move any number of spaces orthogonally or diagonally; Kings (1): can move one space orthogonally or diagonally. An opponent's piece is captured by moving a player's own piece onto a space occupied by the opponent's piece. When a King can be captured on the next turn by an opponent's piece, it is in check. The King must not be in check at the end of the player's turn. If this is not possible, it is checkmate and the opponent wins. When a player is reduced to a King without any other pieces, the game is a draw. 
(game "Chandaraki" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (if (is In (from) (sites Start (piece (what at:(from))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to)))))})) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King1" coord:"E1" state:1) (place "Rook2" {"A8" "H8"} state:1) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King2" coord:"E8" state:1)}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King" Mover))))) (end {(if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win)) (if (= 1 (count Pieces Next)) (result Mover Draw))}))) 
Four players, playing on teams of two. 1 x Shah (king): moves one space orthogonally or diagonally. 2 x Rukh (rook): Any number of spaces orthogonally. 2 x Pil (elephant): any distance diagonally; 2 x Asb (horse): Moves as a chess knight. 8 x Sarbaz (soldier): Moves one space forward orthogonally; one space forward diagonally to capture. The pieces of one team are arranged with Shahs on the two central squares of the outer rows, then the Pils, ASbs, and Rukhs, with the Sarbaz in the row in front of them. When a piece moves onto a space occupied by an opponent's piece, the opponent's piece is captured. When a Shah can be captured on the next turn, it is in check, and cannot remain in check at the end of that player's turn. When this is not possible, it is checkmate, and that player is out of the game. A team wins by checkmating both opposing Kings, or by capturing all of the opponents' pieces aside from the Kings. If all four Kings are the only remaining pieces, the game is a draw. 
(game "Chatrang" (players {(player N) (player S) (player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (if (is In (from) (sites Start (piece (what at:(from))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to)))))})) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "King_noCross" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Elephant" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))}) (rules (start {(place "Pawn1" (intersection (expand (sites Left) steps:3) (sites Row 1))) (place "Pawn2" (intersection (expand (sites Right) steps:3) (sites Row 6))) (place "Pawn3" (intersection (expand (sites Right) steps:3) (sites Row 1))) (place "Pawn4" (intersection (expand (sites Left) steps:3) (sites Row 6))) (place "Rook1" {"A1"}) (place "Knight1" {"B1"}) (place "Elephant1" {"C1"}) (place "King_noCross1" coord:"D1") (place "Rook3" {"H1"}) (place "Knight3" {"G1"}) (place "Elephant3" {"F1"}) (place "King_noCross3" coord:"E1") (place "Rook2" {"H8"}) (place "Knight2" {"G8"}) (place "Elephant2" {"F8"}) (place "King_noCross2" coord:"E8") (place "Rook4" {"A8"}) (place "Knight4" {"B8"}) (place "Elephant4" {"C8"}) (place "King_noCross4" coord:"D8") (set Team 1 {P1 P3}) (set Team 2 {P2 P4})}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))) (then (and {(if (and (is Active P1) (not (is Mover P1))) (if (or (and (is Threatened (id "King_noCross" P1)) (not (can Move (do (and (forEach Piece P1) (set NextPlayer (player 1))) ifAfterwards:(not (is Threatened (id "King_noCross" P1))))))) (= (where (id "King_noCross" P1)) -1)) (forEach Site (sites Occupied by:P1) (remove (site))))) (if (and (is Active P2) (not (is Mover P2))) (if (or (and (is Threatened (id "King_noCross" P2)) (not (can Move (do (and (forEach Piece P2) (set NextPlayer (player 2))) ifAfterwards:(not (is Threatened (id "King_noCross" P2))))))) (= (where (id "King_noCross" P2)) -1)) (forEach Site (sites Occupied by:P2) (remove (site))))) (if (and (is Active P3) (not (is Mover P3))) (if (or (and (is Threatened (id "King_noCross" P3)) (not (can Move (do (and (forEach Piece P3) (set NextPlayer (player 3))) ifAfterwards:(not (is Threatened (id "King_noCross" P3))))))) (= (where (id "King_noCross" P3)) -1)) (forEach Site (sites Occupied by:P3) (remove (site))))) (if (and (is Active P4) (not (is Mover P4))) (if (or (and (is Threatened (id "King_noCross" P4)) (not (can Move (do (and (forEach Piece P4) (set NextPlayer (player 4))) ifAfterwards:(not (is Threatened (id "King_noCross" P4))))))) (= (where (id "King_noCross" P4)) -1)) (forEach Site (sites Occupied by:P4) (remove (site)))))})))) (end {(forEach NonMover if:(= (where "King_noCross" Player) -1) (result Player Loss)) (if (and {(no Pieces Enemy "Pawn") (no Pieces Enemy "Knight") (no Pieces Enemy "Elephant") (no Pieces Enemy "Rook")}) (result TeamMover Win))}))) 
8x8 board. Pieces have special moves, as follows: Rátu (king), moves one square in any direction, but on the first move, if it has not been checked, may move two spaces in any direction or like a Járan; Pateh (minister), moves orthogonally or diagonally any number of spaces; Mántri (x2); move diagonally any distance; Járan (horse) x2, moves orthogonally one space then diagonal one space from there, jumping over any intervening pieces; Práhu (vessel) x2, moves orthogonally any distance; Bídak (pawn) x8: moves one square forward or one square forward diagonally to capture. May move two spaces forward orthogonally if it is that piece's first move. Upon reaching the opposite edge of the board, the Bídak must move backward diagonally three spaces before being promoted to Pateh, unless it is in one of the corner spaces, in which case it is promoted immediately. There is no limit to the number of Patehs on the board. To castle, the Práhu moves next to the Rátu, and then at any turn in the future the Rátu may move to the space on the other side of it, provided the Rátu has not yet been checked and that the space to which it moves remains available. The Rátu cannot be in check at the end of its turn. When this is unavoidable, it is checkmate and the opponent wins. If the Rátu is the only piece belonging to the player on the board, that player wins.
(game "Chatur" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "King_noCross" (or (move Step (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))) (then (if (not (= 1 (state at:(last To)))) (set State at:(last To) 1)))) (if (not (= 1 (state at:(from)))) (or {(move Slide (between (exact 2)) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (if (is In (from) (sites {"E1" "D8"})) (or (if (and {(is Empty (ahead (from) steps:2 W)) (= (what at:(ahead (from) W)) (id "Rook" Mover)) (not (= 1 (state at:(ahead (from) W))))}) (move (from) (to (ahead (from) steps:2 W)))) (if (and {(is Empty (ahead (from) steps:2 E)) (= (what at:(ahead (from) E)) (id "Rook" Mover)) (not (= 1 (state at:(ahead (from) E))))}) (move (from) (to (ahead (from) steps:2 E))))))} (then (set State at:(last To) 1)))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))) (then (if (and (not (= 1 (state at:(last To)))) (not (is In (last To) (sites {"D1" "F1" "C8" "E8"})))) (set State at:(last To) 1))))) (piece "Bishop_noCross" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Pawn" (if (is In (from) (sites Mover "Promotion")) (move Slide (directions {BR BL}) (between (exact 3)) (to if:(is Enemy (who at:(to))) (apply (remove (to)))) (then (promote (last To) (piece "Queen") Mover))) (or (move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (then (if (is In (last To) (intersection (sites Corners) (sites Mover "Promotion"))) (promote (last To) (piece "Queen") Mover)))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Bishop_noCross1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King_noCross1" coord:"E1") (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Bishop_noCross2" {"C8" "F8"}) (place "Queen2" coord:"E8") (place "King_noCross2" coord:"D8")}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))) (then (if (is Threatened (id "King_noCross" Next)) (if (not (= 1 (state at:(where "King_noCross" Next)))) (set State at:(where "King_noCross" Next) 1)))))) (end {(if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win)) (if (= (count Pieces Next) 1) (result Mover Loss))}))) 
12x12 board. Pieces move as follows: Raja (King, x1): moves one space in any direction; Mantri (Minister, placed to the left of the Raja, x1): moves any distance orthogonally or diagonally; Ushtra (Camel, x2): moves diagonally any distance; Chariot (x2), moves orthogonally any distance; Flagcar (x2), moves diagonally any distance; Vaha (Horse, x2): move orthogonally one space and then diagonally another, jumping over any intervening pieces; Danti (Elephant, x2): moves orthogonally any distance. Padati (Pawn, x12): move forward orthogonally one space or one space diagonally forward to capture. When a Padati reaches the opposite edge of the board, it is promoted to a Mantri and is moved immediately to the space it last moved from. An opponent's piece is captured by moving one of the player's own pieces onto the space occupied by the opponent's piece. If the Raja can be captured on the opponent's next turn, it is in check. The Raja cannot be in check at the end of the player's turn. If this is impossible, the opponent wins. When a player is reduced to only their Raja and Padati, the opponent wins. In the case of a stalemate, the player in stalemate may remove any of the opponent's pieces (except their Raja).
(game "Chaturanga (12x12)" (players {(player N) (player S)}) (equipment {(board (square 12)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (and (promote (last To) (piece "Ferz_noCross") Mover) (fromTo (from (last To)) (to (last From)))))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Camel" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "King_noCross" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Bishop_noCross" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Elephant" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Ferz_noCross" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 10)) (place "Elephant1" {"A1" "L1"}) (place "Knight1" {"B1" "K1"}) (place "Bishop_noCross1" {"C1" "J1"}) (place "Rook1" {"D1" "I1"}) (place "Camel1" {"E1" "H1"}) (place "Ferz_noCross1" coord:"F1") (place "King_noCross1" coord:"G1") (place "Elephant2" {"A12" "L12"}) (place "Knight2" {"B12" "K12"}) (place "Bishop_noCross2" {"C12" "J12"}) (place "Rook2" {"D12" "I12"}) (place "Camel2" {"E12" "H12"}) (place "Ferz_noCross2" coord:"G12") (place "King_noCross2" coord:"F12")}) (play (if (no Moves Mover) (move Remove (difference (sites Occupied by:Next) (where "King_noCross" Next))) (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover)))))) (end {(if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win)) (if (and {(no Pieces Next "Ferz_noCross") (no Pieces Next "Knight") (no Pieces Next "Bishop_noCross") (no Pieces Next "Elephant") (no Pieces Next "Rook") (no Pieces Next "Camel")}) (result Mover Win))}))) 
14x14 board. 32 pieces per player. Pieces move as follows: King (x1): Moves any distance orthogonally or diagonally; Crown Prince (x1): moves up to six spaces orthogonally or diagonally; Minister (x1): moves up to six spaces orthogonally or diagonally; Military leader (x1): moves up to six spaces orthogonally or diagonally; Elephant (x2): moves forward orthogonally up to five spaces with the possibility of then moving one space backward diagonally; Cart (x2): moves any distance orthogonally; Horse (x4): moves one space orthogonally and then one space diagonally, leaping over any intervening pieces; Machinist (x4): moves forward orthogonally up to four spaces, forward diagonally one space, or backward orthogonally one space; Archer (x4): moves forward orthogonally up to three spaces, forward diagonally one space, or backward orthogonally one space; Spearmen (x4): moves forward orthogonally up to two spaces, forward diagonally one space, or backward orthogonally one space; Swordsmen (x4): forward one space orthogonally or diagonally or backward one space orthogonally. Players place their pieces on their half of the board in any arrangement they wish. When a piece moves to a space occupied by an opponent's piece, the opponent's piece is captured. If the King can be captured by the opponent on their next turn, it is in check and must not be in check at the end of the player's turn. If this is not possible, the player loses. 
(game "Chaturanga (14x14)" (players {(player N) (player S)}) (equipment {(board (square 14)) (piece "King" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Prince" Each (move Slide (between (max 6) if:(is Empty (between))) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Bishop" Each (move Slide (between (max 6) if:(is Empty (between))) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Queen" Each (move Slide (between (max 6) if:(is Empty (between))) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Elephant" Each (or {(move Slide Forward (between (max 5) if:(is Empty (between))) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Step (directions {BR BL}) (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))) (forEach Direction Forward (between (range 1 5)) (to if:(is Empty (to)) (apply (and {(move (from) (to (sites To (step (from (to)) (if (is Mover P1) (directions {SW SE}) (directions {NW NE})) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))))}))))})) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Horse" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Wrench" Each (or (move Slide Forward (between (max 4) if:(is Empty (between))) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Step (directions {FR FL Backward}) (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))))) (piece "Archer" Each (or (move Slide Forward (between (max 3) if:(is Empty (between))) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Step (directions {FR FL Backward}) (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))))) (piece "Spear" Each (or (move Slide Forward (between (max 2) if:(is Empty (between))) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Step (directions {FR FL Backward}) (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))))) (piece "Sword" Each (move Step (directions {Forward FR FL Backward}) (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (hand Each size:11) (regions P1 (expand (sites Bottom) steps:6)) (regions P2 (expand (sites Top) steps:6))}) (rules (start {(place "King1" (handSite P1)) (place "King2" (handSite P2)) (place "Prince1" (handSite P1 1)) (place "Prince2" (handSite P2 1)) (place "Bishop1" (handSite P1 2)) (place "Bishop2" (handSite P2 2)) (place "Queen1" (handSite P1 3)) (place "Queen2" (handSite P2 3)) (place "Elephant1" (handSite P1 4)) (place "Elephant2" (handSite P2 4)) (place "Rook1" (handSite P1 5) count:2) (place "Rook2" (handSite P2 5) count:2) (place "Horse1" (handSite P1 6) count:4) (place "Horse2" (handSite P2 6) count:4) (place "Wrench1" (handSite P1 7) count:4) (place "Wrench2" (handSite P2 7) count:4) (place "Archer1" (handSite P1 8) count:4) (place "Archer2" (handSite P2 8) count:4) (place "Spear1" (handSite P1 9) count:4) (place "Spear1" (handSite P2 9) count:4) (place "Sword1" (handSite P1 10) count:4) (place "Sword2" (handSite P2 10) count:4)}) phases:{(phase "Placement" (play (move (from (sites Hand Mover) if:(is Occupied (from))) (to (intersection (sites Empty) (sites Mover))))) (nextPhase Mover (all Sites (sites Hand Mover) if:(is Empty (site))) "Play")) (phase "Play" (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King" Mover))))))} (end (if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win))))) 
14x14 board. Pieces move as follows: Raja (King, x1): moves one space in any direction; Mantri (Minister, placed to the left of the Raja, x1): moves any distance orthogonally or diagonally; Queen (x1, placed to the right of the Raja); moves orthogonally one space; Prince (placed to the left of the Minister, x1), moves orthogonally or diagonally any distance; Ushtra (Camel, x2): moves diagonally any distance; Chariot (x2), moves orthogonally any distance; Flagcar (x2), moves diagonally any distance; Vaha (Horse, x2): move orthogonally one space and then diagonally another, jumping over any intervening pieces; Danti (Elephant, x2): moves orthogonally any distance. Padati (Pawn, x14): move forward orthogonally one space or one space diagonally forward to capture. When a Padati reaches the opposite edge of the board, it is promoted to a Mantri and is moved immediately to the space it last moved from. An opponent's piece is captured by moving one of the player's own pieces onto the space occupied by the opponent's piece. If the Raja can be captured on the opponent's next turn, it is in check. The Raja cannot be in check at the end of the player's turn. If this is impossible, the opponent wins. When a player is reduced to only their Raja and Padati, the opponent wins. In the case of a stalemate, the player in stalemate may remove any of the opponent's pieces (except their Raja). 
(game "Chaturanga (Kridakausalya 14x14)" (players {(player N) (player S)}) (equipment {(board (square 14)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (and (promote (last To) (piece "Ferz_noCross") Mover) (fromTo (from (last To)) (to (last From)))))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Camel" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "King_noCross" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Bishop_noCross" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Queen" Each (move Step Orthogonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (piece "Commoner" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Elephant" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Ferz_noCross" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Elephant1" {"A1" "N1"}) (place "Knight1" {"B1" "M1"}) (place "Bishop_noCross1" {"C1" "L1"}) (place "Rook1" {"D1" "K1"}) (place "Camel1" {"E1" "J1"}) (place "Commoner1" coord:"F1") (place "Ferz_noCross1" coord:"G1") (place "King_noCross1" coord:"H1") (place "Queen1" coord:"I1") (place "Pawn2" (sites Row 12)) (place "Elephant2" {"A14" "N14"}) (place "Knight2" {"B14" "M14"}) (place "Bishop_noCross2" {"C14" "L14"}) (place "Rook2" {"D14" "K14"}) (place "Camel2" {"E14" "J14"}) (place "Commoner2" coord:"I14") (place "Ferz_noCross2" coord:"H14") (place "King_noCross2" coord:"G14") (place "Queen2" coord:"F14")}) (play (if (no Moves Mover) (move Remove (difference (sites Occupied by:Next) (where "King_noCross" Next))) (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover)))))) (end {(if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win)) (if (and {(no Pieces Next "Ferz_noCross") (no Pieces Next "Knight") (no Pieces Next "Bishop_noCross") (no Pieces Next "Elephant") (no Pieces Next "Rook") (no Pieces Next "Camel") (no Pieces Next "Commoner") (no Pieces Next "Queen")}) (result Mover Win))}))) 
8x8 board. Pieces move as follows: Raja (x1): moves one space in any direction; Mantri (x1): moves any distance orthogonally or diagonally; Ushtra (x2): moves diagonally any distance; Vaha (x2): move orthogonally one space and then diagonally another, jumping over any intervening pieces; Danti (x2): moves orthogonally any distance. Padati (x8): move forward orthogonally one space or one space diagonally forward to capture. When a Padati reaches the opposite edge of the board, it is promoted to a Mantri and is moved immediately to the space it last moved from. An opponent's piece is captured by moving one of the player's own pieces onto the space occupied by the opponent's piece. If the Raja can be captured on the opponent's next turn, it is in check. The Raja cannot be in check at the end of the player's turn. If this is impossible, the opponent wins. When a player is reduced to only their Raja and Padati, the opponent wins. In the case of a stalemate, the player in stalemate may remove any of the opponent's pieces (except their Raja). 
(game "Chaturanga (Kridakausalya)" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "King_noCross" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Ferz_noCross" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Elephant" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (and (promote (last To) (piece "Ferz_noCross") Mover) (fromTo (from (last To)) (to (last From)))))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Elephant1" {"C1" "F1"}) (place "Ferz_noCross1" coord:"D1") (place "King_noCross1" coord:"E1") (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Elephant2" {"C8" "F8"}) (place "Ferz_noCross2" coord:"D8") (place "King_noCross2" coord:"E8")}) (play (if (can Move (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))))) (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover)))) (move Remove (difference (sites Occupied by:Next) (sites Occupied by:Next component:"King_noCross"))))) (end {(if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win)) (if (and {(no Pieces Next "Ferz_noCross") (no Pieces Next "Knight") (no Pieces Next "Elephant") (no Pieces Next "Rook")}) (result Mover Win))}))) 
8x8 board. 8 Bhata (or Padati; move like Chess pawns but without being able to move two on the first turn); 2 Ashva (horses; move like Chess knights); 2 Gaja (elephants; two spaces in any orthogonal direction, jumping over the first square); 2 Ratha (chariots; moves like a rook in chess); 1 Mantri (counselor; moves one square diagonally in any direction); 1 Raja (king; moves one square in any direction). These are set up along one edge of the board: Gaja-Ratha-Ashva-Mantri-Raja-Ashva-Ratha-Gaja, with the eight Bhata lined up in the row in front of these. Players take turns moving. When one piece lands on the space occupied by another piece, it is captured. When a Raja can be captured by an opponent's piece on the next turn, it is in check. The Raja must not be in check at the end of the player's turn. When this is unavoidable, it is checkmate and the opponent wins. A Raja that is stalemated wins. A player who reduces their opponent to only the Raja wins. 
(game "Chaturanga (al-Adli)" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "King_noCross" (move Step (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Elephant" (move Hop Orthogonal (between (exact 1) if:True) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))})) (piece "Queen" (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Elephant1" {"A1" "H1"}) (place "Rook1" {"B1" "G1"}) (place "Knight1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King_noCross1" coord:"E1") (place "Elephant2" {"A8" "H8"}) (place "Rook2" {"B8" "G8"}) (place "Knight2" {"C8" "F8"}) (place "Queen2" coord:"E8") (place "King_noCross2" coord:"D8")}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))))) (end {(if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win)) (if (= (count Pieces Next) 1) (result Mover Loss))}))) 
Played on an 8x8 board. 8 Bhata (or Padati; move like Chess pawns but without being able to move two on the first turn); 2 Ashva (horses; move like Chess knights); 2 Gaja (elephants; two spaces in any orthogonal direction, jumping over the first square); 2 Ratha (chariots; moves like a rook in chess); 1 Mantri (counselor; moves one square diagonally in any direction); 1 Raja (king; moves one square in any direction). These are set up along one edge of the board: Ratha-Ashva-Gaja-Mantri-Raja-Gaja-Ashva-Ratha, with the eight Bhata lined up in the row in front of these, as in chess. Players take turns moving. When one piece lands on the space occupied by another piece, it is captured. Play continues until one player's king cannot move without being captured. The elephants can jump only orthogonally.
(game "Chaturanga" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (moveAgain))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "King_noCross" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Elephant" Each (move Hop Orthogonal (between if:True) (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Ferz_noCross" Each (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Elephant1" {"C1" "F1"}) (place "Ferz_noCross1" coord:"D1") (place "King_noCross1" coord:"E1") (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Elephant2" {"C8" "F8"}) (place "Ferz_noCross2" coord:"E8") (place "King_noCross2" coord:"D8")}) (play (if (is Prev Mover) (move Promote (last To) (piece "Ferz_noCross") Mover) (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover)))))) (end {(if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win)) (if (no Moves Mover) (result Mover Win)) (if (<= (count Pieces Next) 1) (result Next Loss))}))) 
8x8 board. One player plays with the following pieces: Raja (x1): moves one space in any direction; Mantri (x1): moves any distance orthogonally or diagonally; Ushtra (x2): moves diagonally any distance; Vaha (x2): move orthogonally one space and then diagonally another, jumping over any intervening pieces; Danti (x2): moves orthogonally any distance. Padati (x8): move forward orthogonally one space or one space diagonally forward to capture. When a Padati reaches the opposite edge of the board, it is promoted to a Mantri and is moved immediately to the space it last moved from. The opponent plays as one Raja, which can move as any of the other pieces. This Raja cannot move to a space adjacent to the opponent's Raja. An opponent's piece is captured by moving one of the player's own pieces onto the space occupied by the opponent's piece. If the Raja can be captured on the opponent's next turn, it is in check. The Raja cannot be in check at the end of the player's turn. If this is impossible, the opponent wins. Check and checkmate rules apply to the player with a single Raja.
(game "Cittabhramanrpasya Khelanam" (players {(player S) (player N)}) (equipment {(board (square 8)) (piece "Pawn" P1 (or (move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (then (if (is In (last To) (sites Mover "Promotion")) (and (promote (last To) (piece "Ferz_noCross") Mover) (fromTo (from (last To)) (to (last From)))))))) (piece "Rook" P1 (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "King_noCross" P1 (move Step (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (piece "Elephant" P1 (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Knight" P1 (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Ferz_noCross" P1 (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "King_noCross" P2 (or (move Leap {{F F R F} {F F L F}} (to if:(and (not (is Friend (who at:(to)))) (not (is In (to) (sites Around (where "King-noCross" Next))))) (apply (remove (to))))) (move Slide (to if:(is Enemy (who at:(to))) (apply if:(not (is In (to) (sites Around (where "King-noCross" Next)))) (remove (to))))))) (regions "Promotion" P1 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 6)) (place "Rook1" {"A8" "H8"}) (place "Knight1" {"B8" "G8"}) (place "Elephant1" {"C8" "F8"}) (place "Ferz_noCross1" coord:"E8") (place "King_noCross1" coord:"D8") (place "King_noCross2" coord:"E1")}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))))) (end (if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win))))) 
8x8 board, marked as in Chaturanga. Pieces move according to specialized moves, as follows: Pawns (x8): can move one space forward and capture one space forward diagonally; Elephant (or Chariot or Boat) (x2): can move any number of spaces orthogonally; Elephant (or Camel) (x2): can move any number of spaces diagonally; Horse (2): moves in any direction, one space orthogonally with one space forward diagonally; Vizier (x1): can move any number of spaces orthogonally or diagonally; Raja (x1): can move one space orthogonally or diagonally, but can also move like the horse on its first move, if it has not yet been checked. The pieces are arranged as in Chess, except the Vizier is place to the left of the Raja on both sides. Players capture pieces by moving onto a space occupied by an opponent's piece. When a pawn reaches the opposite edge of the board from where it started, it may be promoted to the more powerful piece that begins the game in that position, but only if one of these belonging to the player has already been captured. If this has not happened, the pawn cannot move to the final row. When a player can capture the opponent's Raja on the next turn, the Raja is in Check, the opponent's next move must free the Raja from check. If the opponent cannot, it is checkmate and the player wins. If a player captures all of the opponent's pieces aside from the Raja and pawns, it is declared a half-win, or Burd. When both players are left with only a Raja, it is a draw. Players are not allowed to stalemate the opponent. If check is given 70 times in succession, the game is a draw.
(game "Hindustani Chess" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (move Step Forward (to if:(and (or (not (is In (to) (sites Mover "Promotion"))) (and (is In (to) (sites Mover "Promotion")) (if (and (is In (to) (sites Corners)) (< (count Sites in:(sites Occupied by:Mover component:"Boat")) 2)) True (if (and (or (= (column of:(to)) 1) (= (column of:(to)) 6)) (< (count Sites in:(sites Occupied by:Mover component:"Horse")) 2)) True (if (and (or (= (column of:(to)) 2) (= (column of:(to)) 5)) (< (count Sites in:(sites Occupied by:Mover component:"Elephant")) 2)) True (if (and (or (= (column of:(to)) 3) (= (column of:(to)) 4)) (< (count Sites in:(sites Occupied by:Mover component:"Ferz_noCross")) 1)) True False)))))) (not (is Friend (who at:(to))))) (apply (remove (to)))) (then (if (is In (last To) (sites Mover "Promotion")) (if (is In (last To) (sites Corners)) (promote (last To) (piece (id "Boat" Mover))) (if (or (= (column of:(last To)) 1) (= (column of:(last To)) 6)) (promote (last To) (piece (id "Horse" Mover))) (if (or (= (column of:(last To)) 2) (= (column of:(last To)) 5)) (promote (last To) (piece (id "Elephant" Mover))) (if (or (= (column of:(last To)) 3) (= (column of:(last To)) 4)) (promote (last To) (piece (id "Queen" Mover))))))))))) (piece "Boat" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "King_noCross" Each (or (move Step (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))) (if (and (not (is Threatened (id "King_noCross" Mover))) (= (state at:(from)) 1)) (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Elephant" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Horse" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Ferz_noCross" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Boat1" {"A1" "H1"}) (place "Horse1" {"B1" "G1"}) (place "Elephant1" {"C1" "F1"}) (place "Ferz_noCross1" coord:"D1") (place "King_noCross1" coord:"E1" state:1) (place "Boat2" {"A8" "H8"}) (place "Horse2" {"B8" "G8"}) (place "Elephant2" {"C8" "F8"}) (place "Ferz_noCross2" coord:"E8") (place "King_noCross2" coord:"D8" state:1)}) (play (do (forEach Piece) ifAfterwards:(and (not (no Moves Next)) (not (is Threatened (id "King_noCross" Mover)))))) (end {(if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win)) (if (= (count Pieces Next) 1) (result Mover Draw)) (if (= (count Pieces Next) (+ 1 (count Sites in:(sites Occupied by:Next component:"Pawn")))) (result Mover Draw))}))) 
8x8 board, with markings in the four central squares, the four corner squares, and the two middle squares of each edge. The pieces have the following movement values: Raja (x1): moves one space in any direction; Mantri (x1): moves diagonally one space; Karabha (x2): jumps exactly two squares diagonally; Raji (x2): moves orthogonally one space and then diagonally another space, jumping over any intervening pieces; Kunjara (x2): moves orthogonally any distance; Patti (x8): move forward orthogonally one space, diagonally forward one space to capture. When a Patti reaches a marked space on the opposite edge of the board, it is promoted to Mantri if it is on a marked square. If it is on an unmarked square, the Patti must move back to the space from which it moved to the last row and is then promoted to Mantri. If the Raja can be taken on the opponent's next turn, it is in check. The Raja must not be in check at the end of the player's turn. If this is not possible, it is checkmate and the opponent wins.If a Raja is in stalemate, and no other pieces can move the player may remove one of the opponent's pieces causing the stalemate. If the opponent is reduced to only their Raja, it is also a victory, though considered a lesser one. Checking the opponent's Raja 64 consecutive times is a win. 
(game "Krida Buddhibalasrita" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "King_noCross" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Ferz_noCross" Each (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Elephant" Each (move Hop Diagonal (between if:True) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (and (promote (last To) (piece "Ferz_noCross") Mover) (if (not (is In (last To) (sites "PromotionMarked"))) (fromTo (from (last To)) (to (last From))))))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom)) (regions "PromotionMarked" (sites {"A1" "D1" "E1" "H1" "A8" "D8" "E8" "H8"}))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Elephant1" {"C1" "F1"}) (place "Ferz_noCross1" coord:"D1") (place "King_noCross1" coord:"E1") (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Elephant2" {"C8" "F8"}) (place "Ferz_noCross2" coord:"D8") (place "King_noCross2" coord:"E8")}) (play (if (can Move (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))) (then (if (is Threatened (id "King_noCross" Next)) (set Value Mover (+ 1 (value Player Mover))) (set Value Mover 0))))) (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))) (then (if (is Threatened (id "King_noCross" Next)) (set Value Mover (+ 1 (value Player Mover))) (set Value Mover 0)))) (move Remove (difference (sites Occupied by:Next) (sites Occupied by:Next component:"King_noCross"))))) (end {(if (or (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next) (forEach Piece))))))) (= 1 (count Pieces Next))) (result Mover Win)) (if (= (value Player P1) 64) (result P1 Win)) (if (= (value Player P2) 64) (result P2 Win))}))) 
8x8 board, with diagonals in every square. Pieces have special moves, as follows: Raja (king), moves one square in any direction, but on the first move, it may jump two squares or move as a knight, with the exception that it cannot jump two squares diagonally; Mantri (minister), moves orthogonally or diagonally any number of spaces; Gajah (x2); move diagonally any distance; Kuda (horse) x2, moves orthogonally one space then diagonal one space from there, jumping over any intervening pieces; Ter/Chemor (chariot) x2, moves orthogonally any distance; Bídaq (pawn) x8: moves one square forward or one square forward diagonally to capture. May move two spaces forward orthogonally if it is that piece's first move. Upon reaching the opposite edge of the board, the Bídaq moves in the opposite direction, reversing again if it reaches the opposite edge. The Mantri is placed to the right of the Raja at the beginning of play. Castling occurs in two moves, the rook moving to the king and then the king jumping over the rook. Pieces are captured by moving onto a space occupied by an opponent's piece. If the Raja can be captured on its next turn, it is in check. The Raja cannot be in check at the end of its turn. When this is unavoidable, it is checkmate and the opponent wins. A stalemate is considered a draw.
(game "Main Chator (Batak)" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "King_noCross" (or (move Step (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))) (if (not (= 1 (state at:(from)))) (or {(move Hop Orthogonal (between (exact 2) if:True) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (if (is In (from) (sites {"E8" "D1"})) (or (if (and {(is Empty (ahead (from) steps:2 W)) (= (what at:(ahead (from) W)) (id "Rook" Mover)) (not (= 1 (state at:(ahead (from) W))))}) (move (from) (to (ahead (from) steps:2 W)))) (if (and {(is Empty (ahead (from) steps:2 E)) (= (what at:(ahead (from) E)) (id "Rook" Mover)) (not (= 1 (state at:(ahead (from) E))))}) (move (from) (to (ahead (from) steps:2 E))))))} (then (set State at:(last To) 1)))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))) (then (if (and (not (= 1 (state at:(last To)))) (not (is In (last To) (sites {"C1" "E1" "D8" "F8"})))) (set State at:(last To) 1))))) (piece "Bishop_noCross" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Pawn" (or {(if (and (= 0 (state at:(last To))) (is In (from) (sites Start (piece (what at:(from)))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))))) (move Step (if (= 1 (state at:(from))) Backward Forward) (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (if (is In (last To) (union (sites Bottom) (sites Top))) (if (= 0 (state at:(last To))) (set State at:(last To) 1) (set State at:(last To) 2)))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to))))))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Bishop_noCross1" {"C1" "F1"}) (place "Queen1" coord:"E1") (place "King_noCross1" coord:"D1") (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Bishop_noCross2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King_noCross2" coord:"E8")}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))))) (end {(if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win)) (if (no Moves Next) (result Mover Draw))}))) 
Played on an 8x8 board with pieces with specialized moves. The pieces are as follows, and placed on the outer rank in the following order, starting from the left corner and moving in, with the placement mirrored on the right side (the Mantri is placed to the right of the Rajah): Tor (2): can move any number of spaces orthogonally; Kudah (2): moves in any direction, one space orthogonally with one space forward diagonally, jumping over any intervening pieces; Gajah (2): can move any number of spaces diagonally; Rajah (1): can move one space orthogonally or diagonally; Mantri (1): can move any number of spaces orthogonally or diagonally; Bidah (8), placed in front of the other pieces: can move one space forward, or one space diagonally to capture. A Bidah may move two squares on its first move. Bidahs may capture en passant only when it is blocked from moving forward by another of the opponent's Bidahs; the blocked Bidah has the option in this scenario of capturing with an en passant move, with the option of capturing either of the two Bidahs in question. The Rajah, for its first move may move like a Kudah as long as it has never been checked. Players capture pieces by moving onto a space occupied by an opponent's piece. Castling occurs by moving the Rajah to the left or the right two squares, regardless of any intervening pieces; the Tor is not moved as part of this move. Promotion of Bidahs occur when they reach the opposite edge of the board, but only immediately if they reach the Tor's square. If it captures on the square next to the Tor's square, from the square in front of the Tor's square, it must move backward diagonally to the square in front of the Tor's square on a subsequent turn and continue before promotion. A Bidah reaching the Kudah's square must move backward diagonally once, to the right or left, before being promoted; a Bidah reaching the Gajah's square must move backward diagonally right or left two spaces, and a Bidah reaching the Raja or Mantri's square must move backward diagonally three squares before being promoted. Bidah's can be promoted to whatever piece the player wishes. If the Rajah can be captured on the opponent's next turn, it is in check. The Rajah must not be in check at the end of the player's turn. If this is impossible, it is checkmate and the opponent wins. If a player is reduced to only their Rajah, it can make the move of any piece. 
(game "Main Chator (Selangor)" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (if (= 0 (state at:(from))) (or {(if (is In (from) (sites Start (piece (what at:(from))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))) (then (set Pending (ahead (last To) Backward))))) (move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Step (directions {FR FL}) (to if:(and (and (is Pending) (= (to) (value Pending))) (= (id "Pawn" Next) (what at:(ahead (from) Forward))))) (then (remove (ahead (last To) Backward)))) (move Step (directions {FR FL}) (to if:(and (and (is Pending) (= (to) (value Pending))) (= (id "Pawn" Next) (what at:(ahead (from) Forward))))) (then (remove (ahead (last From) (if (is Mover P1) N S)))))} (then (if (is In (last To) (sites Mover "Promotion")) (if (is In (last To) (sites Corners)) (moveAgain) (if (is In (last To) (intersection (sites Mover "Promotion") (expand (sites Corners)))) (set State at:(last To) 1) (if (is In (last To) (intersection (sites Mover "Promotion") (expand (sites Corners) steps:2))) (set State at:(last To) 2) (set State at:(last To) 3))))))) (move Step (directions {BR BL}) (to if:(is Empty (to))) (then (and (if (= 1 (state at:(last To))) (moveAgain)) (set State at:(last To) (- (state at:(last To)) 1))))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "King_noCross" Each (if (= (count Pieces Mover) 1) (or (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (or {(move Step (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))) (if (and (= (state at:(from)) 1) (!= (value Player Mover) (mover))) (move Leap {{F F R F} {F F L F}} (to if:(is Empty (to))) (then (set Value Mover (mover))))) (if (= (state at:(from)) 1) (move Hop (directions {E W}) (between if:True) (to if:(is Empty (to)))))} (then (if (= (state at:(last To)) 1) (set State at:(last To) 0)))))) (piece "Elephant" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Ferz_noCross" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Elephant1" {"C1" "F1"}) (place "King_noCross1" coord:"D1" state:1) (place "Ferz_noCross1" coord:"E1") (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Elephant2" {"C8" "F8"}) (place "King_noCross2" coord:"E8" state:1) (place "Ferz_noCross2" coord:"D8")}) (play (if (is Prev Mover) (move Promote (last To) (piece {"Knight" "Elephant" "Rook" "Ferz_noCross"}) Mover) (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))) (then (if (!= (next) (value Player Next)) (if (is Threatened (id "King_noCross" Next)) (set Value Next (next)))))))) (end {(if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win)) (if (no Moves Mover) (result Mover Win)) (if (= (count Pieces Next) 1) (result Mover Win))}))) 
Played on an 8x8 board with pieces with specialized moves. The pieces are as follows, and placed on the outer rank in the following order, starting from the left corner and moving in, with the placement mirrored on the right side (the Mautri is placed to the right of the Rajah): Tor (2): can move any number of spaces orthogonally; Kudah (2): moves in any direction, one space orthogonally with one space forward diagonally, jumping over any intervening pieces; Gajah (2): can move any number of spaces diagonally; Rajah (1): can move one space orthogonally or diagonally; Mautri (1): can move any number of spaces orthogonally or diagonally; Bidah (8), placed in front of the other pieces: can move one space forward, or one space diagonally to capture. The Bidah are placed on the second file. When first checked, the Rajah may move like a Kudah, or move two spaces in any direction. Players capture pieces by moving onto a space occupied by an opponent's piece. Castling may occur in two separate moves: the Tor moves next to the Rajah, and if the Rajah is checked, it may move to the other side of the Tor. Promotion of Bidahs occur when they reach the opposite edge of the board, but only immediately if they reach the Tor's square. Pawns reaching any other square must make two further moves before they can be promoted; the first must be a lateral orthogonal move, the second may be lateral orthogonal or diagonal. If the Rajah can be captured on the opponent's next turn, it is in check. The Rajah must not be in check at the end of the player's turn. If this is impossible, it is checkmate and the opponent wins.
(game "Main Chator" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "King_noCross" (or (move Step (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))) (then (if (not (= 1 (state at:(last To)))) (set State at:(last To) 1)))) (if (is Pending) (or {(move Slide (between (exact 2)) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (if (is In (from) (sites {"E8" "D1"})) (or (if (and {(is Empty (ahead (from) steps:2 W)) (= (what at:(ahead (from) W)) (id "Rook" Mover)) (not (= 1 (state at:(ahead (from) W))))}) (move (from) (to (ahead (from) steps:2 W)))) (if (and {(is Empty (ahead (from) steps:2 E)) (= (what at:(ahead (from) E)) (id "Rook" Mover)) (not (= 1 (state at:(ahead (from) E))))}) (move (from) (to (ahead (from) steps:2 E))))))})))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))) (then (if (and (not (= 1 (state at:(last To)))) (not (is In (last To) (sites {"C1" "E1" "D8" "F8"})))) (set State at:(last To) 1))))) (piece "Bishop_noCross" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Pawn" (if (= 1 (state at:(from))) (move Step (directions {Rightward Leftward}) (to if:(is Empty (to))) (then (set State at:(last To) 2))) (if (= 2 (state at:(from))) (move Step (directions {BR BL Rightward Leftward}) (to if:(is Empty (to))) (then (promote (last To) (piece "Queen") Mover))) (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (if (is In (last To) (sites Corners)) (promote (last To) (piece "Queen") Mover) (set State at:(last To) 1)))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Bishop_noCross1" {"C1" "F1"}) (place "Queen1" coord:"E1") (place "King_noCross1" coord:"D1") (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Bishop_noCross2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King_noCross2" coord:"E8")}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))) (then (if (is Threatened (id "King_noCross" Next)) (if (not (= 1 (state at:(where "King_noCross" Next)))) (and (set State at:(where "King_noCross" Next) 1) (set Pending))))))) (end (if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win))))) 
8x8 board. Each player begins with sixteen pieces with special moves: Khoon (x1): moves orthogonally in any direction; Met (x1): placed to the right of the Khoon, moves one square orthogonally or diagonally forward, or one square diagonally backward, may move two squares orthogonally forward on the first move; Khon (x2): moves one square forward orthogonally or diagonally, may move backward diagonally but not to capture; Maa (x2): moves as a Chess knight; Rooa (x2): moves orthogonally any distance; Bea (x8): move forward one space, but capture diagonally. When they reach the opposite edge of the board, they are promoted to Met. They begin on the third row of the board with respect to each player. When the Khoon is threatened, it is in check and the player's next move must be to remove the check. If the player cannot, it is checkmate and the player loses. If there are no legal moves, the game is a draw. If one player has only a king left, the opponent must checkmate it within a set number of turns, based on the highest ranking piece left on the board, minus the total number of pieces on the board. The values are: two Rooa: eight; one Rooa, sixteen, two Khon, 22; one Khon, 44; two Maa, 33; one Maa, 66; Met and two Bea, 88; one each of Met, Rooa, Maa, Khon, sixteen. With only a Met, the game is a draw.
(game "Mak Ruk" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (promote (last To) (piece "Ferz_noCross") Mover))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "King_noCross" Each (move Step Orthogonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (piece "Bishop_noCross" Each (or (move Step (directions {FL FR Forward}) (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))) (move Step (directions {BL BR}) (to if:(is Empty (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Ferz_noCross" Each (or (if (= (state at:(from)) 1) (move (from) (to (ahead (ahead (from) N) N) if:(is Empty (to)))) (then (set State at:(last To) 0))) (move Step (directions {BL BR FL FR Forward}) (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 2)) (place "Pawn2" (sites Row 5)) (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Bishop_noCross1" {"C1" "F1"}) (place "Ferz_noCross1" coord:"E1" state:1) (place "King_noCross1" coord:"D1") (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Bishop_noCross2" {"C8" "F8"}) (place "Ferz_noCross2" coord:"D8" state:1) (place "King_noCross2" coord:"E8")}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))))) (end {(if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win)) (if (no Moves Next) (result Mover Draw)) (if (and {(= (count Pieces Next) 1) (= (count Pieces Mover) 2) (!= (where "Ferz_noCross" Mover) -1)}) (result Mover Draw))}))) 
8x8 board, not checkered. Pieces, their number, and moves are as follows: Ang/Sdaach ("King")x1: moves on space in any direction, on its first move it may move like a Chess knight; Neang ("Queen")x1; moves diagonally one space, on its first move it may move two spaces forward orthogonally, jumping over the intervening space; Koul ("General")x2: move one space diagonally or one space orthogonally forward; Ses ("Horse")x2: moves like a Chess knight; Tuuk ("Boat")x2: move orthogonally any distance; Trey ("Fish")x8: move orthogonally forward one space, diagonally forward one space to capture. When a Trey reaches the rank where the opponent's Treys begin the game, it is promoted to a Neang. The pieces begin arranged along the edge of the board, in the following order: Tuuk, Ses, Koul, Neang, Ang, Koul, Ses, Tuuk. The Treys are arranged on the third rank (I.e., there is an empty row of spaces between the Treys and the other pieces). The opponent's pieces have the same arrangement on the opposite side of the board. Players take turns moving pieces. When a piece is moved to the same space on which a piece belonging to the opponent is positioned, the opposing piece is taken. If an Ang can be taken on the opponent's next move, it is in "Ouk," and the player must either move the Ang to a safe place, capture the threatening piece, or move another piece in the way of the threatened capture. If it is not possible to remove the Ang from this state, the opponent wins by Ouk Ngueb, "checkmate." A draw occurs when the Ang has no legal move but it not in Ouk.
(game "Ouk Chatrang" (players {(player N) (player S)}) (equipment {(board (square 8)) (hand Each size:5) (piece "King_noCross" Each (or (move Step (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))) (if (= 1 (state at:(from))) (move Leap {{F F R F} {F F L F}} (to if:(is Empty (to))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Boat" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Ferz_noCross" Each (or (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))) (move Step Forward (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Fish" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (promote (last To) (piece "Queen") Mover))))) (piece "Queen" Each (or (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))) (if (= 1 (state at:(from))) (move Hop Forward (between if:True) (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (regions "Promotion" P1 (sites Row 5)) (regions "Promotion" P2 (sites Row 2))}) (rules (start {(place "Fish1" (sites Row 2)) (place "Fish2" (sites Row 5)) (place "Boat1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Ferz_noCross1" {"C1" "F1"}) (place "Queen1" coord:"D1" state:1) (place "King_noCross1" coord:"E1" state:1) (place "Boat2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Ferz_noCross2" {"C8" "F8"}) (place "Queen2" coord:"D8" state:1) (place "King_noCross2" coord:"E8" state:1)}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))))) (end {(if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win)) (if (no Moves Mover) (result Mover Draw))}))) 
8x8 board, marked as in Chaturanga. Pieces move according to specialized moves, as follows: Pawns (x8): can move one space forward, or one space diagonally to capture. The pawns in front of the Raja, Vizier, or Chariot may move two spaces on their first move, but only if the piece which began on the space behind them remains on that spot. Chariot (or Boat): any number of spaces orthogonally; Elephant (x2): can move any number of spaces diagonally; Horse (2): moves in any direction, one space orthogonally with one space forward diagonally; Vizier (x1): can move any number of spaces orthogonally or diagonally; Raja (x1): can move one space orthogonally or diagonally, but can also move like the horse once in the game, if it has not yet been checked. It cannot take a piece with this move. The pieces are arranged as in Chess, except the Vizier is place to the left of the Raja on both sides. Players capture pieces by moving onto a space occupied by an opponent's piece. When a Pawn reaches the opposite edge of the board from where it started, it may be promoted to the more powerful piece that begins the game in that position, but only if one of these belonging to the player has already been captured. If this has not happened, the pawn cannot move to the final row. When promoted to a Horse, the piece may immediately make a Horse's move. When a player can capture the opponent's Raja on the next turn, the Raja is in Check, the opponent's next move must free the Raja from Check. If the opponent cannot, it is Checkmate and the player wins. If a player captures all of the opponent's pieces aside from the Raja, it is a draw, or Boorj. When both players are left with only a Raja, it is a draw. Players are not allowed to stalemate the opponent. Perpetual check is not allowed, a player must make another move if such a state is entered.
(game "Parsi Chess" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (or {(if (is In (from) (sites Start (piece (what at:(from))))) (if (= 1 (state at:(ahead (from) Backward))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to)))))) (move Step Forward (to if:(and (or (not (is In (to) (sites Mover "Promotion"))) (and (is In (to) (sites Mover "Promotion")) (if (and (is In (to) (sites Corners)) (< (count Sites in:(sites Occupied by:Mover component:"Boat")) 2)) True (if (and (or (= (column of:(to)) 1) (= (column of:(to)) 6)) (< (count Sites in:(sites Occupied by:Mover component:"Knight")) 2)) True (if (and (or (= (column of:(to)) 2) (= (column of:(to)) 5)) (< (count Sites in:(sites Occupied by:Mover component:"Elephant")) 2)) True (if (and (or (and (is Mover P1) (= (column of:(to)) 3)) (and (is Mover P2) (= (column of:(to)) 4))) (< (count Sites in:(sites Occupied by:Mover component:"Ferz_noCross")) 1)) True False)))))) (is Empty (to))))) (move Step (directions {FR FL}) (to if:(and (or (not (is In (to) (sites Mover "Promotion"))) (and (is In (to) (sites Mover "Promotion")) (if (and (is In (to) (sites Corners)) (< (count Sites in:(sites Occupied by:Mover component:"Boat")) 2)) True (if (and (or (= (column of:(to)) 1) (= (column of:(to)) 6)) (< (count Sites in:(sites Occupied by:Mover component:"Knight")) 2)) True (if (and (or (= (column of:(to)) 2) (= (column of:(to)) 5)) (< (count Sites in:(sites Occupied by:Mover component:"Elephant")) 2)) True (if (and (or (and (is Mover P1) (= (column of:(to)) 3)) (and (is Mover P2) (= (column of:(to)) 4))) (< (count Sites in:(sites Occupied by:Mover component:"Ferz_noCross")) 1)) True False)))))) (is Enemy (who at:(to)))) (apply (remove (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (promote (last To) (piece (if (is In (last To) (sites Corners)) (id "Boat" Mover) (if (or (= (column of:(last To)) 1) (= (column of:(last To)) 6)) (id "Knight" Mover) (if (or (= (column of:(last To)) 2) (= (column of:(last To)) 5)) (id "Elephant" Mover) (if (or (and (is Mover P2) (= (column of:(last To)) 4)) (and (is Mover P1) (= (column of:(last To)) 3))) (id "Ferz_noCross" Mover) (id "King_noCross" Mover))))))))))) (piece "Boat" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "King_noCross" Each (or (move Step (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))) (if (!= (value Player Mover) (mover)) (move Leap {{F F R F} {F F L F}} (to if:(is Empty (to))) (then (set Value Mover (mover))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Elephant" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Ferz_noCross" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to)))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Boat1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Elephant1" {"C1" "F1"}) (place "Ferz_noCross1" coord:"D1" state:1) (place "King_noCross1" coord:"E1" state:1) (place "Boat2" {"A8" "H8"} state:1) (place "Knight2" {"B8" "G8"}) (place "Elephant2" {"C8" "F8"}) (place "Ferz_noCross2" coord:"E8" state:1) (place "King_noCross2" coord:"D8" state:1)}) (play (do (forEach Piece) ifAfterwards:(and (can Move (forEach Piece Next)) (not (is Threatened (id "King_noCross" Mover)))) (then (if (!= (next) (value Player Next)) (if (is Threatened (id "King_noCross" Next)) (set Value Next (next))))))) (end {(if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win)) (if (= 1 (count Pieces Next)) (result Mover Draw))}))) 
8x8 board. The pieces move as follows, with the number per player: 1 x Shah (king): moves one space orthogonally or diagonally. 1 x Fers (counselor): Any distance orthogonally or diagonally.]. 2 x Rukh (rook): Any number of spaces orthogonally. 2 x Pil (elephant): Any distance diagonally. 2 x Asb (horse): Moves as a chess knight. 8 x Sarbaz (soldier): Moves one space forward orthogonally; one space forward diagonally to capture. No en passant. The first move must be the Fers's Sarbaz, which moves two spaces forward. Castling can happen in three moves, moving the Shah forward or backward once orthogonally and once with the Asb's move, and moving the Rukh to the Shah's former space. Castling can also be done on the Fers's side, but moving the Rukh to the Fers's space. When a piece moves to a space occupied by an opponent's piece, the opponent's piece is captured. If the Shah can be captured on the opponent's next turn, it is in check. A player's Shah must not be in check at the end of their turn. If this is impossible, it is checkmate and the opponent wins. 
(game "Persian Chess with a Queen" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "King_noCross" Each (or {(move Step (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))) (then (if (and (= 1 (state at:(last To))) (= (last To) (mapEntry "AheadKing" Mover))) (set State at:(last To) 2) (if (!= (state at:(last To)) 0) (set State at:(last To) 0))))) (if (and {(= 1 (state at:(from))) (= 1 (state at:(mapEntry "RookRight" Mover))) (is Empty (mapEntry "KnightKingRightForward" Mover))}) (move (from) (to (mapEntry "KnightKingRightForward" Mover)) (then (if (!= (state at:(last To)) 0) (set State at:(last To) 0))))) (if (and {(= 1 (state at:(from))) (= 1 (state at:(mapEntry "RookLeft" Mover))) (is Empty (mapEntry "KnightKingLeftForward" Mover))}) (move (from) (to (mapEntry "KnightKingLeftForward" Mover)) (then (if (!= (state at:(last To)) 0) (set State at:(last To) 0))))) (if (and {(= 2 (state at:(from))) (= 2 (state at:(regionSite (sites Start (piece (id "King" Mover))) index:0)))}) (move (from) (to (mapEntry "KnightKingLeftBackward" Mover)) (then (set State at:(last To) 0)))) (if (and {(= 2 (state at:(from))) (= 3 (state at:(regionSite (sites Start (piece (id "King" Mover))) index:0)))}) (move (from) (to (mapEntry "KnightKingRightBackward" Mover)) (then (set State at:(last To) 0))))})) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))) (then (if (= (state at:(last To)) 1) (if (and (is In (last To) (sites Start (piece (id "King" Mover)))) (= 2 (state at:(where "King" Mover)))) (if (= (last From) (mapEntry "RookLeft" Mover)) (set State at:(last To) 2) (set State at:(last To) 3)) (set State at:(last To) 0))))) maxState:3) (piece "Bishop_noCross" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Ferz_noCross" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))})) (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")}) (map "RookRight" {(pair 1 "H1") (pair 2 "H8")}) (map "AheadKing" {(pair 1 "E2") (pair 2 "E7")}) (map "KnightKingRightForward" {(pair 1 "G2") (pair 2 "G7")}) (map "KnightKingLeftForward" {(pair 1 "C2") (pair 2 "C7")}) (map "KnightKingRightBackward" {(pair 1 "G1") (pair 2 "G8")}) (map "KnightKingLeftBackward" {(pair 1 "C1") (pair 2 "C8")})}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Bishop_noCross1" {"C1" "F1"}) (place "Ferz_noCross1" coord:"D1") (place "King_noCross1" coord:"E1" state:1) (place "Rook2" {"A8" "H8"} state:1) (place "Knight2" {"B8" "G8"}) (place "Bishop_noCross2" {"C8" "F8"}) (place "Ferz_noCross2" coord:"D8") (place "King_noCross2" coord:"E8" state:1)}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))))) (end (if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win))))) 
10x10 board. 22 pieces per player. Pieces begin on the board in the following arrangement, and with the following movements: Outer row, from left corner: Rukh: moves orthogonally any distance; Ghora: moves orthogonally one space and then diagonally another space, jumping over the first space; Fil: moves diagonally any distance; Wazir: moves diagonally or orthogonally any distance; Shahzada: can move like the Wazir and like the Ghora; Padshah: moves one space in any direction; Kotwal: moves like the Shahzada; Fil, Ghora, Rukh. In the next row, the central two squares are occupied by the Urdabegini: move one space in the direction of the opponent's Padshah; the other spaces are occupied by Paidal: moves one square forward orthogonally or one diagonally to capture. The central two squares of the third row contain two more Ghora. Players alternate turns moving a piece to a space on the board. If one of the opponent's pieces is on the space to which a player moves their piece, the opponent's piece is captured. If the Padshah can be captured on the opponent's next turn, it is in check. The Padshah cannot remain in check at the end of the player's turn. If this is not possible, it is checkmate and the opponent wins. 
(game "Qatranj" (players {(player N) (player S)}) (equipment {(board (square 10)) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Bishop_noCross" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Commoner" Each (or (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (piece "King_noCross" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Mann" Each (or (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (piece "Wazir" Each (do (move Step (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))) ifAfterwards:(> (count Steps (last From) (where "King_noCross" Next)) (count Steps (last To) (where "King_noCross" Next))))) (piece "Pawn" Each (or (move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))))}) (rules (start {(place "Rook1" (sites {"A1" "J1"})) (place "Rook2" (sites {"A10" "J10"})) (place "Knight1" (sites {"B1" "I1" "E3" "F3"})) (place "Knight2" (sites {"B10" "I10" "E8" "F8"})) (place "Bishop_noCross1" (sites {"C1" "H1"})) (place "Bishop_noCross2" (sites {"C10" "H10"})) (place "Queen1" coord:"D1") (place "Queen2" coord:"G10") (place "Commoner1" coord:"E1") (place "Commoner2" coord:"F10") (place "King_noCross1" coord:"F1") (place "King_noCross2" coord:"E10") (place "Mann1" coord:"G1") (place "Mann2" coord:"D10") (place "Wazir1" (sites {"E2" "F2"})) (place "Wazir2" (sites {"E9" "F9"})) (place "Pawn1" (difference (sites Row 1) (sites {"E2" "F2"}))) (place "Pawn2" (difference (sites Row 8) (sites {"E9" "F9"})))}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))))) (end (if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win))))) 
8x8 board. The pieces move as follows, with the number per player: King (x1): moves one space orthogonally or diagonally; Counselor (x1): One square diagonally, but may move two spaces forward orthogonally on the first move, jumping over the Soldier in front of it on the first move of the game; Rook (x2): Any number of spaces orthogonally; Elephant (x2): Two squares diagonally, jumping over the first, cannot capture another Elephant; Horse (x2): Moves as a chess knight. Soldier (x8): Moves one space forward orthogonally; one space forward diagonally to capture. The Soldier in front of the Counselor may jump to the space in front of the Counselor when it has used its special move on the first turn, this must be done as the second move of the game, i.e. on the next turn after the Counselor had made its special move. No en passant. Soldiers promote to Counselor when reaching the eighth rank. No castling. Stalemate results in a win for player causing it. The player who checkmates the king wins. 
(game "Rumi Shatranj" (players {(player N) (player S)}) (equipment {(board (square 8)) (hand Each size:5) (piece "King_noCross" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Elephant" Each (move Hop Diagonal (between if:True) (to if:(or (is Empty (to)) (and (is Enemy (who at:(to))) (not (= (what at:(to)) (id "Elephant" Next))))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (moveAgain))))) (piece "Ferz_noCross" Each (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Elephant1" {"C1" "F1"}) (place "Ferz_noCross1" coord:"D1") (place "King_noCross1" coord:"E1") (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Elephant2" {"C8" "F8"}) (place "Ferz_noCross2" coord:"D8") (place "King_noCross2" coord:"E8")}) phases:{(phase "OpeningCounselor" (play (forEach Piece "Ferz_noCross" (move Hop Forward (between if:True) (to if:(is Empty (to)) (apply (remove (to))))))) (nextPhase Mover "OpeningSoldier")) (phase "OpeningSoldier" (play (forEach Piece "Pawn" (if (is In (from) (sites {"D2" "D7"})) (move Hop Forward (between if:True) (to if:(is Empty (to)) (apply (remove (to)))))))) (nextPhase Mover "Playing")) (phase "Playing" (play (if (is Prev Mover) (move Promote (last To) (piece "Ferz_noCross") Mover) (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover)))))))} (end {(if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win)) (if (no Moves Next) (result Mover Win))}))) 
8x8 board. The pieces move as follows, with the number per player: 1 x Negus (king): moves one space orthogonally or diagonally. 1 x Ferz (counselor): One square diagonally. 2 x Der (castle): Any number of spaces orthogonally. 2 x Säbä (man): Three squares diagonally, jumping over the first two. 2 x Färäs (horse): Moves as a chess knight. 8 x Médéq: Moves one space forward orthogonally; one space forward diagonally to capture. No en passant. Promoted to Ferz when reaching the eighth rank. No castling, except in the opening phase. In the opening phase, players play simultaneously at will, with no turn structure, until the first piece is captured, at which point turns alternate for the main phase of the game. Castling is allowed during the opening phase, and pawns may move any distance forward. If only a player's Negus remains, the opponent must checkmate it in ten moves or less, or the game is a stalemate. The player who checkmates the king wins.
(game "Santaraj" (players {(player N) (player S)}) (equipment {(board (square 8)) (hand Each size:5) (piece "King_noCross" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Castle" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Ferz_noCross" Each (move Hop Diagonal (between (exact 2) if:True) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (promote (last To) (piece "Queen") Mover))))) (piece "Queen" Each (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Castle1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Ferz_noCross1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King_noCross1" coord:"E1") (place "Castle2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Ferz_noCross2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King_noCross2" coord:"E8")}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))) (then (if (and (> (count Pieces P1) 1) (> (count Pieces P2) 1)) (set Counter))))) (end {(if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win)) (if (and (or (= (count Pieces P1) 1) (= (count Pieces P2) 1)) (= (counter) 20)) (result Mover Draw))}))) 
Played on an 8x8 board. One player plays as one Raja, the other with the following pieces: 8 Bhata (or Padati; move like Chess pawns but without being able to move two on the first turn); 2 Ashva (horses; move like Chess knights); 2 Gaja (elephants; two spaces in any orthogonal direction, jumping over the first square); 2 Ratha (chariots; moves like a rook in chess); 1 Mantri (counselor; moves one square diagonally in any direction); 1 Raja (king; moves one square in any direction). These are set up along one edge of the board: Ratha-Ashva-Gaja-Mantri-Raja-Gaja-Ashva-Ratha, with the eight Bhata lined up in the row in front of these, as in chess. The player with the full complement of pieces rolls a six-sided die to determine which piece to move: 6=Raja, 5= Mantri, 4=Gaja, 3 = Ashva, 2=Ratha, 1= Bhata. The player with the single Raja can move it according to the moves of any piece. Players take turns moving. When one piece lands on the space occupied by another piece, it is captured. The goal of the player with a full complement of pieces is to block the single Raja so that it cannot move. The Goal of the single Raja is to checkmate the opponent's Raja.
(game "Sarvatobhadra" (players {(player N) (player S)}) (equipment {(board (square 8)) (dice d:6 from:1 num:1) (piece "King_noCross" P1 (move Step (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (piece "Ferz_noCross" P1 (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (piece "Knight" P1 (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Elephant" P1 (move Hop Orthogonal (between if:True) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Rook" P1 (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Pawn" P1 (or (move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (then (if (is In (last To) (sites Top)) (promote (last To) (piece "Ferz_noCross") Mover))))) (piece "King_noCross" P2 (or {(move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Hop Orthogonal (between if:True) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))) (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))) (move Step (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))}))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Elephant1" {"C1" "F1"}) (place "Ferz_noCross1" coord:"D1") (place "King_noCross1" coord:"E1") (place "King_noCross2" coord:"E8")}) (play (do (if (is Mover P1) (do (roll) next:(if (= (count Pips) 6) (forEach Piece "King_noCross") (if (= (count Pips) 5) (forEach Piece "Ferz_noCross") (if (= (count Pips) 4) (forEach Piece "Elephant") (if (= (count Pips) 3) (forEach Piece "Knight") (if (= (count Pips) 2) (forEach Piece "Rook") (forEach Piece "Pawn"))))))) (forEach Piece)) ifAfterwards:(not (is Threatened (id "King_noCross" Mover) (forEach Piece Next))))) (end {(if (and {(is Mover P2) (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next) (forEach Piece))))))}) (result P2 Win)) (if (and (is Mover P1) (no Moves P2)) (result P1 Win)) (if (and {(is Mover P1) (is Threatened (id "King_noCross" P1)) (no Moves P1)}) (result P2 Win))}))) 
8x8 checkered board. The pieces move as follows: Álix' ("old man"), x1: moves one space orthogonally or diagonally; Férsix' ("fers"), x1: moves any number of spaces orthogonally or diagonally; Lúdkax' ("boat"), x2: moves orthogonally any number of spaces; Slúnax' ("elephant"), x2: moves diagonally any number of spaces; Kúnax' ("horse"), x2: moves like a Chess knight; Layakúcan ("little boys"), x8: move forward one space, capture diagonally forward. Captures are made when a piece moves onto a space occupied by an opponent's piece. A player's Álix' is checked when it can be taken by the opponent on their next turn, and this possibility must be removed before the opponent plays. If a player's Álix' is checkmated, the opponent wins. 
(game "Saxun" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))})) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "King_noCross" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Bishop_noCross" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to))))))}) (rules (start {(place "Pawn1" {"F4" "G4" "H4" "B3" "C3" "D3" "E3" "A2"}) (place "Pawn2" {"H7" "H6" "G6" "F6" "E6" "A5" "B5" "C5"}) (place "Rook1" {"C2" "D1"}) (place "Knight1" {"B1" "H2"}) (place "Bishop_noCross1" {"E1" "F1"}) (place "Queen1" coord:"D2") (place "King_noCross1" coord:"C1") (place "Rook2" {"C7" "B8"}) (place "Knight2" {"A7" "H8"}) (place "Bishop_noCross2" {"F7" "G7"}) (place "Queen2" coord:"B7") (place "King_noCross2" coord:"C8")}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))))) (end (if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win))))) 
10x10 board. Pieces move as follows: Raja (x1): moves one space in any direction; Crown Prince (placed to the left of the Raja, x1): moves like any of the other pieces; Kotwal (Police Chief, placed to the right of the Raja, x1): Moves like the Elephant and the Vaha; Mantri (x1): moves any distance orthogonally or diagonally; Elephant (x2): moves diagonally any distance; Vaha (two placed in front of the Queens, x4): move orthogonally one space and then diagonally another, jumping over any intervening pieces; Chariot (x2): moves orthogonally any distance; Queen (placed in front of the Raja and Crown Prince, x2): move one square orthogonally or diagonally; Padati (placed in the second row, except for the central two squares, x8): move forward orthogonally one space or one space diagonally forward to capture. When a Padati reaches the opposite edge of the board, it is promoted to a Mantri and is moved immediately to the space it last moved from. An opponent's piece is captured by moving one of the player's own pieces onto the space occupied by the opponent's piece. If the Raja can be captured on the opponent's next turn, it is in check. The Raja cannot be in check at the end of the player's turn. If this is impossible, the opponent wins. When a player is reduced to only their Raja and Padati, the opponent wins. In the case of a stalemate, the player in stalemate may remove any of the opponent's pieces (except their Raja). 
(game "Shataranja" (players {(player N) (player S)}) (equipment {(board (square 10)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (and (promote (last To) (piece "Bishop_noCross") Mover) (fromTo (from (last To)) (to (last From)))))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "King_noCross" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Elephant" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Queen" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Ferz_noCross" Each (or (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (piece "Bishop_noCross" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Commoner" Each (or (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (difference (sites Row 1) (sites {"E2" "F2"}))) (place "Pawn2" (difference (sites Row 8) (sites {"E2" "F2"}))) (place "Queen1" {"E2" "F2"}) (place "Queen2" {"E9" "F9"}) (place "Rook1" {"A1" "J1"}) (place "Knight1" {"B1" "I1" "E3" "F3"}) (place "Elephant1" {"C1" "H1"}) (place "Ferz_noCross1" coord:"E1") (place "Commoner1" coord:"G1") (place "Bishop_noCross1" coord:"D1") (place "King_noCross1" coord:"F1") (place "Rook2" {"A10" "J10"}) (place "Knight2" {"B10" "I10" "E8" "F8"}) (place "Elephant2" {"C10" "H10"}) (place "Ferz_noCross2" coord:"F10") (place "Commoner2" coord:"D10") (place "Bishop_noCross2" coord:"G10") (place "King_noCross2" coord:"E10")}) (play (if (no Moves Mover) (move Remove (difference (sites Occupied by:Next) (where "King_noCross" Next))) (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover)))))) (end {(if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win)) (if (and {(no Pieces Next "Ferz_noCross") (no Pieces Next "Queen") (no Pieces Next "Knight") (no Pieces Next "Bishop_noCross") (no Pieces Next "Elephant") (no Pieces Next "Rook") (no Pieces Next "Commoner")}) (result Mover Win))}))) 
8x8 board. Two players. Pieces and movement are as follows: King x1, placed on the fifth space from the left on one edge of the board: Moves one space orthogonally or diagonally. Pawns x8, arranged along the row in front of the king: moves one space forward orthogonally or one space forward diagonally to capture. The opponent's pieces are placed in the same position on the opposite side of the board. If the King can be taken on the next turn it is in check, it must not remain in check on the next turn. If the king cannot move out of check, checkmate is declared and the opponent wins.
(game "Shatr ikh Padan" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))})) (piece "King_noCross" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "King_noCross1" coord:"E1") (place "King_noCross2" coord:"D8")}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))))) (end (if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win))))) 
12x12 board. 24 pieces per player. Pieces begin on the board in the following arrangement, and with the following movements: Outer row, from left corner: Rukh: moves orthogonally any distance; Ghora: moves orthogonally one space and then diagonally another space, jumping over the first space; Dahja: moves orthogonally any distance; Ratha: moves orthogonally any distance; Fil: moves diagonally any distance; Wazir: moves diagonally or orthogonally any distance; Padshah: moves one space in any direction; Fil, Ratha, Dahja, Ghora, Rukh. In the second row are twelve Paidal: moves one square forward orthogonally or one diagonally to capture. Players alternate turns moving a piece to a space on the board. If one of the opponent's pieces is on the space to which a player moves their piece, the opponent's piece is captured. If the Padshah can be captured on the opponent's next turn, it is in check. The Padshah cannot remain in check at the end of the player's turn. If this is not possible, it is checkmate and the opponent wins. 
(game "Shatranj (12x12)" (players 2) (equipment {(board (square 12)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))})) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Commoner" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Wazir" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "King_noCross" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Bishop_noCross" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to))))))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 10)) (place "Rook1" {"A1" "L1"}) (place "Knight1" {"B1" "K1"}) (place "Commoner1" {"C1" "J1"}) (place "Wazir1" {"D1" "I1"}) (place "Bishop_noCross1" {"E1" "H1"}) (place "Queen1" coord:"F1") (place "King_noCross1" coord:"G1") (place "Rook2" {"A12" "L12"}) (place "Knight2" {"B12" "K12"}) (place "Commoner2" {"C12" "J12"}) (place "Wazir2" {"D12" "I12"}) (place "Bishop_noCross2" {"E12" "H12"}) (place "Queen2" coord:"G12") (place "King_noCross2" coord:"F12")}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))))) (end (if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win))))) 
14x14 board. 28 pieces per player. Pieces begin on the board in the following arrangement, and with the following movements: Outer row, from left corner: Rukh: moves orthogonally any distance; Ghora: moves orthogonally one space and then diagonally another space, jumping over the first space; Dahja: moves orthogonally any distance; Ratha: moves orthogonally any distance; Fil: moves diagonally any distance; Shahzada: moves diagonally or orthogonally any distance; Wazir: moves diagonally or orthogonally any distance; Raja: moves one space in any direction; Rani: moves one square in any direction; Fil, Ratha, Dahja, Ghora, Rukh. In the second row are fourteen Paidal: moves one square forward orthogonally or one diagonally to capture. Players alternate turns moving a piece to a space on the board. If one of the opponent's pieces is on the space to which a player moves their piece, the opponent's piece is captured. If the Raja can be captured on the opponent's next turn, it is in check. The Raja cannot remain in check at the end of the player's turn. If this is not possible, it is checkmate and the opponent wins. 
(game "Shatranj (14x14)" (players 2) (equipment {(board (square 14)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))})) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Commoner" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Wazir" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "King_noCross" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Mann" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Bishop_noCross" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Amazon" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to))))))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 12)) (place "Rook1" {"A1" "N1"}) (place "Knight1" {"B1" "M1"}) (place "Commoner1" {"C1" "L1"}) (place "Wazir1" {"D1" "K1"}) (place "Bishop_noCross1" {"E1" "J1"}) (place "Amazon1" coord:"F1") (place "Queen1" coord:"G1") (place "King_noCross1" coord:"H1") (place "Mann1" coord:"I1") (place "Rook2" {"A14" "N14"}) (place "Knight2" {"B14" "M14"}) (place "Commoner2" {"C14" "L14"}) (place "Wazir2" {"D14" "K14"}) (place "Bishop_noCross2" {"E14" "J14"}) (place "Amazon2" coord:"I14") (place "Queen2" coord:"H14") (place "King_noCross2" coord:"G14") (place "Mann2" coord:"F14")}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))))) (end (if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win))))) 
8x8 board. The pieces move as follows, with the number per player: 1 x Shah (king): moves one space orthogonally or diagonally. May move like an Asb if it is not in check and has never been in check. Place to a player's square right of center. 1 x Fers (counselor): Any distance orthogonally or diagonally; 2 x Rukh (rook): Any number of spaces orthogonally. 2 x Pil (elephant): Any distance diagonally. 2 x Asb (horse): Moves as a chess knight. 8 x Sarbaz (soldier): Moves one space forward orthogonally; one space forward diagonally to capture. Promoted to Fers when reaching the eighth rank. No en passant. No castling. An opponent's piece is captured by moving a player's own piece onto a space occupied by the opponent's piece. When a Shah can be captured on the next turn by an opponent's piece, it is in check. The Shah must not be in check at the end of the player's turn. If this is not possible, it is checkmate and the opponent wins. Stalemate results in a win for that player causing it. The game ends in a draw only when a player's final piece, being a Sarbaz, is lost, that player's Shah captures the opponent's only remaining piece, a Sarbaz.
(game "Shatranj (Algeria)" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (promote (last To) (piece "Ferz_noCross") Mover))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "King_noCross" Each (or (move Step (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))) (if (!= (value Player Mover) (mover)) (move Leap {{F F R F} {F F L F}} (to if:(is Empty (to))) (then (set Value Mover (mover))))))) (piece "Elephant" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Ferz_noCross" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Elephant1" {"C1" "F1"}) (place "Ferz_noCross1" coord:"D1") (place "King_noCross1" coord:"E1") (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Elephant2" {"C8" "F8"}) (place "Ferz_noCross2" coord:"E8") (place "King_noCross2" coord:"D8")}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))) (then (if (!= (next) (value Player Next)) (if (is Threatened (id "King_noCross" Next)) (set Value Next (next))))))) (end {(if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win)) (if (= (count Pieces Next) 1) (result Mover Win)) (if (no Moves Next) (result Mover Win))}))) 
8x8 board. The pieces move as follows, with the number per player: 1 x Shah (king): moves one space orthogonally or diagonally. 1 x Fers (counselor): Any distance orthogonally or diagonally, or like the Asb. 2 x Rukh (rook): Any number of spaces orthogonally. No castling. 2 x Pil (elephant): Any distance diagonally, jumping over the first. Cannot capture another Pil. 2 x Asb (horse): Moves as a chess knight. 8 x Sarbaz (soldier): Moves one space forward orthogonally; one space forward diagonally to capture. No en passant. Promoted to Fers when reaching the eighth rank. An opponent's piece is captured by moving a player's own piece onto a space occupied by the opponent's piece. When a Shah can be captured on the next turn by an opponent's piece, it is in check. The Shah must not be in check at the end of the player's turn. If this is not possible, it is checkmate and the opponent wins. Stalemate results in a win for that player causing it. 
(game "Shatranj (Iraq)" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "King_noCross" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Ferz_noCross" (or (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (piece "Elephant" (move Slide Diagonal (between if:(or (is In (between) (sites Around (from))) (is Empty (between)))) (to if:(and (not (= (what at:(to)) (id "Elephant" Next))) (is Enemy (who at:(to)))) (apply if:(not (is In (to) (sites Around (from)))) (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (promote (last To) (piece "Ferz_noCross") Mover))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Elephant1" {"C1" "F1"}) (place "Ferz_noCross1" coord:"D1") (place "King_noCross1" coord:"E1") (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Elephant2" {"C8" "F8"}) (place "Ferz_noCross2" coord:"D8") (place "King_noCross2" coord:"E8")}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))))) (end {(if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win)) (if (no Moves Mover) (result Mover Loss))}))) 
8x8 board. The pieces move as follows, with the number per player: 1 x Shah (king): moves one space orthogonally or diagonally. 1 x Fers (counselor): One square diagonally or, one the first turn, may jump two squares diagonally or orthogonally, over any pieces on the first square. There can be no capture with this move. 2 x Rukh (rook): Any number of spaces orthogonally. 2 x Pil (elephant): Two squares diagonally, jumping over the first. 2 x Asb (horse): Moves as a chess knight. 8 x Sarbaz (soldier): Moves one space forward orthogonally; one space forward diagonally to capture. No en passant. Promoted to Fers when reaching the eighth rank. On its first move, this promoted piece may also use the jumping move of the Fers. No castling. An opponent's piece is captured by moving a player's own piece onto a space occupied by the opponent's piece. When a Shah can be captured on the next turn by an opponent's piece, it is in check. The Shah must not be in check at the end of the player's turn. If this is not possible, it is checkmate and the opponent wins. Stalemate results in a win for that player causing it. 
(game "Shatranj (Turkey)" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "King_noCross" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Ferz_noCross" (or (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))) (if (not (= 1 (state at:(from)))) (move Hop (between if:True) (to if:(is Empty (to))))) (then (if (not (= 1 (state at:(last To)))) (set State at:(last To) 1))))) (piece "Elephant" (move Hop Diagonal (between if:True) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (promote (last To) (piece "Ferz_noCross") Mover))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Elephant1" {"C1" "F1"}) (place "Ferz_noCross1" coord:"D1") (place "King_noCross1" coord:"E1") (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Elephant2" {"C8" "F8"}) (place "Ferz_noCross2" coord:"D8") (place "King_noCross2" coord:"E8")}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))))) (end {(if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win)) (if (no Moves Mover) (result Mover Loss))}))) 
8x8 board. One player plays as one Shah, which can move like any of the other pieces. The other player has the usual complement of pieces, as in Chess. Pawns (x8): can move one space forward and capture one space forward diagonally; Rook (x2): can move any number of spaces orthogonally; Elephant (x2): can move any number of spaces diagonally; Horse (2): moves in any direction, one space orthogonally with one space forward diagonally; Vizier (x1): can move any number of spaces orthogonally or diagonally; Shah (x1): can move one space orthogonally or diagonally, but can also move like the horse on its first move, if it has not yet been checked. The pieces are arranged as in Chess, with the Vizier is place to the left of the Shah. Players capture pieces by moving onto a space occupied by an opponent's piece. When a pawn reaches the opposite edge of the board from where it started, it may be promoted to the more powerful piece that begins the game in that position, but only if one of these belonging to the player has already been captured. If this has not happened, the pawn cannot move to the final row. When a player can capture the opponent's Shah on the next turn, the Shah is in check, the opponent's next move must free the Shah from check. If the opponent cannot, it is checkmate and the player wins.
(game "Shatranj Diwana Shah" (players 2) (equipment {(board (square 8)) (piece "Pawn" P2 S (do (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))}) ifAfterwards:(if (is In (last To) (sites Mover "Promotion")) (!= -1 (if (and (is In (last To) (sites Corners)) (!= 2 (count Pieces Mover "Boat"))) (id "Boat" Mover) (if (and (or (= (column of:(last To)) 1) (= (column of:(last To)) 6)) (!= 2 (count Pieces Mover "Knight"))) (id "Knight" Mover) (if (and (or (= (column of:(last To)) 2) (= (column of:(last To)) 5)) (!= 2 (count Pieces Mover "Elephant"))) (id "Elephant" Mover) (if (and (= (column of:(last To)) 3) (!= 1 (count Pieces Mover "Queen"))) (id "Queen" Mover) -1))))) True) (then (if (is In (last To) (sites Mover "Promotion")) (promote (last To) (piece (if (and (is In (last To) (sites Corners)) (!= 2 (count Pieces Mover "Boat"))) (id "Boat" Mover) (if (and (or (= (column of:(last To)) 1) (= (column of:(last To)) 6)) (!= 2 (count Pieces Mover "Knight"))) (id "Knight" Mover) (if (and (or (= (column of:(last To)) 2) (= (column of:(last To)) 5)) (!= 2 (count Pieces Mover "Elephant"))) (id "Elephant" Mover) (if (and (= (column of:(last To)) 3) (!= 1 (count Pieces Mover "Queen"))) (id "Queen" Mover) -1))))) Mover))))) (piece "Boat" P2 (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "King_noCross" Each (if (is Mover P1) (or (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (or (move Step (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))) (if (= (state at:(from)) 1) (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0)))))) (piece "Elephant" P2 (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Knight" P2 (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Queen" P2 (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn2" (sites Row 6)) (place "King_noCross1" coord:"D1") (place "Boat2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Elephant2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King_noCross2" coord:"E8" state:1)}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))) (then (if (and (= (what at:(last To)) (id "King_noCross" P1)) (= (state at:(where "King_noCross" P2)) 1)) (if (is Threatened (id "King_noCross" P2)) (set State at:(where "King_noCross" P2) 0)))))) (end (if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win))))) 
10x10 board, with an extra square placed diagonally behind each Rukh. The pieces move as follows, with the number per player: 1 x Shah (king): moves one space orthogonally or diagonally. 1 x Fers (counselor): One square diagonally. 2 x Rukh (rook): Any number of spaces orthogonally. 2x Dabbaba: any number of squares diagonally. 2 x Pil (elephant): Two squares diagonally, jumping over the first. Cannot capture another Pil. 2 x Asb (horse): Moves as a Chess knight. 12 x Sarbaz (soldier): Moves one space forward orthogonally; one space forward diagonally to capture. No en passant. Promoted to Fers when reaching the tenth rank. No castling. Stalemate results in win for player causing it. The player who checkmates the king wins. If a player moves their king into one of the extra squares on the opposite side of the board, the game is a draw. 
(game "Shatranj al-Husun" (players {(player N) (player S)}) (equipment {(board (merge {(square 10) (shift -1 -1 (square 1)) (shift 10 -1 (square 1)) (shift -1 10 (square 1)) (shift 10 10 (square 1))})) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Queen" Each (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Elephant" Each (move Hop Diagonal (between if:True) (to if:(or (is Empty (to)) (and (is Enemy (who at:(to))) (not (= (what at:(to)) (id "Elephant" Next))))) (apply (remove (to)))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (if (is In (from) (sites Start (piece (what at:(from))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (promote (last To) (piece "Queen") Mover))))) (regions "Promotion" P1 (sites Row 10)) (regions "Promotion" P2 (sites Row 1)) (regions "OppositeExtraSquares" P1 (sites Top)) (regions "OppositeExtraSquares" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 2)) (place "Pawn2" (sites Row 9)) (place "Rook1" (sites {"B2" "K2"})) (place "Knight1" (sites {"C2" "J2"})) (place "Elephant1" (sites {"D2" "I2"})) (place "Bishop1" (sites {"E2" "H2"})) (place "King1" coord:"F2") (place "Queen1" coord:"G2") (place "Rook2" (sites {"B11" "K11"})) (place "Knight2" (sites {"C11" "J11"})) (place "Elephant2" (sites {"D11" "I11"})) (place "Bishop2" (sites {"E11" "H11"})) (place "King2" coord:"F11") (place "Queen2" coord:"G11")}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King" Mover))))) (end {(if (is In (where "King" Mover) (sites Mover "OppositeExtraSquares")) (result Mover Draw)) (if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win)) (if (no Moves Next) (result Mover Win))}))) 
11x10 board, with a twelfth space on the right of the second row of eleven on each side. Each player starts with the following pieces, with their specialized moves: Shah (x1): moves orthogonally or diagonally one space; Wazir (x1): moves one space orthogonally; Firzan (x1) moves one space diagonally; Dabbaba (x2): jumps orthogonally to the third space; Tali'as (x2): moves diagonally two or more spaces; Jamal (x2): jumps diagonally one space then two orthogonally in the same direction; Zurafa (x2): moves diagonally one space then orthogonally three or more spaces; Pil (x2) jumps two spaces diagonally; Asb (x2): jumps one space diagonally and one space orthogonally in the same direction; Rukh(x2): moves any number of spaces orthogonally; Baidaq (x10); move orthogonally forward one space or diagonally forward one space to capture. Each Baidaq is assigned to one of the piece types and promotes to that piece. They are placed in the third rank, with the Baidaq al-Bayadiq on the leftmost square, with the following promotion assignments for each regular Baidaq proceeding from left to right beginning on the second square from the left: Dabbaba, Jamal, Pil, Firzan, Shah, Wazir, Zurafa, Tali'as, Asb, Rukh. Baidaq al-Bayadiq (x1), moves like a Baidaq, but does not promote immediately when it reaches the opposite edge. Instead, it waits there, immune to capture, until a situation arises where two of the opponent's pieces could theoretically be taken by a pawn. The Baidaq al-Bayadiq is then moved to that spot, any piece (including the player's own) being moved from that spot, and then the capture being made on the next turn. It then proceeds as before, and if it is to be promoted again, it becomes a Shah's Baidaq, and is replaced on the appropriate starting position. If it is promoted a third time, it becomes Shah Masnu'a, and the original Shah's Baidaq becomes Shahzada, and both move like the Shah. If the Shah can be taken on the next turn, it is in Check and must not be in Check at the beginning of the next turn. If a Shah is not in Check but no legal moves are available, it is a Stalemate and the opponent wins. If the Shah is in Check and it is impossible to escape, Checkmate occurs and the opponent wins. Once per game, a player may swap a Shah which is in Check or Stalemate with another of the player's pieces. If the player can place the Shah in the extra space on the opponent's side of the board, the game is a draw. The Shah cannot enter the extra space if the opponent's Shah Masnu's occupies it. 
(game "Shatranj al-Kabir" (players {(player N) (player S)}) (equipment {(board (merge {(square 11) (shift 11 1 (square 1)) (shift -1 9 (square 1))})) (piece "Pawn" Each (if (= 23 (value Piece at:(from))) (move Step (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))) (or (move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (then (if (and {(> (value Piece at:(last To)) 2) (is In (last To) (sites Next)) (= 0 (state at:(last To)))}) (promote (last To) (piece (value Piece at:(last To)))) (if (and (is In (last To) (sites Next)) (= 2 (state at:(last To)))) (and {(set Value at:(last To) 23) (set State at:(last To) 0) (forEach Site (sites Board) (if (= (if (is Mover P1) 11 12) (value Piece at:(site))) (set Value at:(site) 23)))}))))))) (piece "Wazir" Each (move Hop Orthogonal (between (exact 2) if:True) (to if:(or (is Empty (to)) (and (is Enemy (who at:(to))) (not (and {(= (what at:(to)) (id "Pawn" Next)) (is In (to) (sites Mover))})))) (apply (remove (to)))))) (piece "Knight_rotated" Each (move Leap {{F F F R F} {F F F L F}} (to if:(or (is Empty (to)) (and (is Enemy (who at:(to))) (not (and {(= (what at:(to)) (id "Pawn" Next)) (is In (to) (sites Mover))})))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Elephant" Each (move Hop Diagonal (between (exact 2) if:True) (to if:(or (is Empty (to)) (and (is Enemy (who at:(to))) (not (and {(= (what at:(to)) (id "Pawn" Next)) (is In (to) (sites Mover))})))) (apply (remove (to)))))) (piece "Queen" Each (move Step Diagonal (to if:(or (is Empty (to)) (and (is Enemy (who at:(to))) (not (and {(= (what at:(to)) (id "Pawn" Next)) (is In (to) (sites Mover))})))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "King_noCross" Each (move Step (to if:(or (is Empty (to)) (and (and (is Enemy (who at:(to))) (not (and {(= (what at:(to)) (id "Pawn" Next)) (is In (to) (sites Mover))}))) (or (!= (to) (mapEntry "ExtraSquare" Next)) (and (= (to) (mapEntry "ExtraSquare" Next)) (< (value Piece at:(to)) 23))))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Amazon" Each (move Step Orthogonal (to if:(or (is Empty (to)) (and (is Enemy (who at:(to))) (not (and {(= (what at:(to)) (id "Pawn" Next)) (is In (to) (sites Mover))})))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Giraffe" Each (forEach Direction Diagonal (to if:(is Empty (to)) (apply (and {(move (from) (to (sites To (slide (from (to)) Orthogonal (between (min 3)) (to if:(and (is Enemy (who at:(to))) (not (and {(= (what at:(to)) (id "Pawn" Next)) (is In (to) (sites Mover))}))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))))}))))) (piece "Bishop_noCross" Each (move Slide Diagonal (between (min 2)) (to if:(and (is Enemy (who at:(to))) (not (and {(= (what at:(to)) (id "Pawn" Next)) (is In (to) (sites Mover))}))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(or (is Empty (to)) (and (is Enemy (who at:(to))) (not (and {(= (what at:(to)) (id "Pawn" Next)) (is In (to) (sites Mover))})))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Rook" Each (move Slide Orthogonal (to if:(and (is Enemy (who at:(to))) (not (and {(= (what at:(to)) (id "Pawn" Next)) (is In (to) (sites Mover))}))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (regions P1 (sites Bottom)) (regions P2 (sites Top)) (map "InitShahPawn" {(pair P1 "G3") (pair P2 "G9")}) (map "ExtraSquare" {(pair P1 "M2") (pair P2 "A10")})}) (rules (start {(place "Pawn1" coord:"B3" value:1) (place "Pawn2" coord:"L9" value:2) (place "Pawn1" coord:"C3" value:3) (place "Pawn2" coord:"K9" value:4) (place "Pawn1" coord:"D3" value:5) (place "Pawn2" coord:"J9" value:6) (place "Pawn1" coord:"E3" value:7) (place "Pawn2" coord:"I9" value:8) (place "Pawn1" coord:"F3" value:9) (place "Pawn2" coord:"H9" value:10) (place "Pawn1" coord:"G3" value:11) (place "Pawn2" coord:"G9" value:12) (place "Pawn1" coord:"H3" value:13) (place "Pawn2" coord:"F9" value:14) (place "Pawn1" coord:"I3" value:15) (place "Pawn2" coord:"E9" value:16) (place "Pawn1" coord:"J3" value:17) (place "Pawn2" coord:"D9" value:18) (place "Pawn1" coord:"K3" value:19) (place "Pawn2" coord:"C9" value:20) (place "Pawn1" coord:"L3" value:21) (place "Pawn2" coord:"B9" value:22) (place "King_noCross1" coord:"G2") (place "King_noCross2" coord:"G10") (place "Queen1" coord:"F2") (place "Queen2" coord:"H10") (place "Amazon1" coord:"H2") (place "Amazon2" coord:"F10") (place "Giraffe1" (sites {"E2" "I2"})) (place "Giraffe2" (sites {"E10" "I10"})) (place "Bishop_noCross1" (sites {"D2" "J2"})) (place "Bishop_noCross2" (sites {"D10" "J10"})) (place "Wazir1" (sites {"F1" "H1"})) (place "Wazir2" (sites {"F11" "H11"})) (place "Knight1" (sites {"C2" "K2"})) (place "Knight2" (sites {"C10" "K10"})) (place "Rook1" (sites {"B2" "L2"})) (place "Rook2" (sites {"B10" "L10"})) (place "Elephant1" (sites {"B1" "L1"})) (place "Elephant2" (sites {"B11" "L11"})) (place "Knight_rotated1" (sites {"D1" "J1"})) (place "Knight_rotated2" (sites {"D11" "J11"}))}) (play (do (or {(move (from (forEach (sites Next) if:(and (= (what at:(site)) (id "Pawn" Mover)) (<= (value Piece at:(site)) 2)))) (to (forEach (sites Empty) if:(if (is Mover P1) (and (is Enemy (who at:(ahead (site) NE))) (is Enemy (who at:(ahead (site) NW)))) (and (is Enemy (who at:(ahead (site) SE))) (is Enemy (who at:(ahead (site) SW))))))) (then (and (set Value at:(last To) (if (is Mover P1) 11 12)) (set State at:(last To) 1)))) (move (from (forEach (sites Next) if:(and {(= (what at:(site)) (id "Pawn" Mover)) (or (= (value Piece at:(site)) 11) (= (value Piece at:(site)) 12)) (= (state at:(site)) 1)}))) (to (mapEntry "InitShahPawn" Mover) if:(is Empty (to))) (then (set State at:(last To) 2))) (if (and (!= (value Player Mover) 1) (is Threatened (id "King_noCross" Mover))) (forEach Site (difference (sites Occupied by:Mover container:"Board") (sites Occupied by:Mover container:"Board" component:"King_noCross")) (move Swap Pieces (where "King_noCross" Mover) (site) (then (set Value Mover 1))))) (forEach Piece)}) ifAfterwards:(and (not (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (not (is Threatened (id "King_noCross" Mover)))))) (end {(if (no Moves Next) (result Mover Win)) (if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win)) (if (or (= (what at:(mapEntry "ExtraSquare" P1)) (id "King_noCross" P2)) (= (what at:(mapEntry "ExtraSquare" P2)) (id "King_noCross" P1))) (result Mover Draw))}))) 
4x16 board. The pieces move as follows, with the number per player: Shah (king)x1: moves one space orthogonally or diagonally. Fers (counselor)x1: one square diagonally; Rukh (rook)x2: any number of spaces orthogonally; Pil (elephant)x2: two squares diagonally, jumping over the first, cannot capture another Pil; Asb (horse)x2: moves orthogonally one space and then diagonally one space, jumping over any intervening pieces; Sarbaz (soldier)x8: moves one space forward orthogonally or one space forward diagonally to capture. No en passant, promoted to Fers when reaching the sixteenth rank. Pieces are placed with the Shah and Fers in the center of the row closest to the player (Shah to the right), a Pil on either side of them, the Asb on the two center squares in the second row, flanked by the Rukh, and the Sarbaz on the fifth and sixth rows. Movement of the pieces is determined by one six-sided die, with the following throws: 6=Shah, 5=Fers, 4=Pil, 3=Asb, 2=Rukh, 1=Sarbaz. No castling. Stalemate results in win for player causing it. When the Shah is in check, the opponent must roll a 6 for it to escape. The player who checkmates the Shah wins. 
(game "Shatranj al-Mustatila" (players {(player N) (player S)}) (equipment {(board (rectangle 16 4)) (piece "King_noCross" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Queen" Each (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (piece "Elephant" Each (move Hop Diagonal (between if:True) (to if:(or (is Empty (to)) (and (is Enemy (who at:(to))) (not (= (what at:(to)) (id "Elephant" Next))))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (promote (last To) (piece "Queen") Mover))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom)) (dice d:6 from:1 num:1)}) (rules (start {(place "Pawn1" (union (sites Row 4) (sites Row 5))) (place "Pawn2" (union (sites Row 10) (sites Row 11))) (place "Elephant1" (sites {"A1" "D1"})) (place "Knight1" (sites {"B2" "C2"})) (place "Rook1" (sites {"A2" "D2"})) (place "King_noCross1" coord:"B1") (place "Queen1" coord:"C1") (place "Elephant2" (sites {"A16" "D16"})) (place "Knight2" (sites {"B15" "C15"})) (place "Rook2" (sites {"A15" "D15"})) (place "King_noCross2" coord:"C16") (place "Queen2" coord:"B16")}) (play (do (do (roll) next:(if (is Threatened (id "King_noCross" Next) (forEach Piece)) (move Pass (then (trigger "NextCanNotEscape" (next)))) (if (= (count Pips) 6) (forEach Piece "King_noCross") (if (= (count Pips) 5) (forEach Piece "Queen") (if (= (count Pips) 4) (forEach Piece "Elephant") (if (= (count Pips) 3) (forEach Piece "Knight") (if (= (count Pips) 2) (forEach Piece "Rook") (forEach Piece "Pawn")))))))) ifAfterwards:(not (is Threatened (id "King_noCross" Mover) (forEach Piece Next))))) (end {(if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win)) (if (is Triggered "CanNotEscape" Next) (result Mover Win)) (if (not (can Move (forEach Piece Next))) (result Mover Win))}))) 
Circular board. Empty central circle, with four concentric rows of spaces, sixteen spaces per circle. Pieces are as follows: Rukh (x2), placed on two adjacent squares in the outer circle, move any number of spaces orthogonally; Asb (x2), placed in the two spaces adjacent to the Rukh in the next circle, move as Chess knights; Pil (x2): Placed in the two spaces adjacent to the Asb in the next circle in, move two spaces diagonally, jumping over the first space; Fres (x1): placed on the inner circle adjacent to the left Pil, moves one space diagonally; Shah (x1), placed to the right of the Fers, moves one space in any direction, Baidaq (x8), placed in each space flanking the other pieces, those on the left move clockwise, those on the right anti-clockwise, one space forward or one space diagonally forward to capture. No en passant, no promotion. When two Baidaq meet and neither can move, the opponent captures them. The opponent who can checkmate the opponent's Shah wins. Rules Murray.
(game "Shatranj ar-Rumiya" (players 2) (equipment {(board (remove (concentric {0 0 0 16 16 16 16}) cells:{1})) (piece "Pawn" Each (or {(move Step (if (= (state at:(from)) 0) CW CCW) (to if:(is Empty (to)))) (move (from) (to (sites Around (sites To (move Step (if (= (state at:(from)) 0) CW CCW) (to if:True))) Orthogonal) if:(and (is Related Diagonal (from) (to)) (is Enemy (who at:(to))))))} (then (if (= (state at:(last To)) 0) (if (= (what at:(ahead (last To) CW)) (id "Pawn" Next)) (and (remove (last To)) (remove (ahead (last To) CW)))) (if (= (what at:(ahead (last To) CCW)) (id "Pawn" Next)) (and (remove (last To)) (remove (ahead (last To) CCW)))))))) (piece "Rook" Each (move Slide Rotational (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Knight" Each (forEach Direction Orthogonal (to if:True (apply (forEach Direction (from (to)) Diagonal (if (and (not (is Friend (who at:(to)))) (= 3 (count Steps Orthogonal (from) (to)))) (move (from) (to (apply if:(is Enemy (who at:(to))) (remove (to))))))))))) (piece "Elephant" Each (move (from) (to (sites Around (sites Around (from) Diagonal) Diagonal) if:(and (not (is Friend (who at:(to)))) (< 2 (count Steps Orthogonal (from) (to)))) (apply if:(is Enemy (who at:(to))) (remove (to)))))) (piece "Queen" Each (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (piece "King_noCross" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))}) (rules (start {(place "Rook1" (sites {52 53})) (place "Rook2" (sites {61 60})) (place "Knight1" (sites {36 37})) (place "Knight2" (sites {44 45})) (place "Elephant1" (sites {20 21})) (place "Elephant2" (sites {28 29})) (place "Queen1" 4) (place "Queen2" 12) (place "King_noCross1" 5) (place "King_noCross2" 13) (place "Pawn1" (sites {3 19 35 51}) state:0) (place "Pawn1" (sites {54 38 22 6}) state:1) (place "Pawn2" (sites {11 27 43 59}) state:0) (place "Pawn2" (sites {14 30 46 62}) state:1)}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))))) (end {(if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win))}))) 
10x10 board. The pieces move as follows, with the number per player: 1 x Shah (king): one space orthogonally or diagonally; 1 x Fers (counselor): one square diagonally; 2 x Rukh (rook): any number of spaces orthogonally; 2x Dabbaba: one space orthogonally or diagonally; 2 x Pil (elephant): two squares diagonally, jumping over the first. Cannot capture another Pil; 2 x Asb (horse): one square orthogonally, and then one square diagonally, jumping over any intervening pieces; 10 x Sarbaz (soldier): one space forward orthogonally or one space forward diagonally to capture. No en passant. Sarbaz begins in the third rank, and is promoted to Fers when reaching the tenth rank, only if the Fers has been captured. Otherwise, the other player captures it. No castling. Stalemate results in win for player causing it. The player who checkmates the king wins.
(game "Shatranj at-Tamma" (players {(player N) (player S)}) (equipment {(piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (if (= (where "Queen" Mover) -1) (promote (last To) (piece "Queen") Mover) (remove (last To))))))) (piece "King_noCross" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Queen" Each (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Wazir" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Elephant" Each (move Hop Diagonal (between if:True) (to if:(or (is Empty (to)) (and (is Enemy (who at:(to))) (not (= (what at:(to)) (id "Elephant" Next))))) (apply (remove (to)))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom)) (board (square 10))}) (rules (start {(place "Pawn1" (sites Row 2)) (place "Pawn2" (sites Row 7)) (place "Rook1" (sites {"A1" "J1"})) (place "Rook2" (sites {"A10" "J10"})) (place "Knight1" (sites {"B1" "I1"})) (place "Knight2" (sites {"B10" "I10"})) (place "Elephant1" (sites {"C1" "H1"})) (place "Elephant2" (sites {"C10" "H10"})) (place "Wazir1" (sites {"D1" "G1"})) (place "Wazir2" (sites {"D10" "G10"})) (place "Queen1" coord:"E1") (place "Queen2" coord:"F10") (place "King_noCross1" coord:"F1") (place "King_noCross2" coord:"E10")}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))))) (end {(if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win)) (if (no Moves Next) (result Mover Win))}))) 
8x8 board. The pieces move as follows, with the number per player: 1 x Shah (king): moves one space orthogonally or diagonally. 1 x Fers (counselor): One square diagonally. 2 x Rukh (rook): Any number of spaces orthogonally. 2 x Pil (elephant): Two squares diagonally, jumping over the first. Cannot capture another Pil. 2 x Asb (horse): Moves as a chess knight. 8 x Sarbaz (soldier): Moves one space forward orthogonally; one space forward diagonally to capture. No en passant. Promoted to Fers when reaching the eighth rank. No castling. Stalemate results in win for player causing it. The player who checkmates the king wins.
(game "Shatranj" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (moveAgain))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "King_noCross" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Bishop_noCross" Each (move Hop Diagonal (between if:True) (to if:(or (is Empty (to)) (is Enemy (who at:(to)))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Ferz_noCross" Each (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Bishop_noCross1" {"C1" "F1"}) (place "Ferz_noCross1" coord:"D1") (place "King_noCross1" coord:"E1") (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Bishop_noCross2" {"C8" "F8"}) (place "Ferz_noCross2" coord:"D8") (place "King_noCross2" coord:"E8")}) (play (if (is Prev Mover) (move Promote (last To) (piece "Ferz_noCross") Mover) (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover)))))) (end {(if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win)) (if (= (count Pieces Next) 1) (result Mover Win)) (if (no Moves Next) (result Mover Win))}))) 
8x8 checkered board. Pieces move according to specialized moves, as follows: Piyatha (x8): can move one space forward, and one space forward diagonally to capture. When they reach the final rank, they may be promoted to the piece belonging to that rank, as long as it has already been captured by the opponent; Rukh (castle), (x2): can move any number of spaces orthogonally; Fil (elephant), (x2): can move any number of spaces diagonally; Ghoda (horse), (2): moves in any direction, one space orthogonally with one space forward diagonally; Farthir (x1): can move any number of spaces orthogonally or diagonally; Shah (x1): can move one space orthogonally or diagonally, and can also move like the horse if it has not yet been checked. The pieces are arranged as in Chess. Players capture pieces by moving onto a space occupied by an opponent's piece. When a player can capture the opponent's Shah on the next turn, the Shah is in Check, the opponent's next move must free the Shah from Check. If the opponent cannot, it is Checkmate and the player wins. Stalemate is allowed. 
(game "Shatren" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (if (and (is In (last To) (sites Corners)) (< (count Sites in:(sites Occupied by:Mover component:"Castle")) 2)) (promote (last To) (piece (id "Castle" Mover))) (if (and (or (= (column of:(last To)) 1) (= (column of:(last To)) 6)) (< (count Sites in:(sites Occupied by:Mover component:"Horse")) 2)) (promote (last To) (piece (id "Horse" Mover))) (if (and (or (= (column of:(last To)) 2) (= (column of:(last To)) 5)) (< (count Sites in:(sites Occupied by:Mover component:"Elephant")) 2)) (promote (last To) (piece (id "Elephant" Mover))) (if (and (= (column of:(last To)) 3) (< (count Sites in:(sites Occupied by:Mover component:"Queen")) 1)) (promote (last To) (piece (id "Queen" Mover))))))))))) (piece "Castle" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "King_noCross" Each (or (move Step (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))) (if (not (is Threatened (id "King_noCross" Mover))) (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))))) (piece "Elephant" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Horse" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Castle1" {"A1" "H1"} state:1) (place "Horse1" {"B1" "G1"}) (place "Elephant1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King_noCross1" coord:"E1" state:1) (place "Castle2" {"A8" "H8"} state:1) (place "Horse2" {"B8" "G8"}) (place "Elephant2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King_noCross2" coord:"E8" state:1)}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))))) (end (if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win))))) 
8x8 checkered board, with the left corner black for each player. Pieces with specialized moves, as follows: Noyion (x1): moves one space in any direction; Merzé (x1, "dog"): moves one space diagonally; Taba (x2, "camel"): move two spaces diagonally, jumping over the first square; Ot (x2, "horse"): move as a Chess knight; Targa (x2, "cart"); moves orthogonally over any distance; Oi (x8, "child"): moves one space forward orthogonally, one space forward diagonally to capture. May move two spaces on the first turn of the game. When it reaches the opposite edge of the board, it is promoted to Merzé. Pieces are captured when an opponent's piece moves to the square occupied by that piece. The goal is to checkmate the Noyion, and it must not be in check at the end of the player's turn, if possible. If checkmate is made without capturing all of the Oi, the game is a draw.
(game "Shodra" (players {(player N) (player S)}) (equipment {(board (square 8)) (hand Each size:5) (piece "King_noCross" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Camel" Each (move Hop Diagonal (between if:True) (to if:(or (is Empty (to)) (is Enemy (who at:(to)))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (if (is In (from) (sites Start (piece (what at:(from))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (promote (last To) (piece "Dog") Mover))))) (piece "Dog" Each (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Camel1" {"C1" "F1"}) (place "Dog1" coord:"D1") (place "King_noCross1" coord:"E1") (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Camel2" {"C8" "F8"}) (place "Dog2" coord:"D8") (place "King_noCross2" coord:"E8")}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))))) (end (if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) {(if (no Pieces Next "Pawn") (result Mover Win)) (if (!= (count Pieces Next "Pawn") 0) (result Mover Draw))})))) 
8x8 board, with diagonals drawn in the 2x2 squares in each corner, as well as the diagonals of the entire board. Each player has a complement of pieces, with special moves as follows: Min-gyi (x1, "Great King"): moves one space in any direction; Sit-ké (x1, "Lieutenant-General"): moves one space diagonally; Sin (x2, "Elephant"): moves one space diagonally or orthogonally forward; Myin (x2, "Horse"): moves as a Chess knight; Yattah (x2, "Chariot"): moves orthogonally any distance; Nè (x8): moves one space orthogonally forward or one space forward diagonally to capture. Promotes to Sit-kè on the next turn after moving to one of the spaces with a diagonal on the opponent's side of the board. At the beginning of the game, the board is laid out with the four of the Nè in the left half of the third third row of squares, and four in the right half of the fourth row of squares. Players alternate turns placing the remaining pieces. The Min-gyi are placed in the second space from the right in the second row, and a Sin must be placed next to it. If a player wishes to place one of their pieces in a spot occupied by a Nè, they may do so and place the Nè elsewhere behind the rows of Nè. When all of the pieces are placed, players may continue alternating turns rearranging pieces, one at a time, as they see fit. When one player is satisfied with their pieces, they move a Nè forward and the rearrangement phase ends. Players alternate turns moving their pieces according to their assigned movements. Pieces are captured when an player's piece lands on a space occupied by an opponent's piece. The Min-gyi is in check when it can be taken on the opponent's next turn; it must not remain in check at the end of the player's subsequent turn. The goal is to checkmate the Min-gyi, where it cannot move out of check. A move which causes a stalemate is not allowed. 
(game "Sittuyin" (players {(player N) (player S)}) (equipment {(board (square 8)) (hand Each size:6) (piece "King_noCross" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Elephant" Each (move Step Forwards (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (if (is In (last To) (difference (sites "DiagonalSites") (sites Mover "Home"))) (promote (last To) (piece "Queen") Mover))))) (piece "Queen" Each (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (regions "Home" P1 (expand (sites Bottom) steps:3)) (regions "Home" P2 (expand (sites Top) steps:3)) (regions "NoPawnSites" (union (difference (sites Row 3) (expand (sites Right) steps:3)) (difference (sites Row 4) (expand (sites Left) steps:3)))) (regions "PawnSites" (union {(difference (sites Row 2) (expand (sites Right) steps:3)) (difference (sites Row 3) (expand (sites Left) steps:3)) (difference (sites Row 4) (expand (sites Right) steps:3)) (difference (sites Row 5) (expand (sites Left) steps:3))})) (regions "DiagonalSites" (union (union (sites Centre) (expand (sites Corners) steps:1)) (sites {"C6" "F6" "F3" "C3"}))) (map "KingInitPos" {(pair P1 (coord "G2")) (pair P2 (coord "B7"))})}) (rules (start {(place "Pawn1" (difference (sites Row 2) (expand (sites Right) steps:3))) (place "Pawn1" (difference (sites Row 3) (expand (sites Left) steps:3))) (place "Pawn2" (difference (sites Row 4) (expand (sites Right) steps:3))) (place "Pawn2" (difference (sites Row 5) (expand (sites Left) steps:3))) (place "King_noCross1" (handSite P1)) (place "King_noCross2" (handSite P2)) (place "Queen1" (handSite P1 1)) (place "Queen2" (handSite P2 1)) (place "Elephant1" (handSite P1 2) count:2) (place "Elephant2" (handSite P2 2) count:2) (place "Knight1" (handSite P1 3) count:2) (place "Knight2" (handSite P2 3) count:2) (place "Rook1" (handSite P1 4) count:2) (place "Rook2" (handSite P2 4) count:2)}) phases:{(phase "PlaceKing" (play (move (from (sites Occupied by:Mover container:"Hand" component:"King_noCross")) (to (mapEntry "KingInitPos" Mover)))) (nextPhase Mover "PlaceFirstElephant")) (phase "PlaceFirstElephant" (play (move (from (sites Occupied by:Mover container:"Hand" component:"Elephant")) (to (sites Around (mapEntry "KingInitPos" Mover))))) (nextPhase Mover "PlaceOtherPieces")) (phase "PlaceOtherPieces" (play (if (!= 0 (count Sites in:(sites Occupied by:Mover container:"Hand" component:"Pawn"))) (move (from (sites Occupied by:Mover container:"Hand" component:"Pawn")) (to (intersection (difference (sites Mover) (union (sites "PawnSites") (sites "NoPawnSites"))) (sites Empty)))) (or (if (= 0 (count Sites in:(union (sites Occupied by:P1 container:"Hand") (sites Occupied by:P2 container:"Hand")))) (or (forEach Piece "Pawn" (move Step Forward (to if:(is Empty (to))))) (move (from (difference (sites Occupied by:Mover container:"Board") (sites Occupied by:Mover container:"Board" component:"Pawn"))) (to (difference (intersection (sites Mover) (union (sites Empty) (sites Occupied by:Mover container:"Board" component:"Pawn"))) (sites "NoPawnSites")) (apply (if (is Occupied (to)) (fromTo (from (to)) (to (handSite Mover 5)))))) (then (if (!= 0 (count Sites in:(sites Occupied by:Mover container:"Hand" component:"Pawn"))) (moveAgain)))))) (move (from (sites Occupied by:Mover container:"Hand")) (to (difference (intersection (sites Mover) (union (sites Empty) (sites Occupied by:Mover container:"Board" component:"Pawn"))) (sites "NoPawnSites")) (apply (if (is Occupied (to)) (fromTo (from (to)) (to (handSite Mover 5)))))) (then (if (!= 0 (count Sites in:(sites Occupied by:Mover container:"Hand" component:"Pawn"))) (moveAgain))))))) (nextPhase (and (is In (last From) (sites Board)) (= (what at:(last To)) (id "Pawn" Mover))) "Playing")) (phase "Playing" (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))))) (end (if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win))))})) 
8x8 board, with diagonals in every square. Pieces have special moves, as follows: Raja (king), moves one square in any direction, but on the first move, it may jump two squares or move as a knight, with the exception that it cannot jump two squares diagonally; Mantri (minister), moves orthogonally or diagonally any number of spaces; Gajah (x2); move diagonally any distance; Kuda (horse) x2, moves orthogonally one space then diagonal one space from there, jumping over any intervening pieces; Ter/Chemor (chariot) x2, moves orthogonally any distance; Bídaq (pawn) x8: moves one square forward or one square forward diagonally to capture. May move two spaces forward orthogonally if it is that piece's first move. Upon reaching the opposite edge of the board, the Bídaq moves in the opposite direction, reversing again if it reaches the opposite edge. The Mantri is placed to the right of the Raja at the beginning of play. Castling occurs in two moves, the rook moving to the king and then the king jumping over the rook. Pieces are captured by moving onto a space occupied by an opponent's piece. If the Raja can be captured on its next turn, it is in check. The Raja cannot be in check at the end of its turn. When this is unavoidable, it is checkmate and the opponent wins. 
(game "Tepong" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "King_noCross" Each (or (move Step (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))) (then (if (not (= 1 (state at:(last To)))) (set State at:(last To) 1)))) (if (not (= 1 (state at:(from)))) (or {(move Hop Orthogonal (between (exact 2) if:True) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (if (is In (from) (sites {"E8" "D1"})) (or (if (and {(is Empty (ahead (from) steps:2 W)) (= (what at:(ahead (from) W)) (id "Rook" Mover)) (not (= 1 (state at:(ahead (from) W))))}) (move (from) (to (ahead (from) steps:2 W)))) (if (and {(is Empty (ahead (from) steps:2 E)) (= (what at:(ahead (from) E)) (id "Rook" Mover)) (not (= 1 (state at:(ahead (from) E))))}) (move (from) (to (ahead (from) steps:2 E))))))} (then (set State at:(last To) 1)))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Bishop_noCross" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))) (then (if (and (not (= 1 (state at:(last To)))) (not (is In (last To) (sites {"C1" "E1" "D8" "F8"})))) (set State at:(last To) 1))))) (piece "Pawn" Each (or {(if (and (= 0 (state at:(last To))) (is In (from) (sites Start (piece (what at:(from)))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))))) (move Step (if (= 1 (state at:(from))) Backward Forward) (to if:(is Empty (to)))) (move Step (if (= 1 (state at:(from))) (directions {BR BL}) (directions {FR FL})) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (if (is In (last To) (union (sites Bottom) (sites Top))) (if (= 0 (state at:(last To))) (set State at:(last To) 1) (set State at:(last To) 2))))))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Bishop_noCross1" {"C1" "F1"}) (place "King_noCross1" coord:"D1") (place "Queen1" coord:"E1") (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Bishop_noCross2" {"C8" "F8"}) (place "King_noCross2" coord:"E8") (place "Queen2" coord:"D8")}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))))) (end (if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win))))) 
8x8 board. Pieces have specific moves, as follows: Mai (x1): moves one space in any direction; Chiroma (x1): Moves one space diagonally; Bintu (x2): moves exactly two spaces diagonally, jumping over the first square; Fer (x2): moves orthogonally one space and then diagonally another space, jumping over any intervening pieces; Kaigamma (x2): moves orthogonally any distance; Gollo: (x8) move one space forward orthogonally, or one space diagonally forward to capture. Pieces capture the opponent's pieces by moving onto the spot they occupy. No en passant; no castling. When the Mai can be captured at the beginning of the opponent's next turn, it is in check and must be removed from this state on the player's turn. If this is not possible, it is checkmate and the player who threatened the Mai wins. 
(game "Tsatsarandi" (players 2) (equipment {(board (square 8)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))})) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "King_noCross" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Bishop_noCross" (move Hop Diagonal (between if:True) (to if:(or (is Empty (to)) (is Enemy (who at:(to)))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Ferz_noCross" (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))))}) (rules (start {(place "King_noCross1" coord:"E1") (place "King_noCross2" coord:"E8") (place "Ferz_noCross1" coord:"D1") (place "Ferz_noCross2" coord:"D8") (place "Bishop_noCross1" {"C1" "F1"}) (place "Bishop_noCross2" {"C8" "F8"}) (place "Knight1" {"B1" "G1"}) (place "Knight2" {"B8" "G8"}) (place "Rook1" {"A1" "H1"}) (place "Rook2" {"A8" "H8"}) (place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6))}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))))) (end (if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win))))) 
Here, the King and Rook move as usual, and the knight moves exactly two squares, and may jump over a piece doing that. Gardner asks his readers whether white can win. (White can make a draw by taking the opponents rook and thus giving stalemate.). Board of length 8.
(game "1D Chess" (players 2) (equipment {(board (rectangle 1 8)) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Knight" Each (move Leap {{F F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))}) (rules (start {(place "Rook1" coord:"C1") (place "Knight1" coord:"B1") (place "King1" coord:"A1") (place "Rook2" coord:"F1") (place "Knight2" coord:"G1") (place "King2" coord:"H1")}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King" Mover))))) (end {(if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win)) (if (or (no Moves Mover) (= (counter) 100)) (result Mover Draw))}))) 
8x8 board. The pieces move as follows: King (x1): one space in any direction' Queen (x1): moves one square diagonally. On its first move, the Queen may jump diagonally two squares. The Queen cannot capture when making this move. Bishop (x2): jumps exactly two squares diagonally; Knight (x2): moves one space orthogonally and then one space diagonally, jumping over the intervening spaces; Rook (x2): moves any distance orthogonally; Pawns (x8): move one square forward orthogonally or one square forward diagonally to capture. Pawns may move two squares on their first move, but only if there have been no captures yet in the game. When reaching the opposite edge of the board, pawns may be promoted to Queen if the Queen has already been taken. If the King can be captured on the opponent's next move, it is in check. The King must not be in check at the end of the player's turn. If this is impossible, it is checkmate, and the opponent wins. 
(game "Acedrex (Alfonso)" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Var 1)))))))) (piece "Queen" Each (or (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Var 1))))))) (if (not (= 1 (state at:(from)))) (move Hop Diagonal (between if:True) (to if:(is Empty (to))))) (then (if (not (= 1 (state at:(last To)))) (set State at:(last To) 1))))) (piece "Bishop" Each (move Hop Diagonal (between if:True) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Var 1)))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Var 1)))))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Var 1))))))) (piece "Pawn" Each (or {(if (and (not (= (var) 1)) (is In (from) (sites Start (piece (what at:(from)))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))))) (move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Var 1)))))))} (then (if (and (= (where "Queen" Mover) -1) (is In (last To) (sites Mover "Promotion"))) (promote (last To) (piece "Queen") Mover))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King1" coord:"E1" state:1) (place "Rook2" {"A8" "H8"} state:1) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King2" coord:"E8" state:1)}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King" Mover))))) (end (if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win))))) 
Played on an 8x8 checkered board, with large diagonals drawn on the inner square 4x4 spaces. Four players, seated, from top left, anti-clockwise: red, black, white, green. Each player has four pawns, a knight, a fil, a rook, and a king. The kings begin in the corner space, with the knight to the adjacent square in the row with the king, the rook in the square in the column adjacent to the king, and the fil in the remaining 2x2 square in the corner. The pawns are placed on the orthogonally adjacent squares to this formation. Pieces move as follows: King: One square in any direction. Knight: As a knight in Chess. Rook: Orthogonally any number of spaces. Fil: moves diagonally two spaces, jumping over any piece in the intervening square. Pawns: move forward along the direction of their nearest edge, but capture diagonally forward. Upon reaching the opposite edge of the board, pawns are immediately promoted to "Fers," which moves diagonally one space in any direction. Pieces are taken by moving onto a space occupied by an enemy piece. Kings cannot be in check at the end of their turn, if this is not possible the king is checkmated and that player loses. Each player makes an opening bet. Any time a player loses a piece or their king is placed in check, they must pay into the pot. When a player's king is checkmated, they must pay into the pot for their remaining pieces, and all their pieces are removed from the board. Each player may capture only the pieces of the player to their right. As players are eliminated, the targeted player is changed accordingly.
(game "Acedrex de los Cuatros Tiempos" (players 4) (equipment {(board (square 8)) (piece "King" Each (move Step (to if:(or (is Empty (to)) (= (if (is Mover P1) (if (is Active P2) 2 (if (is Active P3) 3 4)) (if (is Mover P2) (if (is Active P3) 3 (if (is Active P4) 4 1)) (if (is Mover P3) (if (is Active P4) 4 (if (is Active P1) 1 2)) (if (is Active P1) 1 (if (is Active P2) 2 3))))) (who at:(to)))) (apply (if (= (if (is Mover P1) (if (is Active P2) 2 (if (is Active P3) 3 4)) (if (is Mover P2) (if (is Active P3) 3 (if (is Active P4) 4 1)) (if (is Mover P3) (if (is Active P4) 4 (if (is Active P1) 1 2)) (if (is Active P1) 1 (if (is Active P2) 2 3))))) (who at:(to))) (and (remove (to)) (and (note player:Next "Pays into the pot" to:Next) (set Pot (+ (pot) (amount Next)))))))))) (piece "Pawn" P1 W (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(= (if (is Mover P1) (if (is Active P2) 2 (if (is Active P3) 3 4)) (if (is Mover P2) (if (is Active P3) 3 (if (is Active P4) 4 1)) (if (is Mover P3) (if (is Active P4) 4 (if (is Active P1) 1 2)) (if (is Active P1) 1 (if (is Active P2) 2 3))))) (who at:(to))) (apply (if (= (if (is Mover P1) (if (is Active P2) 2 (if (is Active P3) 3 4)) (if (is Mover P2) (if (is Active P3) 3 (if (is Active P4) 4 1)) (if (is Mover P3) (if (is Active P4) 4 (if (is Active P1) 1 2)) (if (is Active P1) 1 (if (is Active P2) 2 3))))) (who at:(to))) (and (remove (to)) (and (note player:Next "Pays into the pot" to:Next) (set Pot (+ (pot) (amount Next)))))))))} (then (if (is In (last To) (sites Left)) (promote (last To) (piece "Queen") Mover))))) (piece "Pawn3d" P1 N (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(= (if (is Mover P1) (if (is Active P2) 2 (if (is Active P3) 3 4)) (if (is Mover P2) (if (is Active P3) 3 (if (is Active P4) 4 1)) (if (is Mover P3) (if (is Active P4) 4 (if (is Active P1) 1 2)) (if (is Active P1) 1 (if (is Active P2) 2 3))))) (who at:(to))) (apply (if (= (if (is Mover P1) (if (is Active P2) 2 (if (is Active P3) 3 4)) (if (is Mover P2) (if (is Active P3) 3 (if (is Active P4) 4 1)) (if (is Mover P3) (if (is Active P4) 4 (if (is Active P1) 1 2)) (if (is Active P1) 1 (if (is Active P2) 2 3))))) (who at:(to))) (and (remove (to)) (and (note player:Next "Pays into the pot" to:Next) (set Pot (+ (pot) (amount Next)))))))))} (then (if (is In (last To) (sites Top)) (promote (last To) (piece "Queen") Mover))))) (piece "Pawn" P2 W (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(= (if (is Mover P1) (if (is Active P2) 2 (if (is Active P3) 3 4)) (if (is Mover P2) (if (is Active P3) 3 (if (is Active P4) 4 1)) (if (is Mover P3) (if (is Active P4) 4 (if (is Active P1) 1 2)) (if (is Active P1) 1 (if (is Active P2) 2 3))))) (who at:(to))) (apply (if (= (if (is Mover P1) (if (is Active P2) 2 (if (is Active P3) 3 4)) (if (is Mover P2) (if (is Active P3) 3 (if (is Active P4) 4 1)) (if (is Mover P3) (if (is Active P4) 4 (if (is Active P1) 1 2)) (if (is Active P1) 1 (if (is Active P2) 2 3))))) (who at:(to))) (and (remove (to)) (and (note player:Next "Pays into the pot" to:Next) (set Pot (+ (pot) (amount Next)))))))))} (then (if (is In (last To) (sites Left)) (promote (last To) (piece "Queen") Mover))))) (piece "Pawn3d" P2 S (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(= (if (is Mover P1) (if (is Active P2) 2 (if (is Active P3) 3 4)) (if (is Mover P2) (if (is Active P3) 3 (if (is Active P4) 4 1)) (if (is Mover P3) (if (is Active P4) 4 (if (is Active P1) 1 2)) (if (is Active P1) 1 (if (is Active P2) 2 3))))) (who at:(to))) (apply (if (= (if (is Mover P1) (if (is Active P2) 2 (if (is Active P3) 3 4)) (if (is Mover P2) (if (is Active P3) 3 (if (is Active P4) 4 1)) (if (is Mover P3) (if (is Active P4) 4 (if (is Active P1) 1 2)) (if (is Active P1) 1 (if (is Active P2) 2 3))))) (who at:(to))) (and (remove (to)) (and (note player:Next "Pays into the pot" to:Next) (set Pot (+ (pot) (amount Next)))))))))} (then (if (is In (last To) (sites Bottom)) (promote (last To) (piece "Queen") Mover))))) (piece "Pawn" P3 E (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(= (if (is Mover P1) (if (is Active P2) 2 (if (is Active P3) 3 4)) (if (is Mover P2) (if (is Active P3) 3 (if (is Active P4) 4 1)) (if (is Mover P3) (if (is Active P4) 4 (if (is Active P1) 1 2)) (if (is Active P1) 1 (if (is Active P2) 2 3))))) (who at:(to))) (apply (if (= (if (is Mover P1) (if (is Active P2) 2 (if (is Active P3) 3 4)) (if (is Mover P2) (if (is Active P3) 3 (if (is Active P4) 4 1)) (if (is Mover P3) (if (is Active P4) 4 (if (is Active P1) 1 2)) (if (is Active P1) 1 (if (is Active P2) 2 3))))) (who at:(to))) (and (remove (to)) (and (note player:Next "Pays into the pot" to:Next) (set Pot (+ (pot) (amount Next)))))))))} (then (if (is In (last To) (sites Right)) (promote (last To) (piece "Queen") Mover))))) (piece "Pawn3d" P3 S (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(= (if (is Mover P1) (if (is Active P2) 2 (if (is Active P3) 3 4)) (if (is Mover P2) (if (is Active P3) 3 (if (is Active P4) 4 1)) (if (is Mover P3) (if (is Active P4) 4 (if (is Active P1) 1 2)) (if (is Active P1) 1 (if (is Active P2) 2 3))))) (who at:(to))) (apply (if (= (if (is Mover P1) (if (is Active P2) 2 (if (is Active P3) 3 4)) (if (is Mover P2) (if (is Active P3) 3 (if (is Active P4) 4 1)) (if (is Mover P3) (if (is Active P4) 4 (if (is Active P1) 1 2)) (if (is Active P1) 1 (if (is Active P2) 2 3))))) (who at:(to))) (and (remove (to)) (and (note player:Next "Pays into the pot" to:Next) (set Pot (+ (pot) (amount Next)))))))))} (then (if (is In (last To) (sites Bottom)) (promote (last To) (piece "Queen") Mover))))) (piece "Pawn" P4 E (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(= (if (is Mover P1) (if (is Active P2) 2 (if (is Active P3) 3 4)) (if (is Mover P2) (if (is Active P3) 3 (if (is Active P4) 4 1)) (if (is Mover P3) (if (is Active P4) 4 (if (is Active P1) 1 2)) (if (is Active P1) 1 (if (is Active P2) 2 3))))) (who at:(to))) (apply (if (= (if (is Mover P1) (if (is Active P2) 2 (if (is Active P3) 3 4)) (if (is Mover P2) (if (is Active P3) 3 (if (is Active P4) 4 1)) (if (is Mover P3) (if (is Active P4) 4 (if (is Active P1) 1 2)) (if (is Active P1) 1 (if (is Active P2) 2 3))))) (who at:(to))) (and (remove (to)) (and (note player:Next "Pays into the pot" to:Next) (set Pot (+ (pot) (amount Next)))))))))} (then (if (is In (last To) (sites Right)) (promote (last To) (piece "Queen") Mover))))) (piece "Pawn3d" P4 N (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(= (if (is Mover P1) (if (is Active P2) 2 (if (is Active P3) 3 4)) (if (is Mover P2) (if (is Active P3) 3 (if (is Active P4) 4 1)) (if (is Mover P3) (if (is Active P4) 4 (if (is Active P1) 1 2)) (if (is Active P1) 1 (if (is Active P2) 2 3))))) (who at:(to))) (apply (if (= (if (is Mover P1) (if (is Active P2) 2 (if (is Active P3) 3 4)) (if (is Mover P2) (if (is Active P3) 3 (if (is Active P4) 4 1)) (if (is Mover P3) (if (is Active P4) 4 (if (is Active P1) 1 2)) (if (is Active P1) 1 (if (is Active P2) 2 3))))) (who at:(to))) (and (remove (to)) (and (note player:Next "Pays into the pot" to:Next) (set Pot (+ (pot) (amount Next)))))))))} (then (if (is In (last To) (sites Top)) (promote (last To) (piece "Queen") Mover))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(or (is Empty (to)) (= (if (is Mover P1) (if (is Active P2) 2 (if (is Active P3) 3 4)) (if (is Mover P2) (if (is Active P3) 3 (if (is Active P4) 4 1)) (if (is Mover P3) (if (is Active P4) 4 (if (is Active P1) 1 2)) (if (is Active P1) 1 (if (is Active P2) 2 3))))) (who at:(to)))) (apply (if (= (if (is Mover P1) (if (is Active P2) 2 (if (is Active P3) 3 4)) (if (is Mover P2) (if (is Active P3) 3 (if (is Active P4) 4 1)) (if (is Mover P3) (if (is Active P4) 4 (if (is Active P1) 1 2)) (if (is Active P1) 1 (if (is Active P2) 2 3))))) (who at:(to))) (and (remove (to)) (and (note player:Next "Pays into the pot" to:Next) (set Pot (+ (pot) (amount Next)))))))))) (piece "Rook" Each (move Slide Orthogonal (to if:(= (if (is Mover P1) (if (is Active P2) 2 (if (is Active P3) 3 4)) (if (is Mover P2) (if (is Active P3) 3 (if (is Active P4) 4 1)) (if (is Mover P3) (if (is Active P4) 4 (if (is Active P1) 1 2)) (if (is Active P1) 1 (if (is Active P2) 2 3))))) (who at:(to))) (apply (if (= (if (is Mover P1) (if (is Active P2) 2 (if (is Active P3) 3 4)) (if (is Mover P2) (if (is Active P3) 3 (if (is Active P4) 4 1)) (if (is Mover P3) (if (is Active P4) 4 (if (is Active P1) 1 2)) (if (is Active P1) 1 (if (is Active P2) 2 3))))) (who at:(to))) (and (remove (to)) (and (note player:Next "Pays into the pot" to:Next) (set Pot (+ (pot) (amount Next)))))))))) (piece "Bishop" Each (move Hop Diagonal (between if:True) (to if:(or (is Empty (to)) (= (if (is Mover P1) (if (is Active P2) 2 (if (is Active P3) 3 4)) (if (is Mover P2) (if (is Active P3) 3 (if (is Active P4) 4 1)) (if (is Mover P3) (if (is Active P4) 4 (if (is Active P1) 1 2)) (if (is Active P1) 1 (if (is Active P2) 2 3))))) (who at:(to)))) (apply (if (= (if (is Mover P1) (if (is Active P2) 2 (if (is Active P3) 3 4)) (if (is Mover P2) (if (is Active P3) 3 (if (is Active P4) 4 1)) (if (is Mover P3) (if (is Active P4) 4 (if (is Active P1) 1 2)) (if (is Active P1) 1 (if (is Active P2) 2 3))))) (who at:(to))) (and (remove (to)) (and (note player:Next "Pays into the pot" to:Next) (set Pot (+ (pot) (amount Next)))))))))) (piece "Queen" Each (move Step Diagonal (to if:(or (is Empty (to)) (= (if (is Mover P1) (if (is Active P2) 2 (if (is Active P3) 3 4)) (if (is Mover P2) (if (is Active P3) 3 (if (is Active P4) 4 1)) (if (is Mover P3) (if (is Active P4) 4 (if (is Active P1) 1 2)) (if (is Active P1) 1 (if (is Active P2) 2 3))))) (who at:(to)))) (apply (if (= (if (is Mover P1) (if (is Active P2) 2 (if (is Active P3) 3 4)) (if (is Mover P2) (if (is Active P3) 3 (if (is Active P4) 4 1)) (if (is Mover P3) (if (is Active P4) 4 (if (is Active P1) 1 2)) (if (is Active P1) 1 (if (is Active P2) 2 3))))) (who at:(to))) (and (remove (to)) (and (note player:Next "Pays into the pot" to:Next) (set Pot (+ (pot) (amount Next))))))))))}) (rules (start {(place "King1" coord:"H1") (place "Knight1" coord:"G1") (place "Rook1" coord:"H2") (place "Bishop1" coord:"G2") (place "Pawn1" {"F1" "F2"}) (place "Pawn3d1" {"G3" "H3"}) (place "King2" coord:"H8") (place "Knight2" coord:"G8") (place "Rook2" coord:"H7") (place "Bishop2" coord:"G7") (place "Pawn2" {"F8" "F7"}) (place "Pawn3d2" {"H6" "G6"}) (place "King3" coord:"A8") (place "Knight3" coord:"B8") (place "Rook3" coord:"A7") (place "Bishop3" coord:"B7") (place "Pawn3" {"C7" "C8"}) (place "Pawn3d3" {"A6" "B6"}) (place "King4" coord:"A1") (place "Knight4" coord:"B1") (place "Rook4" coord:"A2") (place "Bishop4" coord:"B2") (place "Pawn4" {"C1" "C2"}) (place "Pawn3d4" {"A3" "B3"})}) phases:{(phase "Betting" (play (move Bet Mover (range 0 100))) (nextPhase Mover)) (phase "Playing" (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King" Mover))) (then (if (is Threatened (id "King" Next)) (if (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next)))))) (forEach Site (sites Occupied by:Next) (and (remove (to)) (and (note player:Next "Pays into the pot" to:Next) (set Pot (+ (pot) (amount Next)))))) (and (note player:Next "Pays into the pot" to:Next) (set Pot (+ (pot) (amount Next))))))))))} (end (if (no Pieces Next) (result Next Loss))))) 
A move in Alice chess has two basic stipulations: the move must be legal on the board on which it is played, and the square transferred to on the opposite board must be vacant. (Consequently, capture is possible only on the board upon which a piece currently stands). The en passant rule is removed.
(game "Alice Chess" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (or {(if (is In (from) (sites Start (piece (what at:(from))))) (move Slide Forward (between (exact 2) if:(or (is Empty (between)) (!= (value Piece at:(from)) (value Piece at:(between))))) (to if:(is Empty (to)) (apply if:(is Empty (to)))))) (move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(and (is Enemy (who at:(to))) (= (value Piece at:(from)) (value Piece at:(to)))) (apply (remove (to)))))} (then (and {(if (is In (last To) (sites Mover "Promotion")) (moveAgain)) (set Counter) (set Value at:(last To) (% (+ (value Piece at:(last To)) 1) 2))})))) (piece "Rook" Each (move Slide Orthogonal (between if:(or (is Empty (between)) (!= (value Piece at:(from)) (value Piece at:(between))))) (to if:(and (is Enemy (who at:(to))) (= (value Piece at:(from)) (value Piece at:(to)))) (apply if:(or (and (is Enemy (who at:(to))) (= (value Piece at:(from)) (value Piece at:(to)))) (is Empty (to))) (if (and (is Enemy (who at:(to))) (= (value Piece at:(from)) (value Piece at:(to)))) (remove (to) (then (set Counter)))))) (then (and (if (= (state at:(last To)) 1) (set State at:(last To) 0)) (set Value at:(last To) (% (+ (value Piece at:(last To)) 1) 2)))))) (piece "King" Each (move Step (to if:(and (not (is Friend (who at:(to)))) (or (is Empty (to)) (= (value Piece at:(from)) (value Piece at:(to))))) (apply if:(or (and (is Enemy (who at:(to))) (= (value Piece at:(from)) (value Piece at:(to)))) (is Empty (to))) (if (and (is Enemy (who at:(to))) (= (value Piece at:(from)) (value Piece at:(to)))) (remove (to) (then (set Counter)))))) (then (and (if (= (state at:(last To)) 1) (set State at:(last To) 0)) (set Value at:(last To) (% (+ (value Piece at:(last To)) 1) 2)))))) (piece "Bishop" Each (move Slide Diagonal (between if:(or (is Empty (between)) (!= (value Piece at:(from)) (value Piece at:(between))))) (to if:(and (is Enemy (who at:(to))) (= (value Piece at:(from)) (value Piece at:(to)))) (apply if:(or (and (is Enemy (who at:(to))) (= (value Piece at:(from)) (value Piece at:(to)))) (is Empty (to))) (if (and (is Enemy (who at:(to))) (= (value Piece at:(from)) (value Piece at:(to)))) (remove (to) (then (set Counter)))))) (then (set Value at:(last To) (% (+ (value Piece at:(last To)) 1) 2))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(and (not (is Friend (who at:(to)))) (or (is Empty (to)) (= (value Piece at:(from)) (value Piece at:(to))))) (apply if:(or (and (is Enemy (who at:(to))) (= (value Piece at:(from)) (value Piece at:(to)))) (is Empty (to))) (if (and (is Enemy (who at:(to))) (= (value Piece at:(from)) (value Piece at:(to)))) (remove (to) (then (set Counter)))))) (then (set Value at:(last To) (% (+ (value Piece at:(last To)) 1) 2))))) (piece "Queen" Each (move Slide (between if:(or (is Empty (between)) (!= (value Piece at:(from)) (value Piece at:(between))))) (to if:(and (is Enemy (who at:(to))) (= (value Piece at:(from)) (value Piece at:(to)))) (apply if:(or (and (is Enemy (who at:(to))) (= (value Piece at:(from)) (value Piece at:(to)))) (is Empty (to))) (if (and (is Enemy (who at:(to))) (= (value Piece at:(from)) (value Piece at:(to)))) (remove (to) (then (set Counter)))))) (then (set Value at:(last To) (% (+ (value Piece at:(last To)) 1) 2))))) (map "King" {(pair 1 "E1") (pair 2 "E8")}) (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")}) (map "RookRight" {(pair 1 "H1") (pair 2 "H8")}) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King1" coord:"E1" state:1) (place "Rook2" {"A8" "H8"} state:1) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King2" coord:"E8" state:1)}) (play (if (is Prev Mover) (do (set Var "promotedValue" (value Piece at:(last To))) next:(move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover (then (set Value at:(last To) (var "promotedValue"))))) (do (or (forEach Piece) (if (and (= (state at:(mapEntry "King" (mover))) 1) (not (is Threatened (id "King" Mover)))) (or (if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (do (set Value at:(mapEntry "RookLeft" (mover)) (% (+ (value Piece at:(mapEntry "RookLeft" (mover))) 1) 2)) next:(slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:(or (is Empty (between)) (!= (value Piece at:(from)) (value Piece at:(between))))) (to if:True (apply (set State at:(from) 0))))))) (do (set Value at:(mapEntry "King" (mover)) (% (+ (value Piece at:(mapEntry "King" (mover))) 1) 2)) next:(move Slide (from (mapEntry "King" (mover))) W (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (do (set Value at:(mapEntry "RookLeft" (mover)) (% (+ (value Piece at:(mapEntry "RookLeft" (mover))) 1) 2)) next:(slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:True) (to if:True (apply (set State at:(from) 0))))))))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (do (set Value at:(mapEntry "RookRight" (mover)) (% (+ (value Piece at:(mapEntry "RookRight" (mover))) 1) 2)) next:(slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:(or (is Empty (between)) (!= (value Piece at:(from)) (value Piece at:(between))))) (to if:True (apply (set State at:(from) 0))))))) (do (set Value at:(mapEntry "King" (mover)) (% (+ (value Piece at:(mapEntry "King" (mover))) 1) 2)) next:(move Slide (from (mapEntry "King" (mover))) E (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (do (set Value at:(mapEntry "RookRight" (mover)) (% (+ (value Piece at:(mapEntry "RookRight" (mover))) 1) 2)) next:(slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:True) (to if:True (apply (set State at:(from) 0)))))))))))) ifAfterwards:(not (is Threatened (id "King" Mover)))))) (end {(if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win)) (if (or (no Moves Mover) (= (counter) 99)) (result Mover Draw))}))) 
The rules are exactly the same as in Chess, except the Queen also has the ability to move as a knight.
(game "Amazon Chess" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (or (if (is In (from) (sites Start (piece (what at:(from))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))) (then (set Pending (ahead (last To) Backward))))) (move Step (directions {FR FL}) (to if:(and (is Pending) (= (to) (value Pending)))) (then (remove (ahead (last To) Backward)))))} (then (and (if (is In (last To) (sites Mover "Promotion")) (moveAgain)) (set Counter))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Queen" Each (or (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter)))))) (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter))))))))) (map "King" {(pair 1 "E1") (pair 2 "E8")}) (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")}) (map "RookRight" {(pair 1 "H1") (pair 2 "H8")}) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King1" coord:"E1" state:1) (place "Rook2" {"A8" "H8"} state:1) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King2" coord:"E8" state:1)}) (play (if (is Prev Mover) (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover) (do (or (forEach Piece) (if (and (= (state at:(mapEntry "King" (mover))) 1) (not (is Threatened (id "King" Mover)))) (or (if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) W (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:True) (to if:True (apply (set State at:(from) 0))))))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) E (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:True) (to if:True (apply (set State at:(from) 0)))))))))) ifAfterwards:(not (is Threatened (id "King" Mover)))))) (end {(if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win)) (if (or (no Moves Mover) (= (counter) 100)) (result Mover Draw))}))) 
In standard chess, the captured piece is removed from the board and the capturing piece takes its place. In atomic chess, a capture causes an "explosion" through which both pieces are removed from the board as well as all non-pawn pieces in the eight squares immediately surrounding the capture. Pawns are removed only when capturing, captured directly, or promoted. In case of en passant, the capture is considered to take place on the sixth rank square where the capturing pawn would have landed. Captures that result in the explosion of a player's own king are illegal, and therefore a king can never capture any other piece. To win, a checkmate or an explosion of the opponent king is necessary.
(game "Atomic Chess" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (or {(if (is In (from) (sites Start (piece (what at:(from))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))) (then (set Pending (ahead (last To) Backward))))) (move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))) (then (and {(remove (last To)) (forEach Site (sites Around (last To) includeSelf:False) (if (and {(is Occupied (site)) (and (not (= (what at:(site)) (id "Pawn" P1))) (not (= (what at:(site)) (id "Pawn" P2))))}) (remove (site))))}))) (move Step (directions {FR FL}) (to if:(and (is Pending) (= (to) (value Pending)))) (then (and {(remove (ahead (last To) Backward)) (remove (last To)) (forEach Site (sites Around (last To) includeSelf:False) (if (and {(is Occupied (site)) (and (not (= (what at:(site)) (id "Pawn" P1))) (not (= (what at:(site)) (id "Pawn" P2))))}) (remove (site))))})))} (then (and (if (is In (last To) (sites Mover "Promotion")) (moveAgain)) (set Counter))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (and {(remove (to)) (forEach Site (sites Around (to) includeSelf:False) (if (and {(is Occupied (site)) (and (not (= (what at:(site)) (id "Pawn" P1))) (not (= (what at:(site)) (id "Pawn" P2))))}) (remove (site)))) (set Counter)})))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "King" Each (move Step (to if:(is Empty (to))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (and {(remove (to)) (forEach Site (sites Around (to) includeSelf:False) (if (and {(is Occupied (site)) (and (not (= (what at:(site)) (id "Pawn" P1))) (not (= (what at:(site)) (id "Pawn" P2))))}) (remove (site)))) (set Counter)})))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (and {(remove (to)) (forEach Site (sites Around (to) includeSelf:False) (if (and {(is Occupied (site)) (and (not (= (what at:(site)) (id "Pawn" P1))) (not (= (what at:(site)) (id "Pawn" P2))))}) (remove (site)))) (set Counter)})))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (and {(remove (to)) (forEach Site (sites Around (to) includeSelf:False) (if (and {(is Occupied (site)) (and (not (= (what at:(site)) (id "Pawn" P1))) (not (= (what at:(site)) (id "Pawn" P2))))}) (remove (site)))) (set Counter)})))))) (map "King" {(pair 1 "E1") (pair 2 "E8")}) (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")}) (map "RookRight" {(pair 1 "H1") (pair 2 "H8")}) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King1" coord:"E1" state:1) (place "Rook2" {"A8" "H8"} state:1) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King2" coord:"E8" state:1)}) (play (if (is Prev Mover) (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover) (do (or (forEach Piece) (if (and (= (state at:(mapEntry "King" (mover))) 1) (not (is Threatened (id "King" Mover)))) (or (if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) W (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:True) (to if:True (apply (set State at:(from) 0))))))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) E (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:True) (to if:True (apply (set State at:(from) 0)))))))))) ifAfterwards:(and (not (is Threatened (id "King" Mover))) (!= (where "King" Mover) -1))))) (end {(if (or (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (= (where "King" Next) -1)) (result Mover Win)) (if (or (no Moves Mover) (= (counter) 99)) (result Mover Draw))}))) 
Beirut chess follows all the rules and conventions of standard chess, with one difference: Before the game begins, each player secretly attaches a red dot to the bottom of one of their pieces (but not the king). This piece is called a bomb carrier. On any turn, instead of moving, a player may say "Boom!" and overturn their bomb carrier. All pieces of either color on squares adjacent to the bomb carrier are removed from the game, as well as the bomb carrier itself. There are two ways to win: Checkmate the opponent. Blow up the enemy king. A captured piece may not be inspected to see whether or not it was a bomb carrier.
(game "Beirut Chess" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (or (if (is In (from) (sites Start (piece (what at:(from))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))) (then (set Pending (ahead (last To) Backward))))) (move Step (directions {FR FL}) (to if:(and (is Pending) (= (to) (value Pending)))) (then (remove (ahead (last To) Backward)))))} (then (and (if (is In (last To) (sites Mover "Promotion")) (moveAgain)) (set Counter))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (map "King" {(pair 1 "E1") (pair 2 "E8")}) (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")}) (map "RookRight" {(pair 1 "H1") (pair 2 "H8")}) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King1" coord:"E1" state:1) (place "Rook2" {"A8" "H8"} state:1) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King2" coord:"E8" state:1)}) phases:{(phase "Bomb" (play (forEach Site (sites Occupied by:Mover) (if (!= (what at:(site)) (id "King" Mover)) (move Select (from (site)) (then (and (set Value at:(last To) 1) (set Hidden Value at:(last To) to:Next))))))) (nextPhase Mover "Play")) (phase "Play" (play (if (is Prev Mover) (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover) (or (do (or (forEach Piece) (if (and (= (state at:(mapEntry "King" (mover))) 1) (not (is Threatened (id "King" Mover)))) (or (if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) W (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:True) (to if:True (apply (set State at:(from) 0))))))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) E (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:True) (to if:True (apply (set State at:(from) 0)))))))))) ifAfterwards:(not (is Threatened (id "King" Mover)))) (move Select (from (sites Occupied by:Mover) if:(= 1 (value Piece at:(from)))) (then (forEach Site (sites Around (last To) includeSelf:True) (if (is Occupied (site)) (remove (site))))))))))} (end {(if (or (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (= (where "King" Next) -1)) (result Mover Win)) (if (= (where "King" Mover) -1) (result Mover Loss)) (if (or (no Moves Mover) (= (counter) 99)) (result Mover Draw))}))) 
Brusky Chess is played on a hexagonal board with sides of length 4, 5, and 9, and each space oriented vertically. It has 84 spaces. Piece Movement: * Queens, Rooks, Bishops, and Knights move as in Glinski Chess. - Queens slide in any of the 12 directions. - Rooks slide in any of the 6 adjacent directions. - Bishops slide in any of the 6 'diagonal' directions. - Knights move two spaces in any adjacent direction, then one space in another direction. * Kings step in any of the 12 direction, and castle either kingside (moving two spaces) or queenside (moving three spaces). Castling can only take place when neither the King nor the Rook being moved have moved before. * Pawns, when moving from a Pawn start space, can advance without capturing to either of the two spaces slightly left of forward, or either of the two spaces slightly right of forward, unless they are 'blocked'. A Pawn on a Pawn start space is 'blocked' if an enemy piece is adjacent to it in either of the forward adjacent directions. Pawns not on a Pawn start space can only advance one space without capturing. Pawns capture in a forward diagonal direction (i.e., to a space one row forward and off to the side, to a space connected by an edge, and having the same colour). A Pawn on a Pawn start space can also capture forwards (i.e., to the space directly ahead, having the same colour). En passant capture and Pawn promotion take place as in Glinski Chess. The game ends on a checkmate or stalemate.
(game "Brusky Chess" (players {(player N) (player S)}) (equipment {(board (remove (hex Rectangle 8 13) cells:{0 1 13 25 75 88 11 12 24 37 62 74 86 87 98 99})) (piece "King" Each (or {(move Step All (to if:(or (is In (to) (sites Empty)) (is Enemy (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0)))) (if (and {(= (what at:(mapEntry "King" (mover))) (id "King" Mover)) (= (state at:(mapEntry "King" (mover))) 1) (not (is Threatened (id "King" Mover)))}) (or {(if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (move Slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:(is In (to) (sites Empty)))))) (move Slide (from (mapEntry "King" (mover))) E (between (exact 2) if:(and (is In (to) (sites Empty)) (not (is Threatened (id "King" Mover) at:(to))))) (then (and (set State at:(last To) 0) (move Slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:True)))))) (if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (move Slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:(is In (to) (sites Empty)))))) (move Slide (from (mapEntry "King" (mover))) W (between (exact 3) if:(and (is In (to) (sites Empty)) (not (is Threatened (id "King" Mover) at:(to))))) (then (and (set State at:(last To) 0) (move Slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:True))))))}))})) (piece "Queen" Each (move Slide All (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Pawn" Each (or {(move Step (if (is Mover P1) (directions {WNW ENE}) (directions {WSW ESE})) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (if (if (is Mover P1) (and (is In (ahead (from) steps:1 NNW) (sites Empty)) (is In (ahead (from) steps:1 NNE) (sites Empty))) (and (is In (ahead (from) steps:1 SSW) (sites Empty)) (is In (ahead (from) steps:1 SSE) (sites Empty)))) (move Step (if (is Mover P1) (directions {NNW NNE}) (directions {SSW SSE})) (to if:(is In (to) (sites Empty))))) (if (is In (from) (sites Start (piece (what at:(from))))) (or (move Step (if (is Mover P1) (directions {N}) (directions {S})) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (if (if (is Mover P1) (and (is In (ahead (from) steps:1 NNW) (sites Empty)) (is In (ahead (from) steps:1 NNE) (sites Empty))) (and (is In (ahead (from) steps:1 SSW) (sites Empty)) (is In (ahead (from) steps:1 SSE) (sites Empty)))) (if (is Mover P1) (or (move Hop NNW (between if:(is In (between) (sites Empty))) (to if:(is In (to) (sites Empty))) (then (and {(set Pending (ahead (last To) SSE)) (set Var (last To))}))) (move Hop NNE (between if:(is In (between) (sites Empty))) (to if:(is In (to) (sites Empty))) (then (and {(set Pending (ahead (last To) SSW)) (set Var (last To))})))) (or (move Hop SSW (between if:(is In (between) (sites Empty))) (to if:(is In (to) (sites Empty))) (then (and {(set Pending (ahead (last To) NNE)) (set Var (last To))}))) (move Hop SSE (between if:(is In (between) (sites Empty))) (to if:(is In (to) (sites Empty))) (then (and {(set Pending (ahead (last To) NNW)) (set Var (last To))}))))))) (move Step (if (is Mover P1) (directions {WNW ENE}) (directions {WSW ESE})) (to if:(and (is Pending) (= (to) (value Pending)))) (then (remove (var)))))} (then (and (if (is In (last To) (sites Mover "PromotionZone")) (moveAgain)) (set Counter))))) (map "King" {(pair 1 "F1") (pair 2 "I8")}) (map "RookLeft" {(pair 1 "A1") (pair 2 "D8")}) (map "RookRight" {(pair 1 "I1") (pair 2 "L8")}) (regions "PromotionZone" P1 (sites Top)) (regions "PromotionZone" P2 (sites Bottom)) (regions "Region-Dark" (sites Phase 2)) (regions "Region-Light" (sites Phase 1)) (regions "Region-Medium" (sites Phase 0))}) (rules (start {(place "King1" coord:"F1" state:1) (place "Queen1" coord:"D1") (place "Rook1" {"A1" "I1"} state:1) (place "Bishop1" {"C1" "G1" "E1"}) (place "Knight1" {"B1" "H1"}) (place "King2" coord:"I8" state:1) (place "Queen2" coord:"G8") (place "Rook2" {"D8" "L8"} state:1) (place "Bishop2" {"F8" "H8" "J8"}) (place "Knight2" {"E8" "K8"}) (place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6))}) phases:{(phase "Movement" (play (if (is Prev Mover) (move Promote (last To) (piece {"Queen" "Rook" "Bishop" "Knight"}) Mover) (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King" Mover)))))) (end {(if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win)) (if (or (no Moves Mover) (= (counter) 100)) (result Mover Draw))}))})) 
Played on an 8x8 board with pieces with specialized moves: Pawns (8): can move one space forward; Rooks (2): can move any number of spaces orthogonally; Bishops (2): can move any number of spaces diagonally; Knight (2): moves in any direction, one space orthogonally with one space forward diagonally; Queens (1): can move any number of spaces orthogonally or diagonally; Kings (1): can move one space orthogonally or diagonally. Players capture pieces by moving onto a space occupied by an opponent's piece. Player wins when they checkmate the other player's king.
(game "Chess" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (or (if (is In (from) (sites Start (piece (what at:(from))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))) (then (set Pending (ahead (last To) Backward))))) (move Step (directions {FR FL}) (to if:(and (is Pending) (= (to) (value Pending)))) (then (remove (ahead (last To) Backward)))))} (then (and (if (is In (last To) (sites Mover "Promotion")) (moveAgain)) (set Counter))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (map "King" {(pair 1 "E1") (pair 2 "E8")}) (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")}) (map "RookRight" {(pair 1 "H1") (pair 2 "H8")}) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King1" coord:"E1" state:1) (place "Rook2" {"A8" "H8"} state:1) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King2" coord:"E8" state:1)}) (play (if (is Prev Mover) (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover) (do (or (forEach Piece) (if (and (= (state at:(mapEntry "King" (mover))) 1) (not (is Threatened (id "King" Mover)))) (or (if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) W (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:True) (to if:True (apply (set State at:(from) 0))))))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) E (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:True) (to if:True (apply (set State at:(from) 0)))))))))) ifAfterwards:(not (is Threatened (id "King" Mover)))))) (end {(if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win)) (if (or (no Moves Mover) (= (counter) 99)) (result Mover Draw))}))) 
In Chessence, kings do not move and must remain fixed on their starting squares the entire game. (Thus, a king is unable to move out of check.) A man has capability to move based on its relative position to other friendly men on the board, as follows: - If a man is orthogonally adjacent to a friendly man, then both have the ability to move as a rook in chess. - If a man is diagonally adjacent to a friendly man, then both have the ability to move as a chess bishop. - If a man is a knight's move away from a friendly man, then both have the ability to move as a knight. A man with more than one position relationship has the ability to move in more than one way. Likewise, if a man has no position relationship defined above, that man cannot move. The king has no bearing on how the other men may move. A man may not move to, nor through, a non-existent (blackened-out) square; except that a man moving as a knight may jump over a non-existent square. For a turn, a player may move a man on the board, or alternatively, they may put one of their reserve men in play by placing it on any of their six initial starting squares that are currently open. Checks, checkmate, and captures are as in standard chess. If a player has no legal moves, they lose the game.
(game "Chessence" (players 2) (equipment {(board (rectangle 9 6)) (piece "Pawn" Each (or {(if (not (all Sites (sites Around (from) Orthogonal) if:(not (= (what at:(site)) (id "Pawn" Mover))))) (move Slide Orthogonal (between if:(and (is Empty (between)) (not (is In (between) (sites "BlackenedSquares"))))) (to if:(is Enemy (who at:(to))) (apply if:(not (is In (to) (sites "BlackenedSquares"))) (if (is Enemy (who at:(to))) (remove (to))))))) (if (not (all Sites (sites Around (from) Diagonal) if:(not (= (what at:(site)) (id "Pawn" Mover))))) (move Slide Diagonal (between if:(and (is Empty (between)) (not (is In (between) (sites "BlackenedSquares"))))) (to if:(is Enemy (who at:(to))) (apply if:(not (is In (to) (sites "BlackenedSquares"))) (if (is Enemy (who at:(to))) (remove (to))))))) (if (not (all Sites (forEach (sites Around (sites To (hop Orthogonal (between if:True) (to if:True))) Orthogonal) if:(= 2 (count Steps (from) (site)))) if:(!= (what at:(site)) (id "Pawn" Mover)))) (move Leap {{F F R F} {F F L F}} (to if:(and (not (is Friend (who at:(to)))) (not (is In (to) (sites "BlackenedSquares")))) (apply if:(not (is In (to) (sites "BlackenedSquares"))) (if (is Enemy (who at:(to))) (remove (to)))))))})) (piece "King" Each) (hand Each) (regions "BlackenedSquares" (sites {"A2" "B3" "B5" "C6" "D4" "E5" "E7" "F8"})) (regions "PawnStart" P1 (sites {"E1" "E2" "F2" "D2" "D3" "E3"})) (regions "PawnStart" P2 (sites {"B9" "B8" "A8" "C8" "C7" "B7"}))}) (rules (start {(place "Pawn" "Hand" count:3) (place "Pawn1" (sites P1 "PawnStart")) (place "Pawn2" (sites P2 "PawnStart")) (place "King1" coord:"F1") (place "King2" coord:"A9")}) (play (or (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King" Mover)))) (if (is Occupied (handSite Mover)) (move (from (sites Hand)) (to (sites Mover "PawnStart") if:(is Empty (to))))))) (end {(if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win)) (if (no Moves Mover) (result Mover Loss))}))) 
The 32 pieces in Chex represent the 16 chess pieces on each side of a normal chess game. Each player shuffles his own 16 tiles and places them face down, then white draws his top tile and places it, with the piece oriented so it looks upright to him. Black then draws the top tile in his pile and places it so that it touches white's piece, either orthogonally or diagonally, and oriented so that it looks upright to him. At that point, white can either add another piece or move his piece on the board. A move must be a legal chess move and may not separate any element of the board; all pieces much remain touching, even if just diagonally, when a move has ended. Thus you can "pin" a piece by placing a new piece on the far corner of a piece already in play. The game ends in checkmate or stalemate, with a stalemate occurring when you must place your king into check when you draw it.
(game "Chex" (players {(player N) (player S)}) (equipment {(boardless Square) (hand Each) (tile "Pawn" Each numSides:4 (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))})) (tile "Rook" Each numSides:4 (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (tile "King" Each numSides:4 (move Step (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (tile "Bishop" Each numSides:4 (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (tile "Knight" Each numSides:4 (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (tile "Queen" Each numSides:4 (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to))))))}) (rules (start {(place Random {(count "Pawn1" 8) (count "Rook1" 2) (count "Knight1" 2) (count "Bishop1" 2) (count "Queen1" 1) (count "King1" 1)} (handSite 1)) (place Random {(count "Pawn2" 8) (count "Rook2" 2) (count "Knight2" 2) (count "Bishop2" 2) (count "Queen2" 1) (count "King2" 1)} (handSite 2)) (forEach Value min:0 max:(topLevel at:(handSite 1)) (set Hidden What at:(handSite 1) level:(value) to:P1)) (forEach Value min:0 max:(topLevel at:(handSite 1)) (set Hidden What at:(handSite 1) level:(value) to:P2)) (forEach Value min:0 max:(topLevel at:(handSite 2)) (set Hidden What at:(handSite 2) level:(value) to:P1)) (forEach Value min:0 max:(topLevel at:(handSite 2)) (set Hidden What at:(handSite 2) level:(value) to:P2))}) (play (if (is Prev Mover) (if (= (count Moves) 1) (move (from (handSite (mover))) (to (centrePoint))) (do (move (from (handSite (mover))) (to (sites Around (union (sites Occupied by:P1 container:"Board") (sites Occupied by:P2 container:"Board")) Empty))) ifAfterwards:(not (is Threatened (id "King" Mover))))) (or (if (is Occupied (handSite (mover))) (move Select (from (handSite (mover))) (then (and {(moveAgain) (set Hidden What at:(last To) level:(topLevel at:(last To)) False to:P1) (set Hidden What at:(last To) level:(topLevel at:(last To)) False to:P2)})))) (do (forEach Piece) ifAfterwards:(and (= 1 (count Groups)) (not (is Threatened (id "King" Mover)))))))) (end {(if (and {(not (can Move (if (!= (what at:(handSite (mover))) 0) (move Select (from (handSite (mover))))))) (!= (where "King" Next) -1) (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(and (= 1 (count Groups)) (not (is Threatened (id "King" Next)))))))}) (result Mover Win)) (if (and {(is Prev Mover) (is Threatened (id "King" Mover)) (not (can Move (do (move (from (handSite (mover))) (to (sites Around (union (sites Occupied by:P1 container:"Board") (sites Occupied by:P2 container:"Board")) Empty))) ifAfterwards:(not (is Threatened (id "King" Mover))))))}) (result Next Win)) (if (no Moves Mover) (result Mover Draw))}))) 
8x12 board. Each player begins with a complement of pieces, each with their own powers of movement as follows: King (x1): may move one space in any direction; Queen (x1): moves one space diagonally, may leap two spaces diagonally on its first move over any intervening pieces; Man (x1): moves one space in any direction; Fool (x1): moves orthogonally one space; Courier (x2): moves diagonally any distance; Bishop (x2): moves diagonally two spaces, jumping over any intervening pieces; Knight (x2): moves orthogonally one space and then diagonally another space, jumping over any intervening pieces; Rook (x2): moves orthogonally any distance; Pawns (x12): move forward one space or diagonally forward one space to capture. Only the Rooks' and Queens' pawns may move forward two spaces for their first move. Each player must move the Rooks' Pawns and Queens' Pawn in this way in their first three moves. A piece is captured when an opponent's piece moves onto its space. The King is in check when it can be taken on the opponent's next turn; it must not remain in check at the end of the player's turn. When the king cannot move out of check, it is checkmated and the opponent wins.
(game "Currierspiel" (players {(player N) (player S)}) (equipment {(board (rectangle 8 12)) (regions "StartingPawnRookQueen" P1 (sites {"A2" "G2" "L2"})) (regions "StartingPawnRookQueen" P2 (sites {"A7" "G7" "L7"})) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Queen" Each (or (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))) (if (= 1 (state at:(from))) (move Hop (between if:True) (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))) (then (set State at:(last To) 0))))) (piece "Mann" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Fool" Each (move Step Orthogonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (piece "Ferz" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Bishop" Each (move Hop (between if:True) (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))}))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "L1"}) (place "Knight1" {"B1" "K1"}) (place "Ferz1" {"C1" "J1"}) (place "Bishop1" {"D1" "I1"}) (place "Queen1" coord:"G1" state:1) (place "Fool1" coord:"H1") (place "Mann1" coord:"E1") (place "King1" coord:"F1") (place "Rook2" {"A8" "L8"}) (place "Knight2" {"B8" "K8"}) (place "Ferz2" {"C8" "J8"}) (place "Bishop2" {"D8" "I8"}) (place "Queen2" coord:"G8" state:1) (place "Fool2" coord:"H8") (place "Mann2" coord:"E8") (place "King2" coord:"F8")}) phases:{(phase "Opening" (play (forEach Site (intersection (sites Occupied by:Mover) (sites Mover)) (move (from (site)) (to (ahead (site) steps:2 Forward))))) (nextPhase Mover (= 0 (count Sites in:(intersection (sites Occupied by:Mover) (sites Mover)))) "Playing")) (phase "Playing" (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King" Mover))))))} (end (if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win))))) 
De Vasa Chess is most commonly played on a 9x9 rhombus-shaped board with 81 spaces. It is sometimes played on the original layout, involving a 9x8 rhombus-shaped board with only 72 spaces. Piece Movement: * All pieces other than Kings and Pawns move as in Glinski Chess. - Queens slide in any of the 12 directions. - Rooks slide in any of the 6 adjacent directions. - Bishops slide in any of the 6 'diagonal' directions. - Knights move two spaces in any adjacent direction, then one space in another direction. * Kings step one space in any of the 12 directions, and can castle either kingside (moving two spaces) or queenside (moving three spaces). Castling can only take place when neither the King nor the Rook being moved have moved before. * Pawns advance without capturing to an adjacent space slightly left or right of forward. On their first move, they can move two spaces in either of these directions without capturing. They capture 'diagonally forward' (i.e., to a space ahead connected by an edge, and having the same colour). En passant capture and Pawn promotion take place as in Glinski Chess. The game ends on a checkmate or stalemate. 9x9 rhombus-shaped board, with pieces on rows 1, 3, 7, and 9
(game "De Vasa Chess" (players {(player NNE) (player SSW)}) (equipment {(board (hex Diamond 9)) (piece "King" Each (or {(move Step All (to if:(or (is In (to) (sites Empty)) (is Enemy (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0)))) (if (and {(= (what at:(mapEntry "King" (mover))) (id "King" Mover)) (= (state at:(mapEntry "King" (mover))) 1) (not (is Threatened (id "King" Mover)))}) (or {(if (is Mover P1) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (move Slide (from (mapEntry "RookRight" (mover))) WNW (between (exact 2) if:(is In (to) (sites Empty)))))) (move Slide (from (mapEntry "King" (mover))) ESE (between (exact 2) if:(and (is In (to) (sites Empty)) (not (is Threatened (id "King" Mover) at:(to))))) (then (and (set State at:(last To) 0) (move Slide (from (mapEntry "RookRight" (mover))) WNW (between (exact 2) if:True)))))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (move Slide (from (mapEntry "RookRight" (mover))) WNW (between (exact 2) if:(is In (to) (sites Empty)))))) (move Slide (from (mapEntry "King" (mover))) ESE (between (exact 2) if:(and (is In (to) (sites Empty)) (not (is Threatened (id "King" Mover) at:(to))))) (then (and (set State at:(last To) 0) (move Slide (from (mapEntry "RookRight" (mover))) WNW (between (exact 2) if:True))))))) (if (is Mover P1) (if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (move Slide (from (mapEntry "RookLeft" (mover))) ESE (between (exact 3) if:(is In (to) (sites Empty)))))) (move Slide (from (mapEntry "King" (mover))) WNW (between (exact 3) if:(and (is In (to) (sites Empty)) (not (is Threatened (id "King" Mover) at:(to))))) (then (and (set State at:(last To) 0) (move Slide (from (mapEntry "RookLeft" (mover))) ESE (between (exact 3) if:True)))))) (if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (move Slide (from (mapEntry "RookLeft" (mover))) ESE (between (exact 3) if:(is In (to) (sites Empty)))))) (move Slide (from (mapEntry "King" (mover))) WNW (between (exact 3) if:(and (is In (to) (sites Empty)) (not (is Threatened (id "King" Mover) at:(to))))) (then (and (set State at:(last To) 0) (move Slide (from (mapEntry "RookLeft" (mover))) ESE (between (exact 3) if:True)))))))}))})) (piece "Queen" Each (move Slide All (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Pawn" Each (or {(move Step (if (is Mover P1) (directions {N ENE}) (directions {S WSW})) (to if:(is Empty (to)))) (if (is In (from) (sites Start (piece (what at:(from))))) (if (is Mover P1) (or (move Hop N (between if:(is In (between) (sites Empty))) (to if:(is In (to) (sites Empty))) (then (and {(set Pending (ahead (last To) S)) (set Var (last To))}))) (move Hop ENE (between if:(is In (between) (sites Empty))) (to if:(is In (to) (sites Empty))) (then (and {(set Pending (ahead (last To) WSW)) (set Var (last To))})))) (or (move Hop S (between if:(is In (between) (sites Empty))) (to if:(is In (to) (sites Empty))) (then (and {(set Pending (ahead (last To) N)) (set Var (last To))}))) (move Hop WSW (between if:(is In (between) (sites Empty))) (to if:(is In (to) (sites Empty))) (then (and {(set Pending (ahead (last To) ENE)) (set Var (last To))})))))) (move Step (if (is Mover P1) (directions {NNW E}) (directions {SSE W})) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Step (if (is Mover P1) (directions {NNW E}) (directions {SSE W})) (to if:(and (is Pending) (= (to) (value Pending)))) (then (remove (var))))} (then (and (if (is In (last To) (sites Mover "PromotionZone")) (moveAgain)) (set Counter))))) (map "King" {(pair 1 "A4") (pair 2 "I4")}) (map "RookLeft" {(pair 1 "A9") (pair 2 "I9")}) (map "RookRight" {(pair 1 "A1") (pair 2 "I1")}) (regions "Region-Dark" (sites Phase 0)) (regions "Region-Light" (sites Phase 1)) (regions "Region-Medium" (sites Phase 2)) (regions "PromotionZone" P1 (sites Side NE)) (regions "PromotionZone" P2 (sites Side SW))}) (rules (start {(place "King1" coord:"A4" state:1) (place "Queen1" coord:"A6") (place "Rook1" {"A9" "A1"} state:1) (place "Bishop1" {"A3" "A5" "A7"}) (place "Knight1" {"A8" "A2"}) (place "King2" coord:"I4" state:1) (place "Queen2" coord:"I6") (place "Rook2" {"I9" "I1"} state:1) (place "Bishop2" {"I7" "I5" "I3"}) (place "Knight2" {"I8" "I2"}) (place "Pawn1" {"C9" "C8" "C7" "C6" "C5" "C4" "C3" "C2" "C1"}) (place "Pawn2" {"G1" "G2" "G3" "G4" "G5" "G6" "G7" "G8" "G9"})}) phases:{(phase "Movement" (play (if (is Prev Mover) (move Promote (last To) (piece {"Queen" "Rook" "Bishop" "Knight"}) Mover) (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King" Mover)))))) (end {(if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win)) (if (or (no Moves Mover) (= (counter) 100)) (result Mover Draw))}))})) 
This game is a variant of classic Chess, which adds a random factor to the strategy. The following list describes all differences of the rules: There is no check or checkmate, it is allowed to move the king to a square attacked by opponent's piece. The goal is to capture opponent's king. A die is rolled for every move. The number determines which piece can be used to make the move. 1 - pawn, 2 - knight, 3 - bishop, 4 - rook, 5 - queen, 6 - king. If a pawn is to be promoted (would advance to the last row), the player can move it even if the die does not show 1. However, he can only promote it to the piece chosen by the die roll - for example, if 3 is rolled, the pawn can be promoted to a bishop only. If 1 is rolled, the pawn can be promoted to any piece. The game is played on a 8x8 board.
(game "Dice Chess" (players {(player N) (player S)}) (equipment {(board (square 8)) (dice d:6 from:1 num:1) (piece "Pawn" Each (or {(if (is In (from) (sites Start (piece (what at:(from))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))))) (move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (moveAgain))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "King_noCross" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" {"A2" "B2" "C2" "D2" "E2" "F2" "G2" "H2"}) (place "Pawn2" {"H7" "G7" "E7" "F7" "D7" "C7" "B7" "A7"}) (place "Bishop1" {"C1" "F1"}) (place "Bishop2" {"C8" "F8"}) (place "Knight1" {"B1" "G1"}) (place "Knight2" {"G8" "B8"}) (place "Rook1" {"A1" "H1"}) (place "Rook2" {"H8" "A8"}) (place "Queen1" coord:"D1") (place "Queen2" coord:"D8") (place "King_noCross1" coord:"E1") (place "King_noCross2" coord:"E8")}) (play (do (if (not (is Prev Mover)) (roll)) next:(if (is Prev Mover) (if (= (count Pips) 1) (or {(move Promote (last To) (piece "Bishop") Mover) (move Promote (last To) (piece "Knight") Mover) (move Promote (last To) (piece "Rook") Mover) (move Promote (last To) (piece "Queen") Mover) (move Promote (last To) (piece "King_noCross") Mover)}) (if (= (count Pips) 2) (move Promote (last To) (piece "Knight") Mover) (if (= (count Pips) 3) (move Promote (last To) (piece "Bishop") Mover) (if (= (count Pips) 4) (move Promote (last To) (piece "Rook") Mover) (if (= (count Pips) 5) (move Promote (last To) (piece "Queen") Mover) (move Promote (last To) (piece "King_noCross") Mover)))))) (or (forEach Die (if (= (pips) 6) (forEach Piece "King_noCross") (if (= (pips) 5) (forEach Piece "Queen") (if (= (pips) 4) (forEach Piece "Rook") (if (= (pips) 2) (forEach Piece "Knight") (if (= (pips) 3) (forEach Piece "Bishop") (if (= (pips) 1) (forEach Piece "Pawn")))))))) (forEach Site (sites Direction from:(sites Mover) (if (is Mover P1) S N) distance:1) (if (= (what at:(site)) (id "Pawn" Mover)) (or (if (can Move (move Step (from (site)) (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (move Step (from (site)) (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (if (can Move (move Step (from (site)) Forward (to if:(is Empty (to))))) (move Step (from (site)) Forward (to if:(is Empty (to))))) (then (if (is In (last To) (sites Mover "Promotion")) (moveAgain)))))))))) (end (if (no Pieces Next "King_noCross") (result Next Loss))))) 
Rules are the same as Chess except pawns may move up to four squares on their first move and kings may only castle on their own half of the board. The player that checkmates one of the opposing kings wins.
(game "Double Chess" (players {(player N) (player S)}) (equipment {(board (rectangle 12 16)) (piece "Pawn" Each (or {(if (is In (from) (sites Start (piece (what at:(from))))) (forEach Value min:2 max:4 (move Slide Forward (between (exact (value)) if:(is Empty (between)) (apply (set Pending (between)))) (to if:(is Empty (to))) (then (set Var (last To)))))) (move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Step (directions {FR FL}) (to if:(is In (to) (sites Pending))) (then (remove (var))))} (then (and (if (is In (last To) (sites Mover "Promotion")) (moveAgain)) (set Counter))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (map "KingLeft" {(pair 1 "E1") (pair 2 "E12")}) (map "RookLeftLeft" {(pair 1 "A1") (pair 2 "A12")}) (map "RookLeftRight" {(pair 1 "H1") (pair 2 "H12")}) (map "KingRight" {(pair 1 "M1") (pair 2 "M12")}) (map "RookRightLeft" {(pair 1 "I1") (pair 2 "I12")}) (map "RookRightRight" {(pair 1 "P1") (pair 2 "P12")}) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 10)) (place "Rook1" {"A1" "H1" "I1" "P1"} state:1) (place "Knight1" {"B1" "G1" "J1" "O1"}) (place "Bishop1" {"C1" "F1" "K1" "N1"}) (place "Queen1" {"D1" "L1"}) (place "King1" {"E1" "M1"} state:1) (place "Rook2" {"A12" "H12" "I12" "P12"} state:1) (place "Knight2" {"B12" "G12" "J12" "O12"}) (place "Bishop2" {"C12" "F12" "K12" "N12"}) (place "Queen2" {"D12" "L12"}) (place "King2" {"E12" "M12"} state:1)}) (play (if (is Prev Mover) (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover) (or (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King" Mover) in:(sites Occupied by:Mover component:"King")))) (or (if (and {(= (what at:(mapEntry "KingLeft" (mover))) (id "King" Mover)) (= (state at:(mapEntry "KingLeft" (mover))) 1) (not (is Threatened (id "King" Mover) at:(mapEntry "KingLeft" (mover))))}) (or (if (and (= (state at:(mapEntry "RookLeftLeft" (mover))) 1) (can Move (move Slide (from (mapEntry "RookLeftLeft" (mover))) E (between (exact 3) if:(is Empty (to)))))) (move Slide (from (mapEntry "KingLeft" (mover))) W (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (then (and (set State at:(last To) 0) (move Slide (from (mapEntry "RookLeftLeft" (mover))) E (between (exact 3) if:True)))))) (if (and (= (state at:(mapEntry "RookLeftRight" (mover))) 1) (can Move (move Slide (from (mapEntry "RookLeftRight" (mover))) W (between (exact 2) if:(is Empty (to)))))) (move Slide (from (mapEntry "KingLeft" (mover))) E (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (then (and (set State at:(last To) 0) (move Slide (from (mapEntry "RookLeftRight" (mover))) W (between (exact 2) if:True)))))))) (if (and {(= (what at:(mapEntry "KingRight" (mover))) (id "King" Mover)) (= (state at:(mapEntry "KingRight" (mover))) 1) (not (is Threatened (id "King" Mover) at:(mapEntry "KingRight" (mover))))}) (or (if (and (= (state at:(mapEntry "RookRightLeft" (mover))) 1) (can Move (move Slide (from (mapEntry "RookRightLeft" (mover))) E (between (exact 3) if:(is Empty (to)))))) (move Slide (from (mapEntry "KingRight" (mover))) W (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (then (and (set State at:(last To) 0) (move Slide (from (mapEntry "RookRightRight" (mover))) E (between (exact 3) if:True)))))) (if (and (= (state at:(mapEntry "RookRightRight" (mover))) 1) (can Move (move Slide (from (mapEntry "RookRightRight" (mover))) W (between (exact 2) if:(is Empty (to)))))) (move Slide (from (mapEntry "KingRight" (mover))) E (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (then (and (set State at:(last To) 0) (move Slide (from (mapEntry "RookRightRight" (mover))) W (between (exact 2) if:True)))))))))))) (end {(if (or (no Moves Mover) (= (counter) 100)) (result Mover Draw)) (if (and (is Threatened (id "King" Next) in:(sites Occupied by:Next component:"King")) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next) in:(sites Occupied by:Next component:"King"))))))) (result Mover Win))}))) 
Same rules as Chess. Dragons move like queens, but at most three squares.
(game "Dragonchess" (players {(player N) (player S)}) (equipment {(board (merge (square 10) (shift -3 3 (rectangle 4 16)))) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (or (if (is In (from) (sites Start (piece (what at:(from))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))) (then (set Pending (ahead (last To) Backward))))) (move Step (directions {FR FL}) (to if:(and (is Pending) (= (to) (value Pending)))) (then (remove (ahead (last To) Backward)))))} (then (and (if (is In (last To) (sites Mover "Promotion")) (moveAgain)) (set Counter))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (piece "Dragon" Each (move Slide (between (max 3) if:(is Empty (between))) (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (map "King" {(pair 1 "I1") (pair 2 "H10")}) (map "RookLeft" {(pair 1 "E1") (pair 2 "L10")}) (map "RookRight" {(pair 1 "L1") (pair 2 "E10")}) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 8)) (place "Dragon1" {"D1" "M1"}) (place "Rook1" {"E1" "L1"} state:1) (place "Knight1" {"F1" "K1"}) (place "Bishop1" {"G1" "J1"}) (place "Queen1" coord:"H1") (place "King1" coord:"I1" state:1) (place "Dragon2" {"D10" "M10"}) (place "Rook2" {"E10" "L10"} state:1) (place "Knight2" {"F10" "K10"}) (place "Bishop2" {"G10" "J10"}) (place "Queen2" coord:"I10") (place "King2" coord:"H10" state:1)}) (play (if (is Prev Mover) (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook" "Dragon"}) Mover) (do (or (forEach Piece) (if (and (= (state at:(mapEntry "King" (mover))) 1) (not (is Threatened (id "King" Mover)))) (or (if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) W (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:True) (to if:True (apply (set State at:(from) 0))))))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) E (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:True) (to if:True (apply (set State at:(from) 0)))))))))) ifAfterwards:(not (is Threatened (id "King" Mover)))))) (end {(if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win)) (if (or (no Moves Mover) (= (counter) 99)) (result Mover Draw))}))) 
Before the game, a starting position is randomly determined and set up, subject to certain requirements. White's pieces (not pawns) are placed randomly on the first rank, following two rules: The bishops must be placed on opposite-color squares. The king must be placed on a square between the rooks. Black's pieces are placed equal-and-opposite to White's pieces. (For example, if the white king is randomly determined to start on f1, then the black king is placed on f8.) Pawns are placed on the players' second ranks as in classical chess. After setup, the game is played the same as classical chess in all respects.
(game "Fischer Random Chess" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (or (if (is In (from) (sites Start (piece (what at:(from))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))) (then (set Pending (ahead (last To) Backward))))) (move Step (directions {FR FL}) (to if:(and (is Pending) (= (to) (value Pending)))) (then (remove (ahead (last To) Backward)))))} (then (and (if (is In (last To) (sites Mover "Promotion")) (moveAgain)) (set Counter))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Rook1" (sites Random (difference (sites Bottom) (expand (sites Right)))) state:1) (place "King1" (sites Random (difference (intersection {(sites Bottom) (expand (sites Occupied by:Mover) steps:8 E) (sites Empty)}) (sites Right))) state:1) (place "Rook1" (sites Random (intersection {(sites Bottom) (expand (sites Occupied by:Mover component:"King") steps:8 E) (sites Empty)})) state:1) (place "Bishop1" (sites Random (intersection {(sites Bottom) (sites Empty) (sites Phase 0)}))) (place "Bishop1" (sites Random (intersection {(sites Bottom) (sites Empty) (sites Phase 1)}))) (place "Knight1" (sites Random (intersection (sites Bottom) (sites Empty)) num:2)) (place "Queen1" (sites Random (intersection (sites Bottom) (sites Empty)))) (place "Pawn1" (sites Row 1)) (place "Rook2" (forEach (sites Top) if:(= (id "Rook1") (what at:(ahead (site) steps:7 S)))) state:1) (place "Bishop2" (forEach (sites Top) if:(= (id "Bishop1") (what at:(ahead (site) steps:7 S))))) (place "Knight2" (forEach (sites Top) if:(= (id "Knight1") (what at:(ahead (site) steps:7 S))))) (place "Queen2" (forEach (sites Top) if:(= (id "Queen1") (what at:(ahead (site) steps:7 S))))) (place "King2" (forEach (sites Top) if:(= (id "King1") (what at:(ahead (site) steps:7 S)))) state:1) (place "Pawn2" (sites Row 6))}) (play (if (is Prev Mover) (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover) (do (or (forEach Piece) (if (and (= (state at:(where "King" Mover)) 1) (not (is Threatened (id "King" Mover)))) (if (is Mover P1) (forEach Site (sites Occupied by:Mover component:"Rook") (if (= (state at:(site)) 1) (if (< (column of:(site)) (column of:(where "King" Mover))) (if (or (can Move (slide (from (site)) (if (< (column of:(site)) (column of:(coord "D1"))) E W) (between (exact (count Steps (coord "D1") (site))) if:(or (is Empty (to)) (= (what at:(to)) (id "King" Mover)))) (to if:True (apply if:(or (= (what at:(to)) (id "King" Mover)) (is Empty (to))) (set State at:(from) 0))))) (= (site) (coord "D1"))) (if (= (where "King" Mover) (coord "C1")) (do (set Var "RookToMove" (site)) next:(move Select (from (where "King" Mover)))) (move Slide (from (where "King" Mover)) (if (< (column of:(where "King" Mover)) (column of:(coord "C1"))) E W) (between (exact (count Steps (coord "C1") (where "King" Mover))) if:(and (or (is Empty (to)) (= (to) (site))) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply if:(or (= (to) (site)) (is Empty (to))) (and (set State at:(from) 0) (set Var "RookToMove" (site)))))) (then (if (= (what at:(var "RookToMove")) (id "Rook" Mover)) (slide (from (var "RookToMove")) (if (< (column of:(var "RookToMove")) (column of:(coord "D1"))) E W) (between (exact (count Steps (coord "D1") (var "RookToMove"))) if:(or (is Empty (to)) (= (what at:(to)) (id "King" Mover)))) (to if:True (apply if:(or (= (what at:(to)) (id "King" Mover)) (is Empty (to))) (set State at:(from) 0)))) (add (piece (id "Rook" Mover)) (to (coord "D1"))))))) (if (or (can Move (slide (from (site)) (if (< (column of:(site)) (column of:(coord "F1"))) E W) (between (exact (count Steps (coord "F1") (site))) if:(or (is Empty (to)) (= (what at:(to)) (id "King" Mover)))) (to if:True (apply if:(or (= (what at:(to)) (id "King" Mover)) (is Empty (to))) (set State at:(from) 0))))) (= (site) (coord "F1"))) (if (= (where "King" Mover) (coord "G1")) (do (set Var "RookToMove" (site)) next:(move Select (from (where "King" Mover)))) (move Slide (from (where "King" Mover)) (if (< (column of:(where "King" Mover)) (column of:(coord "G1"))) E W) (between (exact (count Steps (coord "G1") (where "King" Mover))) if:(and (or (is Empty (to)) (= (to) (site))) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply if:(or (= (to) (site)) (is Empty (to))) (and (set State at:(from) 0) (set Var "RookToMove" (site)))))) (then (if (= (what at:(var "RookToMove")) (id "Rook" Mover)) (slide (from (var "RookToMove")) (if (< (column of:(var "RookToMove")) (column of:(coord "F1"))) E W) (between (exact (count Steps (coord "F1") (var "RookToMove"))) if:(or (is Empty (to)) (= (what at:(to)) (id "King" Mover)))) (to if:True (apply if:(or (= (what at:(to)) (id "King" Mover)) (is Empty (to))) (set State at:(from) 0)))) (add (piece (id "Rook" Mover)) (to (coord "F1")))))))))) (forEach Site (sites Occupied by:Mover component:"Rook") (if (= (state at:(site)) 1) (if (> (column of:(site)) (column of:(where "King" Mover))) (if (or (can Move (slide (from (site)) (if (< (column of:(site)) (column of:(coord "F8"))) E W) (between (exact (count Steps (coord "F8") (site))) if:(or (is Empty (to)) (= (what at:(to)) (id "King" Mover)))) (to if:True (apply if:(or (= (what at:(to)) (id "King" Mover)) (is Empty (to))) (set State at:(from) 0))))) (= (site) (coord "F8"))) (if (= (where "King" Mover) (coord "G8")) (do (set Var "RookToMove" (site)) next:(move Select (from (where "King" Mover)))) (move Slide (from (where "King" Mover)) (if (< (column of:(where "King" Mover)) (column of:(coord "G8"))) E W) (between (exact (count Steps (coord "G8") (where "King" Mover))) if:(and (or (is Empty (to)) (= (to) (site))) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply if:(or (= (to) (site)) (is Empty (to))) (and (set State at:(from) 0) (set Var "RookToMove" (site)))))) (then (if (= (what at:(var "RookToMove")) (id "Rook" Mover)) (slide (from (var "RookToMove")) (if (< (column of:(var "RookToMove")) (column of:(coord "F8"))) E W) (between (exact (count Steps (coord "F8") (var "RookToMove"))) if:(or (is Empty (to)) (= (what at:(to)) (id "King" Mover)))) (to if:True (apply if:(or (= (what at:(to)) (id "King" Mover)) (is Empty (to))) (set State at:(from) 0)))) (add (piece (id "Rook" Mover)) (to (coord "F8"))))))) (if (or (can Move (slide (from (site)) (if (< (column of:(site)) (column of:(coord "D8"))) E W) (between (exact (count Steps (coord "D8") (site))) if:(or (is Empty (to)) (= (what at:(to)) (id "King" Mover)))) (to if:True (apply if:(or (= (what at:(to)) (id "King" Mover)) (is Empty (to))) (set State at:(from) 0))))) (= (site) (coord "D8"))) (if (= (where "King" Mover) (coord "C8")) (do (set Var "RookToMove" (site)) next:(move Select (from (where "King" Mover)))) (move Slide (from (where "King" Mover)) (if (< (column of:(where "King" Mover)) (column of:(coord "C8"))) E W) (between (exact (count Steps (coord "C8") (where "King" Mover))) if:(and (or (is Empty (to)) (= (to) (site))) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply if:(or (= (to) (site)) (is Empty (to))) (and (set State at:(from) 0) (set Var "RookToMove" (site)))))) (then (if (= (what at:(var "RookToMove")) (id "Rook" Mover)) (slide (from (var "RookToMove")) (if (< (column of:(var "RookToMove")) (column of:(coord "D8"))) E W) (between (exact (count Steps (coord "D8") (var "RookToMove"))) if:(or (is Empty (to)) (= (what at:(to)) (id "King" Mover)))) (to if:True (apply if:(or (= (what at:(to)) (id "King" Mover)) (is Empty (to))) (set State at:(from) 0)))) (add (piece (id "Rook" Mover)) (to (coord "D8"))))))))))))) ifAfterwards:(not (is Threatened (id "King" Mover)))))) (end {(if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win)) (if (or (no Moves Mover) (= (counter) 99)) (result Mover Draw))}))) 
8x8 board. The pieces move as follows, with the number per player: 1 x King: moves one space orthogonally or diagonally. 1 x Queen : One square diagonally. 2 x Rook: Any number of spaces orthogonally. 2 x Fil: Two squares diagonally, jumping over the first. Cannot capture another Fil. 2 x Knight: Moves orthogonally one space and then diagonally another space, jumping over any intervening pieces; 8 x Pawns: Moves one space forward orthogonally; one space forward diagonally to capture. No en passant. Pawns are promoted to Queen when reaching the eighth rank. No castling. When a piece can be captured, it must be. The highest ranking piece must be captured, and the lowest ranking piece must make the capture if several are able to capture the same piece. The ranking, from highest to lowest, is: King, Rook, Knight, Queen, Fil, Pawn. Stalemate results in a win for player causing it. The player who checkmates the king wins. 
(game "Forcado" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (promote (last To) (piece "Ferz_noCross") Mover))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "King_noCross" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Bishop_noCross" Each (move Hop Diagonal (between if:True) (to if:(or (is Empty (to)) (is Enemy (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Ferz_noCross" Each (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Bishop_noCross1" {"C1" "F1"}) (place "Ferz_noCross1" coord:"D1") (place "King_noCross1" coord:"E1") (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Bishop_noCross2" {"C8" "F8"}) (place "Ferz_noCross2" coord:"D8") (place "King_noCross2" coord:"E8")}) (play (priority {(do (forEach Piece {"Pawn"} (move Step (directions {FR FL}) (to if:(and (is Enemy (who at:(to))) (= (what at:(to)) (id "Rook" Next))) (apply (remove (to))))) Mover) ifAfterwards:(not (is Threatened (id "King_noCross" Mover)))) (do (forEach Piece {"Bishop_noCross"} (move Hop Diagonal (between if:True) (to if:(and (is Enemy (who at:(to))) (= (what at:(to)) (id "Rook" Next))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) Mover) ifAfterwards:(not (is Threatened (id "King_noCross" Mover)))) (do (forEach Piece {"Ferz_noCross"} (move Step Diagonal (to if:(and (is Enemy (who at:(to))) (= (what at:(to)) (id "Rook" Next))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) Mover) ifAfterwards:(not (is Threatened (id "King_noCross" Mover)))) (do (forEach Piece {"Knight"} (move Leap {{F F R F} {F F L F}} (to if:(and (is Enemy (who at:(to))) (= (what at:(to)) (id "Rook" Next))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) Mover) ifAfterwards:(not (is Threatened (id "King_noCross" Mover)))) (do (forEach Piece {"Rook"} (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply if:(and (is Enemy (who at:(to))) (= (what at:(to)) (id "Rook" Next))) (if (is Enemy (who at:(to))) (remove (to)))))) Mover) ifAfterwards:(not (is Threatened (id "King_noCross" Mover)))) (do (forEach Piece {"King_noCross"} (move Step (to if:(and (is Enemy (who at:(to))) (= (what at:(to)) (id "Rook" Next))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) Mover) ifAfterwards:(not (is Threatened (id "King_noCross" Mover)))) (do (forEach Piece {"Pawn"} (move Step (directions {FR FL}) (to if:(and (is Enemy (who at:(to))) (= (what at:(to)) (id "Knight" Next))) (apply (remove (to))))) Mover) ifAfterwards:(not (is Threatened (id "King_noCross" Mover)))) (do (forEach Piece {"Bishop_noCross"} (move Hop Diagonal (between if:True) (to if:(and (is Enemy (who at:(to))) (= (what at:(to)) (id "Knight" Next))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) Mover) ifAfterwards:(not (is Threatened (id "King_noCross" Mover)))) (do (forEach Piece {"Ferz_noCross"} (move Step Diagonal (to if:(and (is Enemy (who at:(to))) (= (what at:(to)) (id "Knight" Next))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) Mover) ifAfterwards:(not (is Threatened (id "King_noCross" Mover)))) (do (forEach Piece {"Knight"} (move Leap {{F F R F} {F F L F}} (to if:(and (is Enemy (who at:(to))) (= (what at:(to)) (id "Knight" Next))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) Mover) ifAfterwards:(not (is Threatened (id "King_noCross" Mover)))) (do (forEach Piece {"Rook"} (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply if:(and (is Enemy (who at:(to))) (= (what at:(to)) (id "Knight" Next))) (if (is Enemy (who at:(to))) (remove (to)))))) Mover) ifAfterwards:(not (is Threatened (id "King_noCross" Mover)))) (do (forEach Piece {"King_noCross"} (move Step (to if:(and (is Enemy (who at:(to))) (= (what at:(to)) (id "Knight" Next))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) Mover) ifAfterwards:(not (is Threatened (id "King_noCross" Mover)))) (do (forEach Piece {"Pawn"} (move Step (directions {FR FL}) (to if:(and (is Enemy (who at:(to))) (= (what at:(to)) (id "Ferz_noCross" Next))) (apply (remove (to))))) Mover) ifAfterwards:(not (is Threatened (id "King_noCross" Mover)))) (do (forEach Piece {"Bishop_noCross"} (move Hop Diagonal (between if:True) (to if:(and (is Enemy (who at:(to))) (= (what at:(to)) (id "Ferz_noCross" Next))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) Mover) ifAfterwards:(not (is Threatened (id "King_noCross" Mover)))) (do (forEach Piece {"Ferz_noCross"} (move Step Diagonal (to if:(and (is Enemy (who at:(to))) (= (what at:(to)) (id "Ferz_noCross" Next))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) Mover) ifAfterwards:(not (is Threatened (id "King_noCross" Mover)))) (do (forEach Piece {"Knight"} (move Leap {{F F R F} {F F L F}} (to if:(and (is Enemy (who at:(to))) (= (what at:(to)) (id "Ferz_noCross" Next))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) Mover) ifAfterwards:(not (is Threatened (id "King_noCross" Mover)))) (do (forEach Piece {"Rook"} (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply if:(and (is Enemy (who at:(to))) (= (what at:(to)) (id "Ferz_noCross" Next))) (if (is Enemy (who at:(to))) (remove (to)))))) Mover) ifAfterwards:(not (is Threatened (id "King_noCross" Mover)))) (do (forEach Piece {"King_noCross"} (move Step (to if:(and (is Enemy (who at:(to))) (= (what at:(to)) (id "Ferz_noCross" Next))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) Mover) ifAfterwards:(not (is Threatened (id "King_noCross" Mover)))) (do (forEach Piece {"Pawn"} (move Step (directions {FR FL}) (to if:(and (is Enemy (who at:(to))) (= (what at:(to)) (id "Bishop_noCross" Next))) (apply (remove (to))))) Mover) ifAfterwards:(not (is Threatened (id "King_noCross" Mover)))) (do (forEach Piece {"Bishop_noCross"} (move Hop Diagonal (between if:True) (to if:(and (is Enemy (who at:(to))) (= (what at:(to)) (id "Bishop_noCross" Next))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) Mover) ifAfterwards:(not (is Threatened (id "King_noCross" Mover)))) (do (forEach Piece {"Ferz_noCross"} (move Step Diagonal (to if:(and (is Enemy (who at:(to))) (= (what at:(to)) (id "Bishop_noCross" Next))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) Mover) ifAfterwards:(not (is Threatened (id "King_noCross" Mover)))) (do (forEach Piece {"Knight"} (move Leap {{F F R F} {F F L F}} (to if:(and (is Enemy (who at:(to))) (= (what at:(to)) (id "Bishop_noCross" Next))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) Mover) ifAfterwards:(not (is Threatened (id "King_noCross" Mover)))) (do (forEach Piece {"Rook"} (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply if:(and (is Enemy (who at:(to))) (= (what at:(to)) (id "Bishop_noCross" Next))) (if (is Enemy (who at:(to))) (remove (to)))))) Mover) ifAfterwards:(not (is Threatened (id "King_noCross" Mover)))) (do (forEach Piece {"King_noCross"} (move Step (to if:(and (is Enemy (who at:(to))) (= (what at:(to)) (id "Bishop_noCross" Next))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) Mover) ifAfterwards:(not (is Threatened (id "King_noCross" Mover)))) (do (forEach Piece {"Pawn"} (move Step (directions {FR FL}) (to if:(and (is Enemy (who at:(to))) (= (what at:(to)) (id "Pawn" Next))) (apply (remove (to))))) Mover) ifAfterwards:(not (is Threatened (id "King_noCross" Mover)))) (do (forEach Piece {"Bishop_noCross"} (move Hop Diagonal (between if:True) (to if:(and (is Enemy (who at:(to))) (= (what at:(to)) (id "Pawn" Next))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) Mover) ifAfterwards:(not (is Threatened (id "King_noCross" Mover)))) (do (forEach Piece {"Ferz_noCross"} (move Step Diagonal (to if:(and (is Enemy (who at:(to))) (= (what at:(to)) (id "Pawn" Next))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) Mover) ifAfterwards:(not (is Threatened (id "King_noCross" Mover)))) (do (forEach Piece {"Knight"} (move Leap {{F F R F} {F F L F}} (to if:(and (is Enemy (who at:(to))) (= (what at:(to)) (id "Pawn" Next))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) Mover) ifAfterwards:(not (is Threatened (id "King_noCross" Mover)))) (do (forEach Piece {"Rook"} (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply if:(and (is Enemy (who at:(to))) (= (what at:(to)) (id "Pawn" Next))) (if (is Enemy (who at:(to))) (remove (to)))))) Mover) ifAfterwards:(not (is Threatened (id "King_noCross" Mover)))) (do (forEach Piece {"King_noCross"} (move Step (to if:(and (is Enemy (who at:(to))) (= (what at:(to)) (id "Pawn" Next))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) Mover) ifAfterwards:(not (is Threatened (id "King_noCross" Mover)))) (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))))})) (end (if (or (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (no Moves Next)) (result Mover Win))))) 
Once a player is checkmated their king is removed, but all their other pieces remain on the board as neutral obstacles. Neutral pieces cannot help checkmate other players. If a player cannot make a move when there are more than two players remaining, they skip their turn rather than giving a stalemate. Four Players.
(game "Four-Player Chess" (players {(player N) (player S) (player E) (player W)}) (equipment {(board (merge (shift 0 3 (rectangle 8 14)) (shift 3 0 (rectangle 14 8)))) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (or (if (is In (from) (sites Start (piece (what at:(from))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))) (then (set Pending (ahead (last To) Backward))))) (move Step (directions {FR FL}) (to if:(and (is Pending) (= (to) (value Pending)))) (then (remove (ahead (last To) Backward)))))} (then (and (if (is In (last To) (sites Mover "Promotion")) (moveAgain)) (set Counter))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (map "King" {(pair 1 "H1") (pair 2 "H14") (pair 3 "A7") (pair 4 "N7")}) (map "RookLeft" {(pair 1 "D1") (pair 2 "K14") (pair 3 "A11") (pair 4 "N4")}) (map "RookRight" {(pair 1 "K1") (pair 2 "D14") (pair 3 "A4") (pair 4 "N11")}) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom)) (regions "Promotion" P3 (sites Right)) (regions "Promotion" P4 (sites Left))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 12)) (place "Pawn3" (sites Column 1)) (place "Pawn4" (sites Column 12)) (place "Rook1" {"D1" "K1"} state:1) (place "Knight1" {"E1" "J1"}) (place "Bishop1" {"F1" "I1"}) (place "Queen1" coord:"G1") (place "King1" coord:"H1" state:1) (place "Rook2" {"D14" "K14"} state:1) (place "Knight2" {"E14" "J14"}) (place "Bishop2" {"F14" "I14"}) (place "Queen2" coord:"G14") (place "King2" coord:"H14" state:1) (place "Rook3" {"A11" "A4"} state:1) (place "Knight3" {"A10" "A5"}) (place "Bishop3" {"A6" "A9"}) (place "Queen3" coord:"A8") (place "King3" coord:"A7" state:1) (place "Rook4" {"N4" "N11"} state:1) (place "Knight4" {"N5" "N10"}) (place "Bishop4" {"N6" "N9"}) (place "Queen4" coord:"N8") (place "King4" coord:"N7" state:1)}) (play (if (is Prev Mover) (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover) (do (or (forEach Piece) (if (and (= (state at:(mapEntry "King" (mover))) 1) (not (is Threatened (id "King" Mover)))) (or {(if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) W (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:True) (to if:True (apply (set State at:(from) 0))))))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) E (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:True) (to if:True (apply (set State at:(from) 0))))))) (if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (slide (from (mapEntry "RookLeft" (mover))) S (between (exact 3) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) N (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookLeft" (mover))) S (between (exact 3) if:True) (to if:True (apply (set State at:(from) 0))))))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (slide (from (mapEntry "RookRight" (mover))) N (between (exact 2) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) S (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookRight" (mover))) N (between (exact 2) if:True) (to if:True (apply (set State at:(from) 0)))))))}))) ifAfterwards:(not (is Threatened (id "King" Mover)))) (then (and {(if (and (is Active P1) (not (is Mover P1))) (if (and (is Threatened (id "King" P1)) (not (can Move (do (and (forEach Piece P1) (set NextPlayer (player 1))) ifAfterwards:(not (is Threatened (id "King" P1))))))) (remove (where (id "King" P1))))) (if (and (is Active P2) (not (is Mover P2))) (if (and (is Threatened (id "King" P2)) (not (can Move (do (and (forEach Piece P2) (set NextPlayer (player 2))) ifAfterwards:(not (is Threatened (id "King" P2))))))) (remove (where (id "King" P2))))) (if (and (is Active P3) (not (is Mover P3))) (if (and (is Threatened (id "King" P3)) (not (can Move (do (and (forEach Piece P3) (set NextPlayer (player 3))) ifAfterwards:(not (is Threatened (id "King" P3))))))) (remove (where (id "King" P3))))) (if (and (is Active P4) (not (is Mover P4))) (if (and (is Threatened (id "King" P4)) (not (can Move (do (and (forEach Piece P4) (set NextPlayer (player 4))) ifAfterwards:(not (is Threatened (id "King" P4))))))) (remove (where (id "King" P4)))))})))) (end {(forEach NonMover if:(= (where "King" Player) -1) (result Player Loss)) (if (and (<= (count Active) 2) (or (no Moves Mover) (= (counter) (* 50 (count Active))))) (result Mover Draw))}))) 
Glinski Chess is played on a hexagonal board with each side having length 6, and each space oriented horizontally. The board has 91 spaces. Piece Movement: * Kings can move one space in any of the 12 directions from the current space. There is no castling. * Rooks can slide in any of the six 'adjacent' directions from their current space---North, South, or 60 degrees off either of those. * Bishops can slide in the six 'diagonal' directions: West, East, or 30 degrees off due North or 30 degrees off due South. Note that, given the 3-colour colouring of the board, each of the three Bishops remains on the same colour that it started the game on. * Queens can make any move that would be available to a Rook or a Bishop on the current space. * Knights can leap to any space that is two spaces away in an adjacent direction (North, South, or 60 degrees off either of those), plus one more space 60 degrees off of that direction. Note that a Knight always moves to a space of a different colour than the space it moved from. * Pawns can advance one space forward without capturing. They capture by moving to one of the two adjacent spaces 60 degrees left or right of forward. A Pawn on a Pawn start space can advance two spaces forward without capturing, even if it has previously moved (by capturing) to a different Pawn start space than it started the game on. A Pawn can capture an opponent Pawn 'en passant' if the opponent Pawn just advanced two spaces on its previous turn, and the capture direction of the current player's Pawn lands it on the space that the opponent Pawn just skipped over. On reaching the farthest rank in a given file, Pawns are promoted to a Queen, Rook, Bishop, or Knight, as the player chooses. The game ends on a checkmate or stalemate. By convention, the player that causes the stalemate is awarded 3/4 of a point, while the other player is awarded 1/4 of a point. Variations: Shift the innermost 3 or 5 Pawns toward the edge of the board by one space, as proposed in A Player's Guide to Table Games, by John Jackson, Stackpole Books, 1975. Pawns in the starting position chosen by Władysław Gliński in 1936
(game "Glinski Chess" (players {(player N) (player S)}) (equipment {(board (rotate 90 (hex 6))) (piece "King" Each (move Step All (to if:(or (is In (to) (sites Empty)) (is Enemy (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Queen" Each (move Slide All (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(or (is In (to) (sites Empty)) (is Enemy (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (if (is In (from) (sites Start (piece (what at:(from))))) (move Hop Forward (between if:(is In (between) (sites Empty))) (to if:(is In (to) (sites Empty))) (then (and {(set Pending (ahead (last To) Backward)) (set Var (last To))})))) (move Step (if (is Mover P1) (directions {WNW ENE}) (directions {WSW ESE})) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Step (if (is Mover P1) (directions {WNW ENE}) (directions {WSW ESE})) (to if:(and (is Pending) (= (to) (value Pending)))) (then (remove (var))))} (then (and (if (is In (last To) (sites Mover "PromotionZone")) (moveAgain)) (set Counter))))) (regions "PromotionZone" P1 (union (sites Side NW) (sites Side NE))) (regions "PromotionZone" P2 (union (sites Side SW) (sites Side SE))) (regions "Region-Dark" (sites Phase 0)) (regions "Region-Light" (sites Phase 2)) (regions "Region-Medium" (sites Phase 1))}) (rules (start {(place "King1" coord:"B1") (place "Queen1" coord:"A2") (place "Rook1" {"A4" "D1"}) (place "Bishop1" {"A1" "B2" "C3"}) (place "Knight1" {"A3" "C1"}) (place "King2" coord:"K10") (place "Queen2" coord:"J11") (place "Rook2" {"H11" "K8"}) (place "Bishop2" {"K11" "J10" "I9"}) (place "Knight2" {"I11" "K9"}) (place "Pawn1" {"A5" "B5" "C5" "D5" "E5" "E4" "E3" "E2" "E1"}) (place "Pawn2" {"G11" "G10" "G9" "G8" "G7" "H7" "I7" "J7" "K7"})}) phases:{(phase "Movement" (play (if (is Prev Mover) (move Promote (last To) (piece {"Queen" "Rook" "Bishop" "Knight"}) Mover) (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King" Mover)))))) (end {(if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win)) (if (or (no Moves Mover) (= (counter) 100)) (result Mover Draw))}))})) 
12x12 checkered board. Each player begins with 24 pieces with special moves: King (x1): Moves one space orthogonally or diagonally or may jump over one space forward orthogonally or diagonally on its first move; Aanca (x2): Moves diagonally one and one space orthogonally in the same direction, and may continue moving in that same direction any distance; Crocodile (x2): moves diagonally any distance; Giraffe (x2): moves two spaces diagonally and then one orthogonally in the same direction, jumping over any intervening pieces; Rhinoceros (x2): moves diagonally one space and then one orthogonally in the same directions, jumping over any intervening pieces, and then may continue along the diagonal in the same direction; Lion (x2); jumps orthogonally three spaces away. Rook (x2): moves any distance orthogonally; Pawns (12): move forward orthogonally one pace or diagonally one space to capture. When they reach the opposite edge of the board, they are promoted to the piece which began in that space. If this is the King's space, it is promoted to Aanca. The opening position is for white: Rook, Lion, Rhinoceros, Giraffe, Crocodile, Aanca, King, Crocodile, Giraffe, Rhinoceros, Lion, Rook. This is mirrored for black so that the kings face each other. The pawns begin on the fourth row. Pieces are captured when a piece lands on a space occupied by the opposing player. The goal is to checkmnate the King. When the King can be captured on the opponent's next turn, it is in check. The player must remove the King from check on their next turn. If the King cannot move out of check, it is checkmated and the opponent wins.  The rules of Alfonso X without dice.
(game "Grande Acedrex" (players {(player N) (player S)}) (equipment {(board (square 12)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (promote (last To) (piece (if (is In (last To) (sites Corners)) (id "Rook" Mover) (if (or (= (column of:(last To)) 1) (= (column of:(last To)) 10)) (id "Lion" Mover) (if (or (= (column of:(last To)) 2) (= (column of:(last To)) 9)) (id "Rhino" Mover) (if (or (= (column of:(last To)) 3) (= (column of:(last To)) 8)) (id "Giraffe" Mover) (if (or (= (column of:(last To)) 4) (= (column of:(last To)) 7)) (id "Crocodile" Mover) (id "Eagle" Mover)))))))))))) (piece "Crocodile" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Eagle" Each (move (from) (to (union {(sites To (if (and (!= (ahead (from) NW) -1) (not (is Friend (who at:(ahead (from) NW))))) (or (fromTo (from) (to (ahead (from) NW))) (slide (from (ahead (from) NW)) (directions {N W}) (to if:(is Enemy (who at:(to)))))))) (sites To (if (and (!= (ahead (from) NE) -1) (not (is Friend (who at:(ahead (from) NE))))) (or (fromTo (from) (to (ahead (from) NE))) (slide (from (ahead (from) NE)) (directions {N E}) (to if:(is Enemy (who at:(to)))))))) (sites To (if (and (!= (ahead (from) SW) -1) (not (is Friend (who at:(ahead (from) SW))))) (or (fromTo (from) (to (ahead (from) SW))) (slide (from (ahead (from) SW)) (directions {S W}) (to if:(is Enemy (who at:(to)))))))) (sites To (if (and (!= (ahead (from) SE) -1) (not (is Friend (who at:(ahead (from) SE))))) (or (fromTo (from) (to (ahead (from) SE))) (slide (from (ahead (from) SE)) (directions {E S}) (to if:(is Enemy (who at:(to))))))))}) (apply if:(is Enemy (who at:(to))) (remove (to)))))) (piece "Rhino" Each (move (from) (to (union {(sites To (if (!= (ahead (from) N) -1) (slide (from (ahead (from) N)) (directions {NE NW}) (to if:(is Enemy (who at:(to))))))) (sites To (if (!= (ahead (from) W) -1) (slide (from (ahead (from) W)) (directions {NW SW}) (to if:(is Enemy (who at:(to))))))) (sites To (if (!= (ahead (from) S) -1) (slide (from (ahead (from) S)) (directions {SW SE}) (to if:(is Enemy (who at:(to))))))) (sites To (if (!= (ahead (from) E) -1) (slide (from (ahead (from) E)) (directions {SE NE}) (to if:(is Enemy (who at:(to)))))))}) (apply if:(is Enemy (who at:(to))) (remove (to)))))) (piece "Giraffe" Each (move Leap {{F F F R F F} {F F F L F F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Lion" Each (move Leap {{F F F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "King" Each (or (move Step (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))) (if (= (state at:(from)) 1) (move Hop Forwards (between if:True) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 3)) (place "Rook1" (sites {"A1" "L1"})) (place "Lion1" (sites {"B1" "K1"})) (place "Rhino1" (sites {"C1" "J1"})) (place "Giraffe1" (sites {"D1" "I1"})) (place "Crocodile1" (sites {"E1" "H1"})) (place "Eagle1" coord:"F1") (place "King1" coord:"G1" state:1) (place "Pawn2" (sites Row 8)) (place "Rook2" (sites {"A12" "L12"})) (place "Lion2" (sites {"B12" "K12"})) (place "Rhino2" (sites {"C12" "J12"})) (place "Giraffe2" (sites {"D12" "I12"})) (place "Crocodile2" (sites {"E12" "H12"})) (place "Eagle2" coord:"F12") (place "King2" coord:"G12" state:1)}) (play (do (or {(forEach Piece "Pawn") (forEach Piece "King") (forEach Piece "Rook") (forEach Piece "Lion") (forEach Piece "Giraffe") (forEach Piece "Eagle") (forEach Piece "Crocodile") (forEach Piece "Rhino")}) ifAfterwards:(not (is Threatened (id "King" Mover))))) (end (if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win))))) 
Half Chess is played with the same rules as chess.
(game "Half Chess" (players 2) (equipment {(board (rectangle 4 8)) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter)))))))}) (rules (start {(place "Rook1" {"H1" "H4"}) (place "Knight1" {"G1" "G4"}) (place "Bishop1" {"G2" "G3"}) (place "Queen1" coord:"H3") (place "King1" coord:"H2") (place "Rook2" {"A1" "A4"}) (place "Knight2" {"B1" "B4"}) (place "Bishop2" {"B2" "B3"}) (place "Queen2" coord:"A3") (place "King2" coord:"A2")}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King" Mover))))) (end {(if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win)) (if (or (no Moves Mover) (= (counter) 100)) (result Mover Draw))}))) 
The rules are the same as for Chess with these differences: White wins by capturing all black pieces. Black wins by checkmating the white king. If no black piece can make a valid move, the game is a draw (stalemate). Black pawns can be promoted to a black queen, rook, bishop or knight if they reach the last row. Black pawns cannot move two spaces forward from any position except the second rank.
(game "Horde Chess" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (or (if (and (= (who at:(from)) P1) (is In (from) (sites Start (piece (what at:(from)))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))) (then (set Pending (ahead (last To) Backward))))) (move Step (directions {FR FL}) (to if:(and (is Pending) (= (to) (value Pending)))) (then (remove (ahead (last To) Backward)))))} (then (and (if (is In (last To) (sites Mover "Promotion")) (moveAgain)) (set Counter))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (map "King" {(pair 1 "E1") (pair 2 "E8")}) (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")}) (map "RookRight" {(pair 1 "H1") (pair 2 "H8")}) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (union {(sites Row 5) (sites Row 6) (sites Row 4) (difference (sites Row 7) (sites {"D8" "E8"})) (difference (sites Row 3) (sites {"A4" "B4" "C4" "F4" "G4" "H4"}))})) (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King1" coord:"E1" state:1)}) (play (if (is Prev Mover) (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover) (if (is Mover P1) (do (or (forEach Piece) (if (and {(= (what at:(mapEntry "King" (mover))) (id "King" Mover)) (= (state at:(mapEntry "King" (mover))) 1) (not (is Threatened (id "King" Mover)))}) (or (if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (move Slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:(is Empty (to)))))) (move Slide (from (mapEntry "King" (mover))) W (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (then (and (set State at:(last To) 0) (move Slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:True)))))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (move Slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:(is Empty (to)))))) (move Slide (from (mapEntry "King" (mover))) E (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (then (and (set State at:(last To) 0) (move Slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:True))))))))) ifAfterwards:(not (is Threatened (id "King" Mover)))) (forEach Piece)))) (end {(if (and (is Mover P1) (no Pieces P2)) (result P1 Win)) (if (and {(is Mover P2) (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))}) (result P2 Win)) (if (or (no Moves Mover) (= (counter) 100)) (result Mover Draw))}))) 
Played on an 8x8 board with pieces with specialized moves: Pawns (8): can move one space forward, or one space diagonally forward to capture; Players agree at the beginning of the game whether pawns may move two spaces on their first turn. Two pawns may be moved by a player in their first turn of the game. Pawns may only be promoted to a piece that has already been captured. If none have been captured, the pawn must remain in place until a piece has been captured. Rooks (2): can move any number of spaces orthogonally; Bishops (2): can move any number of spaces diagonally; Knight (2): moves in any direction, one space orthogonally with one space forward diagonally, jumping over any intervening pieces; Queens (1): can move any number of spaces orthogonally or diagonally; Kings (1): can move one space orthogonally or diagonally. A King cannot castle if it has ever been checked. Players capture pieces by moving onto a space occupied by an opponent's piece. A player must say 'Gardez la reine' (Guard the Queen) when the queen is threatened. When a King can be captured on the next turn by an opponent's piece, it is in check. The King must not be in check at the end of the player's turn. If this is not possible, it is checkmate and the opponent wins. A player who causes a stalemate loses.  The pawns can double step from the starting positions.
(game "Korkserschach" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (if (!= (last To) (from)) (or {(if (and (or {(is In (id "Queen" Mover) (values Remembered "CapturedPieces")) (is In (id "Knight" Mover) (values Remembered "CapturedPieces")) (is In (id "Rook" Mover) (values Remembered "CapturedPieces")) (is In (id "Bishop" Mover) (values Remembered "CapturedPieces"))}) (is In (from) (sites Mover "Promotion"))) (or {(if (is In (id "Queen" Mover) (values Remembered "CapturedPieces")) (move Promote (from) (piece {"Queen"}) Mover)) (if (is In (id "Knight" Mover) (values Remembered "CapturedPieces")) (move Promote (from) (piece {"Knight"}) Mover)) (if (is In (id "Rook" Mover) (values Remembered "CapturedPieces")) (move Promote (from) (piece {"Rook"}) Mover)) (if (is In (id "Bishop" Mover) (values Remembered "CapturedPieces")) (move Promote (from) (piece {"Bishop"}) Mover))} (then (set Pending)))) (if (is In (from) (sites Start (piece (what at:(from))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))))) (move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (and (remember Value "CapturedPieces" (what at:(to))) (remove (to))))))} (then (and (if (and (is In (last To) (sites Mover "Promotion")) (or {(is In (id "Queen" Mover) (values Remembered "CapturedPieces")) (is In (id "Knight" Mover) (values Remembered "CapturedPieces")) (is In (id "Rook" Mover) (values Remembered "CapturedPieces")) (is In (id "Bishop" Mover) (values Remembered "CapturedPieces"))})) (moveAgain)) (if (and (not (is Prev Mover)) (<= (count Turns) 2)) (and (set Pending) (moveAgain)))))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (and (remember Value "CapturedPieces" (what at:(to))) (remove (to)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (and (remember Value "CapturedPieces" (what at:(to))) (remove (to)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (and (remember Value "CapturedPieces" (what at:(to))) (remove (to)))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (and (remember Value "CapturedPieces" (what at:(to))) (remove (to)))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (and (remember Value "CapturedPieces" (what at:(to))) (remove (to)))))))) (map "King" {(pair 1 "E1") (pair 2 "E8")}) (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")}) (map "RookRight" {(pair 1 "H1") (pair 2 "H8")}) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King1" coord:"E1" state:1) (place "Rook2" {"A8" "H8"} state:1) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King2" coord:"E8" state:1)}) (play (if (and (not (is Pending)) (is Prev Mover)) (or {(if (is In (id "Queen" Mover) (values Remembered "CapturedPieces")) (move Promote (last To) (piece {"Queen"}) Mover)) (if (is In (id "Knight" Mover) (values Remembered "CapturedPieces")) (move Promote (last To) (piece {"Knight"}) Mover)) (if (is In (id "Rook" Mover) (values Remembered "CapturedPieces")) (move Promote (last To) (piece {"Rook"}) Mover)) (if (is In (id "Bishop" Mover) (values Remembered "CapturedPieces")) (move Promote (last To) (piece {"Bishop"}) Mover))}) (do (if (is Pending) (or (move Pass) (forEach Piece "Pawn" Mover)) (or (forEach Piece) (if (and (= (state at:(mapEntry "King" (mover))) 1) (not (is Threatened (id "King" Mover)))) (or (if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) W (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:True) (to if:True (apply (set State at:(from) 0))))))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) E (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:True) (to if:True (apply (set State at:(from) 0))))))))))) ifAfterwards:(not (is Threatened (id "King" Mover)))) (then (and (if (or (is Threatened (id "Queen" P1)) (is Threatened (id "Queen" P2))) (note "Gardez la reine")) (if (and (= (state at:(where "King" Next)) 1) (is Threatened (id "King" Next))) (set State at:(where "King" Next) 0)))))) (end (if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win))))) 
All movement of chessman’s are the same, just if you want to go on higher level, you can just go on first reachable chess box of higher level. And on next move, go on that level or to lower levels without restrictions. Knight goes without any restrictions. Once a player is checkmated their king is removed, but all their other pieces remain on the board as neutral obstacles. Neutral pieces cannot help checkmate other players. If a player cannot make a move when there are more than two players remaining, they skip their turn rather than giving a stalemate. Four Players.
(game "Level Chess" (players {(player N) (player S) (player E) (player W)}) (equipment {(board (merge (shift 0 3 (rectangle 8 14)) (shift 3 0 (rectangle 14 8)))) (piece "Pawn" Each (if (is Active (who at:(from))) (or {(if (is In (from) (sites Start (piece (what at:(from))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to)) (apply if:(>= (+ (if (is In (from) (sites "Level5")) 5 (if (is In (from) (sites "Level4")) 4 (if (is In (from) (sites "Level3")) 3 (if (is In (from) (sites "Level2")) 2 1)))) 1) (if (is In (to) (sites "Level5")) 5 (if (is In (to) (sites "Level4")) 4 (if (is In (to) (sites "Level3")) 3 (if (is In (to) (sites "Level2")) 2 1))))))) (then (set Pending (ahead (last To) Backward))))) (move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Step (directions {FR FL}) (to if:(and (is Pending) (= (to) (value Pending)))) (then (remove (ahead (last To) Backward))))} (then (and (if (is In (last To) (sites Mover "Promotion")) (moveAgain)) (set Counter)))))) (piece "Rook" Each (if (is Active (who at:(from))) (move Slide Orthogonal (to if:(or (is Enemy (who at:(to))) (and (< (if (is In (from) (sites "Level5")) 5 (if (is In (from) (sites "Level4")) 4 (if (is In (from) (sites "Level3")) 3 (if (is In (from) (sites "Level2")) 2 1)))) (if (is In (to) (sites "Level5")) 5 (if (is In (to) (sites "Level4")) 4 (if (is In (to) (sites "Level3")) 3 (if (is In (to) (sites "Level2")) 2 1))))) (not (is Friend (who at:(to)))))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0)))))) (piece "King" Each (if (is Active (who at:(from))) (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0)))))) (piece "Bishop" Each (if (is Active (who at:(from))) (move Slide Diagonal (to if:(or (is Enemy (who at:(to))) (and (< (if (is In (from) (sites "Level5")) 5 (if (is In (from) (sites "Level4")) 4 (if (is In (from) (sites "Level3")) 3 (if (is In (from) (sites "Level2")) 2 1)))) (if (is In (to) (sites "Level5")) 5 (if (is In (to) (sites "Level4")) 4 (if (is In (to) (sites "Level3")) 3 (if (is In (to) (sites "Level2")) 2 1))))) (not (is Friend (who at:(to)))))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter))))))))) (piece "Knight" Each (if (is Active (who at:(from))) (move (from) (to (difference (forEach (sites Board) if:(and {(not (is Friend (who at:(site)))) (= 3 (count Steps Orthogonal (from) (site)))})) (sites To (slide (between if:True)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter))))))))) (piece "Queen" Each (if (is Active (who at:(from))) (move Slide (to if:(or (is Enemy (who at:(to))) (and (< (if (is In (from) (sites "Level5")) 5 (if (is In (from) (sites "Level4")) 4 (if (is In (from) (sites "Level3")) 3 (if (is In (from) (sites "Level2")) 2 1)))) (if (is In (to) (sites "Level5")) 5 (if (is In (to) (sites "Level4")) 4 (if (is In (to) (sites "Level3")) 3 (if (is In (to) (sites "Level2")) 2 1))))) (not (is Friend (who at:(to)))))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter))))))))) (map "King" {(pair 1 "H1") (pair 2 "H14") (pair 3 "A7") (pair 4 "N7")}) (map "RookLeft" {(pair 1 "D1") (pair 2 "K14") (pair 3 "A11") (pair 4 "N4")}) (map "RookRight" {(pair 1 "K1") (pair 2 "D14") (pair 3 "A4") (pair 4 "N11")}) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom)) (regions "Promotion" P3 (sites Right)) (regions "Promotion" P4 (sites Left)) (regions "Level2" (difference (sites Board) (union {(expand (sites Top) steps:2) (expand (sites Bottom) steps:2) (expand (sites Left) steps:2) (expand (sites Right) steps:2)}))) (regions "Level2Phase0" (intersection (sites Phase 0) (difference (sites Board) (union {(expand (sites Top) steps:2) (expand (sites Bottom) steps:2) (expand (sites Left) steps:2) (expand (sites Right) steps:2)})))) (regions "Level2Phase1" (intersection (sites Phase 1) (difference (sites Board) (union {(expand (sites Top) steps:2) (expand (sites Bottom) steps:2) (expand (sites Left) steps:2) (expand (sites Right) steps:2)})))) (regions "Level3" (difference (sites Board) (union {(expand (sites Top) steps:4) (expand (sites Bottom) steps:4) (expand (sites Left) steps:4) (expand (sites Right) steps:4)}))) (regions "Level3Phase0" (intersection (sites Phase 0) (difference (sites Board) (union {(expand (sites Top) steps:4) (expand (sites Bottom) steps:4) (expand (sites Left) steps:4) (expand (sites Right) steps:4)})))) (regions "Level3Phase1" (intersection (sites Phase 1) (difference (sites Board) (union {(expand (sites Top) steps:4) (expand (sites Bottom) steps:4) (expand (sites Left) steps:4) (expand (sites Right) steps:4)}))))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 12)) (place "Pawn3" (sites Column 1)) (place "Pawn4" (sites Column 12)) (place "Rook1" {"D1" "K1"} state:1) (place "Knight1" {"E1" "J1"}) (place "Bishop1" {"F1" "I1"}) (place "Queen1" coord:"G1") (place "King1" coord:"H1" state:1) (place "Rook2" {"D14" "K14"} state:1) (place "Knight2" {"E14" "J14"}) (place "Bishop2" {"F14" "I14"}) (place "Queen2" coord:"G14") (place "King2" coord:"H14" state:1) (place "Rook3" {"A11" "A4"} state:1) (place "Knight3" {"A10" "A5"}) (place "Bishop3" {"A6" "A9"}) (place "Queen3" coord:"A8") (place "King3" coord:"A7" state:1) (place "Rook4" {"N4" "N11"} state:1) (place "Knight4" {"N5" "N10"}) (place "Bishop4" {"N6" "N9"}) (place "Queen4" coord:"N8") (place "King4" coord:"N7" state:1)}) (play (if (is Prev Mover) (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover) (do (or (forEach Piece) (if (and (= (state at:(mapEntry "King" (mover))) 1) (not (is Threatened (id "King" Mover)))) (or {(if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) W (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:True) (to if:True (apply (set State at:(from) 0))))))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) E (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:True) (to if:True (apply (set State at:(from) 0))))))) (if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (slide (from (mapEntry "RookLeft" (mover))) S (between (exact 3) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) N (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookLeft" (mover))) S (between (exact 3) if:True) (to if:True (apply (set State at:(from) 0))))))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (slide (from (mapEntry "RookRight" (mover))) N (between (exact 2) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) S (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookRight" (mover))) N (between (exact 2) if:True) (to if:True (apply (set State at:(from) 0)))))))}))) ifAfterwards:(not (is Threatened (id "King" Mover)))) (then (and {(if (and (is Active P1) (not (is Mover P1))) (if (and (is Threatened (id "King" P1)) (not (can Move (do (and (forEach Piece P1) (set NextPlayer (player 1))) ifAfterwards:(not (is Threatened (id "King" P1))))))) (remove (where (id "King" P1))))) (if (and (is Active P2) (not (is Mover P2))) (if (and (is Threatened (id "King" P2)) (not (can Move (do (and (forEach Piece P2) (set NextPlayer (player 2))) ifAfterwards:(not (is Threatened (id "King" P2))))))) (remove (where (id "King" P2))))) (if (and (is Active P3) (not (is Mover P3))) (if (and (is Threatened (id "King" P3)) (not (can Move (do (and (forEach Piece P3) (set NextPlayer (player 3))) ifAfterwards:(not (is Threatened (id "King" P3))))))) (remove (where (id "King" P3))))) (if (and (is Active P4) (not (is Mover P4))) (if (and (is Threatened (id "King" P4)) (not (can Move (do (and (forEach Piece P4) (set NextPlayer (player 4))) ifAfterwards:(not (is Threatened (id "King" P4))))))) (remove (where (id "King" P4)))))})))) (end {(forEach NonMover if:(= (where "King" Player) -1) (result Player Loss)) (if (and (<= (count Active) 2) (or (no Moves Mover) (= (counter) (* 50 (count Active))))) (result Mover Draw))}))) 
8x8 board. The pieces move as follows, with the number per player: 1 x King (king): moves one space orthogonally or diagonally. The King may leap to the second or third square on its first move, or move as a Knight, and does not hop over an opponent's piece. The King also cannot capture with this move. 1 x Queen: One square diagonally. On its first move, the Queen may jump diagonally two squares. The Queen cannot capture when making this move. 2 x Rook: Any number of spaces orthogonally. 2 x Bishop: Two squares diagonally, jumping over the first. Cannot capture another Bishop. 2 x Knight: Moves one space orthogonally and then one space diagonally, jumping over any intervening pieces. 8 x Pawn: Moves one space forward orthogonally; one space forward diagonally to capture. May move two spaces on its first move. En passant is not allowed. Promoted to Queen when reaching the eighth rank, and may make the Queen's leap on its first move after being promoted. If this promotion is made with the opponent's King at the distance of the extended move, it does not give check on that turn. No castling. An opponent's piece is captured by moving a player's own piece onto a space occupied by the opponent's piece. When a King can be captured on the next turn by an opponent's piece, it is in check. The King must not be in check at the end of the player's turn. If this is not possible, it is checkmate and the opponent wins. Stalemate results in a draw. 
(game "Lombard Chess" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "King" Each (or (move Step (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))) (if (= 1 (state at:(from))) (or (move Hop (between (range 1 2) if:(not (is Enemy (who at:(between))))) (to if:(is Empty (to)))) (move Leap {{F F R F} {F F L F}} (to if:(is Empty (to)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Bishop" Each (move Hop Diagonal (between if:True) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Queen" Each (or (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0)))) (if (= 1 (state at:(from))) (move Hop Diagonal (between if:True) (to if:(is Empty (to))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (if (is In (from) (sites Start (piece (what at:(from))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (and (promote (last To) (piece (id "Queen" Mover))) (set State at:(last To) 1)))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1" state:1) (place "King1" coord:"E1" state:1) (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8" state:1) (place "King2" coord:"E8" state:1)}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King" Mover))) (then (if (and (= 1 (state at:(where "King" Next))) (is Threatened (id "King" Next))) (set State at:(where "King" Next) 0))))) (end {(if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win)) (if (no Moves Next) (result Mover Draw))}))) 
8x8 board. The pieces move as follows, with the number per player: 1 x King (king): moves one space orthogonally or diagonally. The King may leap to the second square on its first move if it has not yet been checked and does not hop over an opponent's piece. 1 x Queen: One square diagonally. On its first move, the Queen may jump diagonally two squares. The Queen cannot capture when making this move. 2 x Rook: Any number of spaces orthogonally. 2 x Fil (elephant): Two squares diagonally, jumping over the first. Cannot capture another Fil. 2 x Knight: Moves as a chess knight. 8 x Pawn: Moves one space forward orthogonally; one space forward diagonally to capture. May move two spaces on its first move. En passant is allowed. Promoted to Queen when reaching the eighth rank, and may make the Queen's leap on its first move after being promoted. No castling. An opponent's piece is captured by moving a player's own piece onto a space occupied by the opponent's piece. When a King can be captured on the next turn by an opponent's piece, it is in check. The King must not be in check at the end of the player's turn. If this is not possible, it is checkmate and the opponent wins. Stalemate results in a draw. Capturing all of an opponent's pieces except the King also results in a win.
(game "Long Assize" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "King" Each (or (move Step (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))) (if (= 1 (state at:(from))) (move Hop (between if:(not (is Enemy (who at:(between))))) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Bishop" Each (move Hop Diagonal (between if:True) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Queen" Each (or (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0)))) (if (= 1 (state at:(from))) (move Hop Diagonal (between if:True) (to if:(is Empty (to))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (or (if (is In (from) (sites Start (piece (what at:(from))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))) (then (set Pending (ahead (last To) Backward))))) (move Step (directions {FR FL}) (to if:(and (is Pending) (= (to) (value Pending)))) (then (remove (ahead (last To) Backward)))))} (then (if (is In (last To) (sites Mover "Promotion")) (and (promote (last To) (piece (id "Queen" Mover))) (set State at:(last To) 1)))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1" state:1) (place "King1" coord:"E1" state:1) (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8" state:1) (place "King2" coord:"E8" state:1)}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King" Mover))) (then (if (and (= 1 (state at:(where "King" Next))) (is Threatened (id "King" Next))) (set State at:(where "King" Next) 0))))) (end {(if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win)) (if (no Moves Next) (result Mover Draw)) (if (= (count Pieces Next) 1) (result Mover Win))}))) 
The rules are the same as for Chess, except instead of moving a piece, a player's turn may be taken by replacing a captured piece on the board on any empty space. This piece is controlled by the player who replaced it. Captured pawns cannot be placed in the first or last row.
(game "Loop Chess" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (or {(if (is In (from) (sites Start (piece (what at:(from))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))) (then (set Pending (ahead (last To) Backward))))) (move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (add (piece (mapEntry "captured" (what at:(to)))) (to (mapEntry "where" (what at:(to)))))))) (move Step (directions {FR FL}) (to if:(and (is Pending) (= (to) (value Pending)))) (then (add (piece (mapEntry "captured" (what at:(ahead (last To) Backward)))) (to (mapEntry "where" (what at:(ahead (last To) Backward)))))))} (then (and (if (is In (last To) (sites Mover "Promotion")) (moveAgain)) (set Counter))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "captured" (what at:(to)))) (to (mapEntry "where" (what at:(to)))) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "captured" (what at:(to)))) (to (mapEntry "where" (what at:(to)))) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "captured" (what at:(to)))) (to (mapEntry "where" (what at:(to)))) (then (set Counter)))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "captured" (what at:(to)))) (to (mapEntry "where" (what at:(to)))) (then (set Counter)))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "captured" (what at:(to)))) (to (mapEntry "where" (what at:(to)))) (then (set Counter)))))))) (map "where" {(pair 2 64) (pair 1 70) (pair 4 65) (pair 3 71) (pair 6 66) (pair 5 72) (pair 8 67) (pair 7 73) (pair 10 68) (pair 9 74) (pair 12 69) (pair 11 75)}) (map "captured" {(pair 1 2) (pair 2 1) (pair 3 4) (pair 4 3) (pair 5 6) (pair 6 5) (pair 7 8) (pair 8 7) (pair 9 10) (pair 10 9) (pair 11 12) (pair 12 11)}) (map "King" {(pair 1 "E1") (pair 2 "E8")}) (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")}) (map "RookRight" {(pair 1 "H1") (pair 2 "H8")}) (regions "LastRanks" (union (sites Top) (sites Bottom))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom)) (hand Each size:6)}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King1" coord:"E1" state:1) (place "Rook2" {"A8" "H8"} state:1) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King2" coord:"E8" state:1)}) (play (if (is Prev Mover) (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover) (do (or {(move (from (sites Occupied by:Mover container:"Hand" components:{"Rook" "Bishop" "Knight" "Queen"})) (to (sites Empty))) (move (from (sites Occupied by:Mover container:"Hand" component:"Pawn")) (to (difference (sites Empty) (sites "LastRanks")))) (forEach Piece) (if (and {(= (what at:(mapEntry "King" (mover))) (id "King" Mover)) (= (state at:(mapEntry "King" (mover))) 1) (not (is Threatened (id "King" Mover)))}) (or (if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (move Slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:(is Empty (to)))))) (move Slide (from (mapEntry "King" (mover))) W (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (then (and (set State at:(last To) 0) (move Slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:True)))))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (move Slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:(is Empty (to)))))) (move Slide (from (mapEntry "King" (mover))) E (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (then (and (set State at:(last To) 0) (move Slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:True))))))))}) ifAfterwards:(not (is Threatened (id "King" Mover)))))) (end {(if (and (is Threatened (id "King" Next)) (not (can Move (do (or {(forEach Piece Next) (move (from (sites Occupied by:Next container:"Hand" components:{"Rook" "Bishop" "Knight" "Queen"})) (to (sites Empty))) (move (from (sites Occupied by:Next container:"Hand" component:"Pawn")) (to (difference (sites Empty) (sites "LastRanks"))))}) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win)) (if (or (no Moves Mover) (= (counter) 100)) (result Mover Draw))}))) 
The rules are the same as for Chess, except pawns cannot move two spaces on the first move, there is no castling, and no en-passant capture.
(game "Los Alamos Chess" (players {(player N) (player S)}) (equipment {(board (square 6)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (and (if (is In (last To) (sites Mover "Promotion")) (moveAgain)) (set Counter))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 4)) (place "Rook1" {"A1" "F1"}) (place "Knight1" {"B1" "E1"}) (place "Queen1" coord:"C1") (place "King1" coord:"D1") (place "Rook2" {"A6" "F6"}) (place "Knight2" {"B6" "E6"}) (place "Queen2" coord:"C6") (place "King2" coord:"D6")}) (play (if (is Prev Mover) (move Promote (last To) (piece {"Queen" "Knight" "Rook"}) Mover) (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King" Mover)))))) (end {(if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win)) (if (or (no Moves Mover) (= (counter) 100)) (result Mover Draw))}))) 
The black player has a normal set of chess pieces. The white player has a single piece which can move either as a queen or as a knight. Black's goal is to checkmate the white piece, White's goal is to checkmate the black king. There is no pawn promotion.
(game "Maharajah Chess" (players 2) (equipment {(board (square 8)) (piece "Pawn" P2 S (or {(if (is In (from) (sites Start (piece (what at:(from))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))))) (move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (set Counter)))) (piece "Rook" P2 (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "King" P2 (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Bishop" P2 (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Knight" P2 (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Queen" P2 (move Slide (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Amazon" P1 (or (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter))))))) (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter)))))))) (map "King" {(pair 1 "E1") (pair 2 "E8")}) (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")}) (map "RookRight" {(pair 1 "H1") (pair 2 "H8")})}) (rules (start {(place "Pawn2" (sites Row 6)) (place "Amazon1" coord:"E1") (place "Rook2" {"A8" "H8"} state:1) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King2" coord:"E8" state:1)}) (play (do (or (forEach Piece) (if (and {(is Mover P2) (= (what at:(mapEntry "King" (mover))) (id "King" Mover)) (= (state at:(mapEntry "King" (mover))) 1) (not (is Threatened (id "King" Mover)))}) (or (if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (move Slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:(is Empty (to)))))) (move Slide (from (mapEntry "King" (mover))) W (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (then (and (set State at:(last To) 0) (move Slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:True)))))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (move Slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:(is Empty (to)))))) (move Slide (from (mapEntry "King" (mover))) E (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (then (and (set State at:(last To) 0) (move Slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:True))))))))) ifAfterwards:(if (is Mover P1) (not (is Threatened (id "Amazon" Mover))) (not (is Threatened (id "King" Mover)))))) (end {(if (if (is Mover P1) (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (and (is Threatened (id "Amazon" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "Amazon" Next)))))))) (result Mover Win)) (if (or (no Moves Mover) (= (counter) 100)) (result Mover Draw))}))) 
McCooey Chess is played on a hexagonal board with each side having length 6, and each space oriented horizontally. The board has has 91 spaces. Piece Movement: * All pieces other than Pawns move as in Glinski Chess. - Kings step one space in any of the 12 directions. They do not castle. - Queens slide in any of the 12 directions. - Rooks slide in any of the 6 adjacent direction. - Bishops slide in any of the 6 'diagonal' directions. - Knights move two spaces in any adjacent direction, then one space in another direction. * Pawns can advance one space forward without capturing. A Pawn on a Pawn start space but not in the innermost column can advance two spaces forward without capturing. Pawns capture 'diagonally forward' (i.e., to a space ahead connected by an edge, and having the same colour). En Passant capture and Pawn promotion take place as in Glinski Chess. The game ends on a checkmate or stalemate.
(game "McCooey Chess" (players {(player N) (player S)}) (equipment {(board (rotate 90 (hex 6))) (piece "King" Each (move Step All (to if:(or (is In (to) (sites Empty)) (is Enemy (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Queen" Each (move Slide All (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(or (is In (to) (sites Empty)) (is Enemy (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (if (and (is In (from) (sites Start (piece (what at:(from))))) (not (is In (from) (sites Mover "CentrePawnStartCell")))) (move Hop Forward (between if:(is In (between) (sites Empty))) (to if:(is In (to) (sites Empty))) (then (and {(set Pending (ahead (last To) Backward)) (set Var (last To))})))) (move Step (if (is Mover P1) (directions {NNW NNE}) (directions {SSW SSE})) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Step (if (is Mover P1) (directions {NNW NNE}) (directions {SSW SSE})) (to if:(and (is Pending) (= (to) (value Pending)))) (then (remove (var))))} (then (and (if (is In (last To) (sites Mover "PromotionZone")) (moveAgain)) (set Counter))))) (regions "CentrePawnStartCell" P1 (sites {"D4"})) (regions "CentrePawnStartCell" P2 (sites {"H8"})) (regions "PromotionZone" P1 (union (sites Side NW) (sites Side NE))) (regions "PromotionZone" P2 (union (sites Side SW) (sites Side SE))) (regions "Region-Dark" (sites Phase 0)) (regions "Region-Light" (sites Phase 2)) (regions "Region-Medium" (sites Phase 1))}) (rules (start {(place "King1" coord:"B1") (place "Queen1" coord:"A2") (place "Rook1" {"A3" "C1"}) (place "Bishop1" {"A1" "B2" "C3"}) (place "Knight1" {"B3" "C2"}) (place "King2" coord:"K10") (place "Queen2" coord:"J11") (place "Rook2" {"I11" "K9"}) (place "Bishop2" {"K11" "J10" "I9"}) (place "Knight2" {"I10" "J9"}) (place "Pawn1" {"A4" "B4" "C4" "D4" "D3" "D2" "D1"}) (place "Pawn2" {"H11" "H10" "H9" "H8" "I8" "J8" "K8"})}) phases:{(phase "Movement" (play (if (is Prev Mover) (move Promote (last To) (piece {"Queen" "Rook" "Bishop" "Knight"}) Mover) (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King" Mover)))))) (end {(if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win)) (if (or (no Moves Mover) (= (counter) 100)) (result Mover Draw))}))})) 
8x8 board. The pieces move as follows, with the number per player: 1 x King (king): moves one space orthogonally or diagonally. 1 x Queen (counselor): One square diagonally. 2 x Rook (rook): Any number of spaces orthogonally. 2 x Fil (elephant): Two squares diagonally, jumping over the first. Cannot capture another Fil. 2 x Knight: Moves as a chess knight. 8 x Pawn: Moves one space forward orthogonally; one space forward diagonally to capture. No en passant. Promoted to Fers when reaching the eighth rank. No castling. An opponent's piece is captured by moving a player's own piece onto a space occupied by the opponent's piece. When a Shah can be captured on the next turn by an opponent's piece, it is in check. The Shah must not be in check at the end of the player's turn. If this is not possible, it is checkmate and the opponent wins. Stalemate results in a win for that player causing it. 
(game "Medieval Chess" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (moveAgain))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "King_noCross" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Bishop_noCross" Each (move Hop Diagonal (between if:True) (to if:(or (is Empty (to)) (is Enemy (who at:(to)))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Ferz_noCross" Each (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Bishop_noCross1" {"C1" "F1"}) (place "Ferz_noCross1" coord:"D1") (place "King_noCross1" coord:"E1") (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Bishop_noCross2" {"C8" "F8"}) (place "Ferz_noCross2" coord:"D8") (place "King_noCross2" coord:"E8")}) (play (if (is Prev Mover) (move Promote (last To) (piece "Ferz_noCross") Mover) (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover)))))) (end {(if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win)) (if (= (count Pieces Next) 1) (result Mover Win)) (if (no Moves Next) (result Mover Win))}))) 
Mini Hexchess is played on a hexagonal board with each side having length 5, and each space oriented horizontally. The board has 37 spaces. Piece Movement: * Kings, Rooks, Bishops, and Knights move as in Glinski Chess. - Kings step one space in any of the 12 directions. They do not castle. - Rooks slide in any of the 6 adjacent directions. - Bishops slide in any of the 6 'diagonal' directions. - Knights move two spaces in any adjacent direction, then one space in another direction. * There are no Queens in Mini Hexchess. * Pawns can advance one space forward without capturing. Pawns can never advance more than one space. Pawns capture 'diagonally forward' (i.e., to a space ahead connected by an edge, and having the same colour). There is no en passant capture. On reaching the farthest rank in a given file, Pawns are promoted to a Rook, Bishop, or Knight. Note that a Pawn cannot be promoted to a Queen, since there are no Queens in Mini Hexchess. The game ends on a checkmate or stalemate.
(game "Mini Hexchess" (players {(player N) (player S)}) (equipment {(board (rotate 90 (hex 4))) (piece "King" Each (move Step All (to if:(or (is In (to) (sites Empty)) (is Enemy (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (if (is Mover P1) (directions {NNW NNE}) (directions {SSW SSE})) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (and (if (is In (last To) (sites Mover "PromotionZone")) (moveAgain)) (set Counter))))) (regions "PromotionZone" P1 (union (sites Side NW) (sites Side NE))) (regions "PromotionZone" P2 (union (sites Side SW) (sites Side SE))) (regions "Region-Dark" (sites Phase 2)) (regions "Region-Light" (sites Phase 1)) (regions "Region-Medium" (sites Phase 0))}) (rules (start {(place "King1" coord:"B2") (place "Rook1" coord:"B1") (place "Bishop1" coord:"A1") (place "Knight1" coord:"A2") (place "King2" coord:"F6") (place "Rook2" coord:"F7") (place "Bishop2" coord:"G7") (place "Knight2" coord:"G6") (place "Pawn1" {"A3" "B3" "C3" "C2" "C1"}) (place "Pawn2" {"E7" "E6" "E5" "F5" "G5"})}) phases:{(phase "Movement" (play (if (is Prev Mover) (move Promote (last To) (piece {"Rook" "Bishop" "Knight"}) Mover) (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King" Mover)))))) (end {(if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win)) (if (or (no Moves Mover) (= (counter) 100)) (result Mover Draw))}))})) 
Played on an 8x6 board with pieces with specialized moves. White moves first: Pawns (6): can move one space forwards (orthogonally or diagonally across dark squares) and can capture an enemy located diagonally across either of the adjacent dark squares (diagonal forwards and diagonal backwards). Upon reaching the last rank, Pawns promote to any major piece except a king. -- There are no initial double moves, nor enpassant. Bishops (2): Can move like chess queens - any orthogonal direction or allowed diagonal direction (but not across light squares). Knights (2) move one space orthogonally and one space diagonally, in either order to reach a non-adjacent destination. The intermediate position may be occupied. Knights capture at their destination, but if the destination is empty, they capture an enemy along their path. Queen (1): can move any number of spaces diagonally only, but once per turn, may change direction while crossing a dark square. They capture an enemy at the destination. Kings (1): can move one space orthogonally or diagonally. The King can move twice per turn, but not in the same direction nor back to the same place. A King may capture on both parts of its turn, but only if the piece(s) captured is not defended. Checks: A check is a threat to take a king, or a threat on a site that the king passes through. -- The King may not move across- nor to- a position that remains in check at the completion of its full turn. Nor may a king be put into check by the movement of another friendly piece, including by the opening of a space that allows a knight to jump across the king, or opening a space between opposing kings. Note: While a king may not move across an open site under check, it may still threaten check across it, thus preventing the opposing king from occupying those sites -- because if the opposing king were captured at those sites, the game would be over and all checks would be null, including those on the intervening site. A king does not threaten check across an occupied site. In no case may a King put the other king directly into check, because in all such cases both the kings would be put into check, and movement into check is forbidden. A King must move when in check. The game is won when the ememy king must move, but cannot. Not implemented yet and still under consideration: 13 continuous ckeck moves is also a win. the last player to move a pawn or capture a piece loses after 20 moves per player: Note that bare kings will normally end in a stalemate win before this limit is reached. Resolution of Check is excluded from the move limit count.
(game "Nodal Chess" (players {(player N) (player S)}) (equipment {(board (add (remove (rectangle 8 6) cells:{1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33}) edges:{{1 2} {3 4} {6 12} {11 17} {18 24} {23 29} {30 36} {35 41} {43 44} {45 46}}) use:Vertex) (piece "Pawn" Each (or {(move Step (if (= 1 (mover)) (union N (union NE NW)) (union S (union SW SE))) (to if:(is Empty (to))) (then (and (set Score Mover 0) (if (is In (last To) (sites Mover "Promotion")) (moveAgain))))) (move Step Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))) (then (and (set Score Mover 0) (if (is In (last To) (sites Mover "Promotion")) (moveAgain)))))})) (piece "King" Each (if (not (is Prev Mover)) (or {(move (from (from)) (to (difference (sites (from) {{F R F F} {F L F F} {F R F}}) (sites Around (from) All)) if:(and {(is Enemy (who at:(to))) (< 0 (count Sites in:(intersection (sites Around (from) All if:(is Empty (to))) (sites Around (to) All))))}) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Score Mover 0))))))) (move (from (from)) (to (difference (sites (from) {{F R F F} {F L F F} {F R F}}) (sites Around (from) All)) if:(and {(is Empty (to)) (< 0 (count Sites in:(intersection (sites Around (from) All if:(is Empty (to))) (sites Around (to) All))))}) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Score Mover 0))))))) (or (move Step All (to if:(and {(!= (from) (to)) (is Enemy (who at:(to))) (not (is In (to) (sites (from) {{F F} {F F R F F}})))}) (apply if:(is Enemy (who at:(to))) (remove (to) (then (set Score Mover 0)))))) (move Step All (to if:(and {(!= (from) (to)) (is Empty (to)) (not (is In (to) (sites (from) {{F F} {F F R F F}})))}) (apply if:(is Enemy (who at:(to))) (remove (to) (then (set Score Mover 0)))))) (then (moveAgain)))} (then (set Var "LF" (last From)))) (or {(move Pass) (move Step All (to if:(and {(!= (var "LF") (to)) (is Enemy (who at:(to))) (not (is In (to) (sites (var "LF") {{F F} {F F R F F}})))}) (apply if:(is Enemy (who at:(to))) (remove (to) (then (set Score Mover 0)))))) (move Step All (to if:(and {(!= (var "LF") (to)) (is Empty (to)) (not (is In (to) (sites (var "LF") {{F F} {F F R F F}})))}) (apply if:(is Enemy (who at:(to))) (remove (to) (then (set Score Mover 0))))))}))) (piece "Bishop" Each (move Slide All (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Score Mover 0)))))))) (piece "Knight" Each (move Leap {{F R F F} {F L F F}} (to if:(not (is Mover (who at:(to)))) (apply (if (is Next (who at:(to))) (remove (to) (then (set Score Mover 0))) (if (< 0 (count Pieces Next in:(intersection (sites Around (to) All) (sites Around (from) All)))) (remove (intersection (sites Around (to) All) (sites Around (from) All)) (then (set Score Mover 0))))))))) (piece "Queen" Each (move (from (from)) (to (union {(sites To (slide (from (from)) Diagonal (to if:(is Enemy (who at:(to)))))) (sites (results from:(union (sites To (slide (from (from)) Diagonal)) (sites {(from)})) to:(sites (results from:(sites Incident Cell of:Vertex at:(from)) to:(forEach (sites Incident Vertex of:Cell at:(from)) if:(not (is Mover (who at:(site))))) (to))) (to))) (forEach of:(sites (results from:(union (sites To (slide (from (from)) Diagonal)) (sites {(from)})) to:(sites (results from:(sites Incident Cell of:Vertex at:(from)) to:(forEach (sites Incident Vertex of:Cell at:(from)) if:(is Empty (site))) (to))) (to))) (sites To (slide (from (site)) Diagonal (to if:(is Enemy (who at:(to)))))))}) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Score Mover 0))) (set NextPlayer (player (next)))))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Knight1" {"B1" "E1"}) (place "Bishop1" {"A1" "F1"}) (place "Queen1" coord:"C1") (place "King1" coord:"D1" state:1) (place "Knight2" {"B8" "E8"}) (place "Bishop2" {"A8" "F8"}) (place "Queen2" coord:"C8") (place "King2" coord:"D8" state:1)}) (play (if (not (is Prev Mover)) (if (and {(not (is Threatened (id "King" Mover))) (not (is Threatened (id "King" Mover) (forEach Piece "Knight" (or (move Step Diagonal (to if:(and (is Enemy (who at:(to))) (< 0 (count Sites in:(difference (sites Around (to) Orthogonal if:(is Empty (to))) (sites Around (from) Orthogonal))))) (apply (remove (to))))) (move Step Orthogonal (to if:(and (is Enemy (who at:(to))) (< 0 (count Sites in:(difference (sites Around (to) Diagonal if:(is Empty (to))) (sites Around (from) Orthogonal))))) (apply (remove (to)))))))))}) (or (do (forEach Piece {"Queen" "Knight" "Bishop" "Pawn"}) ifAfterwards:(and {(not (is Threatened (id "King" Mover))) (not (is Threatened (id "King" Mover) (forEach Piece "Knight" (or (move Step Diagonal (to if:(and (is Enemy (who at:(to))) (< 0 (count Sites in:(difference (sites Around (to) Orthogonal if:(is Empty (to))) (sites Around (from) Orthogonal))))) (apply (remove (to))))) (move Step Orthogonal (to if:(and (is Enemy (who at:(to))) (< 0 (count Sites in:(difference (sites Around (to) Diagonal if:(is Empty (to))) (sites Around (from) Orthogonal))))) (apply (remove (to)))))))))})) (do (forEach Piece "King") ifAfterwards:(and {(not (is Threatened (id "King" Mover))) (not (is Threatened (id "King" Mover) (forEach Piece "Knight" (or (move Step Diagonal (to if:(and (is Enemy (who at:(to))) (< 0 (count Sites in:(difference (sites Around (to) Orthogonal if:(is Empty (to))) (sites Around (from) Orthogonal))))) (apply (remove (to))))) (move Step Orthogonal (to if:(and (is Enemy (who at:(to))) (< 0 (count Sites in:(difference (sites Around (to) Diagonal if:(is Empty (to))) (sites Around (from) Orthogonal))))) (apply (remove (to))))))))) (can Move (do (move Step (from (last To)) All (to if:(is In (to) (sites Around (var "LF") All includeSelf:True)))) ifAfterwards:(or (not (is Threatened (id "King" Mover) (forEach Piece {"Queen" "Knight" "Bishop" "Pawn"}))) (= (var "LF") (last To)))))})) (then (addScore Mover 1))) (do (or (do (forEach Piece {"Queen" "Knight" "Bishop" "Pawn"}) ifAfterwards:(and {(not (is Threatened (id "King" Mover))) (not (is Threatened (id "King" Mover) (forEach Piece "Knight" (or (move Step Diagonal (to if:(and (is Enemy (who at:(to))) (< 0 (count Sites in:(difference (sites Around (to) Orthogonal if:(is Empty (to))) (sites Around (from) Orthogonal))))) (apply (remove (to))))) (move Step Orthogonal (to if:(and (is Enemy (who at:(to))) (< 0 (count Sites in:(difference (sites Around (to) Diagonal if:(is Empty (to))) (sites Around (from) Orthogonal))))) (apply (remove (to)))))))))})) (do (forEach Piece "King") ifAfterwards:(and {(not (is Threatened (id "King" Mover))) (not (is Threatened (id "King" Mover) (forEach Piece "Knight" (or (move Step Diagonal (to if:(and (is Enemy (who at:(to))) (< 0 (count Sites in:(difference (sites Around (to) Orthogonal if:(is Empty (to))) (sites Around (from) Orthogonal))))) (apply (remove (to))))) (move Step Orthogonal (to if:(and (is Enemy (who at:(to))) (< 0 (count Sites in:(difference (sites Around (to) Diagonal if:(is Empty (to))) (sites Around (from) Orthogonal))))) (apply (remove (to))))))))) (can Move (do (move Step (from (last To)) All (to if:(is In (to) (sites Around (var "LF") All includeSelf:True)))) ifAfterwards:(or (not (is Threatened (id "King" Mover) (forEach Piece {"Queen" "Knight" "Bishop" "Pawn"}))) (= (var "LF") (last To)))))})) (then (addScore Mover 1))) next:(addScore Mover -1))) (if (= (id "King" Mover) (what at:(last To))) (do (forEach Piece "King" Mover) ifAfterwards:(and {(not (is Threatened (id "King" Mover))) (not (is Threatened (id "King" Mover) (forEach Piece "Knight" (or (move Step Diagonal (to if:(and (is Enemy (who at:(to))) (< 0 (count Sites in:(difference (sites Around (to) Orthogonal if:(is Empty (to))) (sites Around (from) Orthogonal))))) (apply (remove (to))))) (move Step Orthogonal (to if:(and (is Enemy (who at:(to))) (< 0 (count Sites in:(difference (sites Around (to) Diagonal if:(is Empty (to))) (sites Around (from) Orthogonal))))) (apply (remove (to)))))))))})) (move Promote (last To) (piece {"Queen" "Knight" "Bishop"}) Mover)) (then (if (and {(not (is Threatened (id "King" Prev))) (not (is Threatened (id "King" Prev) (forEach Piece "Knight" (or (move Step Diagonal (to if:(and (is Enemy (who at:(to))) (< 0 (count Sites in:(difference (sites Around (to) Orthogonal if:(is Empty (to))) (sites Around (from) Orthogonal))))) (apply (remove (to))))) (move Step Orthogonal (to if:(and (is Enemy (who at:(to))) (< 0 (count Sites in:(difference (sites Around (to) Diagonal if:(is Empty (to))) (sites Around (from) Orthogonal))))) (apply (remove (to)))))))))}) (addScore Mover 0))))) (end {(if (no Moves Next) (result Mover Win)) (if (< 13 (score Mover)) (result Mover Loss))}))) 
Same rules as Chess, just a different setup.
(game "Official Football Chess" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (or (if (is In (from) (sites Start (piece (what at:(from))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))) (then (set Pending (ahead (last To) Backward))))) (move Step (directions {FR FL}) (to if:(and (is Pending) (= (to) (value Pending)))) (then (remove (ahead (last To) Backward)))))} (then (and (if (is In (last To) (sites Mover "Promotion")) (moveAgain)) (set Counter))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (map "King" {(pair 1 "D1") (pair 2 "D8")}) (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")}) (map "RookRight" {(pair 1 "H1") (pair 2 "H8")}) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites {"B2" "C2" "E2" "F2"})) (place "Pawn2" (sites {"B7" "C7" "E7" "F7"})) (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"D2"}) (place "Bishop1" {"A2" "H2"}) (place "Queen1" coord:"E1") (place "King1" coord:"D1" state:1) (place "Rook2" {"A8" "H8"} state:1) (place "Knight2" {"D7"}) (place "Bishop2" {"A7" "H7"}) (place "Queen2" coord:"E8") (place "King2" coord:"D8" state:1)}) (play (if (is Prev Mover) (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover) (do (or (forEach Piece) (if (and (= (state at:(mapEntry "King" (mover))) 1) (not (is Threatened (id "King" Mover)))) (or (if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) W (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:True) (to if:True (apply (set State at:(from) 0))))))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) E (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:True) (to if:True (apply (set State at:(from) 0)))))))))) ifAfterwards:(not (is Threatened (id "King" Mover)))))) (end {(if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win)) (if (or (no Moves Mover) (= (counter) 99)) (result Mover Draw))}))) 
Phase Chess is a variant of Chess played on standard Chess board and Chess set, with same rules as Chess except the next player must move from a cell of the same colour just moved to if they can. It they can not, they can move any piece.
(game "Phase Chess" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (or (if (is In (from) (sites Start (piece (what at:(from))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))) (then (set Pending (ahead (last To) Backward))))) (move Step (directions {FR FL}) (to if:(and (is Pending) (= (to) (value Pending)))) (then (remove (ahead (last To) Backward)))))} (then (and (if (is In (last To) (sites Mover "Promotion")) (moveAgain)) (set Counter))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (map "King" {(pair 1 "E1") (pair 2 "E8")}) (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")}) (map "RookRight" {(pair 1 "H1") (pair 2 "H8")}) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King1" coord:"E1" state:1) (place "Rook2" {"A8" "H8"} state:1) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King2" coord:"E8" state:1)}) (play (if (is Prev Mover) (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover) (priority {(if (!= 0 (count Moves)) (do (or {(forEach Piece "Queen" (if (= (phase of:(from)) (phase of:(last To))) (move Slide (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter))))))))) (forEach Piece "Knight" (if (= (phase of:(from)) (phase of:(last To))) (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter))))))))) (forEach Piece "Bishop" (if (= (phase of:(from)) (phase of:(last To))) (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter))))))))) (forEach Piece "King" (if (= (phase of:(from)) (phase of:(last To))) (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0)))))) (forEach Piece "Rook" (if (= (phase of:(from)) (phase of:(last To))) (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0)))))) (forEach Piece "Pawn" (if (= (phase of:(from)) (phase of:(last To))) (or {(if (is In (from) (sites Start (piece (what at:(from))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))) (then (set Pending (ahead (last To) Backward))))) (move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Step (directions {FR FL}) (to if:(and (is Pending) (= (to) (value Pending)))) (then (remove (ahead (last To) Backward))))} (then (and (if (is In (last To) (sites Mover "Promotion")) (moveAgain)) (set Counter)))))) (if (= 0 (phase of:(last To))) (if (and {(= (what at:(mapEntry "King" (mover))) (id "King" Mover)) (= (state at:(mapEntry "King" (mover))) 1) (not (is Threatened (id "King" Mover)))}) (or (if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (move Slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:(is Empty (to)))))) (move Slide (from (mapEntry "King" (mover))) W (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (then (and (set State at:(last To) 0) (move Slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:True)))))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (move Slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:(is Empty (to)))))) (move Slide (from (mapEntry "King" (mover))) E (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (then (and (set State at:(last To) 0) (move Slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:True)))))))))}) ifAfterwards:(not (is Threatened (id "King" Mover) (forEach Piece))))) (do (or (forEach Piece) (if (and {(= (what at:(mapEntry "King" (mover))) (id "King" Mover)) (= (state at:(mapEntry "King" (mover))) 1) (not (is Threatened (id "King" Mover)))}) (or (if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (move Slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:(is Empty (to)))))) (move Slide (from (mapEntry "King" (mover))) W (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (then (and (set State at:(last To) 0) (move Slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:True)))))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (move Slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:(is Empty (to)))))) (move Slide (from (mapEntry "King" (mover))) E (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (then (and (set State at:(last To) 0) (move Slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:True))))))))) ifAfterwards:(not (is Threatened (id "King" Mover))))}))) (end {(if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next) (forEach Piece))))))) (result Mover Win)) (if (or (no Moves Mover) (= (counter) 100)) (result Mover Draw))}))) 
The following rules are additionally used to the chess rules: - Pawns can only advance one space on their first move. There is no en passant capturing. - A pawn can only promote to a captured piece. - There is no castling. - If 20 moves are played without a capture or promotion, the player with the most `points' on the board wins. (Pawn=1 pt., Bishop/Knight=3, Rook=5, Queen = 9.) The game starts like in the encyclopedia of Chess Variants.
(game "Quick Chess" (players {(player N) (player S)}) (equipment {(board (rectangle 6 5)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (and (remove (to)) (remember Value "CapturedPieces" (what at:(to)))))))} (then (and (if (and (is In (last To) (sites Mover "Promotion")) (can Move (or {(if (is In (id "Queen" Mover) (values Remembered "CapturedPieces")) (move Promote (last To) (piece {"Queen"}) Mover)) (if (is In (id "Knight" Mover) (values Remembered "CapturedPieces")) (move Promote (last To) (piece {"Knight"}) Mover)) (if (is In (id "Rook" Mover) (values Remembered "CapturedPieces")) (move Promote (last To) (piece {"Rook"}) Mover)) (if (is In (id "Bishop" Mover) (values Remembered "CapturedPieces")) (move Promote (last To) (piece {"Bishop"}) Mover))}))) (moveAgain)) (set Counter))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (and (remove (to) (then (set Counter))) (remember Value "CapturedPieces" (what at:(to))))))))) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (and (remove (to) (then (set Counter))) (remember Value "CapturedPieces" (what at:(to))))))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (and (remove (to) (then (set Counter))) (remember Value "CapturedPieces" (what at:(to))))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (and (remove (to) (then (set Counter))) (remember Value "CapturedPieces" (what at:(to))))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (and (remove (to) (then (set Counter))) (remember Value "CapturedPieces" (what at:(to))))))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 4)) (place "Rook1" {"E1"}) (place "Knight1" {"A1"}) (place "Bishop1" {"D1"}) (place "Queen1" coord:"C1") (place "King1" coord:"B1") (place "Rook2" {"E6"}) (place "Knight2" {"A6"}) (place "Bishop2" {"D6"}) (place "Queen2" coord:"C6") (place "King2" coord:"B6")}) (play (if (is Prev Mover) (or {(if (is In (id "Queen" Mover) (values Remembered "CapturedPieces")) (move Promote (last To) (piece {"Queen"}) Mover)) (if (is In (id "Knight" Mover) (values Remembered "CapturedPieces")) (move Promote (last To) (piece {"Knight"}) Mover)) (if (is In (id "Rook" Mover) (values Remembered "CapturedPieces")) (move Promote (last To) (piece {"Rook"}) Mover)) (if (is In (id "Bishop" Mover) (values Remembered "CapturedPieces")) (move Promote (last To) (piece {"Bishop"}) Mover))}) (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King" Mover)))) (then (if (= 19 (counter)) (and (forEach Player (forEach Site (sites Occupied by:Player) (if (= (what at:(site)) (id "Pawn" Player)) (addScore Player 1) (if (= (what at:(site)) (id "Rook" Player)) (addScore Player 5) (if (= (what at:(site)) (id "Queen" Player)) (addScore Player 9) (if (!= (what at:(site)) (id "King" Player)) (addScore Player 3))))))) (set Var "NoEnoughCapture" 1)))))) (end {(if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win)) (if (no Moves Mover) (result Mover Draw)) (if (= (var "NoEnoughCapture") 1) (byScore))}))) 
12x12 board, with yellow and green squares, with four 4x4 extensions overlapping the 2x2 squares in each corner of the board. There are two walls next to each fortress, one on the outer side of the bottom two squares of the left hand side of each fortress and one on the top edge of the two top left squares. Pieces cannot move across the wall or diagonally across the end of the wall. Four players, white and red play as a team, and black and blue as a team. Players are are arranged as follows, clockwise from the top: red, blue, white, black. Each team has the usual complement of Chess pieces, with an extra Knight, Rook, and Bishop, The pieces are as in chess, with the Kings on the players' right, on the central eight squares of each side of the board. The three extra pieces begin in the 4x4 extension at the player's right, placed anywhere they please. Kings move one square orthogonally or diagonally; Queens move any distance orthogonally or diagonally; Bishops move any distance diagonally; Knights move orthogonally one square and then diagonally another square or diagonally one square and then orthogonally one square (this is important for calculating moves near walls), jumping over any intervening pieces; Rooks move orthogonally any distance; Pawns move forward one space orthogonally, or diagonally one space forward to capture. Pawns may move two spaces on their first turn. When a pawn reaches the back row of one of the other players' sides, it is promoted to any piece. When a player moves a piece onto a space occupied by an opponent's piece, the opponent's piece is captured. When a King can be captured on the next turn, it is in check. The King must not be in check at the end of the player's next turn. If this is impossible, it is checkmate and that player's pieces are removed from the game. The team who checkmates both of their opponents wins.
(game "Russian Fortress Chess" (players {(player S) (player W) (player N) (player E)}) (equipment {(board (merge {(square 4) (shift 2 2 (square 12)) (shift 12 0 (square 4)) (shift 0 12 (square 4)) (shift 12 12 (square 4))})) (piece "Disc" Shared) (piece "King" Each (if (is Active (who at:(from))) (or (move Step Orthogonal (to if:(and (not (is Friend (who at:(to)))) (all Sites (intersection (sites Incident Edge of:Cell at:(from)) (sites Incident Edge of:Cell at:(to))) if:(is Empty Edge (site)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Step Diagonal (to if:(and (not (is Friend (who at:(to)))) (all Sites (intersection (sites Incident Vertex of:Cell at:(from)) (sites Incident Vertex of:Cell at:(to))) if:(all Sites (sites Incident Edge of:Vertex at:(site)) if:(is Empty Edge (site))))) (apply (if (is Enemy (who at:(to))) (remove (to))))))))) (piece "Queen" Each (if (is Active (who at:(from))) (or (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply if:(all Sites (sites Between (directions Cell from:(from) to:(to)) from:(from) fromIncluded:True to:(to)) if:(not (not (all Sites (intersection (sites Incident Edge of:Cell at:(site)) (sites Incident Edge of:Cell at:(ahead (site) (directions Cell from:(from) to:(to))))) if:(is Empty Edge (site)))))) (if (is Enemy (who at:(to))) (remove (to)))))) (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply if:(all Sites (sites Between (directions Cell from:(from) to:(to)) from:(from) fromIncluded:True to:(to)) if:(not (not (all Sites (intersection (sites Incident Vertex of:Cell at:(site)) (sites Incident Vertex of:Cell at:(ahead (site) (directions Cell from:(from) to:(to))))) if:(all Sites (sites Incident Edge of:Vertex at:(site)) if:(is Empty Edge (site))))))) (if (is Enemy (who at:(to))) (remove (to))))))))) (piece "Knight" Each (if (is Active (who at:(from))) (move (from (from)) (to (union (intersection (sites Around (forEach (sites Around (from) Diagonal) if:(all Sites (intersection (sites Incident Vertex of:Cell at:(from)) (sites Incident Vertex of:Cell at:(site))) if:(all Sites (sites Incident Edge of:Vertex at:(site)) if:(is Empty Edge (site))))) Orthogonal if:(and (all Sites (intersection (sites Incident Edge of:Cell at:(from)) (sites Incident Edge of:Cell at:(to))) if:(is Empty Edge (site))) (not (is Friend (who at:(to)))))) (sites Distance Orthogonal from:(from) (exact 3))) (intersection (sites Around (forEach (sites Around (from) Orthogonal) if:(all Sites (intersection (sites Incident Edge of:Cell at:(from)) (sites Incident Edge of:Cell at:(site))) if:(is Empty Edge (site)))) Diagonal if:(and (all Sites (intersection (sites Incident Vertex of:Cell at:(from)) (sites Incident Vertex of:Cell at:(to))) if:(all Sites (sites Incident Edge of:Vertex at:(site)) if:(is Empty Edge (site)))) (not (is Friend (who at:(to)))))) (sites Distance Orthogonal from:(from) (exact 3)))) (apply if:(is Enemy (who at:(to))) (remove (to))))))) (piece "Bishop" Each (if (is Active (who at:(from))) (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply if:(all Sites (sites Between (directions Cell from:(from) to:(to)) from:(from) fromIncluded:True to:(to)) if:(not (not (all Sites (intersection (sites Incident Vertex of:Cell at:(site)) (sites Incident Vertex of:Cell at:(ahead (site) (directions Cell from:(from) to:(to))))) if:(all Sites (sites Incident Edge of:Vertex at:(site)) if:(is Empty Edge (site))))))) (if (is Enemy (who at:(to))) (remove (to)))))))) (piece "Rook" Each (if (is Active (who at:(from))) (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply if:(all Sites (sites Between (directions Cell from:(from) to:(to)) from:(from) fromIncluded:True to:(to)) if:(not (not (all Sites (intersection (sites Incident Edge of:Cell at:(site)) (sites Incident Edge of:Cell at:(ahead (site) (directions Cell from:(from) to:(to))))) if:(is Empty Edge (site)))))) (if (is Enemy (who at:(to))) (remove (to)))))))) (piece "Pawn" Each (if (is Active (who at:(from))) (or {(if (is In (from) (sites Start (piece (what at:(from))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))))) (move Step Forward (to if:(and (is Empty (to)) (all Sites (intersection (sites Incident Edge of:Cell at:(from)) (sites Incident Edge of:Cell at:(to))) if:(is Empty Edge (site)))))) (move Step (directions {FR FL}) (to if:(and (is Enemy (who at:(to))) (all Sites (intersection (sites Incident Vertex of:Cell at:(from)) (sites Incident Vertex of:Cell at:(to))) if:(all Sites (sites Incident Edge of:Vertex at:(site)) if:(is Empty Edge (site))))) (apply (remove (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (moveAgain)))))) (hand Each size:3) (regions "ExtraSquare" P1 (expand origin:181 steps:3)) (regions "ExtraSquare" P2 (expand origin:191 steps:3)) (regions "ExtraSquare" P3 (expand origin:174 steps:3)) (regions "ExtraSquare" P4 (expand origin:0 steps:3)) (regions "Promotion" P1 (union (sites {"E3" "F3" "G3" "H3" "I3" "J3" "K3" "L3"}) (sites Bottom))) (regions "Promotion" P2 (union (sites {"C5" "C6" "C7" "C8" "C9" "C10" "C11" "C12"}) (sites Left))) (regions "Promotion" P3 (union (sites {"E14" "F14" "G14" "H14" "I14" "J14" "K14" "L14"}) (sites Top))) (regions "Promotion" P4 (union (sites {"N5" "N6" "N7" "N8" "N9" "N10" "N11" "N12"}) (sites Right)))}) (rules (start {(place "Disc" Edge (sites {26 35 278 279 300 325 88 89 36 37 391 382 353 344 396 397})) (set Team 1 {P1 P3}) (set Team 2 {P2 P4}) (place "King1" coord:"H14") (place "King2" coord:"N9") (place "King3" coord:"I3") (place "King4" coord:"C8") (place "Queen1" coord:"I14") (place "Queen2" coord:"N8") (place "Queen3" coord:"H3") (place "Queen4" coord:"C9") (place "Bishop1" (sites {"G14" "J14"})) (place "Bishop2" (sites {"N7" "N10"})) (place "Bishop3" (sites {"G3" "J3"})) (place "Bishop4" (sites {"C10" "C7"})) (place "Knight1" (sites {"F14" "K14"})) (place "Knight2" (sites {"N6" "N11"})) (place "Knight3" (sites {"F3" "K3"})) (place "Knight4" (sites {"C11" "C6"})) (place "Rook1" (sites {"E14" "L14"})) (place "Rook2" (sites {"N5" "N12"})) (place "Rook3" (sites {"E3" "L3"})) (place "Rook4" (sites {"C12" "C5"})) (place "Pawn1" (sites {"E13" "F13" "G13" "H13" "I13" "J13" "K13" "L13"})) (place "Pawn2" (sites {"M5" "M6" "M7" "M8" "M9" "M10" "M11" "M12"})) (place "Pawn3" (sites {"E4" "F4" "G4" "H4" "I4" "J4" "K4" "L4"})) (place "Pawn4" (sites {"D5" "D6" "D7" "D8" "D9" "D10" "D11" "D12"})) (place "Bishop1" (handSite P1)) (place "Bishop2" (handSite P2)) (place "Bishop3" (handSite P3)) (place "Bishop4" (handSite P4)) (place "Knight1" (handSite P1 1)) (place "Knight2" (handSite P2 1)) (place "Knight3" (handSite P3 1)) (place "Knight4" (handSite P4 1)) (place "Rook1" (handSite P1 2)) (place "Rook2" (handSite P2 2)) (place "Rook3" (handSite P3 2)) (place "Rook4" (handSite P4 2))}) phases:{(phase "Placing" (play (forEach Site (sites Hand Mover) (if (is Occupied (site)) (move (from (site)) (to (intersection (sites Empty) (sites Mover "ExtraSquare"))))))) (nextPhase Mover (no Pieces Mover in:(sites Hand Mover)) "Playing")) (phase "Playing" (play (if (is Prev Mover) (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover) (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King" Mover)))) (then (and {(if (and (is Active P1) (not (is Mover P1))) (if (and (is Threatened (id "King" P1)) (not (can Move (do (and (forEach Piece P1) (set NextPlayer (player 1))) ifAfterwards:(not (is Threatened (id "King" P1))))))) (remove (where (id "King" P1))))) (if (and (is Active P2) (not (is Mover P2))) (if (and (is Threatened (id "King" P2)) (not (can Move (do (and (forEach Piece P2) (set NextPlayer (player 2))) ifAfterwards:(not (is Threatened (id "King" P2))))))) (remove (where (id "King" P2))))) (if (and (is Active P3) (not (is Mover P3))) (if (and (is Threatened (id "King" P3)) (not (can Move (do (and (forEach Piece P3) (set NextPlayer (player 3))) ifAfterwards:(not (is Threatened (id "King" P3))))))) (remove (where (id "King" P3))))) (if (and (is Active P4) (not (is Mover P4))) (if (and (is Threatened (id "King" P4)) (not (can Move (do (and (forEach Piece P4) (set NextPlayer (player 4))) ifAfterwards:(not (is Threatened (id "King" P4))))))) (remove (where (id "King" P4)))))})))))} (end {(forEach NonMover if:(= (where "King" Player) -1) (result Player Loss)) (if (and {(not (is Active P1)) (not (is Active P3)) (is Active P2)}) (result P2 Win)) (if (and {(not (is Active P1)) (not (is Active P3)) (is Active P4)}) (result P4 Win)) (if (and {(not (is Active P2)) (not (is Active P4)) (is Active P1)}) (result P1 Win)) (if (and {(not (is Active P2)) (not (is Active P4)) (is Active P3)}) (result P3 Win))}))) 
 Played on an 8x8 board with pieces with specialized moves: Pawns (8): can move one space orthogonally forward, or two steps orthogonally forward on their first move, capture one space diagonally forward; Rooks (2): can move any number of spaces orthogonally; Bishops (2): can move any number of spaces diagonally; Knight (2): moves in any direction, one space orthogonally with one space forward diagonally; Queens (1): can move any number of spaces orthogonally or diagonally, cannot capture another Queen; Kings (1): can move one space orthogonally or diagonally, but on the first turn may move two squares provided it is not currently in check. The King cannot capture with this move. Castling, En Passant, and Pawn promotion allowed. Pawns promote to Queens when reaching the last row on the board only if that player's Queen has already been captured. An opponent's piece is captured by moving a player's own piece onto a space occupied by the opponent's piece. When a King can be captured on the next turn by an opponent's piece, it is in check. The King must not be in check at the end of the player's turn. If this is not possible, it is checkmate and the opponent wins. If the opponent is reduced to only a king, it is considered a win. Stalemate is also a win for the player causing the stalemate. 
(game "Scachs" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (or (if (is In (from) (sites Start (piece (what at:(from))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))) (then (set Pending (ahead (last To) Backward))))) (move Step (directions {FR FL}) (to if:(and (is Pending) (= (to) (value Pending)))) (then (remove (ahead (last To) Backward)))))} (then (if (and (= (where "Queen" Mover) -1) (is In (last To) (sites Mover "Promotion"))) (promote (last To) (piece {"Queen"}) Mover))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "King" Each (or (if (and (not (is Threatened (id "King" Mover))) (= (state at:(mapEntry "King" (mover))) 1)) (move Slide (between (exact 2)) (to if:(is Empty (to))))) (move Step (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Queen" Each (move Slide (to if:(and (not (= (what at:(to)) (id "Queen" Next))) (is Enemy (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (map "King" {(pair 1 "E1") (pair 2 "E8")}) (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")}) (map "RookRight" {(pair 1 "H1") (pair 2 "H8")}) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King1" coord:"E1" state:1) (place "Rook2" {"A8" "H8"} state:1) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King2" coord:"E8" state:1)}) (play (do (or (forEach Piece) (if (and (= (state at:(mapEntry "King" (mover))) 1) (not (is Threatened (id "King" Mover)))) (or (if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) W (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:True) (to if:True (apply (set State at:(from) 0))))))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) E (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:True) (to if:True (apply (set State at:(from) 0)))))))))) ifAfterwards:(not (is Threatened (id "King" Mover))))) (end {(if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win)) (if (= 1 (count Pieces Next)) (result Mover Win)) (if (no Moves Next) (result Mover Win))}))) 
8x8 board. The pieces move as follows, with the number per player: 1 x King (king): moves one space orthogonally or diagonally. The King may leap one, two, or three squares on its first move if it has not yet been checked and does not hop over an opponent's piece. The King cannot make this leap over an opponent's piece. A capture cannot be made with this special first move. 1 x Queen: One square diagonally. On its first move, the Queen may jump diagonally two squares. The Queen cannot capture when making this move. 2 x Rook: Any number of spaces orthogonally. 2 x Bishop: Two squares diagonally, jumping over the first. Cannot capture another Bishop. 2 x Knight: Moves as a chess knight. 8 x Pawn: Moves one space forward orthogonally; one space forward diagonally to capture. The Rook's, King's and Queen's Pawns may move two spaces on its first move. The King's and Queen's Pawns are restricted in having this ability only if no piece on the board has been captured. Promoted to Queen when reaching the eighth rank, and may make the Queen's leap on its first move after being promoted, but cannot capture with this move. No castling. An opponent's piece is captured by moving a player's own piece onto a space occupied by the opponent's piece. When a King can be captured on the next turn by an opponent's piece, it is in check. The King must not be in check at the end of the player's turn. If this is not possible, it is checkmate and the opponent wins. 
(game "Schachzabel" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "King" Each (or (move Step (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))) (if (= 1 (state at:(from))) (move Hop (between (range 1 3) if:(not (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Bishop" Each (move Hop Diagonal (between if:True) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Queen" Each (or (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0)))) (if (= 1 (state at:(from))) (move Hop Diagonal (between if:True) (to if:(is Empty (to))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (if (and {(is In (from) (sites Start (piece (what at:(from))))) (= 1 (state at:(from))) (= 32 (count Sites in:(sites Occupied by:All)))}) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to)))))} (then (if (is In (last To) (sites Mover "Promotion")) (and (promote (last To) (piece (id "Queen" Mover))) (set State at:(last To) 1)))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites {"A2" "D2" "E2" "H2"}) state:1) (place "Pawn2" (sites {"A7" "D7" "E7" "H7"}) state:1) (place "Pawn1" (sites {"B2" "C2" "F2" "G2"})) (place "Pawn2" (sites {"B7" "C7" "F7" "G7"})) (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1" state:1) (place "King1" coord:"E1" state:1) (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8" state:1) (place "King2" coord:"E8" state:1)}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King" Mover))) (then (if (and (= 1 (state at:(where "King" Next))) (is Threatened (id "King" Next))) (set State at:(where "King" Next) 0))))) (end (if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win))))) 
Shafran Chess is played on a 'narrow' hexagonal board that can be thought of as a hexagonal board of size 6 with some outer spaces removed. The board has 70 spaces. Piece Movement: * Queens, Rooks, Bishops, and Knights move as in Glinski Chess. - Queens slide in any of the 12 directions. - Rooks slide in any of the 6 adjacent directions. - Bishops slide in any of the 6 'diagonal' directions. - Knights move two spaces in an adjacent direction, then one space in another direction. * Kings move as in Glinski Chess, but can also castle. In 'Long Castling', the King moves three spaces toward its queenside Rook and the Rook moves two spaces in the opposite direction. In 'Short Castling', the King moves two spaces toward its bishopside Rook (i.e., the one on the side of the board with two bishops), and the Rook moves three spaces. Castling can only take place when neither the King nor the Rook being moved have moved before. * Pawns can advance one space forward without capturing. A Pawn on a Pawn start space can advance any number of spaces, up to the middle row of the board. Thus the outermost Pawns on their first moves can only advance one space, while the Pawns in the three innermost columns can advance up to three spaces. Pawns capture 'diagonally forward' (i.e., to a space ahead connected by an edge, and having the same colour). En passant capture works as in Glinski chess, except that if the opponent just advanced a Pawn three spaces, then the next player can perform en passant capture by landing a Pawn on either of the two spaces that the opponent Pawn just skipped over. On reaching the farthest rank in a given file, Pawns are promoted to a Queen, Rook, Bishop, or Knight, as the player chooses.
(game "Shafran Chess" (players {(player N) (player S)}) (equipment {(board (remove (rotate 90 (hex 6)) cells:{0 1 2 3 4 5 85 86 87 88 89 90 84 77 69 60 50 39 29 20 12})) (piece "King" Each (or {(move Step All (to if:(or (is In (to) (sites Empty)) (is Enemy (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0)))) (if (and {(= (what at:(mapEntry "King" (mover))) (id "King" Mover)) (= (state at:(mapEntry "King" (mover))) 1) (not (is Threatened (id "King" Mover)))}) (or {(if (is Mover P1) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (move Slide (from (mapEntry "RookRight" (mover))) WSW (between (exact 2) if:(is In (to) (sites Empty)))))) (move Slide (from (mapEntry "King" (mover))) ENE (between (exact 3) if:(and (is In (to) (sites Empty)) (not (is Threatened (id "King" Mover) at:(to))))) (then (and (set State at:(last To) 0) (move Slide (from (mapEntry "RookRight" (mover))) WSW (between (exact 2) if:True)))))) (if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (move Slide (from (mapEntry "RookLeft" (mover))) ENE (between (exact 2) if:(is In (to) (sites Empty)))))) (move Slide (from (mapEntry "King" (mover))) WSW (between (exact 3) if:(and (is In (to) (sites Empty)) (not (is Threatened (id "King" Mover) at:(to))))) (then (and (set State at:(last To) 0) (move Slide (from (mapEntry "RookLeft" (mover))) ENE (between (exact 2) if:True))))))) (if (is Mover P1) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (move Slide (from (mapEntry "RookRight" (mover))) WSW (between (exact 3) if:(is In (to) (sites Empty)))))) (move Slide (from (mapEntry "King" (mover))) ENE (between (exact 2) if:(and (is In (to) (sites Empty)) (not (is Threatened (id "King" Mover) at:(to))))) (then (and (set State at:(last To) 0) (move Slide (from (mapEntry "RookRight" (mover))) WSW (between (exact 3) if:True)))))) (if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (move Slide (from (mapEntry "RookLeft" (mover))) ENE (between (exact 3) if:(is In (to) (sites Empty)))))) (move Slide (from (mapEntry "King" (mover))) WSW (between (exact 2) if:(and (is In (to) (sites Empty)) (not (is Threatened (id "King" Mover) at:(to))))) (then (and (set State at:(last To) 0) (move Slide (from (mapEntry "RookLeft" (mover))) ENE (between (exact 3) if:True))))))) (if (is Mover P1) (if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (move Slide (from (mapEntry "RookLeft" (mover))) ESE (between (exact 2) if:(is In (to) (sites Empty)))))) (move Slide (from (mapEntry "King" (mover))) WNW (between (exact 3) if:(and (is In (to) (sites Empty)) (not (is Threatened (id "King" Mover) at:(to))))) (then (and (set State at:(last To) 0) (move Slide (from (mapEntry "RookLeft" (mover))) ESE (between (exact 2) if:True)))))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (move Slide (from (mapEntry "RookRight" (mover))) WNW (between (exact 2) if:(is In (to) (sites Empty)))))) (move Slide (from (mapEntry "King" (mover))) ESE (between (exact 3) if:(and (is In (to) (sites Empty)) (not (is Threatened (id "King" Mover) at:(to))))) (then (and (set State at:(last To) 0) (move Slide (from (mapEntry "RookRight" (mover))) WNW (between (exact 2) if:True))))))) (if (is Mover P1) (if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (move Slide (from (mapEntry "RookLeft" (mover))) ESE (between (exact 3) if:(is In (to) (sites Empty)))))) (move Slide (from (mapEntry "King" (mover))) WNW (between (exact 2) if:(and (is In (to) (sites Empty)) (not (is Threatened (id "King" Mover) at:(to))))) (then (and (set State at:(last To) 0) (move Slide (from (mapEntry "RookLeft" (mover))) ESE (between (exact 3) if:True)))))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (move Slide (from (mapEntry "RookRight" (mover))) WNW (between (exact 3) if:(is In (to) (sites Empty)))))) (move Slide (from (mapEntry "King" (mover))) ESE (between (exact 2) if:(and (is In (to) (sites Empty)) (not (is Threatened (id "King" Mover) at:(to))))) (then (and (set State at:(last To) 0) (move Slide (from (mapEntry "RookRight" (mover))) WNW (between (exact 3) if:True)))))))}))})) (piece "Queen" Each (move Slide All (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (if (is In (from) (sites Start (piece (what at:(from))))) (or {(if (is In (from) (sites Mover "Pawn_Step2Cells")) (move Hop (from) Forward (between (range 1 1) if:(is Empty (between)) (apply (set Pending (between)))) (to if:(is Empty (to))) (then (set Var (last To))))) (if (is In (from) (sites Mover "Pawn_Step3Cells")) (move Hop (from) Forward (between (range 1 2) if:(is Empty (between)) (apply (set Pending (between)))) (to if:(is Empty (to))) (then (set Var (last To)))))})) (move Step (if (is Mover P1) (directions {NNW NNE}) (directions {SSW SSE})) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Step (if (is Mover P1) (directions {NNW NNE}) (directions {SSW SSE})) (to if:(is In (to) (sites Pending))) (then (remove (var))))} (then (and (if (is In (last To) (sites Mover "PromotionZone")) (moveAgain)) (set Counter))))) (map "King" {(pair 1 "A1") (pair 2 "J10")}) (map "RookLeft" {(pair 1 "A5") (pair 2 "F10")}) (map "RookRight" {(pair 1 "E1") (pair 2 "J6")}) (regions "Pawn_Step2Cells" P1 (sites {"B5" "B4" "B3" "B2" "C2" "D2" "E2"})) (regions "Pawn_Step2Cells" P2 (sites {"F9" "G9" "H9" "I9" "I8" "I7" "I6"})) (regions "Pawn_Step3Cells" P1 (sites {"B3" "B2" "C2"})) (regions "Pawn_Step3Cells" P2 (sites {"H9" "I9" "I8"})) (regions "PromotionZone" P1 (union (sites Side NW) (sites Side NE))) (regions "PromotionZone" P2 (union (sites Side SW) (sites Side SE))) (regions "Region-Dark" (sites Phase 2)) (regions "Region-Light" (sites Phase 0)) (regions "Region-Medium" (sites Phase 1))}) (rules (start {(place "King1" coord:"A1" state:1) (place "Queen1" coord:"A2") (place "Rook1" {"A5" "E1"} state:1) (place "Bishop1" {"A3" "B1" "D1"}) (place "Knight1" {"A4" "C1"}) (place "King2" coord:"J10" state:1) (place "Queen2" coord:"J9") (place "Rook2" {"F10" "J6"} state:1) (place "Bishop2" {"G10" "I10" "J8"}) (place "Knight2" {"H10" "J7"}) (place "Pawn1" {"B6" "B5" "B4" "B3" "B2" "C2" "D2" "E2" "F2"}) (place "Pawn2" {"E9" "F9" "G9" "H9" "I9" "I8" "I7" "I6" "I5"})}) phases:{(phase "Movement" (play (if (is Prev Mover) (move Promote (last To) (piece {"Queen" "Rook" "Bishop" "Knight"}) Mover) (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King" Mover)))))) (end {(if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win)) (if (or (no Moves Mover) (= (counter) 100)) (result Mover Draw))}))})) 
Played on an 8x8 board with pieces with specialized moves: Pawns (8): can move one space orthogonally forward, or two steps orthogonally forward on their first move, capture one space diagonally forward; Rooks (2): can move any number of spaces orthogonally; Bishops (2): can move any number of spaces diagonally; Knight (2): moves in any direction, one space orthogonally with one space forward diagonally; Queens (1): can move any number of spaces orthogonally or diagonally; Kings (1): can move one space orthogonally or diagonally. Castling, En Passant, and Pawn promotion allowed. Play begins by each player moving two of their pieces in the same turn, provided that neither enter the opponent's half of the board. An opponent's piece is captured by moving a player's own piece onto a space occupied by the opponent's piece. When a King can be captured on the next turn by an opponent's piece, it is in check. The King must not be in check at the end of the player's turn. If this is not possible, it is checkmate and the opponent wins. 
(game "Shakhmaty" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (or {(if (is In (from) (sites Start (piece (what at:(from))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))) (then (set Pending (ahead (last To) Backward))))) (move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Step (directions {FR FL}) (to if:(and (is Pending) (= (to) (value Pending)))) (then (remove (ahead (last To) Backward))))} (then (if (is In (last To) (sites Mover "Promotion")) (moveAgain))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (map "King" {(pair 1 "E1") (pair 2 "E8")}) (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")}) (map "RookRight" {(pair 1 "H1") (pair 2 "H8")}) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom)) (regions "Half" P1 (expand (sites Bottom) steps:3)) (regions "Half" P2 (expand (sites Top) steps:3))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King1" coord:"E1" state:1) (place "Rook2" {"A8" "H8"} state:1) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King2" coord:"E8" state:1)}) phases:{(phase "Opening" (play (do (forEach Piece) ifAfterwards:(and (is In (last To) (sites Mover "Half")) (not (is Threatened (id "King" Mover)))) (then (if (not (is Prev Mover)) (moveAgain))))) (nextPhase Mover (is Prev Mover) "Playing")) (phase "Playing" (play (if (is Prev Mover) (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover) (do (or (forEach Piece) (if (and (= (state at:(mapEntry "King" (mover))) 1) (not (is Threatened (id "King" Mover)))) (or (if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) W (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:True) (to if:True (apply (set State at:(from) 0))))))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) E (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:True) (to if:True (apply (set State at:(from) 0)))))))))) ifAfterwards:(not (is Threatened (id "King" Mover)))))))} (end (if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win))))) 
Played on an 8x8 board with pieces with specialized moves: Pawns (8): can move one space forward or two on their first turn, capture diagonally one space forward; Rooks (2): can move any number of spaces orthogonally; Bishops (2): can move any number of spaces diagonally; Knight (2): moves in any direction, one space orthogonally with one space forward diagonally; Queens (1): can move any number of spaces orthogonally or diagonally; Kings (1): can move one space orthogonally or diagonally. Players move three pieces on their first turn. Players capture pieces by moving onto a space occupied by an opponent's piece. When a king can be captured on the next turn, it is in check, and the king must not be in check at the beginning of the opponent's next turn. If this is not possible, it is checkmate, and the opponent wins. 
(game "Shatera" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (or {(if (is In (from) (sites Start (piece (what at:(from))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))))) (move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))})) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King1" coord:"E1") (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King2" coord:"E8")}) phases:{(phase "Opening" (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King" Mover))) (then (and (set Value Mover (+ 1 (value Player Mover))) (if (!= (value Player Mover) 1) (moveAgain)))))) (nextPhase Mover (= 2 (value Player Mover)) "Playing")) (phase "Playing" (play (if (is Prev Mover) (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover) (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King" Mover)))))))} (end (if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win))))) 
8x8 board. The pieces move as follows, with the number per player: 1 x King (king): moves one space orthogonally or diagonally. 1 x Queen: One square diagonally. 2 x Rook: Any number of spaces orthogonally. 2 x Fil (elephant): Two squares diagonally, jumping over the first. Cannot capture another Fil. 2 x Knight: Moves as a chess knight. 8 x Pawn: Moves one space forward orthogonally; one space forward diagonally to capture. No en passant. Promoted to Queen when reaching the eighth rank. The pieces begin in the following position: Fils on the third and sixth spaces of the first row, King on the fifth space of the first row, Rooks on the third and sixth spaces of the second row, Knights on the fourth and fifth spaces of the second row, Pawns on the third row, the Queen sharing a space with the Pawn in the fifth space. Kings are on the same column. The only time two pieces can be on the same space is in this initial arrangement. No castling. An opponent's piece is captured by moving a player's own piece onto a space occupied by the opponent's piece. When a King can be captured on the next turn by an opponent's piece, it is in check. The King must not be in check at the end of the player's turn. If this is not possible, it is checkmate and the opponent wins. Stalemate results in a win for that player causing it. Capturing all of an opponent's pieces except the King also results in a win. 
(game "Short Assize" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "King" Each (move Step (from (from) level:(level)) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (forEach Level (to) (remove (to) level:(level)))))))) (piece "Rook" Each (move Slide (from (from) level:(level)) Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (forEach Level (to) (remove (to) level:(level)))))))) (piece "Bishop" Each (move Hop (from (from) level:(level)) Diagonal (between if:True) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (forEach Level (to) (remove (to) level:(level)))))))) (piece "Knight" Each (move Leap (from (from) level:(level)) {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (forEach Level (to) (remove (to) level:(level)))))))) (piece "Queen" Each (move Step (from (from) level:(level)) Diagonal (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (forEach Level (to) (remove (to) level:(level)))))))) (piece "Pawn" Each (or (move Step (from (from) level:(level)) Forward (to if:(is Empty (to)))) (move Step (from (from) level:(level)) (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (forEach Level (to) (remove (to) level:(level)))))) (then (if (is In (last To) (sites Mover "Promotion")) (promote (last To) (piece (id "Queen" Mover))))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Bishop1" (sites {"C1" "F1"})) (place "Rook1" (sites {"C2" "F2"})) (place "Knight1" (sites {"D2" "E2"})) (place "King1" coord:"E1") (place Stack "Pawn1" (sites Row 2)) (place Stack "Queen1" (sites {"D3"})) (place "Bishop2" (sites {"C8" "F8"})) (place "Rook2" (sites {"C7" "F7"})) (place "Knight2" (sites {"D7" "E7"})) (place "King2" coord:"E8") (place Stack "Pawn2" (sites Row 5)) (place Stack "Queen2" (sites {"D6"}))}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King" Mover))))) (end {(if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win)) (if (no Moves Next) (result Mover Win)) (if (= (count Pieces Next) 1) (result Mover Win))}))) 
TODO 
(game "Social Distance Chess" (players {(player N) (player S)}) (equipment {(board (rectangle 8 15)) (piece "Pawn" Each (or {(if (is In (from) (sites Start (piece (what at:(from))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))) (then (set Pending (ahead (last To) Backward))))) (move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Step (directions {FR FL}) (to if:(and (is Pending) (= (to) (value Pending)))) (then (remove (ahead (last To) Backward))))} (then (and (if (is In (last To) (sites Mover "Promotion")) (moveAgain)) (set Counter))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (map "King" {(pair 1 "I1") (pair 2 "I8")}) (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")}) (map "RookRight" {(pair 1 "O1") (pair 2 "O8")}) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" {"A3" "C3" "E3" "G3" "I3" "K3" "M3" "O3"}) (place "Pawn2" {"A6" "C6" "E6" "G6" "I6" "K6" "M6" "O6"}) (place "Rook1" {"A1" "O1"} state:1) (place "Knight1" {"C1" "M1"}) (place "Bishop1" {"E1" "K1"}) (place "Queen1" {"G1"}) (place "King1" {"I1"} state:1) (place "Rook2" {"A8" "O8"} state:1) (place "Knight2" {"C8" "M8"}) (place "Bishop2" {"E8" "K8"}) (place "Queen2" {"G8"}) (place "King2" {"I8"} state:1)}) (play (if (is Prev Mover) (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover) (do (or (forEach Piece) (if (and {(= (what at:(mapEntry "King" (mover))) (id "King" Mover)) (= (state at:(mapEntry "King" (mover))) 1) (not (is Threatened (id "King" Mover)))}) (or (if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (move Slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:(is Empty (to)))))) (move Slide (from (mapEntry "King" (mover))) W (between (exact 4) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (then (and (set State at:(last To) 0) (move Slide (from (mapEntry "RookLeft" (mover))) E (between (exact 5) if:True)))))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (move Slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:(is Empty (to)))))) (move Slide (from (mapEntry "King" (mover))) E (between (exact 4) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (then (and (set State at:(last To) 0) (move Slide (from (mapEntry "RookRight" (mover))) W (between (exact 4) if:True))))))))) ifAfterwards:(not (is Threatened (id "King" Mover)))))) (end {(if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win)) (if (or (no Moves Mover) (= (counter) 100)) (result Mover Draw))}))) 
<b>The Pieces</b> - <i>White</i> (the Persians) has orthodox chess pieces in standard spaces: 2 Rooks (A1, H1); 2 Knights (B1, G1); 2 Bishops (C1, F1); 1 Queen (D1); 1 King (E1); 8 Pawns (A2-H2). - <i>Black</i> (the Spartans) has: 2 Lieutenants (A8, H8); 1 General (B8); 1 Warlord (G8); 2 Kings (C8, F8); 2 Captains (D8, E8); 8 Hoplites (A7-H7). <b>The Moves</b> - <i>Pawns</i> can move (but not capture) one space forward. On their first move they can move two spaces forward. They capture one space diagonally forward. There is no en passant rule. - <i>Rooks</i> can move and capture any number of spaces orthogonally. - <i>Bishops</i> can move and capture any number of spaces diagonally. - <i>Knights</i> can move one space orthogonally with one space forward diagonally leaping over intervening pieces and capturing what they land on. - The <i>Queen</i> can move and capture any number of spaces orthogonally or diagonally. - <i>Kings</i> can move and capture one space orthogonally or diagonally. - <i>Lieutenants</i> (shown as crosses) can move and capture diagonally upto two spaces, jumping over any piece if necessary. They can also move (but not capture) one space sideways. - The <i>General</i> (shown as an upside-down rook) can move and capture any number of spaces orthogonally or one space diagonally. - The <i>Warlord</i> (shown as an upside-down bishop) can move and capture any number of spaces diagonally or like a knight. - <i>Captains</i> (shown as squares) can move and capture upto spaces orthogonally and may jump if necessary. - <i>Hoplites</i> (shown as an upside-down pawns) can move (but not capture) one space diagonally forward. On their first move they can move two spaces diagonally forward, jumping if necessary. They capture one space forward. <b>Winning</b> The Spartan and Persian have different victory conditions. <i>Spartan Victory</i>: The Spartan wins when the Persian King is checkmated as in orthodox chess. <i>Persians Victory</i>: The Persian wins once one of the Spartan Kings is captured and the remaining Spartan King is checkmated or when both Spartan Kings are placed under simultaneous attack (duple-check) and neither King can be removed from attack on the next move (Duple-Check and Mate). <b>First Move</b> The Persians, being the aggressors historically and White, always move first. <b>Check Immunity</b> When the Spartan has two Kings in play a Spartan King is immune from check. Thus, the Spartan may move a King onto an enemy attacked square, leave a King under attack or move a piece that would expose a King to attack. <b>Duple-Check & Mate</b> If both Spartan Kings are placed under simultaneous attack this is a form of check called duple-check. It is illegal for the Spartan to make a move that will place both of his Kings underattack. With both Kings under attack, the Spartan loses if on his move he is unable to remove at least one King from attack. In such case the game ends in checkmate. <b>Promotion</b> A hoplite, upon reaching its 8th rank, may promote to any Spartan piece including a King but only if the Spartan has only one king in play. A pawn, upon reaching its 8th rank, may promote to any Persian piece apart from the King. <b>Capturing en passant</b> There is no capturing en passant in Spartan Chess. <b>Castling</b> Spartan Kings may not castle. Persian Kings may castle as normal.
(game "Spartan Chess" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" P1 (or {(if (is In (from) (sites Start (piece (what at:(from))))) (move Hop Forward (between if:(is Empty (between))) (to if:(is Empty (to))))) (move Step Forward (to if:(is Empty (to)))) (move Step (directions {FL FR}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (and (if (is In (last To) (sites Mover "Promotion")) (moveAgain)) (set Counter))))) (piece "Hoplite" P2 (or {(if (is In (from) (sites Start (piece (what at:(from))))) (move Hop (directions {FL FR}) (to if:(is Empty (to))))) (move Step (directions {FL FR}) (to if:(is Empty (to)))) (move Step Forward (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (and (if (is In (last To) (sites Mover "Promotion")) (moveAgain)) (set Counter))))) (piece "Rook" P1 (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "General" P2 (or (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter))))))) (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter))))))))) (piece "Warlord" P2 (or (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter))))))) (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter))))))))) (piece "Lieutenant" P2 (or {(move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter))))))) (move Hop Diagonal (to if:(or (is Enemy (who at:(to))) (is Empty (to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter))))))) (move Step (directions {W E}) (to if:(is Empty (to))))})) (piece "Captain" P2 (or (move Step Orthogonal (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter))))))) (move Hop Orthogonal (to if:(or (is Enemy (who at:(to))) (is Empty (to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter))))))))) (piece "King" Each (move Step Adjacent (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Bishop" P1 (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Knight" P1 (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Queen" P1 (move Slide (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Hoplite2" (sites Row 6)) (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King1" coord:"E1" state:1) (place "Lieutenant2" {"A8" "H8"}) (place "Warlord2" {"G8"}) (place "General2" {"B8"}) (place "King2" {"C8" "F8"} state:0) (place "Captain2" {"D8" "E8"})}) (play (if (is Prev Mover) (if (= (mover) (id P1)) (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover) (if (= 1 (count Sites in:(sites Occupied by:P2 component:"King"))) (move Promote (last To) (piece {"King" "Captain" "General" "Warlord" "Lieutenant"}) Mover) (move Promote (last To) (piece {"Captain" "General" "Warlord" "Lieutenant"}) Mover))) (do (or (forEach Piece) (if (and {(= (what at:4) (id "King" Mover)) (= (state at:4) 1) (not (is Threatened (id "King" Mover)))}) (or (if (and (= (state at:0) 1) (can Move (move Slide (from 0) E (between (exact 3) if:(is Empty (to)))))) (move Slide (from 4) W (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (then (and (set State at:(last To) 0) (move Slide (from 0) E (between (exact 3) if:True)))))) (if (and (= (state at:7) 1) (can Move (move Slide (from 7) W (between (exact 2) if:(is Empty (to)))))) (move Slide (from 4) E (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (then (and (set State at:(last To) 0) (move Slide (from 7) W (between (exact 2) if:True))))))))) ifAfterwards:(not (all Sites (sites Occupied by:Mover component:"King") if:(is Threatened at:(site))))))) (end {(if (and (all Sites (sites Occupied by:Next component:"King") if:(is Threatened at:(site))) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (all Sites (sites Occupied by:Next component:"King") if:(is Threatened at:(site)))))))) (result Mover Win)) (if (or (no Moves Mover) (= (counter) 100)) (result Mover Draw))}))) 
Starchess is played on a star-shaped hexagonal board that can be thought of as a hexagon-shaped board with each side having length 6, but with four spaces removed from each corner. The board has 37 spaces. Starchess starts off with the non-Pawn pieces being placed behind the Pawns. This happens one piece at a time, in alternating turns, until all non-Pawn pieces have been placed. Then the 'movement phase' of the game begins as usual. Piece Movement: * Knights move as in Glinsky Chess. - They move two spaces in any adjacent direction, then one space in another direction. * Kings can move one space in any of those same six adjacent directions. There is no castling. * Queens can slide in any of the six adjacent directions from their current space---North, South, or 60 degrees off either of those. * Rooks can slide forward or backward only in their given column. * Bishops can slide in only four of the adjacent directions: they cannot slide North or South. * Pawns can advance one space forward without capturing. A Pawn on a Pawn start space can advance two spaces forward, even if it has previously moved (by capturing) to a different Pawn start space than it started the game on. Pawns capture by moving to one of the two adjacent spaces 60 degrees left or right of forward. On reaching the farthest rank in any of the innermost five columns, Pawns are promoted to a Queen, Rook, Bishop, or Knight, as the player chooses. The game ends on a checkmate or stalemate. Some terminology: a Pawn off to the side, in one of the two spaces at the extremes of the middle row is called a 'mummy', while a Pawn in one of the spaces adjacent to that is called a 'dead Pawn'. Mummies and dead Pawns cannot be promoted until they return to one of the innermost five columns.
(game "Starchess" (players {(player N) (player S)}) (equipment {(board (rotate 30 (hex Star 2))) (piece "King" Each (move Step Orthogonal (to if:(or (is In (to) (sites Empty)) (is Enemy (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Queen" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Rook" Each (move Slide (directions {N S}) (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Bishop" Each (move Slide (directions {WNW ENE WSW ESE}) (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (if (is In (from) (sites Start (piece (what at:(from))))) (move Hop Forward (between if:(is In (between) (sites Empty))) (to if:(is In (to) (sites Empty))) (then (and (set Pending (ahead (last To) Backward)) (set Var (last To)))))) (move Step (if (is Mover P1) (directions {WNW ENE}) (directions {WSW ESE})) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Step (if (is Mover P1) (directions {WNW ENE}) (directions {WSW ESE})) (to if:(and (is Pending) (= (to) (value Pending)))) (then (remove (var))))} (then (and (if (is In (last To) (sites Mover "PromotionZone")) (moveAgain)) (set Counter))))) (hand Each size:5) (regions "Home" P1 (sites {"A3" "B3" "C3" "C2" "C1"})) (regions "Home" P2 (sites {"G9" "G8" "G7" "H7" "I7"})) (regions "PromotionZone" P1 (sites P2 "Home")) (regions "PromotionZone" P2 (sites P1 "Home")) (regions "Region-Dark" (sites Phase 1)) (regions "Region-Light" (sites Phase 2)) (regions "Region-Medium" (sites Phase 0))}) (rules (start {(place "King" "Hand" count:1) (place "Queen" "Hand" count:1) (place "Rook" "Hand" count:1) (place "Bishop" "Hand" count:1) (place "Knight" "Hand" count:1) (place "Pawn1" {"B4" "C4" "D4" "D3" "D2"}) (place "Pawn2" {"F8" "F7" "F6" "G6" "H6"})}) phases:{(phase "Placement" (play (move (from (sites Occupied by:Mover container:(mover))) (to (intersection (sites Mover "Home") (sites Empty))))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (if (is Prev Mover) (move Promote (last To) (piece {"Queen" "Rook" "Bishop" "Knight"}) Mover) (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King" Mover)))))) (end {(if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win)) (if (or (no Moves Mover) (= (counter) 100)) (result Mover Draw))}))})) 
The standard conventions of chess apply, including normal castling and en passant. Pawns promote on the 9th ranks and may promote to missile. The missile moves and captures as a chess king: one step in any direction. It may be captured like any other piece. Missile launches A player can launch a missile at any time to any board square, occupied or not. The launched missile "destroys" (eliminates from play) all pieces (except kings, which are immune) of either colour on the target square, as well as on all immediately surrounding squares. The missile itself is also destroyed in the launch. Launching a missile constitutes a turn. There are two prerequisites for launching a missile: - A non-pawn piece must have been captured at some point prior in the game. - The missile cannot be under attack by an enemy piece at time of launch.
(game "Stratomic" (players {(player N) (player S)}) (equipment {(board (square 10)) (piece "Pawn" Each (or {(if (is In (from) (sites Start (piece (what at:(from))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))) (then (set Pending (ahead (last To) Backward))))) (move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (and (if (and (not (= (var "NonPawnPieceCapture") 1)) (!= (id "Pawn" Next) (what at:(to)))) (set Var "NonPawnPieceCapture" 1)) (remove (to)))))) (move Step (directions {FR FL}) (to if:(and (is Pending) (= (to) (value Pending)))) (then (and (if (and (not (= (var "NonPawnPieceCapture") 1)) (!= (id "Pawn" Next) (what at:(ahead (last To) Backward)))) (set Var "NonPawnPieceCapture" 1)) (remove (ahead (last To) Backward)))))} (then (and (if (is In (last To) (sites Mover "Promotion")) (moveAgain)) (set Counter))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (and (if (and (not (= (var "NonPawnPieceCapture") 1)) (!= (id "Pawn" Next) (what at:(to)))) (set Var "NonPawnPieceCapture" 1)) (remove (to) (then (set Counter))))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (and (if (and (not (= (var "NonPawnPieceCapture") 1)) (!= (id "Pawn" Next) (what at:(to)))) (set Var "NonPawnPieceCapture" 1)) (remove (to) (then (set Counter))))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (and (if (and (not (= (var "NonPawnPieceCapture") 1)) (!= (id "Pawn" Next) (what at:(to)))) (set Var "NonPawnPieceCapture" 1)) (remove (to) (then (set Counter))))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (and (if (and (not (= (var "NonPawnPieceCapture") 1)) (!= (id "Pawn" Next) (what at:(to)))) (set Var "NonPawnPieceCapture" 1)) (remove (to) (then (set Counter))))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (and (if (and (not (= (var "NonPawnPieceCapture") 1)) (!= (id "Pawn" Next) (what at:(to)))) (set Var "NonPawnPieceCapture" 1)) (remove (to) (then (set Counter))))))))) (piece "NuclearBomb" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (and (if (and (not (= (var "NonPawnPieceCapture") 1)) (!= (id "Pawn" Next) (what at:(to)))) (set Var "NonPawnPieceCapture" 1)) (remove (to) (then (set Counter))))))))) (map "King" {(pair 1 "F2") (pair 2 "E9")}) (map "RookLeft" {(pair 1 "A2") (pair 2 "J9")}) (map "RookRight" {(pair 1 "J2") (pair 2 "A9")}) (regions "Promotion" P1 (sites Row 8)) (regions "Promotion" P2 (sites Row 1))}) (rules (start {(place "Pawn1" (sites Row 2)) (place "Pawn2" (sites Row 7)) (place "NuclearBomb1" (sites {"A2" "J2"})) (place "Rook1" {"B2" "I2"} state:1) (place "Knight1" {"C2" "H2"}) (place "Bishop1" {"D2" "G2"}) (place "Queen1" coord:"E2") (place "King1" coord:"F2" state:1) (place "NuclearBomb2" (sites {"A9" "J9"})) (place "Rook2" {"B9" "I9"} state:1) (place "Knight2" {"C9" "H9"}) (place "Bishop2" {"D9" "G9"}) (place "Queen2" coord:"F9") (place "King2" coord:"E9" state:1)}) (play (if (is Prev Mover) (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook" "NuclearBomb"}) Mover) (do (or (if (= (var "NonPawnPieceCapture") 1) (move Select (from (sites Occupied by:Mover component:"NuclearBomb") if:(not (is Threatened (id "NuclearBomb" Mover) at:(from) (forEach Piece)))) (to (sites Board)) (then (and (forEach Site (sites Around (last To) includeSelf:True) (if (and {(is Occupied (site)) (!= (what at:(site)) (id "King" P1)) (!= (what at:(site)) (id "King" P2))}) (remove (site)))) (remove (last From)))))) (or (forEach Piece) (if (and (= (state at:(mapEntry "King" (mover))) 1) (not (is Threatened (id "King" Mover) (forEach Piece)))) (or (if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) W (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to) (forEach Piece))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:True) (to if:True (apply (set State at:(from) 0))))))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) E (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to) (forEach Piece))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:True) (to if:True (apply (set State at:(from) 0))))))))))) ifAfterwards:(not (is Threatened (id "King" Mover) (or (forEach Piece) (if (and (= (state at:(mapEntry "King" (mover))) 1) (not (is Threatened (id "King" Mover) (forEach Piece)))) (or (if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) W (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to) (forEach Piece))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:True) (to if:True (apply (set State at:(from) 0))))))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) E (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to) (forEach Piece))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:True) (to if:True (apply (set State at:(from) 0))))))))))))))) (end {(if (and (is Threatened (id "King" Next) (or (forEach Piece) (if (and (= (state at:(mapEntry "King" (mover))) 1) (not (is Threatened (id "King" Mover) (forEach Piece)))) (or (if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) W (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to) (forEach Piece))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:True) (to if:True (apply (set State at:(from) 0))))))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) E (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to) (forEach Piece))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:True) (to if:True (apply (set State at:(from) 0))))))))))) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next) (or (forEach Piece) (if (and (= (state at:(mapEntry "King" (mover))) 1) (not (is Threatened (id "King" Mover) (forEach Piece)))) (or (if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) W (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to) (forEach Piece))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:True) (to if:True (apply (set State at:(from) 0))))))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) E (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to) (forEach Piece))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:True) (to if:True (apply (set State at:(from) 0)))))))))))))))) (result Mover Win)) (if (or (no Moves Mover) (= (counter) 99)) (result Mover Draw))}))) 
1) When castling king moves 3 squares towards either rook. 2) Both bishops of each player cannot run along squares of a same color. One of them must change in such a manner that it transits through squares of the other color. Being in its original square without having been moved before, it will take an orthogonal step towards any of the 3 surrounding squares that are of the other color, provided that these are empty. This special move is called conversion and it must be done as an ordinary move during the game.
(game "Symmetric Chess" (players {(player N) (player S)}) (equipment {(board (rectangle 8 9)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (or (if (is In (from) (sites Start (piece (what at:(from))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))) (then (set Pending (ahead (last To) Backward))))) (move Step (directions {FR FL}) (to if:(and (is Pending) (= (to) (value Pending)))) (then (remove (ahead (last To) Backward)))))} (then (and (if (is In (last To) (sites Mover "Promotion")) (moveAgain)) (set Counter))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Bishop" Each (or {(move Slide (from if:(!= (state at:(from)) 2)) Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))) (then (and (forEach Site (sites Occupied by:Mover component:"Bishop") (set State at:(site) 2)) (set State at:(last To) 0)))) (move Step Orthogonal (to if:(and (not (is Friend (who at:(to)))) (!= (state at:(from)) 0)) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (forEach Site (sites Occupied by:Mover component:"Bishop") (set State at:(site) 0))))})) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (map "King" {(pair 1 "E1") (pair 2 "E8")}) (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")}) (map "RookRight" {(pair 1 "I1") (pair 2 "I8")}) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "I1"} state:1) (place "Knight1" {"B1" "H1"}) (place "Bishop1" {"C1" "G1"} state:1) (place "Queen1" {"D1" "F1"}) (place "King1" coord:"E1" state:1) (place "Rook2" {"A8" "I8"} state:1) (place "Knight2" {"B8" "H8"}) (place "Bishop2" {"C8" "G8"} state:1) (place "Queen2" {"D8" "F8"}) (place "King2" coord:"E8" state:1)}) (play (if (is Prev Mover) (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover) (do (or (forEach Piece) (if (and (= (state at:(mapEntry "King" (mover))) 1) (not (is Threatened (id "King" Mover)))) (or (if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 2) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) W (between (exact 3) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookLeft" (mover))) E (between (exact 2) if:True) (to if:True (apply (set State at:(from) 0))))))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:(is Empty (to))) (to if:True (apply (set State at:(from) 0)))))) (move Slide (from (mapEntry "King" (mover))) E (between (exact 3) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (to if:True (apply (set State at:(from) 0))) (then (slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:True) (to if:True (apply (set State at:(from) 0)))))))))) ifAfterwards:(not (is Threatened (id "King" Mover)))))) (end {(if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win)) (if (or (no Moves Mover) (= (counter) 99)) (result Mover Draw))}))) 
Ultimate Chess is a variant of Chess played on a 9x9 Sudoku checkerboard as shown, with same rules as Chess except: - Pawns can move 2 or 3 steps forward in their first move. The pawn can be captured by En Passant if they do a such move. - Kings can make a large casting in either side. - The next player must move from the sub-grid corresponding to the cell just moved to (if they have a legal move from there).
(game "Ultimate Chess" (players {(player N) (player S)}) (equipment {(board (square 9)) (piece "Pawn" Each (or {(if (is In (from) (sites Start (piece (what at:(from))))) (forEach Value min:2 max:3 (move Slide Forward (between (exact (value)) if:(is Empty (between)) (apply (set Pending (between)))) (to if:(is Empty (to))) (then (set Var (last To)))))) (move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Step (directions {FR FL}) (to if:(is In (to) (sites Pending))) (then (remove (var))))} (then (and (if (is In (last To) (sites Mover "Promotion")) (moveAgain)) (set Counter))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (map "King" {(pair 1 "E1") (pair 2 "E9")}) (map "RookLeft" {(pair 1 "A1") (pair 2 "A9")}) (map "RookRight" {(pair 1 "I1") (pair 2 "I9")}) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 7)) (place "Rook1" {"A1" "I1"} state:1) (place "Knight1" {"B1" "H1"}) (place "Bishop1" {"C1" "G1"}) (place "Queen1" {"D1" "F1"}) (place "King1" coord:"E1" state:1) (place "Rook2" {"A9" "I9"} state:1) (place "Knight2" {"B9" "H9"}) (place "Bishop2" {"C9" "G9"}) (place "Queen2" {"D9" "F9"}) (place "King2" coord:"E9" state:1)}) (play (if (is Prev Mover) (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover) (priority {(if (!= 0 (count Moves)) (do (or {(forEach Piece "Queen" (if (and {(<= (column of:(from)) (+ (* (% (column of:(last To)) 3) 3) 2)) (>= (column of:(from)) (* (% (column of:(last To)) 3) 3)) (<= (row of:(from)) (+ (* (% (row of:(last To)) 3) 3) 2)) (>= (row of:(from)) (* (% (row of:(last To)) 3) 3))}) (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter)))))))) (forEach Piece "Knight" (if (and {(<= (column of:(from)) (+ (* (% (column of:(last To)) 3) 3) 2)) (>= (column of:(from)) (* (% (column of:(last To)) 3) 3)) (<= (row of:(from)) (+ (* (% (row of:(last To)) 3) 3) 2)) (>= (row of:(from)) (* (% (row of:(last To)) 3) 3))}) (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter))))))))) (forEach Piece "Bishop" (if (and {(<= (column of:(from)) (+ (* (% (column of:(last To)) 3) 3) 2)) (>= (column of:(from)) (* (% (column of:(last To)) 3) 3)) (<= (row of:(from)) (+ (* (% (row of:(last To)) 3) 3) 2)) (>= (row of:(from)) (* (% (row of:(last To)) 3) 3))}) (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter)))))))) (forEach Piece "King" (if (and {(<= (column of:(from)) (+ (* (% (column of:(last To)) 3) 3) 2)) (>= (column of:(from)) (* (% (column of:(last To)) 3) 3)) (<= (row of:(from)) (+ (* (% (row of:(last To)) 3) 3) 2)) (>= (row of:(from)) (* (% (row of:(last To)) 3) 3))}) (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0)))))) (forEach Piece "Rook" (if (and {(<= (column of:(from)) (+ (* (% (column of:(last To)) 3) 3) 2)) (>= (column of:(from)) (* (% (column of:(last To)) 3) 3)) (<= (row of:(from)) (+ (* (% (row of:(last To)) 3) 3) 2)) (>= (row of:(from)) (* (% (row of:(last To)) 3) 3))}) (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0)))))) (forEach Piece "Pawn" (if (and {(<= (column of:(from)) (+ (* (% (column of:(last To)) 3) 3) 2)) (>= (column of:(from)) (* (% (column of:(last To)) 3) 3)) (<= (row of:(from)) (+ (* (% (row of:(last To)) 3) 3) 2)) (>= (row of:(from)) (* (% (row of:(last To)) 3) 3))}) (or {(if (is In (from) (sites Start (piece (what at:(from))))) (forEach Value min:2 max:3 (move Slide Forward (between (exact (value)) if:(is Empty (between)) (apply (set Pending (between)))) (to if:(is Empty (to))) (then (set Var (last To)))))) (move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Step (directions {FR FL}) (to if:(is In (to) (sites Pending))) (then (remove (var))))} (then (and (if (is In (last To) (sites Mover "Promotion")) (moveAgain)) (set Counter)))))) (if (and (= (% (row of:(last To)) 3) 0) (= (% (column of:(last To)) 3) 1)) (if (and {(= (what at:(mapEntry "King" (mover))) (id "King" Mover)) (= (state at:(mapEntry "King" (mover))) 1) (not (is Threatened (id "King" Mover)))}) (or (if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (move Slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:(is Empty (to)))))) (move Slide (from (mapEntry "King" (mover))) W (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (then (and (set State at:(last To) 0) (move Slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:True)))))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (move Slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:(is Empty (to)))))) (move Slide (from (mapEntry "King" (mover))) E (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (then (and (set State at:(last To) 0) (move Slide (from (mapEntry "RookRight" (mover))) W (between (exact 3) if:True)))))))))}) ifAfterwards:(not (is Threatened (id "King" Mover) (forEach Piece))))) (do (or (forEach Piece) (if (and {(= (what at:(mapEntry "King" (mover))) (id "King" Mover)) (= (state at:(mapEntry "King" (mover))) 1) (not (is Threatened (id "King" Mover)))}) (or (if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (move Slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:(is Empty (to)))))) (move Slide (from (mapEntry "King" (mover))) W (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (then (and (set State at:(last To) 0) (move Slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:True)))))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (move Slide (from (mapEntry "RookRight" (mover))) W (between (exact 3) if:(is Empty (to)))))) (move Slide (from (mapEntry "King" (mover))) E (between (exact 2) if:(and (is Empty (to)) (not (is Threatened (id "King" Mover) at:(to))))) (then (and (set State at:(last To) 0) (move Slide (from (mapEntry "RookRight" (mover))) W (between (exact 3) if:True))))))))) ifAfterwards:(not (is Threatened (id "King" Mover))))}))) (end {(if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win)) (if (or (no Moves Mover) (= (counter) 100)) (result Mover Draw))}))) 
Same as standard Chess except: 1. The board is initially empty and each player has the normal complement of 16 pieces in reserve. 2. During a turn, a player must do one of three things: --- place a piece from in hand on an empty square on the board --- move a previously placed piece to an empty square --- move a previously placed piece onto a square occupied by an opposing piece, capturing it. 3. Pawns may be entered on the first, second, third or fourth rows only. 4. No en-passant, castling, or initial double-step pawn moves. 5. A player's King must be placed before being allowed to make any capturing moves. A piece that controls the square that the enemy King occupies does not check it until the friendly King is entered onto the board. That is called 'quasi-check'. A player is under no compulsion to move out of quasi-check, and may even move into quasi-check. A player may legally move into quasi-check. Original
(game "Unachess" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (and (if (is In (last To) (sites Mover "Promotion")) (moveAgain)) (set Counter))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to) (then (set Counter)))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to) (then (set Counter))))))) (map "King" {(pair 1 "E1") (pair 2 "E8")}) (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")}) (map "RookRight" {(pair 1 "H1") (pair 2 "H8")}) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom)) (regions "PawnPlacementRows" P1 (expand (sites Bottom) steps:3)) (regions "PawnPlacementRows" P2 (expand (sites Top) steps:3)) (hand Each size:6)}) (rules (start {(place "Pawn1" (handSite P1 0) count:8) (place "Pawn2" (handSite P2 0) count:8) (place "Rook1" (handSite P1 1) count:2 state:1) (place "Knight1" (handSite P1 2) count:2) (place "Bishop1" (handSite P1 3) count:2) (place "Queen1" (handSite P1 4)) (place "King1" (handSite P1 5) state:1) (place "Rook2" (handSite P2 1) count:2 state:1) (place "Knight2" (handSite P2 2) count:2) (place "Bishop2" (handSite P2 3) count:2) (place "Queen2" (handSite P2 4)) (place "King2" (handSite P2 5) state:1)}) (play (if (is Prev Mover) (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover) (do (or {(do (move (from (sites Occupied by:Mover container:"Hand" components:{"King" "Queen" "Rook" "Bishop" "Knight"})) (to (sites Empty))) ifAfterwards:True) (do (move (from (sites Occupied by:Mover container:"Hand" component:"Pawn")) (to (intersection (sites Empty) (sites Mover "PawnPlacementRows")))) ifAfterwards:True) (forEach Piece)}) ifAfterwards:(or (not (is Threatened (id "King" Mover))) (no Pieces Next "King" in:(sites Board)))))) (end {(if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win)) (if (or (no Moves Mover) (= (counter) 99)) (result Mover Draw))}))) 
Viking Chess is played on a board with 12 files and 7 ranks. The pieces are set up with both sides starting on the same side of board. Both sides' Pawns move in the same direction, and all Pawns promote normally upon reaching the (same) 7th rank. There is no Pawn double-move or en passant capture. There is no castling.
(game "Viking Chess" (players {(player N) (player N)}) (equipment {(board (rectangle 7 12)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))} (then (and (if (is In (last To) (sites Mover "Promotion")) (moveAgain)) (set Counter))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Top))}) (rules (start {(place "Pawn1" {"B2" "B3" "C3" "D3" "E3" "E2" "F2" "F1"}) (place "Rook1" {"A1" "A2"}) (place "Knight1" {"C2" "D2"}) (place "Bishop1" {"B1" "E1"}) (place "Queen1" coord:"D1") (place "King1" coord:"C1") (place "Pawn2" {"G1" "G2" "H2" "H3" "I3" "J3" "K3" "K2"}) (place "Rook2" {"L1" "L2"}) (place "Knight2" {"J2" "I2"}) (place "Bishop2" {"K1" "H1"}) (place "Queen2" coord:"I1") (place "King2" coord:"J1")}) (play (if (is Prev Mover) (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover) (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King" Mover)))))) (end {(if (and (is Threatened (id "King" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King" Next))))))) (result Mover Win)) (if (or (no Moves Mover) (= (counter) 100)) (result Mover Draw))}))) 
Wellisch Chess is played on a hexagonal board with each side having length 6 and each space oriented vertically. The board has 91 spaces. The board spaces are traditionally coloured red, yellow, and either gray or black. Capture and Pawn Promotion: * When pieces other than Kings and Pawns are captured, they are set aside for later Pawn promotion. When a Pawn reaches the side of the board opposite its starting side, it is eligible for promotion. * When a Pawn is eligible for promotion, and there are pieces of that colour available from previous capture, then the Pawn is promoted to one of the captured pieces, as the player chooses. * If there are no pieces of the given colour when a Pawn reaches the far side, then the Pawn remains where it is (unless captured) until a piece of the given colour is captured. Then, on the player's next turn, the Pawn is promoted. Piece Movement: * Rooks move as in Glinski Chess. - They slide in any of the 6 adjacent direction. * There are no Bishops in Wellisch Chess. * Kings can move one space in any of the six adjacent directions from their current space---West, East, or 60 degrees off either of those. They castle by swapping locations with one of the Rooks belonging to the same player. Castling can only take place when neither the King nor the Rook being moved have moved before. * Knights move one space 'diagonally' (i.e., along an edge, to any of the six nearest spaces of the same colour). Note that a Knight always moves to a space of the same colour as the space it moved from. * Queens can make any move that would be available to a Rook or a Knight on the current space. * Pawns can advance with or without capturing by moving one space forward to an adjacent space slightly left or right of forward. Pawns can never advance more than one space. There is no en passant capture. As mentioned above, Pawns can be promoted upon reaching the side of the board farthest from their starting side, but can only be promoted to a piece (Queen, Rook, or Knight) of the same colour that has already been captured. If a Pawn reaches the farthest side without any captured pieces available, then it remains in that position until a piece becomes available for its delayed promotion, on the player's next turn. (Note: Currently, on a turn where the delayed promotion takes place, the possible post-promotion movement of the Pawn is displayed before the promotion visually takes place.) The game ends when a King is captured, or there is a stalemate due to turns elapsed without a capture or Pawn move. * When the game ends in checkmate, the checkmating player wins, the checkmated player loses, and the remaining player draws. * When the game ends in stalemate, all players draw. (Note: A player not being able to escape check passes the current move, This does not result in a stalemate.) Variations: In Wellisch's version of the game, the first player to capture another's King takes possession of the other player's pieces. (The Pawns keep their direction of movement.) In another variant, some people play with a rule that if Player 1's move exposes a threat by Player 2 against Player 3's King, then Player 2 may not capture Player 3's King until Player 3 has had a chance to move.
(game "Wellisch Chess" (players {(player N) (player ESE) (player WSW)}) (equipment {(board (hex 6)) (piece "King" Each (or {(move Step Orthogonal (to if:(or (is In (to) (sites Empty)) (is Enemy (who at:(to)))) (apply (if (is Enemy (who at:(to))) (if (or {(= (what at:(to)) (id "Pawn" P1)) (= (what at:(to)) (id "Pawn" P2)) (= (what at:(to)) (id "Pawn" P3))}) (remove (to)) (if (or {(= (what at:(to)) (id "King" P1)) (= (what at:(to)) (id "King" P2)) (= (what at:(to)) (id "King" P3))}) (and (trigger "CapturedEnemyKing" Mover) (remove (to))) (move (from (to)) (to (handSite (who at:(to)) (mapEntry "HandIndex" (what at:(to))))) (then (set Counter)))))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0)))) (if (and {(= (what at:(mapEntry "King" (mover))) (id "King" Mover)) (= (state at:(mapEntry "King" (mover))) 1) (not (is Threatened (id "King" Mover)))}) (or {(if (is Mover P1) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (not (is Threatened (id "King" Mover) at:(mapEntry "RookRight" Mover)))) (move Swap Pieces 3 4 (then (set State at:(last To) 0)))) (if (is Mover P2) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (not (is Threatened (id "King" Mover) at:(mapEntry "RookRight" Mover)))) (move Swap Pieces 61 51 (then (set State at:(last To) 0)))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (not (is Threatened (id "King" Mover) at:(mapEntry "RookRight" Mover)))) (move Swap Pieces 77 84 (then (set State at:(last To) 0)))))) (if (is Mover P1) (if (and {(= (state at:(mapEntry "RookLeft" (mover))) 1) (not (is Threatened (id "King" Mover) at:(mapEntry "RookLeft" Mover))) (not (is Threatened (id "King" Mover) at:(mapEntry "Queen" Mover))) (is In (mapEntry "Queen" Mover) (sites Empty))}) (move Swap Pieces 3 1 (then (set State at:(last To) 0)))) (if (is Mover P2) (if (and {(= (state at:(mapEntry "RookLeft" (mover))) 1) (not (is Threatened (id "King" Mover) at:(mapEntry "RookLeft" Mover))) (not (is Threatened (id "King" Mover) at:(mapEntry "Queen" Mover))) (is In (mapEntry "Queen" Mover) (sites Empty))}) (move Swap Pieces 61 78 (then (set State at:(last To) 0)))) (if (and {(= (state at:(mapEntry "RookLeft" (mover))) 1) (not (is Threatened (id "King" Mover) at:(mapEntry "RookLeft" Mover))) (not (is Threatened (id "King" Mover) at:(mapEntry "Queen" Mover))) (is In (mapEntry "Queen" Mover) (sites Empty))}) (move Swap Pieces 77 60 (then (set State at:(last To) 0))))))}))})) (piece "Queen" Each (or (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (or {(= (what at:(to)) (id "Pawn" P1)) (= (what at:(to)) (id "Pawn" P2)) (= (what at:(to)) (id "Pawn" P3))}) (remove (to)) (if (or {(= (what at:(to)) (id "King" P1)) (= (what at:(to)) (id "King" P2)) (= (what at:(to)) (id "King" P3))}) (and (trigger "CapturedEnemyKing" Mover) (remove (to))) (move (from (to)) (to (handSite (who at:(to)) (mapEntry "HandIndex" (what at:(to))))) (then (set Counter)))))))) (move Step Diagonal (to if:(or (is In (to) (sites Empty)) (is Enemy (who at:(to)))) (apply (if (is Enemy (who at:(to))) (if (or {(= (what at:(to)) (id "Pawn" P1)) (= (what at:(to)) (id "Pawn" P2)) (= (what at:(to)) (id "Pawn" P3))}) (remove (to)) (if (or {(= (what at:(to)) (id "King" P1)) (= (what at:(to)) (id "King" P2)) (= (what at:(to)) (id "King" P3))}) (and (trigger "CapturedEnemyKing" Mover) (remove (to))) (move (from (to)) (to (handSite (who at:(to)) (mapEntry "HandIndex" (what at:(to))))) (then (set Counter))))))))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (or {(= (what at:(to)) (id "Pawn" P1)) (= (what at:(to)) (id "Pawn" P2)) (= (what at:(to)) (id "Pawn" P3))}) (remove (to)) (if (or {(= (what at:(to)) (id "King" P1)) (= (what at:(to)) (id "King" P2)) (= (what at:(to)) (id "King" P3))}) (and (trigger "CapturedEnemyKing" Mover) (remove (to))) (move (from (to)) (to (handSite (who at:(to)) (mapEntry "HandIndex" (what at:(to))))) (then (set Counter))))))))) (piece "Knight" Each (move Step Diagonal (to if:(or (is In (to) (sites Empty)) (is Enemy (who at:(to)))) (apply (if (is Enemy (who at:(to))) (if (or {(= (what at:(to)) (id "Pawn" P1)) (= (what at:(to)) (id "Pawn" P2)) (= (what at:(to)) (id "Pawn" P3))}) (remove (to)) (if (or {(= (what at:(to)) (id "King" P1)) (= (what at:(to)) (id "King" P2)) (= (what at:(to)) (id "King" P3))}) (and (trigger "CapturedEnemyKing" Mover) (remove (to))) (move (from (to)) (to (handSite (who at:(to)) (mapEntry "HandIndex" (what at:(to))))) (then (set Counter)))))))))) (piece "Pawn" Each (or {(move Step (if (is Mover P1) (directions {NNW NNE}) (if (is Mover P2) (directions {E SSE}) (directions {SSW W}))) (to if:(is Empty (to)))) (move Step (if (is Mover P1) (directions {NNW NNE}) (if (is Mover P2) (directions {E SSE}) (directions {SSW W}))) (to if:(is Enemy (who at:(to))) (apply (if (or {(= (what at:(to)) (id "Pawn" P1)) (= (what at:(to)) (id "Pawn" P2)) (= (what at:(to)) (id "Pawn" P3))}) (remove (to)) (if (or {(= (what at:(to)) (id "King" P1)) (= (what at:(to)) (id "King" P2)) (= (what at:(to)) (id "King" P3))}) (and (trigger "CapturedEnemyKing" Mover) (remove (to))) (move (from (to)) (to (handSite (who at:(to)) (mapEntry "HandIndex" (what at:(to)))))))))))} (then (and (if (is In (last To) (sites Mover "PromotionZone")) (moveAgain)) (set Counter))))) (map "King" {(pair 1 "D1") (pair 2 "C8") (pair 3 "K9")}) (map "RookLeft" {(pair 1 "B1") (pair 2 "E10") (pair 3 "K7")}) (map "RookRight" {(pair 1 "E1") (pair 2 "B7") (pair 3 "K10")}) (map "Queen" {(pair 1 2) (pair 2 70) (pair 3 69)}) (hand Each size:3) (map "HandIndex" {(pair 4 0) (pair 7 1) (pair 10 2) (pair 5 0) (pair 8 1) (pair 11 2) (pair 6 0) (pair 9 1) (pair 12 2)}) (regions "PromotionZone" P1 (sites Top)) (regions "PromotionZone" P2 (sites {"K6" "J5" "I4" "H3" "G2" "F1"})) (regions "PromotionZone" P3 (sites {"A1" "A2" "A3" "A4" "A5" "A6"})) (regions "Region-Grey" (sites Phase 1)) (regions "Region-Red" (sites Phase 2)) (regions "Region-Yellow" (sites Phase 0))}) (rules (start {(place "King1" coord:"D1" state:1) (place "Queen1" coord:"C1") (place "Rook1" {"B1" "E1"} state:1) (place "Knight1" {"A1" "D2" "F1"}) (place "King3" coord:"K9" state:1) (place "Queen3" coord:"K8") (place "Rook3" {"K10" "K7"} state:1) (place "Knight3" {"K11" "J8" "K6"}) (place "King2" coord:"C8" state:1) (place "Queen2" coord:"D9") (place "Rook2" {"B7" "E10"} state:1) (place "Knight2" {"A6" "D8" "F11"}) (place "Pawn1" {"A2" "B2" "C2" "D3" "E3" "E2" "F2" "G2"}) (place "Pawn3" {"J11" "J10" "J9" "I8" "I7" "J7" "J6" "J5"}) (place "Pawn2" {"A5" "B6" "C7" "D7" "E8" "E9" "F10" "G11"})}) phases:{(phase "Movement" (play (if (is Prev Mover) (if (not (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site))))) (move (from (sites Occupied by:Mover container:"Hand" components:{"Queen" "Rook" "Knight"})) (to (last To)))) (do (if (> (count in:(sites Hand Mover)) 0) (move (from (sites Occupied by:Mover container:"Hand" components:{"Queen" "Rook" "Knight"})) (to (sites Mover "PromotionZone") if:(= (what at:(to)) (id "Pawn" Mover))))) next:(do (forEach Piece) ifAfterwards:(not (is Threatened (id "King" Mover))))))) (end {(if (is Triggered "CapturedEnemyKing" P1) (result P1 Win)) (if (is Triggered "CapturedEnemyKing" P2) (result P2 Win)) (if (is Triggered "CapturedEnemyKing" P3) (result P3 Win)) (if (= (where "King" P1) -1) (result P1 Loss)) (if (= (where "King" P2) -1) (result P2 Loss)) (if (= (where "King" P3) -1) (result P3 Loss)) (if (= (counter) 100) (result Mover Draw))}))})) 
8x8. Each player begins with a complement of pieces, each with their own powers of movement as follows: King (x1): may move one space in any direction; Queen (x1): moves one space diagonally, may leap two spaces diagonally on its first move over any intervening pieces; Bishop (x2): moves diagonally two spaces, jumping over any intervening pieces; Knight (x2): moves orthogonally one space and then diagonally another space, jumping over any intervening pieces; Rook (x2): moves orthogonally any distance; Pawns (x8): move forward one space or diagonally forward one space to capture. Only the Rooks' and Queens' pawns may move forward two spaces for their first move. When a Pawn reaches the row on the opposite side of the board from which it began, it must move two spaces backward to the sixth row, then to the fourth, and then to the second, and then is promoted to Queen. It cannot jump over any pieces or taken a piece during these moves. A Pawn is immune from capture on the eight rank, but not on the others while making these promotion moves. Each player must move the Rooks' Pawns and Queens' Pawn in this way, as well as the jump of the Queen, in their first four moves. There is no castling. A piece is captured when an opponent's piece moves onto its space. The King is in check when it can be taken on the opponent's next turn; it must not remain in check at the end of the player's turn. When the king cannot move out of check, it is checkmated and the opponent wins.
(game "Welschschach" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "King_noCross" (move Step (to if:(and (not (is Friend (who at:(to)))) (if (not (is In (to) (sites Next "Promotion"))) True (not (= (what at:(to)) (id "Pawn" Next))))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Queen" (move Step Diagonal (to if:(and (not (is Friend (who at:(to)))) (if (not (is In (to) (sites Next "Promotion"))) True (!= (what at:(to)) (id "Pawn" Next)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Bishop_noCross" (move Hop Diagonal (between if:True) (to if:(and (not (is Friend (who at:(to)))) (if (not (is In (to) (sites Next "Promotion"))) True (!= (what at:(to)) (id "Pawn" Next)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Knight" (move Leap {{F F R F} {F F L F}} (to if:(and (not (is Friend (who at:(to)))) (if (not (is In (to) (sites Next "Promotion"))) True (!= (what at:(to)) (id "Pawn" Next)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Rook" (move Slide Orthogonal (to if:(and (not (is Friend (who at:(to)))) (if (not (is In (to) (sites Next "Promotion"))) True (!= (what at:(to)) (id "Pawn" Next)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Pawn" (if (= 0 (state at:(from))) (or (move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(and (is Enemy (who at:(to))) (if (not (is In (to) (sites Next "Promotion"))) True (!= (what at:(to)) (id "Pawn" Next)))) (apply (remove (to))))) (then (if (is In (last To) (sites Mover "Promotion")) (set State at:(last To) 1)))) (move Slide Backward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))) (then (if (is In (last To) (sites Start (piece (what at:(last To))))) (promote (last To) (piece "Queen") Mover)))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"}) (place "Knight1" {"B1" "G1"}) (place "Bishop_noCross1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King_noCross1" coord:"E1") (place "Rook2" {"A8" "H8"}) (place "Knight2" {"B8" "G8"}) (place "Bishop_noCross2" {"C8" "F8"}) (place "Queen2" coord:"E8") (place "King_noCross2" coord:"D8")}) phases:{(phase "Opening" (play (or {(forEach Piece "Queen" (if (is In (from) (sites Start (piece (what at:(from))))) (move Hop Diagonal (between (exact 1) if:True) (to if:(and (not (is Friend (who at:(to)))) (if (not (is In (to) (sites Next "Promotion"))) True (!= (what at:(to)) (id "Pawn" Next)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) Mover) (forEach Piece "Pawn" (if (is In (from) (intersection (sites {"A2" "D2" "H2" "A7" "H7" "E7"}) (sites Start (piece (what at:(from)))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))))) Mover)})) (nextPhase (= 8 (count Moves)) "Playing")) (phase "Playing" (play (do (forEach Piece) ifAfterwards:(not (is Threatened (id "King_noCross" Mover))))))} (end (if (and (is Threatened (id "King_noCross" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "King_noCross" Next))))))) (result Mover Win))))) 
The rules are the same of Mini Shogi except the value of the die rolled at each turn is the index of the column of a piece must go. When you have pieces on your hand, you can drop a piece you like on the column with the index equal to the value of the die. If there are no legal moves with the value of the die, or if the value of the die is equal to 6, you can move any piece according to the rules of Mini Shogi.
(game "Dice Shogi" (players {(player N) (player S)}) (equipment {(board (square 5)) (piece "Osho" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))))) (piece "Fuhyo" Each (move Step Forward (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))) (then (if (is In (last To) (sites Mover "Promotion")) (move Promote (last To) (piece (mapEntry "Promoted" (what at:(last To))))))))) (piece "Ginsho" Each (move Step (directions {Forward BL BR FL FR}) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))) (then (if (or (is In (last To) (sites Mover "Promotion")) (is In (last From) (sites Mover "Promotion"))) (moveAgain))))) (piece "Hisha" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))) (then (if (or (is In (last To) (sites Mover "Promotion")) (is In (last From) (sites Mover "Promotion"))) (moveAgain))))) (piece "Kakugyo" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))) (then (if (or (is In (last To) (sites Mover "Promotion")) (is In (last From) (sites Mover "Promotion"))) (moveAgain))))) (piece "Kinsho" Each (move Step (directions {Forward Backward Rightward Leftward FL FR}) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))))) (piece "Tokin" Each (move Step (directions {Forward Backward Rightward Leftward FL FR}) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))))) (piece "Narigin" Each (move Step (directions {Forward Backward Rightward Leftward FL FR}) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))))) (piece "Ryuo" Each (or (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to))))))))) (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to))))))))))) (piece "Ryuma" Each (or (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to))))))))) (move Step Orthogonal (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to))))))))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom)) (map "Where" {(pair (id "Fuhyo" P1) (handSite P2)) (pair (id "Fuhyo" P2) (handSite P1)) (pair (id "Ginsho" P1) (handSite P2 1)) (pair (id "Ginsho" P2) (handSite P1 1)) (pair (id "Hisha" P1) (handSite P2 2)) (pair (id "Hisha" P2) (handSite P1 2)) (pair (id "Kakugyo" P1) (handSite P2 3)) (pair (id "Kakugyo" P2) (handSite P1 3)) (pair (id "Kinsho" P1) (handSite P2 4)) (pair (id "Kinsho" P2) (handSite P1 4)) (pair (id "Tokin" P1) (handSite P2)) (pair (id "Tokin" P2) (handSite P1)) (pair (id "Narigin" P1) (handSite P2 1)) (pair (id "Narigin" P2) (handSite P1 1)) (pair (id "Ryuo" P1) (handSite P2 2)) (pair (id "Ryuo" P2) (handSite P1 2)) (pair (id "Ryuma" P1) (handSite P2 3)) (pair (id "Ryuma" P2) (handSite P1 3))}) (map "Captured" {(pair (id "Fuhyo" P1) (id "Fuhyo" P2)) (pair (id "Fuhyo" P2) (id "Fuhyo" P1)) (pair (id "Ginsho" P1) (id "Ginsho" P2)) (pair (id "Ginsho" P2) (id "Ginsho" P1)) (pair (id "Hisha" P1) (id "Hisha" P2)) (pair (id "Hisha" P2) (id "Hisha" P1)) (pair (id "Kakugyo" P1) (id "Kakugyo" P2)) (pair (id "Kakugyo" P2) (id "Kakugyo" P1)) (pair (id "Kinsho" P1) (id "Kinsho" P2)) (pair (id "Kinsho" P2) (id "Kinsho" P1)) (pair (id "Tokin" P1) (id "Fuhyo" P2)) (pair (id "Tokin" P2) (id "Fuhyo" P1)) (pair (id "Narigin" P1) (id "Ginsho" P2)) (pair (id "Narigin" P2) (id "Ginsho" P1)) (pair (id "Ryuo" P1) (id "Hisha" P2)) (pair (id "Ryuo" P2) (id "Hisha" P1)) (pair (id "Ryuma" P1) (id "Kakugyo" P2)) (pair (id "Ryuma" P2) (id "Kakugyo" P1))}) (map "Promoted" {(pair (id "Fuhyo" P1) (id "Tokin" P1)) (pair (id "Fuhyo" P2) (id "Tokin" P2)) (pair (id "Ginsho" P1) (id "Narigin" P1)) (pair (id "Ginsho" P2) (id "Narigin" P2)) (pair (id "Hisha" P1) (id "Ryuo" P1)) (pair (id "Hisha" P2) (id "Ryuo" P2)) (pair (id "Kakugyo" P1) (id "Ryuma" P1)) (pair (id "Kakugyo" P2) (id "Ryuma" P2))}) (hand Each size:5) (dice num:1)}) (rules (start {(place "Osho1" coord:"A1") (place "Kinsho1" coord:"B1") (place "Ginsho1" coord:"C1") (place "Kakugyo1" coord:"D1") (place "Hisha1" coord:"E1") (place "Fuhyo1" coord:"A2") (place "Osho2" coord:"E5") (place "Kinsho2" coord:"D5") (place "Ginsho2" coord:"C5") (place "Kakugyo2" coord:"B5") (place "Hisha2" coord:"A5") (place "Fuhyo2" coord:"E4")}) (play (if (is Prev Mover) (or (move Promote (last To) (piece (mapEntry "Promoted" (what at:(last To))))) (move Pass)) (do (roll) next:(do (if (!= 6 (count Pips)) (or {(if (can Move (do (or (or {(move (from (sites Occupied by:Mover container:"Hand" components:{"Kakugyo" "Ginsho" "Hisha" "Kinsho"})) (to (sites Empty))) (do (move (from (sites Occupied by:Mover container:"Hand" component:"Fuhyo")) (to (difference (sites Empty) (sites Mover "Promotion")))) ifAfterwards:(not (is Threatened (id "Osho" Next) (forEach Piece Mover))))}) (forEach Piece)) ifAfterwards:(and (not (is Threatened (id "Osho" Mover) (forEach Piece Next))) (= (+ 1 (column of:(last To))) (count Pips))))) (do (or (or {(move (from (sites Occupied by:Mover container:"Hand" components:{"Kakugyo" "Ginsho" "Hisha" "Kinsho"})) (to (sites Empty))) (do (move (from (sites Occupied by:Mover container:"Hand" component:"Fuhyo")) (to (difference (sites Empty) (sites Mover "Promotion")))) ifAfterwards:(not (is Threatened (id "Osho" Next) (forEach Piece Mover))))}) (forEach Piece)) ifAfterwards:(= (+ 1 (column of:(last To))) (count Pips))) (or (or {(move (from (sites Occupied by:Mover container:"Hand" components:{"Kakugyo" "Ginsho" "Hisha" "Kinsho"})) (to (sites Empty))) (do (move (from (sites Occupied by:Mover container:"Hand" component:"Fuhyo")) (to (difference (sites Empty) (sites Mover "Promotion")))) ifAfterwards:(not (is Threatened (id "Osho" Next) (forEach Piece Mover))))}) (forEach Piece)))}) (or (or {(move (from (sites Occupied by:Mover container:"Hand" components:{"Kakugyo" "Ginsho" "Hisha" "Kinsho"})) (to (sites Empty))) (do (move (from (sites Occupied by:Mover container:"Hand" component:"Fuhyo")) (to (difference (sites Empty) (sites Mover "Promotion")))) ifAfterwards:(not (is Threatened (id "Osho" Next) (forEach Piece Mover))))}) (forEach Piece))) ifAfterwards:(not (is Threatened (id "Osho" Mover) (forEach Piece Next))))))) (end {(if (and (is Threatened (id "Osho" Next) (or (or {(move (from (sites Occupied by:Mover container:"Hand" components:{"Kakugyo" "Ginsho" "Hisha" "Kinsho"})) (to (sites Empty))) (do (move (from (sites Occupied by:Mover container:"Hand" component:"Fuhyo")) (to (difference (sites Empty) (sites Mover "Promotion")))) ifAfterwards:(not (is Threatened (id "Osho" Next) (forEach Piece Mover))))}) (forEach Piece))) (not (can Move (do (or (or {(move (from (sites Occupied by:Next container:"Hand" components:{"Kakugyo" "Ginsho" "Hisha" "Kinsho"})) (to (sites Empty))) (do (move (from (sites Occupied by:Next container:"Hand" component:"Fuhyo")) (to (difference (sites Empty) (sites Next "Promotion")))) ifAfterwards:(not (is Threatened (id "Osho" Mover) (forEach Piece Next))))}) (forEach Piece Next)) ifAfterwards:(not (is Threatened (id "Osho" Next) (or (or {(move (from (sites Occupied by:Mover container:"Hand" components:{"Kakugyo" "Ginsho" "Hisha" "Kinsho"})) (to (sites Empty))) (do (move (from (sites Occupied by:Mover container:"Hand" component:"Fuhyo")) (to (difference (sites Empty) (sites Mover "Promotion")))) ifAfterwards:(not (is Threatened (id "Osho" Next) (forEach Piece Mover))))}) (forEach Piece)))))))) (result Mover Win)) (if (no Moves Next) (result Mover Win))}))) 
Play begins with the pieces arranged in the last row of squares on opposite sides of the board. Pieces move as rooks in Chess. An opponent's piece is captured by surrounding it on two opposite sides by a player's piece. Play continues until all but one player's pieces are captured.
(game "Hasami Shogi" (players 2) (equipment {(board (square 9)) (piece "Fuhyo" P1 (move Slide Orthogonal (then (or (custodial (from (last To)) Orthogonal (between (max 1) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Friend (who at:(to))))) (surround (from (last To)) Orthogonal (between if:(and (is In (between) (sites Corners)) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Friend (who at:(to))))))))) (piece "Tokin" P2 (move Slide Orthogonal (then (or (custodial (from (last To)) Orthogonal (between (max 1) if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Friend (who at:(to))))) (surround (from (last To)) Orthogonal (between if:(and (is In (between) (sites Corners)) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Friend (who at:(to)))))))))}) (rules (start {(place "Fuhyo1" (sites Bottom)) (place "Tokin2" (sites Top))}) (play (forEach Piece)) (end (if (= (count Pieces Next) 1) (result Mover Win))))) 
Piece movement has been updated to work on hexagonal cells, but all other rules remain the same.
(game "Hexshogi" (players {(player N) (player S)}) (equipment {(board (rotate 90 (remove (hex Rectangle 9 11) cells:{0 10 21 31 42 52 63 73 84 94}))) (piece "Osho" Each (move Step All (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))))) (piece "Fuhyo" Each (move Step Forward (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))) (then (if (is In (last To) (sites Mover "Promotion")) (if (is In (last To) (sites Mover "LastRank")) (move Promote (last To) (piece (mapEntry "Promoted" (what at:(last To))))) (moveAgain)))))) (piece "Ginsho" Each (move Leap {{F} {F L F} {F R F} {L F L F} {R F R F} {L L F L F} {R R F R F}} rotations:False (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))))) (piece "Hisha" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))) (then (if (or (is In (last To) (sites Mover "Promotion")) (is In (last From) (sites Mover "Promotion"))) (moveAgain))))) (piece "Kakugyo" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))) (then (if (or (is In (last To) (sites Mover "Promotion")) (is In (last From) (sites Mover "Promotion"))) (moveAgain))))) (piece "Keima" Each (move Leap {{F F R F} {F F L F}} rotations:False (to if:(not (is Friend (who at:(to)))) (apply if:(is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to))))))) (then (if (is In (last To) (sites Mover "Promotion")) (if (is In (last To) (sites Mover "TwoFurthestRank")) (move Promote (last To) (piece (mapEntry "Promoted" (what at:(last To))))) (moveAgain)))))) (piece "Kyosha" Each (move Slide Forward (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))) (then (if (is In (last To) (sites Mover "Promotion")) (if (is In (last To) (sites Mover "LastRank")) (move Promote (last To) (piece (mapEntry "Promoted" (what at:(last To))))) (moveAgain)))))) (piece "Kinsho" Each (move Leap {{F} {F L F} {F R F} {L F} {R F} {L L F} {R R F} {L L L F}} rotations:False (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))))) (piece "Tokin" Each (move Leap {{F} {F L F} {F R F} {L F} {R F} {L L F} {R R F} {L L L F}} rotations:False (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))))) (piece "Narigin" Each (move Leap {{F} {F L F} {F R F} {L F} {R F} {L L F} {R R F} {L L L F}} rotations:False (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))))) (piece "Ryuo" Each (or (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to))))))))) (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to))))))))))) (piece "Ryuma" Each (or (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to))))))))) (move Step Orthogonal (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to))))))))))) (piece "Narikei" Each (move Leap {{F} {F L F} {F R F} {L F} {R F} {L L F} {R R F} {L L L F}} rotations:False (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))))) (piece "Narikyo" Each (move Leap {{F} {F L F} {F R F} {L F} {R F} {L L F} {R R F} {L L L F}} rotations:False (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))))) (regions "LastRankP1" P1 (forEach (sites Board) if:(= (site) (ahead (site) N)))) (regions "LastRankP2" P2 (forEach (sites Board) if:(= (site) (ahead (site) S)))) (regions "TwoFurthestRankP1" P1 (forEach (sites Board) if:(= (site) (ahead (site) steps:2 N)))) (regions "TwoFurthestRankP2" P2 (forEach (sites Board) if:(= (site) (ahead (site) steps:2 S)))) (regions "Promotion" P1 (forEach (sites Board) if:(= (site) (ahead (site) steps:3 N)))) (regions "Promotion" P2 (forEach (sites Board) if:(= (site) (ahead (site) steps:3 S)))) (map "Where" {(pair (id "Fuhyo" P1) (handSite P2)) (pair (id "Fuhyo" P2) (handSite P1)) (pair (id "Ginsho" P1) (handSite P2 1)) (pair (id "Ginsho" P2) (handSite P1 1)) (pair (id "Hisha" P1) (handSite P2 2)) (pair (id "Hisha" P2) (handSite P1 2)) (pair (id "Kakugyo" P1) (handSite P2 3)) (pair (id "Kakugyo" P2) (handSite P1 3)) (pair (id "Keima" P1) (handSite P2 4)) (pair (id "Keima" P2) (handSite P1 4)) (pair (id "Kyosha" P1) (handSite P2 5)) (pair (id "Kyosha" P2) (handSite P1 5)) (pair (id "Kinsho" P1) (handSite P2 6)) (pair (id "Kinsho" P2) (handSite P1 6)) (pair (id "Tokin" P1) (handSite P2)) (pair (id "Tokin" P2) (handSite P1)) (pair (id "Narigin" P1) (handSite P2 1)) (pair (id "Narigin" P2) (handSite P1 1)) (pair (id "Ryuo" P1) (handSite P2 2)) (pair (id "Ryuo" P2) (handSite P1 2)) (pair (id "Ryuma" P1) (handSite P2 3)) (pair (id "Ryuma" P2) (handSite P1 3)) (pair (id "Narikei" P1) (handSite P2 4)) (pair (id "Narikei" P2) (handSite P1 4)) (pair (id "Narikyo" P1) (handSite P2 5)) (pair (id "Narikyo" P2) (handSite P1 5))}) (map "Captured" {(pair (id "Fuhyo" P1) (id "Fuhyo" P2)) (pair (id "Fuhyo" P2) (id "Fuhyo" P1)) (pair (id "Ginsho" P1) (id "Ginsho" P2)) (pair (id "Ginsho" P2) (id "Ginsho" P1)) (pair (id "Hisha" P1) (id "Hisha" P2)) (pair (id "Hisha" P2) (id "Hisha" P1)) (pair (id "Kakugyo" P1) (id "Kakugyo" P2)) (pair (id "Kakugyo" P2) (id "Kakugyo" P1)) (pair (id "Keima" P1) (id "Keima" P2)) (pair (id "Keima" P2) (id "Keima" P1)) (pair (id "Kyosha" P1) (id "Kyosha" P2)) (pair (id "Kyosha" P2) (id "Kyosha" P1)) (pair (id "Kinsho" P1) (id "Kinsho" P2)) (pair (id "Kinsho" P2) (id "Kinsho" P1)) (pair (id "Tokin" P1) (id "Fuhyo" P2)) (pair (id "Tokin" P2) (id "Fuhyo" P1)) (pair (id "Narigin" P1) (id "Ginsho" P2)) (pair (id "Narigin" P2) (id "Ginsho" P1)) (pair (id "Ryuo" P1) (id "Hisha" P2)) (pair (id "Ryuo" P2) (id "Hisha" P1)) (pair (id "Ryuma" P1) (id "Kakugyo" P2)) (pair (id "Ryuma" P2) (id "Kakugyo" P1)) (pair (id "Narikei" P1) (id "Keima" P2)) (pair (id "Narikei" P2) (id "Keima" P1)) (pair (id "Narikyo" P1) (id "Kyosha" P2)) (pair (id "Narikyo" P2) (id "Kyosha" P1))}) (map "Promoted" {(pair (id "Fuhyo" P1) (id "Tokin" P1)) (pair (id "Fuhyo" P2) (id "Tokin" P2)) (pair (id "Ginsho" P1) (id "Narigin" P1)) (pair (id "Ginsho" P2) (id "Narigin" P2)) (pair (id "Hisha" P1) (id "Ryuo" P1)) (pair (id "Hisha" P2) (id "Ryuo" P2)) (pair (id "Kakugyo" P1) (id "Ryuma" P1)) (pair (id "Kakugyo" P2) (id "Ryuma" P2)) (pair (id "Keima" P1) (id "Narikei" P1)) (pair (id "Keima" P2) (id "Narikei" P2)) (pair (id "Kyosha" P1) (id "Narikyo" P1)) (pair (id "Kyosha" P2) (id "Narikyo" P2))}) (hand Each size:7)}) (rules (start {(place "Osho1" coord:"C3") (place "Kinsho1" {"B3" "C2"}) (place "Ginsho1" {"B4" "D2"}) (place "Keima1" {"A4" "D1"}) (place "Kyosha1" {"A5" "E1"}) (place "Kakugyo1" coord:"C5") (place "Hisha1" coord:"E3") (place "Fuhyo1" {"C7" "C6" "D6" "D5" "E5" "E4" "F4" "F3" "G3"}) (place "Osho2" coord:"K11") (place "Kinsho2" {"K12" "L11"}) (place "Ginsho2" {"J12" "L10"}) (place "Keima2" {"J13" "M10"}) (place "Kyosha2" {"I13" "M9"}) (place "Kakugyo2" coord:"K9") (place "Hisha2" coord:"I11") (place "Fuhyo2" {"G11" "H11" "H10" "I10" "I9" "J9" "J8" "K8" "K7"})}) (play (if (is Prev Mover) (or (move Promote (last To) (piece (mapEntry "Promoted" (what at:(last To))))) (move Pass)) (do (or {(move (from (sites Occupied by:Mover container:"Hand" components:{"Kakugyo" "Ginsho" "Hisha" "Kinsho"})) (to (sites Empty))) (do (move (from (sites Occupied by:Mover container:"Hand" component:"Fuhyo")) (to (difference (sites Empty) (sites Mover "LastRank")) if:(= (count Sites in:(sites Occupied by:Mover container:"Board" component:"Fuhyo")) (count Sites in:(difference (sites Occupied by:Mover container:"Board" component:"Fuhyo") (union (sites Direction from:(to) N) (sites Direction from:(to) S))))))) ifAfterwards:(not (and (is Threatened (id "Osho" Next)) (not (can Move (do (or {(move (from (sites Occupied by:Next container:"Hand" components:{"Kakugyo" "Ginsho" "Hisha" "Kinsho"})) (to (sites Empty))) (do (move (from (sites Occupied by:Next container:"Hand" component:"Fuhyo")) (to (difference (sites Empty) (sites Next "LastRank")) if:(= (count Sites in:(sites Occupied by:Next container:"Board" component:"Fuhyo")) (count Sites in:(difference (sites Occupied by:Next container:"Board" component:"Fuhyo") (union (sites Direction from:(to) N) (sites Direction from:(to) S))))))) ifAfterwards:(not (is Threatened (id "Osho" Mover)))) (move (from (sites Occupied by:Next container:"Hand" component:"Kyosha")) (to (difference (sites Empty) (sites Next "LastRank")))) (move (from (sites Occupied by:Next container:"Hand" component:"Keima")) (to (difference (sites Empty) (sites Next "TwoFurthestRank")))) (forEach Piece Next)}) ifAfterwards:(not (is Threatened (id "Osho" Next))))))))) (move (from (sites Occupied by:Mover container:"Hand" component:"Kyosha")) (to (difference (sites Empty) (sites Mover "LastRank")))) (move (from (sites Occupied by:Mover container:"Hand" component:"Keima")) (to (difference (sites Empty) (sites Mover "TwoFurthestRank")))) (forEach Piece)}) ifAfterwards:(not (is Threatened (id "Osho" Mover)))))) (end {(if (and (is Threatened (id "Osho" Next)) (not (can Move (do (or {(move (from (sites Occupied by:Next container:"Hand" components:{"Kakugyo" "Ginsho" "Hisha" "Kinsho"})) (to (sites Empty))) (do (move (from (sites Occupied by:Next container:"Hand" component:"Fuhyo")) (to (difference (sites Empty) (sites Next "LastRank")) if:(= (count Sites in:(sites Occupied by:Next container:"Board" component:"Fuhyo")) (count Sites in:(difference (sites Occupied by:Next container:"Board" component:"Fuhyo") (union (sites Direction from:(to) N) (sites Direction from:(to) S))))))) ifAfterwards:(not (is Threatened (id "Osho" Mover)))) (move (from (sites Occupied by:Next container:"Hand" component:"Kyosha")) (to (difference (sites Empty) (sites Next "LastRank")))) (move (from (sites Occupied by:Next container:"Hand" component:"Keima")) (to (difference (sites Empty) (sites Next "TwoFurthestRank")))) (forEach Piece Next)}) ifAfterwards:(not (is Threatened (id "Osho" Next))))))) (result Mover Win)) (if (no Moves Next) (result Mover Win))}))) 
Two players play on a board ruled into a grid of 5 ranks (rows) by 5 files (columns). Each player has a set of 5 wedge-shaped pieces, of slightly different sizes. From largest to smallest (most to least powerful) they are: 1 king, 1 gold general, 1 silver general, 1 tokin, 1 pawn. There is no promotion zone in Kyoto shogi. Every time a piece makes a move it alternately promotes and reverts to its unpromoted state. Promotion is effected by turning the piece over after it moves, revealing the name of its promoted rank; demotion is effected by turning the piece back. The promotion rules and values are reminiscent of microshogi and entirely different from standard shogi: A king cannot promote. A tokin promotes to a lance and vice versa. A silver general promotes to a bishop and vice versa. A gold general promotes to a knight and vice versa. A pawn promotes to a rook and vice versa. A piece is allowed to move, capture or be dropped in a manner that will prevent it from moving on a subsequent turn, which is illegal in standard shogi. For example, a rook can move onto the farthest rank, becoming a pawn and unable to move further. Such pieces may be captured as any other. A captured piece may be dropped with either side facing up. There are no restrictions on where pieces can be dropped, other than that the square must be empty. So unlike in regular Shogi, pieces can be dropped in places where they can never move again, pawns can be dropped in files that already contain a pawn, and checkmate can be delivered through a pawn drop. The conditions to win are the same of the conditions of Shogi by checkmating the King.
(game "Kyoto Shogi" (players {(player N) (player S)}) (equipment {(board (square 5)) (piece "Osho" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))))) (piece "Fuhyo" Each (move Step Forward (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))) (then (promote (last To) (piece (mapEntry "Promoted" (what at:(last To)))))))) (piece "Ginsho" Each (move Step (directions {Forward BL BR FL FR}) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))) (then (promote (last To) (piece (mapEntry "Promoted" (what at:(last To)))))))) (piece "Hisha" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))) (then (promote (last To) (piece (mapEntry "Promoted" (what at:(last To)))))))) (piece "Kakugyo" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))) (then (promote (last To) (piece (mapEntry "Promoted" (what at:(last To)))))))) (piece "Keima" Each (forEach Direction Forward (to if:True (apply (forEach Direction (from (to)) (directions {FR FL}) (if (not (is Friend (who at:(to)))) (move (from) (to (apply if:(is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))))))) (then (promote (last To) (piece (mapEntry "Promoted" (what at:(last To)))))))) (piece "Kyosha" Each (move Slide Forward (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))) (then (promote (last To) (piece (mapEntry "Promoted" (what at:(last To)))))))) (piece "Kinsho" Each (move Step (directions {Forward Backward Rightward Leftward FL FR}) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))) (then (promote (last To) (piece (mapEntry "Promoted" (what at:(last To)))))))) (piece "Tokin" Each (move Step (directions {Forward Backward Rightward Leftward FL FR}) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))) (then (promote (last To) (piece (mapEntry "Promoted" (what at:(last To)))))))) (map "Where" {(pair (id "Fuhyo" P1) (handSite P2)) (pair (id "Fuhyo" P2) (handSite P1)) (pair (id "Ginsho" P1) (handSite P2 1)) (pair (id "Ginsho" P2) (handSite P1 1)) (pair (id "Kinsho" P1) (handSite P2 2)) (pair (id "Kinsho" P2) (handSite P1 2)) (pair (id "Tokin" P1) (handSite P2 3)) (pair (id "Tokin" P2) (handSite P1 3)) (pair (id "Hisha" P1) (handSite P2)) (pair (id "Hisha" P2) (handSite P1)) (pair (id "Kakugyo" P1) (handSite P2 1)) (pair (id "Kakugyo" P2) (handSite P1 1)) (pair (id "Keima" P1) (handSite P2 2)) (pair (id "Keima" P2) (handSite P1 2)) (pair (id "Kyosha" P1) (handSite P2 3)) (pair (id "Kyosha" P2) (handSite P1 3))}) (map "Captured" {(pair (id "Fuhyo" P1) (id "Fuhyo" P2)) (pair (id "Fuhyo" P2) (id "Fuhyo" P1)) (pair (id "Ginsho" P1) (id "Ginsho" P2)) (pair (id "Ginsho" P2) (id "Ginsho" P1)) (pair (id "Kinsho" P1) (id "Kinsho" P2)) (pair (id "Kinsho" P2) (id "Kinsho" P1)) (pair (id "Tokin" P1) (id "Tokin" P2)) (pair (id "Tokin" P2) (id "Tokin" P1)) (pair (id "Hisha" P1) (id "Fuhyo" P2)) (pair (id "Hisha" P2) (id "Fuhyo" P1)) (pair (id "Kakugyo" P1) (id "Ginsho" P2)) (pair (id "Kakugyo" P2) (id "Ginsho" P1)) (pair (id "Keima" P1) (id "Kinsho" P2)) (pair (id "Keima" P2) (id "Kinsho" P1)) (pair (id "Kyosha" P1) (id "Tokin" P2)) (pair (id "Kyosha" P2) (id "Tokin" P1))}) (map "Promoted" {(pair (id "Fuhyo" P1) (id "Hisha" P1)) (pair (id "Fuhyo" P2) (id "Hisha" P2)) (pair (id "Ginsho" P1) (id "Kakugyo" P1)) (pair (id "Ginsho" P2) (id "Kakugyo" P2)) (pair (id "Keima" P1) (id "Kinsho" P1)) (pair (id "Keima" P2) (id "Kinsho" P2)) (pair (id "Kyosha" P1) (id "Tokin" P1)) (pair (id "Kyosha" P2) (id "Tokin" P2)) (pair (id "Hisha" P1) (id "Fuhyo" P1)) (pair (id "Hisha" P2) (id "Fuhyo" P2)) (pair (id "Kakugyo" P1) (id "Ginsho" P1)) (pair (id "Kakugyo" P2) (id "Ginsho" P2)) (pair (id "Kinsho" P1) (id "Keima" P1)) (pair (id "Kinsho" P2) (id "Keima" P2)) (pair (id "Tokin" P1) (id "Kyosha" P1)) (pair (id "Tokin" P2) (id "Kyosha" P2))}) (hand Each size:4)}) (rules (start {(place "Osho1" coord:"C1") (place "Tokin1" coord:"A1") (place "Ginsho1" coord:"B1") (place "Kinsho1" coord:"D1") (place "Fuhyo1" coord:"E1") (place "Osho2" coord:"C5") (place "Tokin2" coord:"E5") (place "Ginsho2" coord:"D5") (place "Kinsho2" coord:"B5") (place "Fuhyo2" coord:"A5")}) (play (if (is Prev Mover) (move Promote (last To) (piece {(mapEntry "Promoted" (what at:(last To))) (what at:(last To))})) (do (or (move (from (sites Occupied by:Mover container:"Hand")) (to (sites Empty)) (then (moveAgain))) (forEach Piece)) ifAfterwards:(not (is Threatened (id "Osho" Mover)))))) (end {(if (and (is Threatened (id "Osho" Next)) (not (can Move (do (or (move (from (sites Occupied by:Next container:"Hand")) (to (sites Empty)) (then (moveAgain))) (forEach Piece Next)) ifAfterwards:(not (is Threatened (id "Osho" Next))))))) (result Mover Win)) (if (no Moves Next) (result Mover Win))}))) 
The rules are identical to those of standard Shogi, except that it is played with a reduced number of pieces on a 5x5 board, and each player's promotion zone consists only of the rank furthest from the player.
(game "Minishogi" (players {(player N) (player S)}) (equipment {(board (square 5)) (piece "Osho" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))))) (piece "Fuhyo" Each (move Step Forward (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))) (then (if (is In (last To) (sites Mover "Promotion")) (move Promote (last To) (piece (mapEntry "Promoted" (what at:(last To))))))))) (piece "Ginsho" Each (move Step (directions {Forward BL BR FL FR}) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))) (then (if (or (is In (last To) (sites Mover "Promotion")) (is In (last From) (sites Mover "Promotion"))) (moveAgain))))) (piece "Hisha" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))) (then (if (or (is In (last To) (sites Mover "Promotion")) (is In (last From) (sites Mover "Promotion"))) (moveAgain))))) (piece "Kakugyo" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))) (then (if (or (is In (last To) (sites Mover "Promotion")) (is In (last From) (sites Mover "Promotion"))) (moveAgain))))) (piece "Kinsho" Each (move Step (directions {Forward Backward Rightward Leftward FL FR}) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))))) (piece "Tokin" Each (move Step (directions {Forward Backward Rightward Leftward FL FR}) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))))) (piece "Narigin" Each (move Step (directions {Forward Backward Rightward Leftward FL FR}) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))))) (piece "Ryuo" Each (or (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to))))))))) (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to))))))))))) (piece "Ryuma" Each (or (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to))))))))) (move Step Orthogonal (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to))))))))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom)) (map "Where" {(pair (id "Fuhyo" P1) (handSite P2)) (pair (id "Fuhyo" P2) (handSite P1)) (pair (id "Ginsho" P1) (handSite P2 1)) (pair (id "Ginsho" P2) (handSite P1 1)) (pair (id "Hisha" P1) (handSite P2 2)) (pair (id "Hisha" P2) (handSite P1 2)) (pair (id "Kakugyo" P1) (handSite P2 3)) (pair (id "Kakugyo" P2) (handSite P1 3)) (pair (id "Kinsho" P1) (handSite P2 4)) (pair (id "Kinsho" P2) (handSite P1 4)) (pair (id "Tokin" P1) (handSite P2)) (pair (id "Tokin" P2) (handSite P1)) (pair (id "Narigin" P1) (handSite P2 1)) (pair (id "Narigin" P2) (handSite P1 1)) (pair (id "Ryuo" P1) (handSite P2 2)) (pair (id "Ryuo" P2) (handSite P1 2)) (pair (id "Ryuma" P1) (handSite P2 3)) (pair (id "Ryuma" P2) (handSite P1 3))}) (map "Captured" {(pair (id "Fuhyo" P1) (id "Fuhyo" P2)) (pair (id "Fuhyo" P2) (id "Fuhyo" P1)) (pair (id "Ginsho" P1) (id "Ginsho" P2)) (pair (id "Ginsho" P2) (id "Ginsho" P1)) (pair (id "Hisha" P1) (id "Hisha" P2)) (pair (id "Hisha" P2) (id "Hisha" P1)) (pair (id "Kakugyo" P1) (id "Kakugyo" P2)) (pair (id "Kakugyo" P2) (id "Kakugyo" P1)) (pair (id "Kinsho" P1) (id "Kinsho" P2)) (pair (id "Kinsho" P2) (id "Kinsho" P1)) (pair (id "Tokin" P1) (id "Fuhyo" P2)) (pair (id "Tokin" P2) (id "Fuhyo" P1)) (pair (id "Narigin" P1) (id "Ginsho" P2)) (pair (id "Narigin" P2) (id "Ginsho" P1)) (pair (id "Ryuo" P1) (id "Hisha" P2)) (pair (id "Ryuo" P2) (id "Hisha" P1)) (pair (id "Ryuma" P1) (id "Kakugyo" P2)) (pair (id "Ryuma" P2) (id "Kakugyo" P1))}) (map "Promoted" {(pair (id "Fuhyo" P1) (id "Tokin" P1)) (pair (id "Fuhyo" P2) (id "Tokin" P2)) (pair (id "Ginsho" P1) (id "Narigin" P1)) (pair (id "Ginsho" P2) (id "Narigin" P2)) (pair (id "Hisha" P1) (id "Ryuo" P1)) (pair (id "Hisha" P2) (id "Ryuo" P2)) (pair (id "Kakugyo" P1) (id "Ryuma" P1)) (pair (id "Kakugyo" P2) (id "Ryuma" P2))}) (hand Each size:5)}) (rules (start {(place "Osho1" coord:"A1") (place "Kinsho1" coord:"B1") (place "Ginsho1" coord:"C1") (place "Kakugyo1" coord:"D1") (place "Hisha1" coord:"E1") (place "Fuhyo1" coord:"A2") (place "Osho2" coord:"E5") (place "Kinsho2" coord:"D5") (place "Ginsho2" coord:"C5") (place "Kakugyo2" coord:"B5") (place "Hisha2" coord:"A5") (place "Fuhyo2" coord:"E4")}) (play (if (is Prev Mover) (or (move Promote (last To) (piece (mapEntry "Promoted" (what at:(last To))))) (move Pass)) (do (or {(move (from (sites Occupied by:Mover container:"Hand" components:{"Kakugyo" "Ginsho" "Hisha" "Kinsho"})) (to (sites Empty))) (do (move (from (sites Occupied by:Mover container:"Hand" component:"Fuhyo")) (to (difference (sites Empty) (sites Mover "Promotion")) if:(= (count Sites in:(sites Occupied by:Mover container:"Board" component:"Fuhyo")) (count Sites in:(difference (sites Occupied by:Mover container:"Board" component:"Fuhyo") (sites Column (column of:(to)))))))) ifAfterwards:(not (and (is Threatened (id "Osho" Next)) (not (can Move (do (or {(move (from (sites Occupied by:Next container:"Hand" components:{"Kakugyo" "Ginsho" "Hisha" "Kinsho"})) (to (sites Empty))) (do (move (from (sites Occupied by:Next container:"Hand" component:"Fuhyo")) (to (difference (sites Empty) (sites Next "Promotion")) if:(= (count Sites in:(sites Occupied by:Next container:"Board" component:"Fuhyo")) (count Sites in:(difference (sites Occupied by:Next container:"Board" component:"Fuhyo") (sites Column (column of:(to)))))))) ifAfterwards:(not (is Threatened (id "Osho" Mover)))) (forEach Piece Next)}) ifAfterwards:(not (is Threatened (id "Osho" Next))))))))) (forEach Piece)}) ifAfterwards:(not (is Threatened (id "Osho" Mover)))))) (end {(if (and (is Threatened (id "Osho" Next)) (not (can Move (do (or {(move (from (sites Occupied by:Next container:"Hand" components:{"Kakugyo" "Ginsho" "Hisha" "Kinsho"})) (to (sites Empty))) (do (move (from (sites Occupied by:Next container:"Hand" component:"Fuhyo")) (to (difference (sites Empty) (sites Next "Promotion")) if:(= (count Sites in:(sites Occupied by:Next container:"Board" component:"Fuhyo")) (count Sites in:(difference (sites Occupied by:Next container:"Board" component:"Fuhyo") (sites Column (column of:(to)))))))) ifAfterwards:(not (is Threatened (id "Osho" Mover)))) (forEach Piece Next)}) ifAfterwards:(not (is Threatened (id "Osho" Next))))))) (result Mover Win)) (if (no Moves Next) (result Mover Win))}))) 
Pieces move as follows: Osho(1): moves one space in any direction Hisha(1): moves any number of spaces orthogonally. Kakugyo(1): moves any number of spaces diagonally. Kinsho(2): moves one square in any direction except diagonally backwards. Ginsho (2): moves one square diagonally or one square forward orthogonally. Keima(2): moves one space forward and then one space diagonally forward. Kyosha(2): moves any number of spaces only forward or backward. Fuhyo(9): moves one space forward. Pieces are promoted when reaching the opposite third of the board. Pieces are captured when an opponent's piece moves to the space it occupies. Captured pieces are held and can re-enter the game under the control of the capturing player as their turn. The goal is to capture the other player's king.
(game "Shogi" (players {(player N) (player S)}) (equipment {(board (square 9)) (piece "Osho" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))))) (piece "Fuhyo" Each (move Step Forward (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))) (then (if (is In (last To) (sites Mover "Promotion")) (if (is In (last To) (sites Mover "LastRank")) (move Promote (last To) (piece (mapEntry "Promoted" (what at:(last To))))) (moveAgain)))))) (piece "Ginsho" Each (move Step (directions {Forward BL BR FL FR}) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))) (then (if (or (is In (last To) (sites Mover "Promotion")) (is In (last From) (sites Mover "Promotion"))) (moveAgain))))) (piece "Hisha" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))) (then (if (or (is In (last To) (sites Mover "Promotion")) (is In (last From) (sites Mover "Promotion"))) (moveAgain))))) (piece "Kakugyo" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))) (then (if (or (is In (last To) (sites Mover "Promotion")) (is In (last From) (sites Mover "Promotion"))) (moveAgain))))) (piece "Keima" Each (forEach Direction Forward (to if:True (apply (forEach Direction (from (to)) (directions {FR FL}) (if (not (is Friend (who at:(to)))) (move (from) (to (apply if:(is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))))))) (then (if (is In (last To) (sites Mover "Promotion")) (if (is In (last To) (sites Mover "TwoFurthestRank")) (move Promote (last To) (piece (mapEntry "Promoted" (what at:(last To))))) (moveAgain)))))) (piece "Kyosha" Each (move Slide Forward (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))) (then (if (is In (last To) (sites Mover "Promotion")) (if (is In (last To) (sites Mover "LastRank")) (move Promote (last To) (piece (mapEntry "Promoted" (what at:(last To))))) (moveAgain)))))) (piece "Kinsho" Each (move Step (directions {Forward Backward Rightward Leftward FL FR}) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))))) (piece "Tokin" Each (move Step (directions {Forward Backward Rightward Leftward FL FR}) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))))) (piece "Narigin" Each (move Step (directions {Forward Backward Rightward Leftward FL FR}) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))))) (piece "Ryuo" Each (or (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to))))))))) (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to))))))))))) (piece "Ryuma" Each (or (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to))))))))) (move Step Orthogonal (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to))))))))))) (piece "Narikei" Each (move Step (directions {Forward Backward Rightward Leftward FL FR}) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))))) (piece "Narikyo" Each (move Step (directions {Forward Backward Rightward Leftward FL FR}) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))))) (regions "LastRankP1" P1 (sites Top)) (regions "LastRankP2" P2 (sites Bottom)) (regions "TwoFurthestRankP1" P1 (expand (sites Top))) (regions "TwoFurthestRankP2" P2 (expand (sites Bottom))) (regions "Promotion" P1 (expand (sites Top) steps:2)) (regions "Promotion" P2 (expand (sites Bottom) steps:2)) (map "Where" {(pair (id "Fuhyo" P1) (handSite P2)) (pair (id "Fuhyo" P2) (handSite P1)) (pair (id "Ginsho" P1) (handSite P2 1)) (pair (id "Ginsho" P2) (handSite P1 1)) (pair (id "Hisha" P1) (handSite P2 2)) (pair (id "Hisha" P2) (handSite P1 2)) (pair (id "Kakugyo" P1) (handSite P2 3)) (pair (id "Kakugyo" P2) (handSite P1 3)) (pair (id "Keima" P1) (handSite P2 4)) (pair (id "Keima" P2) (handSite P1 4)) (pair (id "Kyosha" P1) (handSite P2 5)) (pair (id "Kyosha" P2) (handSite P1 5)) (pair (id "Kinsho" P1) (handSite P2 6)) (pair (id "Kinsho" P2) (handSite P1 6)) (pair (id "Tokin" P1) (handSite P2)) (pair (id "Tokin" P2) (handSite P1)) (pair (id "Narigin" P1) (handSite P2 1)) (pair (id "Narigin" P2) (handSite P1 1)) (pair (id "Ryuo" P1) (handSite P2 2)) (pair (id "Ryuo" P2) (handSite P1 2)) (pair (id "Ryuma" P1) (handSite P2 3)) (pair (id "Ryuma" P2) (handSite P1 3)) (pair (id "Narikei" P1) (handSite P2 4)) (pair (id "Narikei" P2) (handSite P1 4)) (pair (id "Narikyo" P1) (handSite P2 5)) (pair (id "Narikyo" P2) (handSite P1 5))}) (map "Captured" {(pair (id "Fuhyo" P1) (id "Fuhyo" P2)) (pair (id "Fuhyo" P2) (id "Fuhyo" P1)) (pair (id "Ginsho" P1) (id "Ginsho" P2)) (pair (id "Ginsho" P2) (id "Ginsho" P1)) (pair (id "Hisha" P1) (id "Hisha" P2)) (pair (id "Hisha" P2) (id "Hisha" P1)) (pair (id "Kakugyo" P1) (id "Kakugyo" P2)) (pair (id "Kakugyo" P2) (id "Kakugyo" P1)) (pair (id "Keima" P1) (id "Keima" P2)) (pair (id "Keima" P2) (id "Keima" P1)) (pair (id "Kyosha" P1) (id "Kyosha" P2)) (pair (id "Kyosha" P2) (id "Kyosha" P1)) (pair (id "Kinsho" P1) (id "Kinsho" P2)) (pair (id "Kinsho" P2) (id "Kinsho" P1)) (pair (id "Tokin" P1) (id "Fuhyo" P2)) (pair (id "Tokin" P2) (id "Fuhyo" P1)) (pair (id "Narigin" P1) (id "Ginsho" P2)) (pair (id "Narigin" P2) (id "Ginsho" P1)) (pair (id "Ryuo" P1) (id "Hisha" P2)) (pair (id "Ryuo" P2) (id "Hisha" P1)) (pair (id "Ryuma" P1) (id "Kakugyo" P2)) (pair (id "Ryuma" P2) (id "Kakugyo" P1)) (pair (id "Narikei" P1) (id "Keima" P2)) (pair (id "Narikei" P2) (id "Keima" P1)) (pair (id "Narikyo" P1) (id "Kyosha" P2)) (pair (id "Narikyo" P2) (id "Kyosha" P1))}) (map "Promoted" {(pair (id "Fuhyo" P1) (id "Tokin" P1)) (pair (id "Fuhyo" P2) (id "Tokin" P2)) (pair (id "Ginsho" P1) (id "Narigin" P1)) (pair (id "Ginsho" P2) (id "Narigin" P2)) (pair (id "Hisha" P1) (id "Ryuo" P1)) (pair (id "Hisha" P2) (id "Ryuo" P2)) (pair (id "Kakugyo" P1) (id "Ryuma" P1)) (pair (id "Kakugyo" P2) (id "Ryuma" P2)) (pair (id "Keima" P1) (id "Narikei" P1)) (pair (id "Keima" P2) (id "Narikei" P2)) (pair (id "Kyosha" P1) (id "Narikyo" P1)) (pair (id "Kyosha" P2) (id "Narikyo" P2))}) (hand Each size:7)}) (rules (start {(place "Osho1" coord:"E1") (place "Kinsho1" {"D1" "F1"}) (place "Ginsho1" {"C1" "G1"}) (place "Keima1" {"B1" "H1"}) (place "Kyosha1" {"A1" "I1"}) (place "Kakugyo1" coord:"B2") (place "Hisha1" coord:"H2") (place "Fuhyo1" (sites Row 2)) (place "Osho2" coord:"E9") (place "Kinsho2" {"D9" "F9"}) (place "Ginsho2" {"C9" "G9"}) (place "Keima2" {"B9" "H9"}) (place "Kyosha2" {"A9" "I9"}) (place "Kakugyo2" coord:"H8") (place "Hisha2" coord:"B8") (place "Fuhyo2" (sites Row 6))}) (play (if (is Prev Mover) (or (move Promote (last To) (piece (mapEntry "Promoted" (what at:(last To))))) (move Pass)) (do (or {(move (from (sites Occupied by:Mover container:"Hand" components:{"Kakugyo" "Ginsho" "Hisha" "Kinsho"})) (to (sites Empty))) (do (move (from (sites Occupied by:Mover container:"Hand" component:"Fuhyo")) (to (difference (sites Empty) (sites Mover "LastRank")) if:(= (count Sites in:(sites Occupied by:Mover container:"Board" component:"Fuhyo")) (count Sites in:(difference (sites Occupied by:Mover container:"Board" component:"Fuhyo") (sites Column (column of:(to)))))))) ifAfterwards:(not (and (is Threatened (id "Osho" Next)) (not (can Move (do (or {(move (from (sites Occupied by:Next container:"Hand" components:{"Kakugyo" "Ginsho" "Hisha" "Kinsho"})) (to (sites Empty))) (do (move (from (sites Occupied by:Next container:"Hand" component:"Fuhyo")) (to (difference (sites Empty) (sites Next "LastRank")) if:(= (count Sites in:(sites Occupied by:Next container:"Board" component:"Fuhyo")) (count Sites in:(difference (sites Occupied by:Next container:"Board" component:"Fuhyo") (sites Column (column of:(to)))))))) ifAfterwards:(not (is Threatened (id "Osho" Mover)))) (move (from (sites Occupied by:Next container:"Hand" component:"Kyosha")) (to (difference (sites Empty) (sites Next "LastRank")))) (move (from (sites Occupied by:Next container:"Hand" component:"Keima")) (to (difference (sites Empty) (sites Next "TwoFurthestRank")))) (forEach Piece Next)}) ifAfterwards:(not (is Threatened (id "Osho" Next))))))))) (move (from (sites Occupied by:Mover container:"Hand" component:"Kyosha")) (to (difference (sites Empty) (sites Mover "LastRank")))) (move (from (sites Occupied by:Mover container:"Hand" component:"Keima")) (to (difference (sites Empty) (sites Mover "TwoFurthestRank")))) (forEach Piece)}) ifAfterwards:(not (is Threatened (id "Osho" Mover)))))) (end {(if (and (is Threatened (id "Osho" Next)) (not (can Move (do (or {(move (from (sites Occupied by:Next container:"Hand" components:{"Kakugyo" "Ginsho" "Hisha" "Kinsho"})) (to (sites Empty))) (do (move (from (sites Occupied by:Next container:"Hand" component:"Fuhyo")) (to (difference (sites Empty) (sites Next "LastRank")) if:(= (count Sites in:(sites Occupied by:Next container:"Board" component:"Fuhyo")) (count Sites in:(difference (sites Occupied by:Next container:"Board" component:"Fuhyo") (sites Column (column of:(to)))))))) ifAfterwards:(not (is Threatened (id "Osho" Mover)))) (move (from (sites Occupied by:Next container:"Hand" component:"Kyosha")) (to (difference (sites Empty) (sites Next "LastRank")))) (move (from (sites Occupied by:Next container:"Hand" component:"Keima")) (to (difference (sites Empty) (sites Next "TwoFurthestRank")))) (forEach Piece Next)}) ifAfterwards:(not (is Threatened (id "Osho" Next))))))) (result Mover Win)) (if (no Moves Next) (result Mover Win))}))) 
Rules in the Wikipedia page. The rules are describing from wikipedia.
(game "Tenjiku Shogi" (players {(player N) (player S)}) (equipment {(board (square 16)) (piece "Pawn" (move Step Forward (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (piece "King" (move Step Adjacent (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (piece "Prince" (move Step Adjacent (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (piece "DrunkenElephant" (move Step (difference Adjacent (directions {Backward})) (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (piece "ViceGeneral" (or {(if (not (is Prev Mover)) (or (move Hop Diagonal (between (range 1 (count Columns)) if:(not (is In (what at:(between)) (sites {(id "King1") (id "King2") (id "Prince1") (id "Prince2") (id "GreatGeneral1") (id "GreatGeneral2") (id "ViceGeneral1") (id "ViceGeneral2")})))) (to if:(and (is Enemy (who at:(to))) (not (is In (what at:(to)) (sites {(id "King" Next) (id "Prince" Next)})))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (move Step Adjacent (to if:(is Empty (to))) (then (if (< (value Player Mover) 1) (and (set Value Mover (+ 1 (value Player Mover))) (moveAgain)) (set Value Mover -1)))) (move Step Adjacent (to if:(is Enemy (who at:(to))) (apply (remove (to)))) (then (set Value Mover -1)))})) (piece "GreatGeneral" (or (move Hop Adjacent (between (range 1 (count Columns)) if:(not (is In (what at:(between)) (sites {(id "King1") (id "King2") (id "Prince1") (id "Prince2") (id "GreatGeneral1") (id "GreatGeneral2")})))) (to if:(and (is Enemy (who at:(to))) (not (is In (what at:(to)) (sites {(id "King" Next) (id "Prince" Next)})))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Slide Adjacent (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (piece "BishopGeneral" (or (move Hop Diagonal (between (range 1 (count Columns)) if:(not (is In (what at:(between)) (sites {(id "King1") (id "King2") (id "Prince1") (id "Prince2") (id "GreatGeneral1") (id "GreatGeneral2") (id "ViceGeneral1") (id "ViceGeneral2") (id "BishopGeneral1") (id "BishopGeneral2") (id "RookGeneral1") (id "RookGeneral2")})))) (to if:(and (is Enemy (who at:(to))) (not (is In (what at:(to)) (sites {(id "King" Next) (id "Prince" Next)})))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (then (if (and (= (state at:(last To)) 0) (or (is In (last To) (sites Mover "Promotion")) (is In (last From) (sites Mover "Promotion")))) (moveAgain))))) (piece "RookGeneral" (or (move Hop Orthogonal (between (range 1 (count Columns)) if:(not (is In (what at:(between)) (sites {(id "King1") (id "King2") (id "Prince1") (id "Prince2") (id "GreatGeneral1") (id "GreatGeneral2") (id "ViceGeneral1") (id "ViceGeneral2") (id "BishopGeneral1") (id "BishopGeneral2") (id "RookGeneral1") (id "RookGeneral2")})))) (to if:(and (is Enemy (who at:(to))) (not (is In (what at:(to)) (sites {(id "King" Next) (id "Prince" Next)})))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (then (if (and (= (state at:(last To)) 0) (or (is In (last To) (sites Mover "Promotion")) (is In (last From) (sites Mover "Promotion")))) (moveAgain))))) (piece "Lion" (or {(move Step Adjacent (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (step (from (last To)) N (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (move Step Adjacent (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (step (from (last To)) S (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (move Step Adjacent (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (step (from (last To)) E (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (move Step Adjacent (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (step (from (last To)) W (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (move Step Adjacent (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (step (from (last To)) NE (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (move Step Adjacent (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (step (from (last To)) NW (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (move Step Adjacent (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (step (from (last To)) SW (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (move Step Adjacent (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (step (from (last To)) SE (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (move Hop Adjacent (between if:True) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))} (then (if (and (= (state at:(last To)) 0) (or (is In (last To) (sites Mover "Promotion")) (is In (last From) (sites Mover "Promotion")))) (moveAgain))))) (piece "HornedFalcon" (or {(move Step Forward (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (step (from (last To)) N (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (move Step Forward (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (step (from (last To)) S (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (move Hop Forward (between if:True) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Slide (difference Adjacent (directions {Forward})) (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to))))))} (then (if (and (= (state at:(last To)) 0) (or (is In (last To) (sites Mover "Promotion")) (is In (last From) (sites Mover "Promotion")))) (moveAgain))))) (piece "SoaringEagle" (or {(move Step FL (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (step (from (last To)) NW (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (move Step FL (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (step (from (last To)) SE (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (move Step FR (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (step (from (last To)) SW (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (move Step FR (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (step (from (last To)) NE (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (move Hop (directions {FL FR}) (between if:True) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Slide (difference Adjacent (directions {FL FR})) (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to))))))} (then (if (and (= (state at:(last To)) 0) (or (is In (last To) (sites Mover "Promotion")) (is In (last From) (sites Mover "Promotion")))) (moveAgain))))) (piece "DragonHorse" (or (move Step Orthogonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))) (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (then (if (and (= (state at:(last To)) 0) (or (is In (last To) (sites Mover "Promotion")) (is In (last From) (sites Mover "Promotion")))) (moveAgain))))) (piece "DragonKing" (or (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))) (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (then (if (and (= (state at:(last To)) 0) (or (is In (last To) (sites Mover "Promotion")) (is In (last From) (sites Mover "Promotion")))) (moveAgain))))) (piece "Bishop" (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (if (and (= (state at:(last To)) 0) (or (is In (last To) (sites Mover "Promotion")) (is In (last From) (sites Mover "Promotion")))) (moveAgain))))) (piece "Rook" (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (if (and (= (state at:(last To)) 0) (or (is In (last To) (sites Mover "Promotion")) (is In (last From) (sites Mover "Promotion")))) (moveAgain))))) (piece "FerociousLeopard" (move Step (directions {Backward Forward FL FR BR BL}) (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))) (then (if (and (= (state at:(last To)) 0) (or (is In (last To) (sites Mover "Promotion")) (is In (last From) (sites Mover "Promotion")))) (moveAgain))))) (piece "GoldGeneral" (move Step (directions {Backward Forward FL FR Rightward Leftward}) (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))) (then (if (and (= (state at:(last To)) 0) (or (is In (last To) (sites Mover "Promotion")) (is In (last From) (sites Mover "Promotion")))) (moveAgain))))) (piece "FireDemon" (or (if (not (is Prev Mover)) (move Slide (directions {FL FR BR BL Rightward Leftward}) (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (remove (intersection (sites Around (last To)) (sites Occupied by:Next)))))) (move Step Adjacent (to if:(is Empty (to))) (then (if (!= 0 (count Sites in:(intersection (sites Around (last To)) (sites Occupied by:Next)))) (and (remove (intersection (sites Around (last To)) (sites Occupied by:Next))) (set Value Mover -1)) (if (< (value Player Mover) 1) (and (set Value Mover (+ 1 (value Player Mover))) (moveAgain)) (set Value Mover -1))))))) (piece "HeavenlyTetrarch" (or {(move Step N (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (step (from (last To)) S (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (move Step NE (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (step (from (last To)) SW (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (move Step E (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (step (from (last To)) W (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (move Step SE (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (step (from (last To)) NW (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (move Step S (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (step (from (last To)) N (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (move Step SW (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (step (from (last To)) NE (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (move Step W (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (step (from (last To)) E (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (move Step NW (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (step (from (last To)) SE (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (move Slide (directions {FR FL BR BL Forward Backward}) (between if:(or (is Empty (between)) (is In (between) (sites Around (from))))) (to if:(and (not (is In (to) (sites Around (from)))) (is Enemy (who at:(to)))) (apply if:(not (is In (to) (sites Around (from)))) (if (is Enemy (who at:(to))) (remove (to)))))) (move Slide (directions {Rightward Leftward}) (between (max 3) if:(or (is Empty (between)) (is In (between) (sites Around (from))))) (to if:(and (not (is In (to) (sites Around (from)))) (is Enemy (who at:(to)))) (apply if:(not (is In (to) (sites Around (from)))) (if (is Enemy (who at:(to))) (remove (to))))))})) (piece "WaterBuffalo" (or (move Slide (directions {FR FL BR BL Rightward Leftward}) (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Slide (directions {Forward Backward}) (between (max 2)) (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (then (if (and (= (state at:(last To)) 0) (or (is In (last To) (sites Mover "Promotion")) (is In (last From) (sites Mover "Promotion")))) (moveAgain))))) (piece "ChariotSoldier" (or (move Slide (directions {FR FL BR BL Forward Backward}) (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Slide (directions {Rightward Leftward}) (between (max 2)) (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (then (if (and (= (state at:(last To)) 0) (or (is In (last To) (sites Mover "Promotion")) (is In (last From) (sites Mover "Promotion")))) (moveAgain))))) (piece "SideSoldier" (or {(move Slide (directions {Rightward Leftward}) (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Slide Forward (between (max 2)) (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Step Backward (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))} (then (if (and (= (state at:(last To)) 0) (or (is In (last To) (sites Mover "Promotion")) (is In (last From) (sites Mover "Promotion")))) (moveAgain))))) (piece "VerticalSoldier" (or {(move Slide Forward (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Slide (directions {Rightward Leftward}) (between (max 2)) (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Step Backward (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))} (then (if (and (= (state at:(last To)) 0) (or (is In (last To) (sites Mover "Promotion")) (is In (last From) (sites Mover "Promotion")))) (moveAgain))))) (piece "Knight" (forEach Direction Forward (to if:True (apply (forEach Direction (from (to)) (directions {FR FL}) (if (not (is Friend (who at:(to)))) (move (from) (to (apply (if (is Enemy (who at:(to))) (remove (to)))))))))) (then (if (and (= (state at:(last To)) 0) (or (is In (last To) (sites Mover "Promotion")) (is In (last From) (sites Mover "Promotion")))) (moveAgain))))) (piece "IronGeneral" (move Step (directions {Forward FR FL}) (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))) (then (if (and (= (state at:(last To)) 0) (or (is In (last To) (sites Mover "Promotion")) (is In (last From) (sites Mover "Promotion")))) (moveAgain))))) (piece "FreeEagle" (or {(move Slide Adjacent (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Step NE (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (step (from (last To)) NE (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (move Step NE (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (step (from (last To)) NW (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (move Step NE (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (step (from (last To)) SE (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (move Step SE (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (step (from (last To)) SE (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (move Step SE (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (step (from (last To)) NE (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (move Step SE (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (step (from (last To)) SW (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (move Step SW (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (step (from (last To)) SW (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (move Step SW (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (step (from (last To)) NW (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (move Step SW (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (step (from (last To)) SE (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (move Step NW (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (step (from (last To)) NW (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (move Step NW (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (step (from (last To)) NE (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (move Step NW (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (step (from (last To)) SW (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))))})) (piece "LionHawk" (or {(move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Step Adjacent (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (step (from (last To)) N (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (move Step Adjacent (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (step (from (last To)) S (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (move Step Adjacent (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (step (from (last To)) E (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (move Step Adjacent (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (step (from (last To)) W (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (move Step Adjacent (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (step (from (last To)) NE (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (move Step Adjacent (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (step (from (last To)) NW (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (move Step Adjacent (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (step (from (last To)) SW (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (move Step Adjacent (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (step (from (last To)) SE (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (move Hop Adjacent (between if:True) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))})) (piece "Queen" (move Slide Adjacent (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (if (and (= (state at:(last To)) 0) (or (is In (last To) (sites Mover "Promotion")) (is In (last From) (sites Mover "Promotion")))) (moveAgain))))) (piece "Phoenix" (or (move Step Orthogonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))) (move Hop Diagonal (between if:True) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (then (if (and (= (state at:(last To)) 0) (or (is In (last To) (sites Mover "Promotion")) (is In (last From) (sites Mover "Promotion")))) (moveAgain))))) (piece "Kirin" (or (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))) (move Hop Orthogonal (between if:True) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (then (if (and (= (state at:(last To)) 0) (or (is In (last To) (sites Mover "Promotion")) (is In (last From) (sites Mover "Promotion")))) (moveAgain))))) (piece "FreeBoar" (move Slide (directions {FR FL BR BL Rightward Leftward}) (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "FlyingOx" (move Slide (directions {FR FL BR BL Forward Backward}) (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "SideMover" (or (move Step (directions {Forward Backward}) (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))) (move Slide (directions {Rightward Leftward}) (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (then (if (and (= (state at:(last To)) 0) (or (is In (last To) (sites Mover "Promotion")) (is In (last From) (sites Mover "Promotion")))) (moveAgain))))) (piece "VerticalMover" (or (move Step (directions {Rightward Leftward}) (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))) (move Slide (directions {Forward Backward}) (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (then (if (and (= (state at:(last To)) 0) (or (is In (last To) (sites Mover "Promotion")) (is In (last From) (sites Mover "Promotion")))) (moveAgain))))) (piece "CopperGeneral" (move Step (directions {Forward Backward FR FL}) (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))) (then (if (and (= (state at:(last To)) 0) (or (is In (last To) (sites Mover "Promotion")) (is In (last From) (sites Mover "Promotion")))) (moveAgain))))) (piece "SilverGeneral" (move Step (directions {Forward BR BL FR FL}) (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))) (then (if (and (= (state at:(last To)) 0) (or (is In (last To) (sites Mover "Promotion")) (is In (last From) (sites Mover "Promotion")))) (moveAgain))))) (piece "MultiGeneral" (move Slide (directions {Forward BR BL}) (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "FlyingStag" (or (move Slide (directions {Forward Backward}) (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move Step (directions {Rightward Leftward BR BL FR FL}) (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))))) (piece "Dog" (move Step (directions {BR BL Forward}) (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))) (then (if (and (= (state at:(last To)) 0) (or (is In (last To) (sites Mover "Promotion")) (is In (last From) (sites Mover "Promotion")))) (moveAgain))))) (piece "BlindTiger" (move Step (difference Adjacent (directions {Forward})) (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))) (then (if (and (= (state at:(last To)) 0) (or (is In (last To) (sites Mover "Promotion")) (is In (last From) (sites Mover "Promotion")))) (moveAgain))))) (piece "WhiteHorse" (move Slide (directions {Forward FR FL Backward}) (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Whale" (move Slide (directions {Forward BR BL Backward}) (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Lance" (move Slide Forward (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (if (and (= (state at:(last To)) 0) (or (is In (last To) (sites Mover "Promotion")) (is In (last From) (sites Mover "Promotion")))) (moveAgain))))) (piece "ReverseChariot" (move Slide (directions {Forward Backward}) (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (if (and (= (state at:(last To)) 0) (or (is In (last To) (sites Mover "Promotion")) (is In (last From) (sites Mover "Promotion")))) (moveAgain))))) (regions "Promotion" P1 (expand (sites Top) steps:4)) (regions "Promotion" P2 (expand (sites Bottom) steps:4)) (map "Promoted" {(pair (id "FerociousLeopard" P1) (id "Bishop" P1)) (pair (id "FerociousLeopard" P2) (id "Bishop" P2)) (pair (id "Bishop" P1) (id "DragonHorse" P1)) (pair (id "Bishop" P2) (id "DragonHorse" P2)) (pair (id "DragonHorse" P1) (id "HornedFalcon" P1)) (pair (id "DragonHorse" P2) (id "HornedFalcon" P2)) (pair (id "HornedFalcon" P1) (id "BishopGeneral" P1)) (pair (id "HornedFalcon" P2) (id "BishopGeneral" P2)) (pair (id "BishopGeneral" P1) (id "ViceGeneral" P1)) (pair (id "BishopGeneral" P2) (id "ViceGeneral" P2)) (pair (id "Knight" P1) (id "SideSoldier" P1)) (pair (id "Knight" P2) (id "SideSoldier" P2)) (pair (id "SideSoldier" P1) (id "WaterBuffalo" P1)) (pair (id "SideSoldier" P2) (id "WaterBuffalo" P2)) (pair (id "WaterBuffalo" P1) (id "FireDemon" P1)) (pair (id "WaterBuffalo" P2) (id "FireDemon" P2)) (pair (id "Phoenix" P1) (id "Queen" P1)) (pair (id "Phoenix" P2) (id "Queen" P2)) (pair (id "Queen" P1) (id "FreeEagle" P1)) (pair (id "Queen" P2) (id "FreeEagle" P2)) (pair (id "CopperGeneral" P1) (id "SideMover" P1)) (pair (id "CopperGeneral" P2) (id "SideMover" P2)) (pair (id "SideMover" P1) (id "FreeBoar" P1)) (pair (id "SideMover" P2) (id "FreeBoar" P2)) (pair (id "Dog" P1) (id "MultiGeneral" P1)) (pair (id "Dog" P2) (id "MultiGeneral" P2)) (pair (id "Lance" P1) (id "WhiteHorse" P1)) (pair (id "Lance" P2) (id "WhiteHorse" P2)) (pair (id "DrunkenElephant" P1) (id "Prince" P1)) (pair (id "DrunkenElephant" P2) (id "Prince" P2)) (pair (id "Pawn" P1) (id "GoldGeneral" P1)) (pair (id "Pawn" P2) (id "GoldGeneral" P2)) (pair (id "GoldGeneral" P1) (id "Rook" P1)) (pair (id "GoldGeneral" P2) (id "Rook" P2)) (pair (id "Rook" P1) (id "DragonKing" P1)) (pair (id "Rook" P2) (id "DragonKing" P2)) (pair (id "DragonKing" P1) (id "SoaringEagle" P1)) (pair (id "DragonKing" P2) (id "SoaringEagle" P2)) (pair (id "SoaringEagle" P1) (id "RookGeneral" P1)) (pair (id "SoaringEagle" P2) (id "RookGeneral" P2)) (pair (id "RookGeneral" P1) (id "GreatGeneral" P1)) (pair (id "RookGeneral" P2) (id "GreatGeneral" P2)) (pair (id "IronGeneral" P1) (id "VerticalSoldier" P1)) (pair (id "IronGeneral" P2) (id "VerticalSoldier" P2)) (pair (id "VerticalSoldier" P1) (id "ChariotSoldier" P1)) (pair (id "VerticalSoldier" P2) (id "ChariotSoldier" P2)) (pair (id "ChariotSoldier" P1) (id "HeavenlyTetrarch" P1)) (pair (id "ChariotSoldier" P2) (id "HeavenlyTetrarch" P2)) (pair (id "Kirin" P1) (id "Lion" P1)) (pair (id "Kirin" P2) (id "Lion" P2)) (pair (id "Lion" P1) (id "LionHawk" P1)) (pair (id "Lion" P2) (id "LionHawk" P2)) (pair (id "SilverGeneral" P1) (id "VerticalMover" P1)) (pair (id "SilverGeneral" P2) (id "VerticalMover" P2)) (pair (id "VerticalMover" P1) (id "FlyingOx" P1)) (pair (id "VerticalMover" P2) (id "FlyingOx" P2)) (pair (id "BlindTiger" P1) (id "FlyingStag" P1)) (pair (id "BlindTiger" P2) (id "FlyingStag" P2)) (pair (id "ReverseChariot" P1) (id "Whale" P1)) (pair (id "ReverseChariot" P2) (id "Whale" P2))})}) (rules (start {(place "Lance1" (sites {"A1" "P1"})) (place "Lance2" (sites {"A16" "P16"})) (place "Knight1" (sites {"B1" "O1"})) (place "Knight2" (sites {"B16" "O16"})) (place "FerociousLeopard1" (sites {"C1" "N1"})) (place "FerociousLeopard2" (sites {"C16" "N16"})) (place "IronGeneral1" (sites {"D1" "M1"})) (place "IronGeneral2" (sites {"D16" "M16"})) (place "CopperGeneral1" (sites {"E1" "L1"})) (place "CopperGeneral2" (sites {"E16" "L16"})) (place "SilverGeneral1" (sites {"F1" "K1"})) (place "SilverGeneral2" (sites {"F16" "K16"})) (place "GoldGeneral1" (sites {"G1" "J1"})) (place "GoldGeneral2" (sites {"G16" "J16"})) (place "King1" (sites {"H1"})) (place "King2" (sites {"I16"})) (place "DrunkenElephant1" (sites {"I1"})) (place "DrunkenElephant2" (sites {"H16"})) (place "ReverseChariot1" (sites {"A2" "P2"})) (place "ReverseChariot2" (sites {"A15" "P15"})) (place "ChariotSoldier1" (sites {"C2" "N2" "D2" "M2"})) (place "ChariotSoldier2" (sites {"C15" "N15" "D15" "M15"})) (place "BlindTiger1" (sites {"F2" "K2"})) (place "BlindTiger2" (sites {"F15" "K15"})) (place "Kirin1" (sites {"G2"})) (place "Kirin2" (sites {"J15"})) (place "Lion1" (sites {"H2"})) (place "Lion2" (sites {"I15"})) (place "Queen1" (sites {"I2"})) (place "Queen2" (sites {"H15"})) (place "Phoenix1" (sites {"J2"})) (place "Phoenix2" (sites {"G15"})) (place "SideSoldier1" (sites {"A3" "P3"})) (place "SideSoldier2" (sites {"A14" "P14"})) (place "VerticalSoldier1" (sites {"B3" "O3"})) (place "VerticalSoldier2" (sites {"B14" "O14"})) (place "Bishop1" (sites {"C3" "N3"})) (place "Bishop2" (sites {"C14" "N14"})) (place "DragonHorse1" (sites {"D3" "M3"})) (place "DragonHorse2" (sites {"D14" "M14"})) (place "DragonKing1" (sites {"E3" "L3"})) (place "DragonKing2" (sites {"E14" "L14"})) (place "WaterBuffalo1" (sites {"F3" "K3"})) (place "WaterBuffalo2" (sites {"F14" "K14"})) (place "FireDemon1" (sites {"G3" "J3"})) (place "FireDemon2" (sites {"G14" "J14"})) (place "LionHawk1" (sites {"H3"})) (place "LionHawk2" (sites {"I14"})) (place "FreeEagle1" (sites {"I3"})) (place "FreeEagle2" (sites {"H14"})) (place "SideMover1" (sites {"A4" "P4"})) (place "SideMover2" (sites {"A13" "P13"})) (place "VerticalMover1" (sites {"B4" "O4"})) (place "VerticalMover2" (sites {"B13" "O13"})) (place "Rook1" (sites {"C4" "N4"})) (place "Rook2" (sites {"C13" "N13"})) (place "HornedFalcon1" (sites {"D4" "M4"})) (place "HornedFalcon2" (sites {"D13" "M13"})) (place "SoaringEagle1" (sites {"E4" "L4"})) (place "SoaringEagle2" (sites {"E13" "L13"})) (place "BishopGeneral1" (sites {"F4" "K4"})) (place "BishopGeneral2" (sites {"F13" "K13"})) (place "RookGeneral1" (sites {"G4" "J4"})) (place "RookGeneral2" (sites {"G13" "J13"})) (place "GreatGeneral1" (sites {"H4"})) (place "GreatGeneral2" (sites {"I13"})) (place "ViceGeneral1" (sites {"I4"})) (place "ViceGeneral2" (sites {"H13"})) (place "Pawn1" (sites Row 4)) (place "Pawn2" (sites Row 11)) (place "Dog1" (sites {"E6" "L6"})) (place "Dog2" (sites {"E11" "L11"}))}) (play (if (is Prev Mover) (or (if (= (what at:(last To)) (id "ViceGeneral" Mover)) (forEach Piece "ViceGeneral") (if (= (what at:(last To)) (id "FireDemon" Mover)) (forEach Piece "FireDemon") (move Promote (last To) (piece (mapEntry "Promoted" (what at:(last To)))) (then (set State at:(last To) 1))))) (move Pass (then (set Value Mover -1)))) (forEach Piece) (then (if (!= 0 (count Sites in:(intersection (sites Around (last To)) (sites Occupied by:Next component:"FireDemon")))) (and (remove (last To)) (set Value Mover -1)))))) (end (if (and {(not (is Mover Next)) (= (where "King" Next) -1) (= (where "Prince" Next) -1)}) (result Mover Win))))) 
9x9 board. Played with the full complement of Shogi pieces, placed in the first and second rows. All pieces move only one space orthogonally forward or laterally. Pieces capture by hopping over an opponent's piece. The player to capture all of the opponent's pieces wins.
(game "Tobi Shogi" (players {(player N) (player S)}) (equipment {(board (square 9)) (piece "Osho" Each (or (move Step (directions {Forward Rightward Leftward}) (to if:(is Empty (to)))) (move Hop (directions {Forward Rightward Leftward}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))))) (piece "Kinsho" Each (or (move Step (directions {Forward Rightward Leftward}) (to if:(is Empty (to)))) (move Hop (directions {Forward Rightward Leftward}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))))) (piece "Ginsho" Each (or (move Step (directions {Forward Rightward Leftward}) (to if:(is Empty (to)))) (move Hop (directions {Forward Rightward Leftward}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))))) (piece "Keima" Each (or (move Step (directions {Forward Rightward Leftward}) (to if:(is Empty (to)))) (move Hop (directions {Forward Rightward Leftward}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))))) (piece "Kyosha" Each (or (move Step (directions {Forward Rightward Leftward}) (to if:(is Empty (to)))) (move Hop (directions {Forward Rightward Leftward}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to)))))) (piece "Fuhyo" Each (or (move Step (directions {Forward Rightward Leftward}) (to if:(is Empty (to)))) (move Hop (directions {Forward Rightward Leftward}) (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))))}) (rules (start {(place "Osho1" coord:"E1") (place "Kinsho1" {"D1" "F1"}) (place "Ginsho1" {"C1" "G1"}) (place "Keima1" {"B1" "H1"}) (place "Kyosha1" {"A1" "I1"}) (place "Fuhyo1" (sites Row 1)) (place "Osho2" coord:"E9") (place "Kinsho2" {"D9" "F9"}) (place "Ginsho2" {"C9" "G9"}) (place "Keima2" {"B9" "H9"}) (place "Kyosha2" {"A9" "I9"}) (place "Fuhyo2" (sites Row 7))}) (play (forEach Piece)) (end (if (no Pieces Next) (result Next Loss))))) 
Same as standard Shogi except: 1. The board is initially empty and each player has the normal complement of 20 pieces in reserve. 2. During a turn, a player must do one of three things: --- place a piece from the reserve on an empty square on the board --- move a previously placed piece to an empty square --- move a piece to a square occupied by an opposing piece, capturing it. 3. A player may not make a capture until her/his own king is on the board. Your pieces have no real power of check on the opposing king until your own king is placed. Your opponent can legally place his or her king right next to your promoted Rook if your king is still in hand. There is no additional rule governing when you must enter your king. If a piece is checking the opposing king, but the friendly king has not been placed, that is called quasi-check. A player is under no compulsion to move out of quasi-check.
(game "Unashogi" (players {(player N) (player S)}) (equipment {(board (square 9)) (piece "Osho" Each (move Step (to if:(and (not (is Friend (who at:(to)))) (or (not (is Enemy (who at:(to)))) (= (count Pieces Mover "Osho" in:(sites Board)) 1))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))))) (piece "Fuhyo" Each (move Step Forward (to if:(and (not (is Friend (who at:(to)))) (or (not (is Enemy (who at:(to)))) (= (count Pieces Mover "Osho" in:(sites Board)) 1))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))) (then (if (is In (last To) (sites Mover "Promotion")) (if (is In (last To) (sites Mover "LastRank")) (move Promote (last To) (piece (mapEntry "Promoted" (what at:(last To))))) (moveAgain)))))) (piece "Ginsho" Each (move Step (directions {Forward BL BR FL FR}) (to if:(and (not (is Friend (who at:(to)))) (or (not (is Enemy (who at:(to)))) (= (count Pieces Mover "Osho" in:(sites Board)) 1))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))) (then (if (or (is In (last To) (sites Mover "Promotion")) (is In (last From) (sites Mover "Promotion"))) (moveAgain))))) (piece "Hisha" Each (move Slide Orthogonal (to if:(and (is Enemy (who at:(to))) (= (count Pieces Mover "Osho" in:(sites Board)) 1)) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))) (then (if (or (is In (last To) (sites Mover "Promotion")) (is In (last From) (sites Mover "Promotion"))) (moveAgain))))) (piece "Kakugyo" Each (move Slide Diagonal (to if:(and (is Enemy (who at:(to))) (= (count Pieces Mover "Osho" in:(sites Board)) 1)) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))) (then (if (or (is In (last To) (sites Mover "Promotion")) (is In (last From) (sites Mover "Promotion"))) (moveAgain))))) (piece "Keima" Each (forEach Direction Forward (to if:True (apply (forEach Direction (from (to)) (directions {FR FL}) (if (not (is Friend (who at:(to)))) (move (from) (to (apply if:(is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))))))) (then (if (is In (last To) (sites Mover "Promotion")) (if (is In (last To) (sites Mover "TwoFurthestRank")) (move Promote (last To) (piece (mapEntry "Promoted" (what at:(last To))))) (moveAgain)))))) (piece "Kyosha" Each (move Slide Forward (to if:(and (is Enemy (who at:(to))) (= (count Pieces Mover "Osho" in:(sites Board)) 1)) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))) (then (if (is In (last To) (sites Mover "Promotion")) (if (is In (last To) (sites Mover "LastRank")) (move Promote (last To) (piece (mapEntry "Promoted" (what at:(last To))))) (moveAgain)))))) (piece "Kinsho" Each (move Step (directions {Forward Backward Rightward Leftward FL FR}) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))))) (piece "Tokin" Each (move Step (directions {Forward Backward Rightward Leftward FL FR}) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))))) (piece "Narigin" Each (move Step (directions {Forward Backward Rightward Leftward FL FR}) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))))) (piece "Ryuo" Each (or (move Slide Orthogonal (to if:(and (is Enemy (who at:(to))) (= (count Pieces Mover "Osho" in:(sites Board)) 1)) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to))))))))) (move Step Diagonal (to if:(and (not (is Friend (who at:(to)))) (or (not (is Enemy (who at:(to)))) (= (count Pieces Mover "Osho" in:(sites Board)) 1))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to))))))))))) (piece "Ryuma" Each (or (move Slide Diagonal (to if:(and (is Enemy (who at:(to))) (= (count Pieces Mover "Osho" in:(sites Board)) 1)) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to))))))))) (move Step Orthogonal (to if:(and (not (is Friend (who at:(to)))) (or (not (is Enemy (who at:(to)))) (= (count Pieces Mover "Osho" in:(sites Board)) 1))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to))))))))))) (piece "Narikei" Each (move Step (directions {Forward Backward Rightward Leftward FL FR}) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))))) (piece "Narikyo" Each (move Step (directions {Forward Backward Rightward Leftward FL FR}) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to)))))))))) (regions "LastRankP1" P1 (sites Top)) (regions "LastRankP2" P2 (sites Bottom)) (regions "TwoFurthestRankP1" P1 (expand (sites Top))) (regions "TwoFurthestRankP2" P2 (expand (sites Bottom))) (regions "Promotion" P1 (expand (sites Top) steps:2)) (regions "Promotion" P2 (expand (sites Bottom) steps:2)) (map "Where" {(pair (id "Fuhyo" P1) (handSite P2)) (pair (id "Fuhyo" P2) (handSite P1)) (pair (id "Ginsho" P1) (handSite P2 1)) (pair (id "Ginsho" P2) (handSite P1 1)) (pair (id "Hisha" P1) (handSite P2 2)) (pair (id "Hisha" P2) (handSite P1 2)) (pair (id "Kakugyo" P1) (handSite P2 3)) (pair (id "Kakugyo" P2) (handSite P1 3)) (pair (id "Keima" P1) (handSite P2 4)) (pair (id "Keima" P2) (handSite P1 4)) (pair (id "Kyosha" P1) (handSite P2 5)) (pair (id "Kyosha" P2) (handSite P1 5)) (pair (id "Kinsho" P1) (handSite P2 6)) (pair (id "Kinsho" P2) (handSite P1 6)) (pair (id "Tokin" P1) (handSite P2)) (pair (id "Tokin" P2) (handSite P1)) (pair (id "Narigin" P1) (handSite P2 1)) (pair (id "Narigin" P2) (handSite P1 1)) (pair (id "Ryuo" P1) (handSite P2 2)) (pair (id "Ryuo" P2) (handSite P1 2)) (pair (id "Ryuma" P1) (handSite P2 3)) (pair (id "Ryuma" P2) (handSite P1 3)) (pair (id "Narikei" P1) (handSite P2 4)) (pair (id "Narikei" P2) (handSite P1 4)) (pair (id "Narikyo" P1) (handSite P2 5)) (pair (id "Narikyo" P2) (handSite P1 5))}) (map "Captured" {(pair (id "Fuhyo" P1) (id "Fuhyo" P2)) (pair (id "Fuhyo" P2) (id "Fuhyo" P1)) (pair (id "Ginsho" P1) (id "Ginsho" P2)) (pair (id "Ginsho" P2) (id "Ginsho" P1)) (pair (id "Hisha" P1) (id "Hisha" P2)) (pair (id "Hisha" P2) (id "Hisha" P1)) (pair (id "Kakugyo" P1) (id "Kakugyo" P2)) (pair (id "Kakugyo" P2) (id "Kakugyo" P1)) (pair (id "Keima" P1) (id "Keima" P2)) (pair (id "Keima" P2) (id "Keima" P1)) (pair (id "Kyosha" P1) (id "Kyosha" P2)) (pair (id "Kyosha" P2) (id "Kyosha" P1)) (pair (id "Kinsho" P1) (id "Kinsho" P2)) (pair (id "Kinsho" P2) (id "Kinsho" P1)) (pair (id "Tokin" P1) (id "Fuhyo" P2)) (pair (id "Tokin" P2) (id "Fuhyo" P1)) (pair (id "Narigin" P1) (id "Ginsho" P2)) (pair (id "Narigin" P2) (id "Ginsho" P1)) (pair (id "Ryuo" P1) (id "Hisha" P2)) (pair (id "Ryuo" P2) (id "Hisha" P1)) (pair (id "Ryuma" P1) (id "Kakugyo" P2)) (pair (id "Ryuma" P2) (id "Kakugyo" P1)) (pair (id "Narikei" P1) (id "Keima" P2)) (pair (id "Narikei" P2) (id "Keima" P1)) (pair (id "Narikyo" P1) (id "Kyosha" P2)) (pair (id "Narikyo" P2) (id "Kyosha" P1))}) (map "Promoted" {(pair (id "Fuhyo" P1) (id "Tokin" P1)) (pair (id "Fuhyo" P2) (id "Tokin" P2)) (pair (id "Ginsho" P1) (id "Narigin" P1)) (pair (id "Ginsho" P2) (id "Narigin" P2)) (pair (id "Hisha" P1) (id "Ryuo" P1)) (pair (id "Hisha" P2) (id "Ryuo" P2)) (pair (id "Kakugyo" P1) (id "Ryuma" P1)) (pair (id "Kakugyo" P2) (id "Ryuma" P2)) (pair (id "Keima" P1) (id "Narikei" P1)) (pair (id "Keima" P2) (id "Narikei" P2)) (pair (id "Kyosha" P1) (id "Narikyo" P1)) (pair (id "Kyosha" P2) (id "Narikyo" P2))}) (hand Each size:8)}) (rules (start {(place "Osho1" (handSite P1 7)) (place "Kinsho1" (handSite P1 6) count:2) (place "Ginsho1" (handSite P1 1) count:2) (place "Keima1" (handSite P1 4) count:2) (place "Kyosha1" (handSite P1 5) count:2) (place "Kakugyo1" (handSite P1 3)) (place "Hisha1" (handSite P1 2)) (place "Fuhyo1" (handSite P1) count:9) (place "Osho2" (handSite P2 7)) (place "Kinsho2" (handSite P2 6) count:2) (place "Ginsho2" (handSite P2 1) count:2) (place "Keima2" (handSite P2 4) count:2) (place "Kyosha2" (handSite P2 5) count:2) (place "Kakugyo2" (handSite P2 3)) (place "Hisha2" (handSite P2 2)) (place "Fuhyo2" (handSite P2) count:9)}) (play (if (is Prev Mover) (or (move Promote (last To) (piece (mapEntry "Promoted" (what at:(last To))))) (move Pass)) (do (or {(move (from (sites Occupied by:Mover container:"Hand" components:{"Kakugyo" "Ginsho" "Hisha" "Kinsho" "Osho"})) (to (sites Empty))) (do (move (from (sites Occupied by:Mover container:"Hand" component:"Fuhyo")) (to (difference (sites Empty) (sites Mover "LastRank")) if:(= (count Sites in:(sites Occupied by:Mover container:"Board" component:"Fuhyo")) (count Sites in:(difference (sites Occupied by:Mover container:"Board" component:"Fuhyo") (sites Column (column of:(to)))))))) ifAfterwards:(or (not (and (is Threatened (id "Osho" Next)) (not (can Move (do (or {(move (from (sites Occupied by:Next container:"Hand" components:{"Kakugyo" "Ginsho" "Hisha" "Kinsho"})) (to (sites Empty))) (do (move (from (sites Occupied by:Next container:"Hand" component:"Fuhyo")) (to (difference (sites Empty) (sites Next "LastRank")) if:(= (count Sites in:(sites Occupied by:Next container:"Board" component:"Fuhyo")) (count Sites in:(difference (sites Occupied by:Next container:"Board" component:"Fuhyo") (sites Column (column of:(to)))))))) ifAfterwards:(or (not (is Threatened (id "Osho" Mover))) (no Pieces Next "Osho" in:(sites Board)))) (move (from (sites Occupied by:Next container:"Hand" component:"Kyosha")) (to (difference (sites Empty) (sites Next "LastRank")))) (move (from (sites Occupied by:Next container:"Hand" component:"Keima")) (to (difference (sites Empty) (sites Next "TwoFurthestRank")))) (forEach Piece Next)}) ifAfterwards:(or (not (is Threatened (id "Osho" Mover))) (no Pieces Next "Osho" in:(sites Board)))))))) (no Pieces Mover "Osho" in:(sites Board)))) (move (from (sites Occupied by:Mover container:"Hand" component:"Kyosha")) (to (difference (sites Empty) (sites Mover "LastRank")))) (move (from (sites Occupied by:Mover container:"Hand" component:"Keima")) (to (difference (sites Empty) (sites Mover "TwoFurthestRank")))) (forEach Piece)}) ifAfterwards:(or (not (is Threatened (id "Osho" Mover))) (no Pieces Next "Osho" in:(sites Board)))))) (end {(if (and {(is Threatened (id "Osho" Next)) (not (can Move (do (or {(move (from (sites Occupied by:Next container:"Hand" components:{"Kakugyo" "Ginsho" "Hisha" "Kinsho"})) (to (sites Empty))) (do (move (from (sites Occupied by:Next container:"Hand" component:"Fuhyo")) (to (difference (sites Empty) (sites Next "LastRank")) if:(= (count Sites in:(sites Occupied by:Next container:"Board" component:"Fuhyo")) (count Sites in:(difference (sites Occupied by:Next container:"Board" component:"Fuhyo") (sites Column (column of:(to)))))))) ifAfterwards:(or (not (is Threatened (id "Osho" Mover))) (no Pieces Next "Osho" in:(sites Board)))) (move (from (sites Occupied by:Next container:"Hand" component:"Kyosha")) (to (difference (sites Empty) (sites Next "LastRank")))) (move (from (sites Occupied by:Next container:"Hand" component:"Keima")) (to (difference (sites Empty) (sites Next "TwoFurthestRank")))) (forEach Piece Next)}) ifAfterwards:(or (not (is Threatened (id "Osho" Mover))) (no Pieces Next "Osho" in:(sites Board)))))) (= (count Pieces Mover "Osho" in:(sites Board)) 1)}) (result Mover Win)) (if (no Moves Next) (result Mover Win))}))) 
The board has nine vertical lines and ten horizontal rows, and the pieces are placed on the intersections of these lines. Centreed along the back lines of each side is a three by three square with diagonals known as the palace. Pieces have special movement values: Janggun (general): May move one spot along the lines within the palace but cannot leave it. Sa (guards): Same movement as the Janggun. Ma (horses): Move one spot forward orthogonally and then one forward diagonally. Sang (elephants): Move one spot orthogonally forward then two spots diagonally forward. A Ma and Sang can be switched in the initial setup. Cha (chariots): Move like a rook in Chess, but also diagonally within the palace. Po (cannons): Jump over exactly one piece, over any distance horizontally or vertically, but cannot jump over or capture another cannon. Byeong/Jol (soldiers): Move and capture one point forward or sideways. Play continues until Woetong (checkmate) of the Janggun.
(game "Janggi" (players 2) (equipment {(board (rectangle 10 9) use:Vertex) (piece "Han" P1 (move Step (if (is In (from) (sites Mover "PalaceOrtho")) Orthogonal All) (to if:(and (is In (to) (sites Mover "Palace")) (not (is Friend (who at:(to))))) (apply (remove (to)))))) (piece "Cho" P2 (move Step (if (is In (from) (sites Mover "PalaceOrtho")) Orthogonal All) (to if:(and (is In (to) (sites Mover "Palace")) (not (is Friend (who at:(to))))) (apply (remove (to)))))) (piece "Sa" Each (move Step (if (is In (from) (sites Mover "PalaceOrtho")) Orthogonal All) (to if:(and (is In (to) (sites Mover "Palace")) (not (is Friend (who at:(to))))) (apply (remove (to)))))) (piece "Sang" Each (forEach Direction Orthogonal (to if:(is Empty (to)) (apply (forEach Direction (from (to)) (directions {FR FL} of:All) (between (exact 2) if:(is Empty (between))) (if (not (is Friend (who at:(to)))) (move (from) (to (apply if:(is Enemy (who at:(to))) (remove (to))))))))))) (piece "Ma" Each (forEach Direction Orthogonal (to if:(is Empty (to)) (apply (forEach Direction (from (to)) (directions {FR FL} of:All) (if (not (is Friend (who at:(to)))) (move (from) (to (apply if:(is Enemy (who at:(to))) (remove (to))))))))))) (piece "Cha" Each (or {(move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (if (is In (from) (union (sites P1 "Palace") (sites P2 "Palace"))) (move Slide Diagonal (between (max 2) if:(and (is Empty (between)) (is In (between) (union (sites P1 "Palace") (sites P2 "Palace"))))) (to if:(is Enemy (who at:(to))) (apply (remove (to))))))})) (piece "Po" Each (or {(move Hop Orthogonal (between before:(count Rows) after:(count Rows) if:(and {(not (= (what at:(between)) (id "Po" P1))) (not (= (what at:(between)) (id "Po" P2))) (is Occupied (between))})) (to if:(is Empty (to)) (apply if:(and (not (= (what at:(to)) (id "Po" Next))) (not (is Friend (who at:(to))))) (remove (to))))) (move Hop Orthogonal (between before:(count Rows) after:(count Rows) if:(and {(not (= (what at:(between)) (id "Po" P1))) (not (= (what at:(between)) (id "Po" P2))) (is Occupied (between))})) (to if:(is Empty (to)))) (if (is In (from) (union (sites P1 "Palace") (sites P2 "Palace"))) (move Hop Diagonal (between if:(and {(not (= (what at:(between)) (id "Po" P1))) (not (= (what at:(between)) (id "Po" P2))) (is Occupied (between))})) (to if:(and (and (not (= (what at:(to)) (id "Po" Next))) (not (is Friend (who at:(to))))) (is In (to) (union (sites P1 "Palace") (sites P2 "Palace")))) (apply (remove (to))))))})) (piece "Byeong" P1 N (move Step (directions {Forward Rightward Leftward}) (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (piece "Jol" P2 S (move Step (directions {Forward Rightward Leftward}) (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (regions "PalaceP1" P1 {3 4 5 12 13 14 21 22 23}) (regions "PalaceOrthoP1" P1 {4 12 14 22}) (regions "PalaceP2" P2 {66 67 68 75 76 77 84 85 86}) (regions "PalaceOrthoP2" P2 {67 75 77 85})}) (rules (start {(place "Han1" coord:"E2") (place "Sa1" {"D1" "F1"}) (place "Sang1" {"C1" "G1"}) (place "Ma1" {"B1" "H1"}) (place "Cha1" {"A1" "I1"}) (place "Po1" {"B3" "H3"}) (place "Byeong1" {"A4" "C4" "E4" "G4" "I4"}) (place "Cho2" coord:"E9") (place "Sa2" {"D10" "F10"}) (place "Sang2" {"C10" "G10"}) (place "Ma2" {"B10" "H10"}) (place "Cha2" {"A10" "I10"}) (place "Po2" {"B8" "H8"}) (place "Jol2" {"A7" "C7" "E7" "G7" "I7"})}) (play (do (forEach Piece) ifAfterwards:(not (is Threatened (if (is Mover P2) (id "Cho2") (id "Han1")))) (then (if (if (= (column of:(where "Han" P1)) (column of:(where "Cho" P2))) (= (count Sites in:(forEach (sites Direction from:(where "Han" P1) N stop:(= (to) (where "Cho" P2))) if:(is Occupied (site)))) 0) False) (if (!= (var) 1) (set Var 1) (set Var 0)) (set Var 0))))) (end {(if (and (is Threatened (if (is Next P2) (id "Cho2") (id "Han1"))) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (if (is Next P2) (id "Cho2") (id "Han1")))))))) (result Mover Win)) (if (and (if (= (column of:(where "Han" P1)) (column of:(where "Cho" P2))) (= (count Sites in:(forEach (sites Direction from:(where "Han" P1) N stop:(= (to) (where "Cho" P2))) if:(is Occupied (site)))) 0) False) (= (var) 0)) (result Mover Draw))}))) 
The rules are the same as for Xiangqi, except instead of moving a piece, a player's turn may be taken by replacing a captured piece on the board on any empty space. This piece is controlled by the player who replaced it. Captured Shi can only be placed on positions where they could normally reach. Captured Xiang can only be placed on the controlling players side of the river.
(game "Loop Xiangqi" (players {(player N) (player S)}) (equipment {(board (rectangle 10 9) use:Vertex) (piece "Shi" Each (move Step Diagonal (to if:(and (is In (to) (sites Mover "Palace")) (not (is Friend (who at:(to))))) (apply if:(is Enemy (who at:(to))) (add (piece (mapEntry "captured" (what at:(to)))) (to Cell (mapEntry "where" (what at:(to))))))))) (piece "Xiang" Each (move Slide Diagonal (between (exact 2) if:(and {(is In (between) (sites Mover "Home")) (is Empty (between))})) (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "captured" (what at:(to)))) (to Cell (mapEntry "where" (what at:(to)))))))))) (piece "Ma" Each (forEach Direction Orthogonal (to if:(is Empty (to)) (apply (forEach Direction (from (to)) (directions {FR FL} of:All) (if (not (is Friend (who at:(to)))) (move (from) (to (apply if:(is Enemy (who at:(to))) (add (piece (mapEntry "captured" (what at:(to)))) (to Cell (mapEntry "where" (what at:(to)))))))))))))) (piece "Ju" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (if (is Enemy (who at:(to))) (add (piece (mapEntry "captured" (what at:(to)))) (to Cell (mapEntry "where" (what at:(to)))))))))) (piece "Pao" Each (or (move Slide Orthogonal) (move Hop Orthogonal (between before:(count Rows) after:(count Rows) if:(is Occupied (between))) (to if:(is Empty (to)) (apply if:(is Enemy (who at:(to))) (add (piece (mapEntry "captured" (what at:(to)))) (to Cell (mapEntry "where" (what at:(to)))))))))) (piece "Zu" Each (move Step (if (is In (from) (sites Mover "Home")) Forward (directions {Forward Rightward Leftward})) (to (apply if:(is Enemy (who at:(to))) (add (piece (mapEntry "captured" (what at:(to)))) (to Cell (mapEntry "where" (what at:(to))))))))) (piece "Jiang" Each (move Step Orthogonal (to if:(and (is In (to) (sites Mover "Palace")) (not (is Friend (who at:(to))))) (apply if:(is Enemy (who at:(to))) (add (piece (mapEntry "captured" (what at:(to)))) (to Cell (mapEntry "where" (what at:(to))))))))) (regions "PalaceP1" P1 {3 4 5 12 13 14 21 22 23}) (regions "PalaceP2" P2 {66 67 68 75 76 77 84 85 86}) (regions "Home" P1 (expand (sites Bottom) steps:4)) (regions "Home" P2 (expand (sites Top) steps:4)) (map "where" {(pair 2 90) (pair 1 96) (pair 4 91) (pair 3 97) (pair 6 92) (pair 5 98) (pair 8 93) (pair 7 99) (pair 10 94) (pair 9 100) (pair 12 95) (pair 11 101)}) (map "captured" {(pair 1 2) (pair 2 1) (pair 3 4) (pair 4 3) (pair 5 6) (pair 6 5) (pair 7 8) (pair 8 7) (pair 9 10) (pair 10 9) (pair 11 12) (pair 12 11)}) (regions "PalaceShiP1" P1 {3 5 13 21 23}) (regions "PalaceShiP2" P2 {66 68 76 84 86}) (hand Each size:6)}) (rules (start {(place "Jiang1" coord:"E1") (place "Shi1" {"D1" "F1"}) (place "Xiang1" {"C1" "G1"}) (place "Ma1" {"B1" "H1"}) (place "Ju1" {"A1" "I1"}) (place "Pao1" {"B3" "H3"}) (place "Zu1" {"A4" "C4" "E4" "G4" "I4"}) (place "Jiang2" coord:"E10") (place "Shi2" {"D10" "F10"}) (place "Xiang2" {"C10" "G10"}) (place "Ma2" {"B10" "H10"}) (place "Ju2" {"A10" "I10"}) (place "Pao2" {"B8" "H8"}) (place "Zu2" {"A7" "C7" "E7" "G7" "I7"})}) (play (do (or {(forEach Piece) (move (from (sites Occupied by:Mover container:"Hand" components:{"Ma" "Ju" "Pao" "Zu"})) (to (sites Empty))) (move (from (sites Occupied by:Mover container:"Hand" component:"Shi")) (to (intersection (sites Empty) (sites Mover "PalaceShi")))) (move (from (sites Occupied by:Mover container:"Hand" component:"Xiang")) (to (intersection (sites Empty) (sites Mover "Home"))))}) ifAfterwards:(and (if (= (column of:(where "Jiang" P1)) (column of:(where "Jiang" P2))) (not (= (count Sites in:(forEach (sites Direction from:(where "Jiang" P1) N stop:(= (to) (where "Jiang" P2))) if:(is Occupied (site)))) 0)) True) (not (is Threatened (id "Jiang" Mover)))))) (end {(if (and (is Threatened (id "Jiang" Next)) (not (can Move (do (or {(forEach Piece Next) (move (from (sites Occupied by:Next container:"Hand" components:{"Ma" "Ju" "Pao" "Zu"})) (to (sites Empty))) (move (from (sites Occupied by:Next container:"Hand" component:"Shi")) (to (intersection (sites Empty) (sites Next "PalaceShi")))) (move (from (sites Occupied by:Next container:"Hand" component:"Xiang")) (to (intersection (sites Empty) (sites Next "Home"))))}) ifAfterwards:(not (is Threatened (id "Jiang" Next))))))) (result Mover Win)) (if (no Moves Next) (result Mover Win))}))) 
Manzhouqi is played on a Xiangqi board. The black player's pieces are set up as in Xiangqi, but the white player has the following pieces: Five soldiers: Move one space forward orthogonally. Two courtiers: Move one space diagonally and cannot leave the palace. One general: Moves on space orthogonally and cannot leave the palace. Two elephants: Move two spaces diagonally and cannot cross the river. One chariot: can move any distance orthogonally, taking either by jumping or by landing on the same space, and can also move like a knight in chess. The player that checkmates the other player's general wins.
(game "Manzhouqi" (players {(player N) (player S)}) (equipment {(board (rectangle 10 9) use:Vertex) (piece "Jiang" Each (move Step Orthogonal (to if:(and (is In (to) (sites Mover "Palace")) (not (is Friend (who at:(to))))) (apply (remove (to)))))) (piece "Shi" Each (move Step Diagonal (to if:(and (is In (to) (sites Mover "Palace")) (not (is Friend (who at:(to))))) (apply (remove (to)))))) (piece "Xiang" Each (move Slide Diagonal (between (exact 2) if:(and {(is In (between) (sites Mover "Home")) (is Empty (between))})) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Ma" Each (forEach Direction Orthogonal (to if:(is Empty (to)) (apply (forEach Direction (from (to)) (directions {FR FL} of:All) (if (not (is Friend (who at:(to)))) (move (from) (to (apply if:(is Enemy (who at:(to))) (remove (to))))))))))) (piece "Ju" Each (if (is Mover P2) (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (or {(move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (forEach Direction Orthogonal (to if:(is Empty (to)) (apply (forEach Direction (from (to)) (directions {FR FL} of:All) (if (not (is Friend (who at:(to)))) (move (from) (to (apply if:(is Enemy (who at:(to))) (remove (to)))))))))) (or (move Slide Orthogonal) (move Hop Orthogonal (between before:(count Rows) after:(count Rows) if:(is Occupied (between))) (to if:(is Empty (to)) (apply if:(is Enemy (who at:(to))) (remove (to))))))}))) (piece "Pao" Each (or (move Slide Orthogonal) (move Hop Orthogonal (between before:(count Rows) after:(count Rows) if:(is Occupied (between))) (to if:(is Empty (to)) (apply if:(is Enemy (who at:(to))) (remove (to))))))) (piece "Zu" Each (move Step (if (is In (from) (sites Mover "Home")) Forward (directions {Forward Rightward Leftward})) (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (regions "PalaceP1" P1 {3 4 5 12 13 14 21 22 23}) (regions "PalaceP2" P2 {66 67 68 75 76 77 84 85 86}) (regions "Home" P1 (expand (sites Bottom) steps:4)) (regions "Home" P2 (expand (sites Top) steps:4))}) (rules (start {(place "Jiang1" coord:"E1") (place "Shi1" {"D1" "F1"}) (place "Xiang1" {"C1" "G1"}) (place "Ju1" coord:"A1") (place "Zu1" {"A4" "C4" "E4" "G4" "I4"}) (place "Jiang2" coord:"E10") (place "Shi2" {"D10" "F10"}) (place "Xiang2" {"C10" "G10"}) (place "Ma2" {"B10" "H10"}) (place "Ju2" {"A10" "I10"}) (place "Pao2" {"B8" "H8"}) (place "Zu2" {"A7" "C7" "E7" "G7" "I7"})}) (play (do (forEach Piece) ifAfterwards:(and (if (= (column of:(where "Jiang" P1)) (column of:(where "Jiang" P2))) (not (= (count Sites in:(forEach (sites Direction from:(where "Jiang" P1) N stop:(= (to) (where "Jiang" P2))) if:(is Occupied (site)))) 0)) True) (not (is Threatened (id "Jiang" Mover)))))) (end {(if (and (is Threatened (id "Jiang" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "Jiang" Next))))))) (result Mover Win)) (if (no Moves Next) (result Mover Win))}))) 
The rules for pieces are the same as regular Xiangqi, except pawns start with the ability to move sideways.
(game "MiniXiangqi" (players {(player N) (player S)}) (equipment {(board (rectangle 7 7) use:Vertex) (piece "Jiang" Each (move Step Orthogonal (to if:(and (is In (to) (sites Mover "Palace")) (not (is Friend (who at:(to))))) (apply (remove (to)))))) (piece "Ma" Each (forEach Direction Orthogonal (to if:(is Empty (to)) (apply (forEach Direction (from (to)) (directions {FR FL} of:All) (if (not (is Friend (who at:(to)))) (move (from) (to (apply if:(is Enemy (who at:(to))) (remove (to))))))))))) (piece "Ju" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Pao" Each (or (move Slide Orthogonal) (move Hop Orthogonal (between before:(count Rows) after:(count Rows) if:(is Occupied (between))) (to if:(is Empty (to)) (apply if:(is Enemy (who at:(to))) (remove (to))))))) (piece "Zu" Each (move Step (directions {Forward Rightward Leftward}) (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (regions "PalaceP1" P1 {2 3 4 9 10 11 16 17 18}) (regions "PalaceP2" P2 {30 31 32 37 38 39 44 45 46})}) (rules (start {(place "Jiang1" coord:"D1") (place "Ma1" {"C1" "E1"}) (place "Ju1" {"A1" "G1"}) (place "Pao1" {"B1" "F1"}) (place "Zu1" {"A2" "C2" "D2" "E2" "G2"}) (place "Jiang2" coord:"D7") (place "Ma2" {"C7" "E7"}) (place "Ju2" {"A7" "G7"}) (place "Pao2" {"B7" "F7"}) (place "Zu2" {"A6" "C6" "D6" "E6" "G6"})}) (play (do (forEach Piece) ifAfterwards:(and (if (= (column of:(where "Jiang" P1)) (column of:(where "Jiang" P2))) (not (= (count Sites in:(forEach (sites Direction from:(where "Jiang" P1) N stop:(= (to) (where "Jiang" P2))) if:(is Occupied (site)))) 0)) True) (not (is Threatened (id "Jiang" Mover)))))) (end {(if (and (is Threatened (id "Jiang" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "Jiang" Next))))))) (result Mover Win)) (if (no Moves Next) (result Mover Win))}))) 
19x19 lines, pieces are played on the intersections of the lines. Seventeen pieces per player, each with special moves, as follows: Jiang (General) x1: moves orthogonally or diagonally any distance; Pian (Deputy General) x1: Moves orthogonally any distance; Bai (Officer) x1: moves diagonally any distance; Ren (Emissary) x1: moves orthogonally or diagonally any distance, but cannot capture or be captured; Pao (Catapult) x1: moves orthogonally any distance, but can only capture by jumping over one of the player's own pieces first; Gong (Bow) x1: moves orthogonally or diagonally four spaces; Nu (Crossbow) x1: moves orthogonally or diagonally five spaces; Dao (Knife) x2: moves one space diagonally; Jian (Sword) x4: moves one space orthogonally; Qi (Mounted riders) x4: moves one space in a straight line then three diagonally, does not jump. Seven players. Players play as seven states: Ch'in (white), Ch'u (red), Han (orange), Ch'i (dark blue), Wei (green), Chao (purple), and Yen (black). They play in that order. One piece, the Chou (King, which is yellow), is placed in the central spot and does not move and pieces cannot enter that space. Pieces capture an enemy piece by moving to the spot it occupies. A player is eliminated when their general or ten of their pieces are captured, and their remaining pieces are removed from the board. Play continues until one player remains, one player captures two generals, or one player captures thirty pieces. The player with the most captured pieces wins.
(game "Qi Guo Xiangxi" (players 7) (equipment {(board (square 19) use:Vertex) (piece "King" Shared) (piece "General" Each (move Slide All (between if:(and {(is Empty (between)) (!= (who at:(between)) Shared) (not (= (what at:(between)) (id "Diplomat" P1))) (not (= (what at:(between)) (id "Diplomat" P2))) (not (= (what at:(between)) (id "Diplomat" P3))) (not (= (what at:(between)) (id "Diplomat" P4))) (not (= (what at:(between)) (id "Diplomat" P5))) (not (= (what at:(between)) (id "Diplomat" P6))) (not (= (what at:(between)) (id "Diplomat" P7)))})) (to if:(and {(is Enemy (who at:(to))) (!= (who at:(to)) Shared) (not (= (what at:(to)) (id "Diplomat" P1))) (not (= (what at:(to)) (id "Diplomat" P2))) (not (= (what at:(to)) (id "Diplomat" P3))) (not (= (what at:(to)) (id "Diplomat" P4))) (not (= (what at:(to)) (id "Diplomat" P5))) (not (= (what at:(to)) (id "Diplomat" P6))) (not (= (what at:(to)) (id "Diplomat" P7)))}) (apply (if (is Enemy (who at:(to))) (do (if (or {(= (what at:(to)) (id "General" P1)) (= (what at:(to)) (id "General" P2)) (= (what at:(to)) (id "General" P3)) (= (what at:(to)) (id "General" P4)) (= (what at:(to)) (id "General" P5)) (= (what at:(to)) (id "General" P6)) (= (what at:(to)) (id "General" P7))}) (add (piece (id "General" Mover)) (to (handSite Mover)))) next:(remove (to) (then (addScore Mover 1))))))))) (piece "Deputy General" Each (move Slide Orthogonal (between if:(and {(is Empty (between)) (!= (who at:(between)) Shared) (not (= (what at:(between)) (id "Diplomat" P1))) (not (= (what at:(between)) (id "Diplomat" P2))) (not (= (what at:(between)) (id "Diplomat" P3))) (not (= (what at:(between)) (id "Diplomat" P4))) (not (= (what at:(between)) (id "Diplomat" P5))) (not (= (what at:(between)) (id "Diplomat" P6))) (not (= (what at:(between)) (id "Diplomat" P7)))})) (to if:(and {(is Enemy (who at:(to))) (!= (who at:(to)) Shared) (not (= (what at:(to)) (id "Diplomat" P1))) (not (= (what at:(to)) (id "Diplomat" P2))) (not (= (what at:(to)) (id "Diplomat" P3))) (not (= (what at:(to)) (id "Diplomat" P4))) (not (= (what at:(to)) (id "Diplomat" P5))) (not (= (what at:(to)) (id "Diplomat" P6))) (not (= (what at:(to)) (id "Diplomat" P7)))}) (apply (if (is Enemy (who at:(to))) (do (if (or {(= (what at:(to)) (id "General" P1)) (= (what at:(to)) (id "General" P2)) (= (what at:(to)) (id "General" P3)) (= (what at:(to)) (id "General" P4)) (= (what at:(to)) (id "General" P5)) (= (what at:(to)) (id "General" P6)) (= (what at:(to)) (id "General" P7))}) (add (piece (id "General" Mover)) (to (handSite Mover)))) next:(remove (to) (then (addScore Mover 1))))))))) (piece "Officer" Each (move Slide Diagonal (between if:(and {(is Empty (between)) (!= (who at:(between)) Shared) (not (= (what at:(between)) (id "Diplomat" P1))) (not (= (what at:(between)) (id "Diplomat" P2))) (not (= (what at:(between)) (id "Diplomat" P3))) (not (= (what at:(between)) (id "Diplomat" P4))) (not (= (what at:(between)) (id "Diplomat" P5))) (not (= (what at:(between)) (id "Diplomat" P6))) (not (= (what at:(between)) (id "Diplomat" P7)))})) (to if:(and {(is Enemy (who at:(to))) (!= (who at:(to)) Shared) (not (= (what at:(to)) (id "Diplomat" P1))) (not (= (what at:(to)) (id "Diplomat" P2))) (not (= (what at:(to)) (id "Diplomat" P3))) (not (= (what at:(to)) (id "Diplomat" P4))) (not (= (what at:(to)) (id "Diplomat" P5))) (not (= (what at:(to)) (id "Diplomat" P6))) (not (= (what at:(to)) (id "Diplomat" P7)))}) (apply (if (is Enemy (who at:(to))) (do (if (or {(= (what at:(to)) (id "General" P1)) (= (what at:(to)) (id "General" P2)) (= (what at:(to)) (id "General" P3)) (= (what at:(to)) (id "General" P4)) (= (what at:(to)) (id "General" P5)) (= (what at:(to)) (id "General" P6)) (= (what at:(to)) (id "General" P7))}) (add (piece (id "General" Mover)) (to (handSite Mover)))) next:(remove (to) (then (addScore Mover 1))))))))) (piece "Diplomat" Each (move Slide All)) (piece "Archer" Each (move Hop All (between (exact 3) if:(is Empty (between))) (to if:(or (is Empty (to)) (and {(is Enemy (who at:(to))) (!= (who at:(to)) Shared) (not (= (what at:(to)) (id "Diplomat" P1))) (not (= (what at:(to)) (id "Diplomat" P2))) (not (= (what at:(to)) (id "Diplomat" P3))) (not (= (what at:(to)) (id "Diplomat" P4))) (not (= (what at:(to)) (id "Diplomat" P5))) (not (= (what at:(to)) (id "Diplomat" P6))) (not (= (what at:(to)) (id "Diplomat" P7)))})) (apply (if (is Enemy (who at:(to))) (do (if (or {(= (what at:(to)) (id "General" P1)) (= (what at:(to)) (id "General" P2)) (= (what at:(to)) (id "General" P3)) (= (what at:(to)) (id "General" P4)) (= (what at:(to)) (id "General" P5)) (= (what at:(to)) (id "General" P6)) (= (what at:(to)) (id "General" P7))}) (add (piece (id "General" Mover)) (to (handSite Mover)))) next:(remove (to) (then (addScore Mover 1))))))))) (piece "CrossBow" Each (move Hop All (between (exact 4) if:(is Empty (between))) (to if:(or (is Empty (to)) (and {(is Enemy (who at:(to))) (!= (who at:(to)) Shared) (not (= (what at:(to)) (id "Diplomat" P1))) (not (= (what at:(to)) (id "Diplomat" P2))) (not (= (what at:(to)) (id "Diplomat" P3))) (not (= (what at:(to)) (id "Diplomat" P4))) (not (= (what at:(to)) (id "Diplomat" P5))) (not (= (what at:(to)) (id "Diplomat" P6))) (not (= (what at:(to)) (id "Diplomat" P7)))})) (apply (if (is Enemy (who at:(to))) (do (if (or {(= (what at:(to)) (id "General" P1)) (= (what at:(to)) (id "General" P2)) (= (what at:(to)) (id "General" P3)) (= (what at:(to)) (id "General" P4)) (= (what at:(to)) (id "General" P5)) (= (what at:(to)) (id "General" P6)) (= (what at:(to)) (id "General" P7))}) (add (piece (id "General" Mover)) (to (handSite Mover)))) next:(remove (to) (then (addScore Mover 1))))))))) (piece "Knife" Each (move Step Diagonal (to if:(or (is Empty (to)) (and {(is Enemy (who at:(to))) (!= (who at:(to)) Shared) (not (= (what at:(to)) (id "Diplomat" P1))) (not (= (what at:(to)) (id "Diplomat" P2))) (not (= (what at:(to)) (id "Diplomat" P3))) (not (= (what at:(to)) (id "Diplomat" P4))) (not (= (what at:(to)) (id "Diplomat" P5))) (not (= (what at:(to)) (id "Diplomat" P6))) (not (= (what at:(to)) (id "Diplomat" P7)))})) (apply (if (is Enemy (who at:(to))) (do (if (or {(= (what at:(to)) (id "General" P1)) (= (what at:(to)) (id "General" P2)) (= (what at:(to)) (id "General" P3)) (= (what at:(to)) (id "General" P4)) (= (what at:(to)) (id "General" P5)) (= (what at:(to)) (id "General" P6)) (= (what at:(to)) (id "General" P7))}) (add (piece (id "General" Mover)) (to (handSite Mover)))) next:(remove (to) (then (addScore Mover 1))))))))) (piece "Broadsword" Each (move Step Orthogonal (to if:(or (is Empty (to)) (and {(is Enemy (who at:(to))) (!= (who at:(to)) Shared) (not (= (what at:(to)) (id "Diplomat" P1))) (not (= (what at:(to)) (id "Diplomat" P2))) (not (= (what at:(to)) (id "Diplomat" P3))) (not (= (what at:(to)) (id "Diplomat" P4))) (not (= (what at:(to)) (id "Diplomat" P5))) (not (= (what at:(to)) (id "Diplomat" P6))) (not (= (what at:(to)) (id "Diplomat" P7)))})) (apply (if (is Enemy (who at:(to))) (do (if (or {(= (what at:(to)) (id "General" P1)) (= (what at:(to)) (id "General" P2)) (= (what at:(to)) (id "General" P3)) (= (what at:(to)) (id "General" P4)) (= (what at:(to)) (id "General" P5)) (= (what at:(to)) (id "General" P6)) (= (what at:(to)) (id "General" P7))}) (add (piece (id "General" Mover)) (to (handSite Mover)))) next:(remove (to) (then (addScore Mover 1))))))))) (piece "Catapult" Each (or (move Slide Orthogonal) (move Hop Orthogonal (between before:(count Rows) after:(count Rows) if:(is Friend (who at:(between)))) (to if:(is Empty (to)) (apply if:(and {(is Enemy (who at:(to))) (!= (who at:(to)) Shared) (not (= (what at:(to)) (id "Diplomat" P1))) (not (= (what at:(to)) (id "Diplomat" P2))) (not (= (what at:(to)) (id "Diplomat" P3))) (not (= (what at:(to)) (id "Diplomat" P4))) (not (= (what at:(to)) (id "Diplomat" P5))) (not (= (what at:(to)) (id "Diplomat" P6))) (not (= (what at:(to)) (id "Diplomat" P7)))}) (do (if (or {(= (what at:(to)) (id "General" P1)) (= (what at:(to)) (id "General" P2)) (= (what at:(to)) (id "General" P3)) (= (what at:(to)) (id "General" P4)) (= (what at:(to)) (id "General" P5)) (= (what at:(to)) (id "General" P6)) (= (what at:(to)) (id "General" P7))}) (add (piece (id "General" Mover)) (to (handSite Mover)))) next:(remove (to) (then (addScore Mover 1))))))))) (piece "Knight" Each (forEach Direction Orthogonal (to if:(is Empty (to)) (apply (forEach Direction (from (to)) (directions {FR FL} of:All) (between (exact 3) if:(is Empty (between))) (if (or (is Empty (to)) (and {(is Enemy (who at:(to))) (!= (who at:(to)) Shared) (not (= (what at:(to)) (id "Diplomat" P1))) (not (= (what at:(to)) (id "Diplomat" P2))) (not (= (what at:(to)) (id "Diplomat" P3))) (not (= (what at:(to)) (id "Diplomat" P4))) (not (= (what at:(to)) (id "Diplomat" P5))) (not (= (what at:(to)) (id "Diplomat" P6))) (not (= (what at:(to)) (id "Diplomat" P7)))})) (move (from) (to (apply if:(is Enemy (who at:(to))) (do (if (or {(= (what at:(to)) (id "General" P1)) (= (what at:(to)) (id "General" P2)) (= (what at:(to)) (id "General" P3)) (= (what at:(to)) (id "General" P4)) (= (what at:(to)) (id "General" P5)) (= (what at:(to)) (id "General" P6)) (= (what at:(to)) (id "General" P7))}) (add (piece (id "General" Mover)) (to (handSite Mover)))) next:(remove (to) (then (addScore Mover 1))))))))))))) (hand Each)}) (rules (start {(place "King" (centrePoint)) (place "General1" coord:"A10") (place "General2" coord:"F1") (place "General3" coord:"N1") (place "General4" coord:"S6") (place "General5" coord:"S14") (place "General6" coord:"N19") (place "General7" coord:"F19") (place "Deputy General1" coord:"A11") (place "Deputy General2" coord:"E1") (place "Deputy General3" coord:"M1") (place "Deputy General4" coord:"S5") (place "Deputy General5" coord:"S13") (place "Deputy General6" coord:"O19") (place "Deputy General7" coord:"G19") (place "Officer1" coord:"A9") (place "Officer2" coord:"G1") (place "Officer3" coord:"O1") (place "Officer4" coord:"S7") (place "Officer5" coord:"S15") (place "Officer6" coord:"M19") (place "Officer7" coord:"E19") (place "Catapult1" coord:"B10") (place "Catapult2" coord:"F2") (place "Catapult3" coord:"N2") (place "Catapult4" coord:"R6") (place "Catapult5" coord:"R14") (place "Catapult6" coord:"N18") (place "Catapult7" coord:"F18") (place "Broadsword1" {"A12" "B11" "B9" "A8"}) (place "Broadsword2" {"D1" "E2" "G2" "H1"}) (place "Broadsword3" {"L1" "M2" "O2" "P1"}) (place "Broadsword4" {"S4" "R5" "R7" "S8"}) (place "Broadsword5" {"S12" "R13" "R15" "S16"}) (place "Broadsword6" {"P19" "O18" "M18" "L19"}) (place "Broadsword7" {"H19" "G18" "E18" "D19"}) (place "Knight1" {"A13" "B12" "B8" "A7"}) (place "Knight2" {"C1" "D2" "H2" "I1"}) (place "Knight3" {"K1" "L2" "P2" "Q1"}) (place "Knight4" {"S3" "R4" "R8" "S9"}) (place "Knight5" {"S11" "R12" "R16" "S17"}) (place "Knight6" {"P18" "Q19" "L18" "K19"}) (place "Knight7" {"H18" "I19" "D18" "C19"}) (place "CrossBow1" coord:"C10") (place "CrossBow2" coord:"F3") (place "CrossBow3" coord:"N3") (place "CrossBow4" coord:"Q6") (place "CrossBow5" coord:"Q14") (place "CrossBow6" coord:"N17") (place "CrossBow7" coord:"F17") (place "Knife1" {"C9" "C11"}) (place "Knife2" {"E3" "G3"}) (place "Knife3" {"M3" "O3"}) (place "Knife4" {"Q5" "Q7"}) (place "Knife5" {"Q13" "Q15"}) (place "Knife6" {"O17" "M17"}) (place "Knife7" {"G17" "E17"}) (place "Archer1" coord:"D10") (place "Archer2" coord:"F4") (place "Archer3" coord:"N4") (place "Archer4" coord:"P6") (place "Archer5" coord:"P14") (place "Archer6" coord:"N16") (place "Archer7" coord:"F16") (place "Diplomat1" coord:"E10") (place "Diplomat2" coord:"F5") (place "Diplomat3" coord:"N5") (place "Diplomat4" coord:"O6") (place "Diplomat5" coord:"O14") (place "Diplomat6" coord:"N15") (place "Diplomat7" coord:"F15")}) (play (forEach Piece (then (and {(if (and (is Active P1) (or (<= (count Pieces P1 in:(sites Board)) 7) (= (where "General" P1) -1))) (remove (sites Occupied by:P1 container:"Board"))) (if (and (is Active P2) (or (<= (count Pieces P2 in:(sites Board)) 7) (= (where "General" P2) -1))) (remove (sites Occupied by:P2 container:"Board"))) (if (and (is Active P3) (or (<= (count Pieces P3 in:(sites Board)) 7) (= (where "General" P3) -1))) (remove (sites Occupied by:P3 container:"Board"))) (if (and (is Active P4) (or (<= (count Pieces P4 in:(sites Board)) 7) (= (where "General" P4) -1))) (remove (sites Occupied by:P4 container:"Board"))) (if (and (is Active P5) (or (<= (count Pieces P5 in:(sites Board)) 7) (= (where "General" P5) -1))) (remove (sites Occupied by:P5 container:"Board"))) (if (and (is Active P6) (or (<= (count Pieces P6 in:(sites Board)) 7) (= (where "General" P6) -1))) (remove (sites Occupied by:P6 container:"Board"))) (if (and (is Active P7) (or (<= (count Pieces P7 in:(sites Board)) 7) (= (where "General" P7) -1))) (remove (sites Occupied by:P7 container:"Board")))})))) (end {(if (= (count Pieces P1 in:(sites Board)) 0) (result P1 Loss)) (if (= (count Pieces P2 in:(sites Board)) 0) (result P2 Loss)) (if (= (count Pieces P3 in:(sites Board)) 0) (result P3 Loss)) (if (= (count Pieces P4 in:(sites Board)) 0) (result P4 Loss)) (if (= (count Pieces P5 in:(sites Board)) 0) (result P5 Loss)) (if (= (count Pieces P6 in:(sites Board)) 0) (result P6 Loss)) (if (= (count Pieces P7 in:(sites Board)) 0) (result P7 Loss)) (if (or (= (score Mover) 30) (= 2 (count Cell at:(handSite Mover)))) (byScore))}))) 
All rules are the same as regular Xiangqi.
(game "Xiang Hex" (players {(player N) (player S)}) (equipment {(board (renumber Cell (rotate 90 (remove (hex Rectangle 9 11) cells:{0 1 11 21 63 74 85 84 94 93 83 73 31 20 9 10})))) (piece "Jiang" Each (move Step Orthogonal (to if:(and (is In (to) (sites Mover "Palace")) (not (is Friend (who at:(to))))) (apply (remove (to)))))) (piece "Shi" Each (move Step Diagonal (to if:(and (is In (to) (sites Mover "Palace")) (not (is Friend (who at:(to))))) (apply (remove (to)))))) (piece "Xiang" Each (move Slide Diagonal (between (exact 2) if:(and {(is In (between) (sites Mover "Home")) (is Empty (between))})) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Ma" Each (forEach Direction Orthogonal (to if:(is Empty (to)) (apply (forEach Direction (from (to)) (directions {FR FL} of:All) (if (not (is Friend (who at:(to)))) (move (from) (to (apply if:(is Enemy (who at:(to))) (remove (to))))))))))) (piece "Ju" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Pao" Each (or (move Slide Orthogonal) (move Hop Orthogonal (between before:(count Rows) after:(count Rows) if:(is Occupied (between))) (to if:(is Empty (to)) (apply if:(is Enemy (who at:(to))) (remove (to))))))) (piece "Zu" Each (move Step (if (is In (from) (sites Mover "Home")) Forward (union (directions {Forward FL FR}) (directions {W E}))) (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (regions "PalaceP1" P1 {0 1 2 4 7 8 12}) (regions "PalaceP2" P2 {66 70 71 74 76 77 78}) (regions "Home" P1 (forEach (sites Board) if:(< (site) 37))) (regions "Home" P2 (forEach (sites Board) if:(> (site) 41)))}) (rules (start {(place "Jiang1" coord:"A1") (place "Shi1" {"A2" "B1"}) (place "Xiang1" {"A3" "C1"}) (place "Ma1" {"A4" "D1"}) (place "Ju1" {"A5" "E1"}) (place "Pao1" {"B5" "E2"}) (place "Zu1" {"B6" "C5" "D4" "E3" "F2"}) (place "Jiang2" coord:"K11") (place "Shi2" {"J11" "K10"}) (place "Xiang2" {"I11" "K9"}) (place "Ma2" {"H11" "K8"}) (place "Ju2" {"G11" "K7"}) (place "Pao2" {"G10" "J7"}) (place "Zu2" {"F10" "G9" "H8" "I7" "J6"})}) (play (do (forEach Piece) ifAfterwards:(and (if (= (column of:(where "Jiang" P1)) (column of:(where "Jiang" P2))) (not (= (count Sites in:(forEach (sites Direction from:(where "Jiang" P1) N stop:(= (to) (where "Jiang" P2))) if:(is Occupied (site)))) 0)) True) (not (is Threatened (id "Jiang" Mover)))))) (end {(if (and (is Threatened (id "Jiang" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "Jiang" Next))))))) (result Mover Win)) (if (no Moves Next) (result Mover Win))}))) 
Played on a board with 9x10 intersecting lines. Pieces are placed on the intersections of the lines. Centered on opposite sides of the boards are two areas, known as the gong ("castle"). Bisecting the board is a blank space known as the he ("river"). Pieces are double-sided, with different colors and names of the pieces indicating to which player they belong. Jiang("general")/shuai("marshal")(1): may move one space orthogonally and cannot leave the gong except when opposite the opponent's jiang/shuai, in which case the piece can capture the opponent's jiang/shuai. Shi("guard")(2): moves one space diagonally and cannot leave the gong. Xiang("elephant")/xiang("minister")(2): move two places diagonally and cannot cross the river. Ma("horse")(2): move orthogonally one and then diagonally one space. Can be blocked by a piece next to it orthogonally. Ju("chariot"(2): moves any number of spaces orthogonally. Pao("catapult")/pao("cannon") (2): can move orthogonally any number of spaces, captures by jumping one piece (of either player). Zu("private"/zu("soldier")(5): can move one space forward. Once they cross the river, can also move one space horizontally. The goal is to checkmate the opponent's jiang/shuai.
(game "Xiangqi" (players {(player N) (player S)}) (equipment {(board (rectangle 10 9) use:Vertex) (piece "Jiang" Each (move Step Orthogonal (to if:(and (is In (to) (sites Mover "Palace")) (not (is Friend (who at:(to))))) (apply (remove (to)))))) (piece "Shi" Each (move Step Diagonal (to if:(and (is In (to) (sites Mover "Palace")) (not (is Friend (who at:(to))))) (apply (remove (to)))))) (piece "Xiang" Each (move Slide Diagonal (between (exact 2) if:(and {(is In (between) (sites Mover "Home")) (is Empty (between))})) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Ma" Each (forEach Direction Orthogonal (to if:(is Empty (to)) (apply (forEach Direction (from (to)) (directions {FR FL} of:All) (if (not (is Friend (who at:(to)))) (move (from) (to (apply if:(is Enemy (who at:(to))) (remove (to))))))))))) (piece "Ju" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Pao" Each (or (move Slide Orthogonal) (move Hop Orthogonal (between before:(count Rows) after:(count Rows) if:(is Occupied (between))) (to if:(is Empty (to)) (apply if:(is Enemy (who at:(to))) (remove (to))))))) (piece "Zu" Each (move Step (if (is In (from) (sites Mover "Home")) Forward (directions {Forward Rightward Leftward})) (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))))) (regions "PalaceP1" P1 {3 4 5 12 13 14 21 22 23}) (regions "PalaceP2" P2 {66 67 68 75 76 77 84 85 86}) (regions "Home" P1 (expand (sites Bottom) steps:4)) (regions "Home" P2 (expand (sites Top) steps:4))}) (rules (start {(place "Jiang1" coord:"E1") (place "Shi1" {"D1" "F1"}) (place "Xiang1" {"C1" "G1"}) (place "Ma1" {"B1" "H1"}) (place "Ju1" {"A1" "I1"}) (place "Pao1" {"B3" "H3"}) (place "Zu1" {"A4" "C4" "E4" "G4" "I4"}) (place "Jiang2" coord:"E10") (place "Shi2" {"D10" "F10"}) (place "Xiang2" {"C10" "G10"}) (place "Ma2" {"B10" "H10"}) (place "Ju2" {"A10" "I10"}) (place "Pao2" {"B8" "H8"}) (place "Zu2" {"A7" "C7" "E7" "G7" "I7"})}) (play (do (forEach Piece) ifAfterwards:(and (if (= (column of:(where "Jiang" P1)) (column of:(where "Jiang" P2))) (not (= (count Sites in:(forEach (sites Direction from:(where "Jiang" P1) N stop:(= (to) (where "Jiang" P2))) if:(is Occupied (site)))) 0)) True) (not (is Threatened (id "Jiang" Mover)))))) (end {(if (and (is Threatened (id "Jiang" Next)) (not (can Move (do (forEach Piece Next) ifAfterwards:(not (is Threatened (id "Jiang" Next))))))) (result Mover Win)) (if (no Moves Next) (result Mover Win))}))) 
Six or more players, even number of players, played on two teams. The board consists of twenty kernels of corn, spaced evenly in a line. If there are ten to fourteen players, the board is expanded to 25 kernels. If there are more than sixteen players, it is expanded to 30. A circle is drawn in the central space; this is the "fire." Sticks are used to play, (five per player), and are played in the spaces between corn kernels. Dice are also corn kernels, with one side marked with a black dot. Four dice are used, the value of a move determined by the number of black dots that land face up. Each player has two throws on their turn, and moves after the second throw. The throws both must be used, and can be used in any order. Each team's home is the side of the board to their left. Each team moves toward the opposite end of the track, and then back to home. All of the players on one team play in succession, and then the players on the other team play next. Players enter the men on their throws and move along the track. Each player may have only one piece on the board at a time. When a player reaches the team's home field, the piece may be re-entered. Reaching the home field does not require an exact throw, and if one throw brings a player home, they may use the second throw to enter it again. Any piece or stack landing exactly on the fire is removed from the game. If a piece lands on that of an opponent, it is captured. The captures piece is placed on top of the piece that captured it, and the stack now moves toward the capturing player's home space. If the player successfully carries the captured piece to the team's home space, the piece is permanently captured and removed from play. If the opposing side lands on the same space as the stack, they are stacked with the opponent's piece, and the opponent begins carrying the stack to the opposing team's side. Any pieces captured belonging to the team which brings them back to their home are returned to their players. Pieces belonging to the same team may occupy the same space with no consequence for the game. When one team has no more counters left to enter, the winner is the team that captured most of the opposing team's pieces.  The game has 6 players.
(game "A K'aak'il" (players 6) (equipment {(board (rectangle 1 20) {(track "Track1" {19 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18} P1 directed:True) (track "Track2" {20 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18} P2 directed:True) (track "Track3" {21 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18} P3 directed:True) (track "Track4" {22 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0} P4 directed:True) (track "Track5" {23 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0} P5 directed:True) (track "Track6" {24 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0} P6 directed:True) (track "CaptureTrack1" {18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0} P1 directed:True) (track "CaptureTrack2" {18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0} P2 directed:True) (track "CaptureTrack3" {18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0} P3 directed:True) (track "CaptureTrack4" {0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18} P4 directed:True) (track "CaptureTrack5" {0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18} P5 directed:True) (track "CaptureTrack6" {0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18} P6 directed:True)} use:Edge) (regions "AllSites" (sites Board Vertex)) (piece "Stick" Each (forEach Value (values Remembered "Throws") (or (if (= 0 (state at:(from) level:(level))) (if (= (trackSite Move from:(from) "Track" steps:(value)) -1) (move (from (from) level:(level)) (to (handSite Mover) (apply (forget Value "Throws" (value))))) (move (from (from) level:(level) if:(if (is In (from) (sites Hand Mover)) (< (count Pieces Mover in:(sites Board)) 1) True)) (to (trackSite Move from:(from) "Track" steps:(value)) (apply (forget Value "Throws" (value)))) (then (if (is In (last To) (sites Occupied by:Enemy top:False)) (forEach Level (last To) FromTop (and (if (is Enemy (who at:(last To) level:(level))) (set State at:(last To) level:(level) 2)) (if (is Friend (who at:(last To) level:(level))) (set State at:(last To) level:(level) 1))))))))) (if (= 1 (state at:(from) level:(level))) (if (= (trackSite Move from:(from) "CaptureTrack" steps:(value)) -1) (do (forget Value "Throws" (value)) next:(move Remove (from) level:(level) (then (and {(forEach Level (last From) FromTop (if (is Friend (who at:(last From) level:(level))) (set State at:(last From) level:(level) 0))) (forEach Level (last From) FromTop (if (= 2 (state at:(last From) level:(level))) (remove (last From) level:(level)))) (add (piece (id "Stick" Mover)) (to (handSite Mover)))})))) (move (from (from) level:(level)) (to (trackSite Move from:(from) "CaptureTrack" steps:(value)) (apply (forget Value "Throws" (value)))) (then (and (forEach Level (last From) FromTop (if (= 2 (state at:(last From) level:(level))) (fromTo (from (last From) level:(level)) (to (last To))))) (forEach Level (last From) FromTop (if (is Friend (who at:(last From) level:(level))) (set State at:(last From) level:(level) 0))))))))))) (dice d:2 from:0 num:4) (hand Each)}) (rules (start {(set Team 1 {P1 P2 P3}) (set Team 2 {P4 P5 P6}) (place Stack "Stick1" (handSite P1) count:5) (place Stack "Stick2" (handSite P2) count:5) (place Stack "Stick3" (handSite P3) count:5) (place Stack "Stick4" (handSite P4) count:5) (place Stack "Stick5" (handSite P5) count:5) (place Stack "Stick6" (handSite P6) count:5)}) phases:{(phase "ThrowPhase" (play (do (roll) next:(move Pass (then (if (not (no Pieces Mover)) (and {(if (!= 0 (count Pips)) (do (remember Value "Throws" (count Pips)) ifAfterwards:(can Move (or (forEach Piece container:(mover)) (forEach Piece))))) (moveAgain) (if (is Prev Mover) (set Pending))})))))) (nextPhase (is Pending) "MovePhase")) (phase "MovePhase" (play (or (forEach Piece) (forEach Piece container:(mover)) (then (and (if (< 0 (size Array (values Remembered "Throws"))) (moveAgain)) (forEach Site (sites Centre) (if (is Occupied (site)) (forEach Level (site) FromTop (remove (site) level:(level))))))))) (nextPhase (= 0 (size Array (values Remembered "Throws"))) "ThrowPhase"))} (end (if (no Pieces Enemy) (result TeamMover Win))))) 
Played on a standard Backgammon board. Six pieces per player. Pieces begin the game, one on each point on the left half of the player's side of the board. Pieces move in an anti-clockwise direction for both players. Two six-sided dice are rolled. When a 6 is rolled, the player moves two pieces six places. If this is on the player's first turn it must be the two pieces furthest to the left. If a 1 is rolled, the player moves one piece one spot. If doubles are rolled, the player moves twice the normal roll, and plays again. When one player is reduced to a single piece, it moves only to a consecutive corner space with the roll of each 1, or two corner spaces with the roll of each 6, doubling still applies. The first player to capture all of the opponent's pieces wins.
(game "Ad elta stelpur" (players 2) (equipment {(board (rectangle 2 13) {(track "NormalTrack" {0 1 2 3 4 5 7 8 9 10 11 12 25 24 23 22 21 20 18 17 16 15 14 13} loop:True) (track "CornerTrack" {0 5 7 12 25 20 18 13} loop:True)} use:Vertex) (regions "LeftMost" P1 {0 1}) (regions "LeftMost" P2 {24 25}) (dice num:2) (piece "Disc" Each)}) (rules (start {(place "Disc1" {0 1 2 3 4 5}) (place "Disc2" {20 21 22 23 24 25})}) (play (do (if (not (is Prev Mover)) (roll) (if (and (not (is Pending)) (not (or (is AnyDie 6) (is AnyDie 1)))) (roll))) next:(if (is Pending) (forEach Piece (or (move (from) (to (trackSite Move steps:(value Pending)) if:(and (not (is Friend (who at:(to)))) (if (>= (count Turns) 2) True (if (and (or (= 6 (value Pending)) (= 12 (value Pending))) (!= 0 (count in:(sites Mover)))) (is In (from) (sites Mover)) True))) (apply if:(is Enemy (who at:(to))) (remove (to))))) (if (= 1 (count Pieces Mover)) (move (from) (to (trackSite Move "CornerTrack" steps:(if (= (value Pending) 12) 4 (if (= (value Pending) 6) 2 (value Pending)))) if:(not (is Friend (who at:(to)))) (apply if:(is Enemy (who at:(to))) (remove (to)))))))) (forEach Die if:(or (= 6 (pips)) (= 1 (pips))) (if (= 1 (pips)) (forEach Piece (or (move (from) (to (trackSite Move steps:(if (all DiceEqual) 2 1)) if:(and (not (is Friend (who at:(to)))) (if (>= (count Turns) 2) True (if (and (or (= 6 (if (all DiceEqual) 2 1)) (= 12 (if (all DiceEqual) 2 1))) (!= 0 (count in:(sites Mover)))) (is In (from) (sites Mover)) True))) (apply if:(is Enemy (who at:(to))) (remove (to))))) (if (= 1 (count Pieces Mover)) (move (from) (to (trackSite Move "CornerTrack" steps:(if (= (if (all DiceEqual) 2 1) 12) 4 (if (= (if (all DiceEqual) 2 1) 6) 2 (if (all DiceEqual) 2 1)))) if:(not (is Friend (who at:(to)))) (apply if:(is Enemy (who at:(to))) (remove (to)))))))) (forEach Piece (or (move (from) (to (trackSite Move steps:(if (all DiceEqual) 12 6)) if:(and (not (is Friend (who at:(to)))) (if (>= (count Turns) 2) True (if (and (or (= 6 (if (all DiceEqual) 12 6)) (= 12 (if (all DiceEqual) 12 6))) (!= 0 (count in:(sites Mover)))) (is In (from) (sites Mover)) True))) (apply if:(is Enemy (who at:(to))) (remove (to))))) (if (= 1 (count Pieces Mover)) (move (from) (to (trackSite Move "CornerTrack" steps:(if (= (if (all DiceEqual) 12 6) 12) 4 (if (= (if (all DiceEqual) 12 6) 6) 2 (if (all DiceEqual) 12 6)))) if:(not (is Friend (who at:(to)))) (apply if:(is Enemy (who at:(to))) (remove (to))))))) (then (and (set Pending (if (all DiceEqual) 12 6)) (moveAgain)))))) (then (if (or (or (is AnyDie 6) (is AnyDie 1)) (all DiceEqual)) (moveAgain)))))) (end (if (no Pieces Next) (result Next Loss))))) 
7x7 board. 21 pieces per player, which begin in the three rows closest to each player. The central row of the board remains empty. Players alternate turns moving one of their pieces forward, diagonally, or horizontally on the board. When a player's piece is next to an opponent's piece with an empty space immediately on the opposite side of it, the player's piece may hop over the opponent's piece to capture it. The player who captures all of the opponent's pieces wins.
(game "Addi Kul" (players {(player N) (player S)}) (equipment {(board (square 7)) (piece "Marker" Each (or (move Step (directions {Rightward Leftward Forwards}) (to if:(is Empty (to)))) (move Hop (between if:(is Enemy (who at:(between))) (apply (remove (between)))) (to if:(is Empty (to))))))}) (rules (start {(place "Marker1" (expand (sites Bottom) steps:2)) (place "Marker2" (expand (sites Top) steps:2))}) (play (forEach Piece)) (end (if (no Pieces Next) (result Next Loss))))) 
Six or more players, even number of players, played on two teams. The board consists of twenty kernels of corn, spaced evenly in a line. If there are ten to fourteen players, the board is expanded to 25 kernels. If there are more than sixteen players, it is expanded to 30. Sticks are used to play, (five per player), and are played in the spaces between corn kernels. Dice are also corn kernels, with one side marked with a black dot. Four dice are used, the value of a move determined by the number of black dots that land face up. Each player has two throws on their turn, and moves after the second throw. The throws both must be used, and can be used in any order. Each team's home is the side of the board to their left. Each team moves toward the opposite end of the track, exiting at the opposing team's home. All of the players on one team play in succession, and then the players on the other team play next. Players enter the men on their throws and move along the track. Each player may have only one piece on the board at a time. When a player reaches the opposing team's home field, the piece may be re-entered on that player's team's own home field. Reaching the home field does not require an exact throw, and if one throw brings a player home, they may use the second throw to enter it again. If a piece lands on that of an opponent, it is captured. The captured piece is placed on top of the piece that captured it, and the stack continues toward the opposing team's home space. If the player successfully carries the captured piece to the opposing team's home space, the piece is permanently captured and removed from play. If the opposing side lands on the same space as the stack, they are stacked with the opponent's piece, and the opponent begins carrying the stack to the their opposing team's side. Any pieces captured belonging to the team which brings them off the board are returned to their players. Pieces belonging to the same team may occupy the same space with no consequence for the game. When one team has no more counters left to enter, the winner is the team that captured most of the opposing team's pieces.  The game has 6 players.
(game "Aj Sakakil" (players 6) (equipment {(board (rectangle 1 20) {(track "Track1" {19 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18} P1 directed:True) (track "Track2" {20 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18} P2 directed:True) (track "Track3" {21 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18} P3 directed:True) (track "Track4" {22 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0} P4 directed:True) (track "Track5" {23 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0} P5 directed:True) (track "Track6" {24 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0} P6 directed:True)} use:Edge) (regions "AllSites" (sites Board Vertex)) (piece "Stick" Each (forEach Value (values Remembered "Throws") (or (if (= 0 (state at:(from) level:(level))) (if (= (trackSite Move from:(from) steps:(value)) -1) (move (from (from) level:(level)) (to (handSite Mover) (apply (forget Value "Throws" (value))))) (move (from (from) level:(level) if:(if (is In (from) (sites Hand Mover)) (< (count Pieces Mover in:(sites Board)) 1) True)) (to (trackSite Move from:(from) steps:(value)) (apply (forget Value "Throws" (value)))) (then (if (is In (last To) (sites Occupied by:Enemy top:False)) (forEach Level (last To) FromTop (and (if (is Enemy (who at:(last To) level:(level))) (set State at:(last To) level:(level) 2)) (if (is Friend (who at:(last To) level:(level))) (set State at:(last To) level:(level) 1))))))))) (if (= 1 (state at:(from) level:(level))) (if (= (trackSite Move from:(from) steps:(value)) -1) (do (forget Value "Throws" (value)) next:(move Remove (from) level:(level) (then (and {(forEach Level (last From) FromTop (if (is Friend (who at:(last From) level:(level))) (set State at:(last From) level:(level) 0))) (forEach Level (last From) FromTop (if (= 2 (state at:(last From) level:(level))) (remove (last From) level:(level)))) (add (piece (id "Stick" Mover)) (to (handSite Mover)))})))) (move (from (from) level:(level)) (to (trackSite Move from:(from) steps:(value)) (apply (forget Value "Throws" (value)))) (then (and (forEach Level (last From) FromTop (if (= 2 (state at:(last From) level:(level))) (fromTo (from (last From) level:(level)) (to (last To))))) (forEach Level (last From) FromTop (if (is Friend (who at:(last From) level:(level))) (set State at:(last From) level:(level) 0))))))))))) (dice d:2 from:0 num:4) (hand Each)}) (rules (start {(set Team 1 {P1 P2 P3}) (set Team 2 {P4 P5 P6}) (place Stack "Stick1" (handSite P1) count:5) (place Stack "Stick2" (handSite P2) count:5) (place Stack "Stick3" (handSite P3) count:5) (place Stack "Stick4" (handSite P4) count:5) (place Stack "Stick5" (handSite P5) count:5) (place Stack "Stick6" (handSite P6) count:5)}) phases:{(phase "ThrowPhase" (play (do (roll) next:(move Pass (then (if (not (no Pieces Mover)) (and {(if (!= 0 (count Pips)) (do (remember Value "Throws" (count Pips)) ifAfterwards:(can Move (or (forEach Piece container:(mover)) (forEach Piece))))) (moveAgain) (if (is Prev Mover) (set Pending))})))))) (nextPhase (is Pending) "MovePhase")) (phase "MovePhase" (play (or (forEach Piece) (forEach Piece container:(mover)) (then (if (< 0 (size Array (values Remembered "Throws"))) (moveAgain))))) (nextPhase (= 0 (size Array (values Remembered "Throws"))) "ThrowPhase"))} (end (if (no Pieces Enemy) (result TeamMover Win))))) 
Six or more players, even number of players, played on two teams. The board consists of twenty kernels of corn, spaced evenly in a line. If there are ten to fourteen players, the board is expanded to 25 kernels. If there are more than sixteen players, it is expanded to 30. Sticks are used to play, (five per player), and are played in the spaces between corn kernels. Dice are also corn kernels, with one side marked with a black dot. Four dice are used, the value of a move determined by the number of black dots that land face up. Each player has two throws on their turn, and moves after the second throw. The throws both must be used, and can be used in any order. Each team's home is the side of the board to their left. Each team moves toward the opposite end of the track, and then back to home. All of the players on one team play in succession, and then the players on the other team play next. Players enter the men on their throws and move along the track. Each player may have only one piece on the board at a time. When a player reaches the team's home field, the piece may be re-entered. Reaching the home field does not require an exact throw, and if one throw brings a player home, they may use the second throw to enter it again. If a piece lands on that of an opponent, it is captured. The captures piece is placed on top of the piece that captured it, and the stack now moves toward the capturing player's home space. If the player successfully carries the captured piece to the team's home space, the piece is permanently captured and removed from play. If the opposing side lands on the same space as the stack, they are stacked with the opponent's piece, and the opponent begins carrying the stack to the opposing team's side. Any pieces captured belonging to the team which brings them back to their home are returned to their players. Pieces belonging to the same team may occupy the same space with no consequence for the game. When one team has no more counters left to enter, the winner is the team that captured most of the opposing team's pieces. The game has 6 players.
(game "Aj Sayil" (players 6) (equipment {(board (rectangle 1 20) {(track "Track1" {19 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18} P1 directed:True) (track "Track2" {20 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18} P2 directed:True) (track "Track3" {21 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18} P3 directed:True) (track "Track4" {22 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0} P4 directed:True) (track "Track5" {23 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0} P5 directed:True) (track "Track6" {24 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0} P6 directed:True) (track "CaptureTrack1" {18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0} P1 directed:True) (track "CaptureTrack2" {18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0} P2 directed:True) (track "CaptureTrack3" {18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0} P3 directed:True) (track "CaptureTrack4" {0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18} P4 directed:True) (track "CaptureTrack5" {0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18} P5 directed:True) (track "CaptureTrack6" {0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18} P6 directed:True)} use:Edge) (regions "AllSites" (sites Board Vertex)) (piece "Stick" Each (forEach Value (values Remembered "Throws") (or (if (= 0 (state at:(from) level:(level))) (if (= (trackSite Move from:(from) "Track" steps:(value)) -1) (move (from (from) level:(level)) (to (handSite Mover) (apply (forget Value "Throws" (value))))) (move (from (from) level:(level) if:(if (is In (from) (sites Hand Mover)) (< (count Pieces Mover in:(sites Board)) 1) True)) (to (trackSite Move from:(from) "Track" steps:(value)) (apply (forget Value "Throws" (value)))) (then (if (is In (last To) (sites Occupied by:Enemy top:False)) (forEach Level (last To) FromTop (and (if (is Enemy (who at:(last To) level:(level))) (set State at:(last To) level:(level) 2)) (if (is Friend (who at:(last To) level:(level))) (set State at:(last To) level:(level) 1))))))))) (if (= 1 (state at:(from) level:(level))) (if (= (trackSite Move from:(from) "CaptureTrack" steps:(value)) -1) (do (forget Value "Throws" (value)) next:(move Remove (from) level:(level) (then (and {(forEach Level (last From) FromTop (if (is Friend (who at:(last From) level:(level))) (set State at:(last From) level:(level) 0))) (forEach Level (last From) FromTop (if (= 2 (state at:(last From) level:(level))) (remove (last From) level:(level)))) (add (piece (id "Stick" Mover)) (to (handSite Mover)))})))) (move (from (from) level:(level)) (to (trackSite Move from:(from) "CaptureTrack" steps:(value)) (apply (forget Value "Throws" (value)))) (then (and (forEach Level (last From) FromTop (if (= 2 (state at:(last From) level:(level))) (fromTo (from (last From) level:(level)) (to (last To))))) (forEach Level (last From) FromTop (if (is Friend (who at:(last From) level:(level))) (set State at:(last From) level:(level) 0))))))))))) (dice d:2 from:0 num:4) (hand Each)}) (rules (start {(set Team 1 {P1 P2 P3}) (set Team 2 {P4 P5 P6}) (place Stack "Stick1" (handSite P1) count:5) (place Stack "Stick2" (handSite P2) count:5) (place Stack "Stick3" (handSite P3) count:5) (place Stack "Stick4" (handSite P4) count:5) (place Stack "Stick5" (handSite P5) count:5) (place Stack "Stick6" (handSite P6) count:5)}) phases:{(phase "ThrowPhase" (play (do (roll) next:(move Pass (then (if (not (no Pieces Mover)) (and {(if (!= 0 (count Pips)) (do (remember Value "Throws" (count Pips)) ifAfterwards:(can Move (or (forEach Piece container:(mover)) (forEach Piece))))) (moveAgain) (if (is Prev Mover) (set Pending))})))))) (nextPhase (is Pending) "MovePhase")) (phase "MovePhase" (play (or (forEach Piece) (forEach Piece container:(mover)) (then (if (< 0 (size Array (values Remembered "Throws"))) (moveAgain))))) (nextPhase (= 0 (size Array (values Remembered "Throws"))) "ThrowPhase"))} (end (if (no Pieces Enemy) (result TeamMover Win))))) 
Six or more players, even number of players, played on two teams. The board consists of twenty kernels of corn, spaced evenly in a line. If there are ten to fourteen players, the board is expanded to 25 kernels. If there are more than sixteen players, it is expanded to 30. Sticks are used to play, (five per player), and are played in the spaces between corn kernels. Dice are also corn kernels, with one side marked with a black dot. Four dice are used, the value of a move determined by the number of black dots that land face up. Each player has two throws on their turn, and moves after the second throw. The throws both must be used, and can be used in any order. Each team's home is the side of the board to their left. Each team moves toward the opposite end of the track, and then back to home. All of the players on one team play in succession, and then the players on the other team play next. Players enter the men on their throws and move along the track. Each player may have only one piece on the board at a time. When a player reaches the team's home field, the piece may be re-entered. Reaching the home field does not require an exact throw, and if one throw brings a player home, they may use the second throw to enter it again. If a piece lands on that of an opponent, it is captured. Pieces are allowed to move forward or backward if the move captures a piece. The captures piece is placed on top of the piece that captured it, and the stack now moves toward the capturing player's home space. If the player successfully carries the captured piece to the team's home space, the piece is permanently captured and removed from play. If the opposing side lands on the same space as the stack, they are stacked with the opponent's piece, and the opponent begins carrying the stack to the opposing team's side. Any pieces captured belonging to the team which brings them back to their home are returned to their players. Pieces belonging to the same team may occupy the same space with no consequence for the game. When one team has no more counters left to enter, the winner is the team that captured most of the opposing team's pieces.  The game has 6 players.
(game "Aj Sina'anil" (players 6) (equipment {(board (rectangle 1 20) {(track "Track1" {19 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18} P1 directed:True) (track "Track2" {20 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18} P2 directed:True) (track "Track3" {21 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18} P3 directed:True) (track "Track4" {22 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0} P4 directed:True) (track "Track5" {23 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0} P5 directed:True) (track "Track6" {24 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0} P6 directed:True) (track "CaptureTrack1" {18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0} P1 directed:True) (track "CaptureTrack2" {18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0} P2 directed:True) (track "CaptureTrack3" {18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0} P3 directed:True) (track "CaptureTrack4" {0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18} P4 directed:True) (track "CaptureTrack5" {0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18} P5 directed:True) (track "CaptureTrack6" {0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18} P6 directed:True)} use:Edge) (regions "AllSites" (sites Board Vertex)) (piece "Stick" Each (forEach Value (values Remembered "Throws") (or (if (= 0 (state at:(from) level:(level))) (or (if (= (trackSite Move from:(from) "Track" steps:(value)) -1) (move (from (from) level:(level)) (to (handSite Mover) (apply (forget Value "Throws" (value))))) (move (from (from) level:(level) if:(if (is In (from) (sites Hand Mover)) (< (count Pieces Mover in:(sites Board)) 1) True)) (to (trackSite Move from:(from) "Track" steps:(value)) (apply (forget Value "Throws" (value)))) (then (if (is In (last To) (sites Occupied by:Enemy top:False)) (forEach Level (last To) FromTop (and (if (is Enemy (who at:(last To) level:(level))) (set State at:(last To) level:(level) 2)) (if (is Friend (who at:(last To) level:(level))) (set State at:(last To) level:(level) 1)))))))) (if (and (is In (from) (sites Board)) (!= (trackSite Move from:(from) "CaptureTrack" steps:(value)) -1)) (if (is In (trackSite Move from:(from) "CaptureTrack" steps:(value)) (sites Occupied by:Enemy top:False)) (move (from (from) level:(level)) (to (trackSite Move from:(from) "CaptureTrack" steps:(value)) (apply (forget Value "Throws" (value)))) (then (forEach Level (last To) FromTop (and (if (is Enemy (who at:(last To) level:(level))) (set State at:(last To) level:(level) 2)) (if (is Friend (who at:(last To) level:(level))) (set State at:(last To) level:(level) 1)))))))))) (if (= 1 (state at:(from) level:(level))) (if (= (trackSite Move from:(from) "CaptureTrack" steps:(value)) -1) (do (forget Value "Throws" (value)) next:(move Remove (from) level:(level) (then (and {(forEach Level (last From) FromTop (if (is Friend (who at:(last From) level:(level))) (set State at:(last From) level:(level) 0))) (forEach Level (last From) FromTop (if (= 2 (state at:(last From) level:(level))) (remove (last From) level:(level)))) (add (piece (id "Stick" Mover)) (to (handSite Mover)))})))) (move (from (from) level:(level)) (to (trackSite Move from:(from) "CaptureTrack" steps:(value)) (apply (forget Value "Throws" (value)))) (then (and (forEach Level (last From) FromTop (if (= 2 (state at:(last From) level:(level))) (fromTo (from (last From) level:(level)) (to (last To))))) (forEach Level (last From) FromTop (if (is Friend (who at:(last From) level:(level))) (set State at:(last From) level:(level) 0))))))))))) (dice d:2 from:0 num:4) (hand Each)}) (rules (start {(set Team 1 {P1 P2 P3}) (set Team 2 {P4 P5 P6}) (place Stack "Stick1" (handSite P1) count:5) (place Stack "Stick2" (handSite P2) count:5) (place Stack "Stick3" (handSite P3) count:5) (place Stack "Stick4" (handSite P4) count:5) (place Stack "Stick5" (handSite P5) count:5) (place Stack "Stick6" (handSite P6) count:5)}) phases:{(phase "ThrowPhase" (play (do (roll) next:(move Pass (then (if (not (no Pieces Mover)) (and {(if (!= 0 (count Pips)) (do (remember Value "Throws" (count Pips)) ifAfterwards:(can Move (or (forEach Piece container:(mover)) (forEach Piece))))) (moveAgain) (if (is Prev Mover) (set Pending))})))))) (nextPhase (is Pending) "MovePhase")) (phase "MovePhase" (play (or (forEach Piece) (forEach Piece container:(mover)) (then (if (< 0 (size Array (values Remembered "Throws"))) (moveAgain))))) (nextPhase (= 0 (size Array (values Remembered "Throws"))) "ThrowPhase"))} (end (if (no Pieces Enemy) (result TeamMover Win))))) 
Six or more players, even number of players, played on two teams. The board consists of twenty kernels of corn, spaced evenly in a line. If there are ten to fourteen players, the board is expanded to 25 kernels. If there are more than sixteen players, it is expanded to 30. Sticks are used to play, (five per player), and are played in the spaces between corn kernels. Dice are also corn kernels, with one side marked with a black dot. Four dice are used, the value of a move determined by the number of black dots that land face up. Each player has two throws on their turn, and moves after the second throw. The throws both must be used, and can be used in any order. Each team's home is the side of the board to their left. Each team moves toward the opposite end of the track, and then back to home. All of the players on one team play in succession, and then the players on the other team play next. Players enter the men on their throws and move along the track. Each player may have only one piece on the board at a time. When a player reaches the team's home field, the piece may be re-entered. Reaching the home field does not require an exact throw, and if one throw brings a player home, they may use the second throw to enter it again. If a piece lands on that of an opponent, it is captured and immediately leaved the board with the capture. Neither piece is reentered. Pieces belonging to the same team may occupy the same space with no consequence for the game. When one team has no more counters left to enter, the winner is the team that captured most of the opposing team's pieces.  The game has 6 players.
(game "Aj T'iwil" (players 6) (equipment {(board (rectangle 1 20) {(track "Track1" {19 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18} P1 directed:True) (track "Track2" {20 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18} P2 directed:True) (track "Track3" {21 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18} P3 directed:True) (track "Track4" {22 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0} P4 directed:True) (track "Track5" {23 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0} P5 directed:True) (track "Track6" {24 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0} P6 directed:True)} use:Edge) (regions "AllSites" (sites Board Vertex)) (piece "Stick" Each (forEach Value (values Remembered "Throws") (if (= (trackSite Move from:(from) "Track" steps:(value)) -1) (move (from (from) level:(level)) (to (handSite Mover) (apply (forget Value "Throws" (value))))) (move (from (from) level:(level) if:(if (is In (from) (sites Hand Mover)) (< (count Pieces Mover in:(sites Board)) 1) True)) (to (trackSite Move from:(from) "Track" steps:(value)) (apply (and (forEach Level (to) FromTop (if (is Enemy (who at:(to) level:(level))) (remove (to) level:(level)))) (forget Value "Throws" (value))))))))) (dice d:2 from:0 num:4) (hand Each)}) (rules (start {(set Team 1 {P1 P2 P3}) (set Team 2 {P4 P5 P6}) (place Stack "Stick1" (handSite P1) count:5) (place Stack "Stick2" (handSite P2) count:5) (place Stack "Stick3" (handSite P3) count:5) (place Stack "Stick4" (handSite P4) count:5) (place Stack "Stick5" (handSite P5) count:5) (place Stack "Stick6" (handSite P6) count:5)}) phases:{(phase "ThrowPhase" (play (do (roll) next:(move Pass (then (if (not (no Pieces Mover)) (and {(if (!= 0 (count Pips)) (do (remember Value "Throws" (count Pips)) ifAfterwards:(can Move (or (forEach Piece container:(mover)) (forEach Piece))))) (moveAgain) (if (is Prev Mover) (set Pending))})))))) (nextPhase (is Pending) "MovePhase")) (phase "MovePhase" (play (or (forEach Piece) (forEach Piece container:(mover)) (then (if (< 0 (size Array (values Remembered "Throws"))) (moveAgain))))) (nextPhase (= 0 (size Array (values Remembered "Throws"))) "ThrowPhase"))} (end (if (no Pieces Enemy) (result TeamMover Win))))) 
MOVE - A stone can move up to N spaces in any combination of directions (it may even move over intervening stones), where N varies depending on the number of stones he has remaining: - Six pieces: one space per turn - Five pieces: two spaces per turn - Four pieces: three spaces per turn - Three pieces: four spaces per turn - Two pieces: five spaces per turn - One piece: six spaces per turn. CAPTURE - A stone captures an opposing piece by moving onto it. If a stone makes a capture before it has used all of the spaces available to it that move, it may continue to make additional captures until it has moved its limit. GOAL - Wins the player who captures all of his opponent's stones, or, if he reduces his opponent to a single stone without losing any of his own.
(game "Annuvin" (players 2) (equipment {(board (rotate 30 (hex 4))) (piece "Ball" Each (move Slide (between (max (if (= -1 (value Player Mover)) 1 (value Player Mover))) if:(not (is Enemy (who at:(between))))) (to if:(is Enemy (who at:(to))) (apply if:(not (is Friend (who at:(to)))) (if (is Enemy (who at:(to))) (remove (to) (then (set Value Next (+ (value Player Next) 1))))))) (then (if (<= (- (if (= -1 (value Player Mover)) 1 (value Player Mover)) (count Steps (last From) (last To))) 0) (set Value Mover (- 7 (count Pieces Mover))) (and (set Value Mover (- (if (= -1 (value Player Mover)) 1 (value Player Mover)) (count Steps (last From) (last To)))) (moveAgain)))))) (hand Each)}) (rules (start {(place "Ball1" (difference (union {(sites Side NW) (sites Side NE) (expand (sites Side N))}) (union (sites Left) (sites Right)))) (place "Ball2" (difference (union {(sites Side SW) (sites Side SE) (expand (sites Side S))}) (union (sites Left) (sites Right))))}) (play (if (is Prev Mover) (move Slide (from (last To)) (between (max (if (= -1 (value Player Mover)) 1 (value Player Mover))) if:(not (is Enemy (who at:(between))))) (to if:(is Enemy (who at:(to))) (apply if:(not (is Friend (who at:(to)))) (if (is Enemy (who at:(to))) (remove (to) (then (set Value Next (+ (value Player Next) 1))))))) (then (if (<= (- (if (= -1 (value Player Mover)) 1 (value Player Mover)) (count Steps (last From) (last To))) 0) (set Value Mover (- 7 (count Pieces Mover))) (and (set Value Mover (- (if (= -1 (value Player Mover)) 1 (value Player Mover)) (count Steps (last From) (last To)))) (moveAgain))))) (forEach Piece))) (end (if (or (and (= 1 (count Pieces Next)) (= 6 (count Pieces Mover))) (no Pieces Next)) (result Mover Win))))) 
4x13, 19, 21, or 29 board. The number of pieces per player equals the number of spaces in a row, which begin the game arrayed in the outer rows of the board. Four sticks, each with a white side and a yellow side. Throws equal the number of white sides which fall up; when only yellow sides are up the throw equals 6. A throw of 1, 4, or 6 grants another throw to the player. Players perform all of their throws first, and then move pieces according to the values of the throws without subdividing the value of a single throw. Players cannot move their pieces until the throw a 1. Pieces cannot move past one another in the home row. Each piece in the home row must individually be unlocked with a throw of 1 before it can move. In the central rows, when two of a player's pieces land on the same spot, they become a king and can be moved as one piece. There is no limit to the number of pieces in the king. They may be uncoupled with a throw of 1, or another throw which removes that number of pieces from the king. When a player's piece lands in a space occupied by an opponent's piece, the opponent's piece is removed from the board. Play progresses from left to right in the player's home row, and then from right to left in the second row, left to right in the third row, and then right to left in the opponent's row. When a piece enters the opponent's row, it cannot move if there are other pieces which can be moved. The player to capture the most of the opponent's pieces wins. The board has 13 columns.
(game "At-Tab wa-d-Dukk" (players 2) (equipment {(board (rectangle 4 13) {(track "Track1" "0,E,N1,W,N1,E,N1,W" P1 directed:True) (track "Track2" "51,W,S1,E,S1,W,S1,E" P2 directed:True)}) (dice d:2 from:0 num:4) (map {(pair 0 6) (pair 1 1) (pair 2 2) (pair 3 3) (pair 4 4)}) (piece "Marker" Each (if (or (= (state at:(from)) 0) (and (= 1 (mapEntry (count Pips))) (= (state at:(from)) 1))) (if (!= (trackSite Move steps:(mapEntry (count Pips))) -1) (if (or (not (is In (from) (sites Next))) (and (is In (from) (sites Next)) (= (count Sites in:(intersection (sites Occupied by:Next) (sites Next))) 0))) (if (or (is In (trackSite Move steps:(mapEntry (count Pips))) (sites Empty)) (is Enemy (who at:(trackSite Move steps:(mapEntry (count Pips)))))) (or (if (= (+ (mapEntry (count Pips)) 1) (count at:(from))) (move (from) (to (trackSite Move steps:(mapEntry (count Pips))) (apply if:(is Enemy (who at:(to))) (remove (to) (then (addScore Mover 1))))) count:(mapEntry (count Pips)))) (move (from) (to (trackSite Move steps:(mapEntry (count Pips))) (apply if:(is Enemy (who at:(to))) (remove (to) (then (addScore Mover 1))))) count:(count at:(from)))) (if (and (is In (trackSite Move steps:(mapEntry (count Pips))) (sites "CentralRows")) (is Friend (who at:(trackSite Move steps:(mapEntry (count Pips)))))) (move (from) (to (trackSite Move steps:(mapEntry (count Pips)))))))) (then (set State at:(last To) 0))))) (regions "AnotherThrow" (sites {1 4 6})) (regions "CentralRows" (union (sites Row 1) (sites Row 2))) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Marker1" (sites Bottom) state:1) (place "Marker2" (sites Top) state:1)}) (play (do (roll) next:(if (can Move (forEach Piece)) (forEach Piece (then (if (is In (mapEntry (count Pips)) (sites "AnotherThrow")) (moveAgain)))) (move Pass (then (if (is In (mapEntry (count Pips)) (sites "AnotherThrow")) (moveAgain))))))) (end (if (or (and (= (count Sites in:(difference (sites Occupied by:P1) (sites P2))) 0) (= (count Sites in:(difference (sites Occupied by:P2) (sites P1))) 0)) (no Pieces Mover)) (byScore))))) 
5x12 board, played on the intersections of lines. Twelve pieces per player, arranged along the side of twelve closest to the player. Pieces move along a boustrophedon track, one player starting from left to right in their starting row and the other from right to left in their starting row. Moves are determined by the throw of six cowries: one mouth up = 1, two mouth up = 2, three mouths up = 3, four mouths up = 4, five mouths up = 1 (0 and 6 mouths up are not specified, but are between 10 and 20 and the move can be split to make captures). A player must roll 1 or (0 or 6) to begin. When a piece moves to a spot occupied by an opponent's piece, it is captured. The goal of the game is to reduce the other player to one or two pieces. 0 or 6 mouths correspond to 10.
(game "Awangdu" (players 2) (equipment {(board (rectangle 5 12) {(track "Track1" "0,E,N1,W,N1,E,N1,W,N1,E" P1 directed:True) (track "Track2" "59,W,S1,E,S1,W,S1,E,S1,W" P2 directed:True)} use:Vertex) (dice d:2 from:0 num:6) (piece "Disc" Each (if (not (is Friend (who at:(trackSite Move steps:(mapEntry (var)))))) (move (from) (to (trackSite Move steps:(mapEntry (var))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (map {(pair 0 10) (pair 1 1) (pair 2 2) (pair 3 3) (pair 4 4) (pair 5 1) (pair 6 10)})}) (rules (start {(place "Disc1" (sites Bottom)) (place "Disc2" (sites Top))}) (play (do (roll) next:(if (or (= (value Player Mover) 1) (is In (count Pips) (sites {0 1 5 6}))) (do (set Var (count Pips)) next:(forEach Piece (then (if (not (= (value Player Mover) 1)) (set Value Mover 1)))))))) (end (if (<= (count Pieces Next) 2) (result Next Loss))))) 
The first player (Grey) has their home area on the left; the second player (Black) on the right. In the initial setup phase players move their pieces from their hand to their home area. By default the pieces will be placed vertically. Press 'r' whilst moving it, to place one horizontally. Finally the players take turns to guess spaces in their opponent's home area. These are revealed to be either water or a ship according to the following code: <b>C</b>arrier - 5 spaces; <b>B</b>attleship - 4 spaces; <b>D</b>estroyer - 3 spaces; <b>S</b>ubmarine - 3 spaces; <b>P</b>atrol Boat - 2 spaces.
(game "Battleships" (players 2) (equipment {(board (rectangle 10 20)) (piece "Carrier" Each) (tile "CarrierTemplate" Each {{F F F F} {L F F F F}} (move (from if:(is In (from) (sites Hand Mover))) (to (intersection (sites Mover "Defence") (sites Empty))) (then (do (forEach Site (sites LargePiece at:(last To)) (remember Value (site)) (then (remove (last To)))) next:(do (forEach Value (values Remembered) (add (piece (id "Carrier" Mover)) (to (value)) (then (set State at:(last To) 0)))) next:(forget Value All)))))) (piece "Battleship" Each) (tile "BattleshipTemplate" Each {{F F F} {L F F F}} (move (from if:(is In (from) (sites Hand Mover))) (to (intersection (sites Mover "Defence") (sites Empty))) (then (do (forEach Site (sites LargePiece at:(last To)) (remember Value (site)) (then (remove (last To)))) next:(do (forEach Value (values Remembered) (add (piece (id "Battleship" Mover)) (to (value)) (then (set State at:(last To) 0)))) next:(forget Value All)))))) (piece "Destroyer" Each) (tile "DestroyerTemplate" Each {{F F} {L F F}} (move (from if:(is In (from) (sites Hand Mover))) (to (intersection (sites Mover "Defence") (sites Empty))) (then (do (forEach Site (sites LargePiece at:(last To)) (remember Value (site)) (then (remove (last To)))) next:(do (forEach Value (values Remembered) (add (piece (id "Destroyer" Mover)) (to (value)) (then (set State at:(last To) 0)))) next:(forget Value All)))))) (piece "Submarine" Each) (tile "SubmarineTemplate" Each {{F F} {L F F}} (move (from if:(is In (from) (sites Hand Mover))) (to (intersection (sites Mover "Defence") (sites Empty))) (then (do (forEach Site (sites LargePiece at:(last To)) (remember Value (site)) (then (remove (last To)))) next:(do (forEach Value (values Remembered) (add (piece (id "Submarine" Mover)) (to (value)) (then (set State at:(last To) 0)))) next:(forget Value All)))))) (piece "PatrolBoat" Each) (tile "PatrolBoatTemplate" Each {{F} {L F}} (move (from if:(is In (from) (sites Hand Mover))) (to (intersection (sites Mover "Defence") (sites Empty))) (then (do (forEach Site (sites LargePiece at:(last To)) (remember Value (site)) (then (remove (last To)))) next:(do (forEach Value (values Remembered) (add (piece (id "PatrolBoat" Mover)) (to (value)) (then (set State at:(last To) 0)))) next:(forget Value All)))))) (regions "Defence" P1 (expand (sites Left) steps:9)) (regions "Defence" P2 (expand (sites Right) steps:9)) (hand Each size:5)}) (rules (start {(set Hidden (sites P1 "Defence") to:P2) (set Hidden (sites P2 "Defence") to:P1) (set Hidden (sites Hand P1) to:P2) (set Hidden (sites Hand P2) to:P1) (place "CarrierTemplate1" (handSite P1 0)) (place "CarrierTemplate2" (handSite P2 0)) (place "BattleshipTemplate1" (handSite P1 1)) (place "BattleshipTemplate2" (handSite P2 1)) (place "DestroyerTemplate1" (handSite P1 2)) (place "DestroyerTemplate2" (handSite P2 2)) (place "SubmarineTemplate1" (handSite P1 3)) (place "SubmarineTemplate2" (handSite P2 3)) (place "PatrolBoatTemplate1" (handSite P1 4)) (place "PatrolBoatTemplate2" (handSite P2 4))}) phases:{(phase "Setup" (play (forEach Piece container:(mover))) (nextPhase (>= (count Turns) 10) "Playing")) (phase "Playing" (play (move Select (from (intersection (sites Next "Defence") (sites Hidden to:Mover))) (then (set State at:(last From) 1 (then (set Hidden at:(last From) False to:Mover (then (if (and (>= (count Turns) 10) (= 0 (count Sites in:(intersection (sites Hidden to:Mover) (sites Occupied by:Next))))) (set Var (id Mover) (then (forEach Site (sites Board) (set Hidden at:(site) False to:Next)))))))))))))} (end {(if (= (id P1) (var)) (result P1 Win)) (if (= (id P2) (var)) (result P2 Win))}))) 
3x8 board. Eight pieces per player, which start in the spaces of the outer rows of the board. Four cowrie shells used as dice, the number of mouths face up being the value of the throw. A throw of 1 grants the player another throw. A player must throw 1 for the first move of each of their pieces. Players may only play with one piece out of the home row at a time and cannot move the next of their pieces until the piece being played has been captured. Throws of 1 must be used to move a piece in the home row, if possible. Pieces move from left to right in the player's home row, then from right to left in the central row, left to right in the opponent's home row, and right to left in the central row. When a piece lands on a space occupied by an opponent's piece, the opponent's piece is captured. The player who captures all of the opponent's pieces wins.
(game "Bheri Bakhri" (players 2) (equipment {(board (rectangle 3 8) {(track "Track1" "0,E,N1,W,N1,E,S1,W" loop:True P1) (track "Track2" "23,W,S1,E,S1,W,N1,E" loop:True P2)}) (dice d:2 from:0 num:4) (piece "Marker" Each (if (and {(if (!= 0 (state at:(from))) True (= 1 (count Pips)))}) (if (and (not (is Friend (who at:(trackSite Move steps:(count Pips))))) (if (not (is In (from) (sites Mover "Home"))) True (if (is In (trackSite Move steps:(count Pips)) (sites Mover "Home")) True (= (count Pieces Mover in:(difference (sites Board) (sites Mover "Home"))) 0)))) (move (from) (to (trackSite Move steps:(count Pips)) (apply if:(is Enemy (who at:(to))) (remove (to)))) (then (if (and (not (!= 0 (state at:(last To)))) (= 1 (count Pips))) (set State at:(last To) 1))))))) (regions "Home" P1 (sites Bottom)) (regions "Home" P2 (sites Top))}) (rules (start {(place "Marker1" (sites Bottom)) (place "Marker2" (sites Top))}) (play (do (roll) next:(if (= 1 (count Pips)) (priority {(forEach Piece (if (and {(if (!= 0 (state at:(from))) True (= 1 (count Pips))) (is In (from) (sites Mover "Home"))}) (if (and (not (is Friend (who at:(trackSite Move steps:(count Pips))))) (if (not (is In (from) (sites Mover "Home"))) True (if (is In (trackSite Move steps:(count Pips)) (sites Mover "Home")) True (= (count Pieces Mover in:(difference (sites Board) (sites Mover "Home"))) 0)))) (move (from) (to (trackSite Move steps:(count Pips)) (apply if:(is Enemy (who at:(to))) (remove (to)))) (then (if (and (not (!= 0 (state at:(last To)))) (= 1 (count Pips))) (set State at:(last To) 1))))))) (forEach Piece)}) (forEach Piece)) (then (if (= 1 (count Pips)) (moveAgain))))) (end (if (no Pieces Next) (result Next Loss))))) 
Fifteen corn kernels are placed in a line; the playing spaces are the empty spaces between the kernels. Four corn kernels used as dice, marked on one side. The value of a throw is equal to the number of marked sides that land up, except when no marked sides are up, when the value is 5. Any number of players, who play on two teams, each starting from one side of the board. Five pieces per player. Players take turns moving pieces according to the throws of the corn, with two throws per turn. When a player reaches the opposite end of the board, they move to the start and continue moving in the same direction. If a piece lands on a space occupied by an opponent's piece, the player then moves in the reverse direction, carrying the opponent's piece with it in an attempt to move past the starting point and off the board. When the player moves past the starting point and then moves off the board, the opponent's piece is captured. The player who made the capture enters their piece again on their next turn. However, if the opponent lands on a piece carrying one of their pieces away, they then start carrying both of those pieces back to their starting point, freeing the captured piece and capturing the other player's piece. Players belonging to the same team may land on the same spot, but both are taken back to start if the opponent lands on them. Players cannot enter more than one of their pieces on the board at one time. The first team to capture all of the opposing team's pieces wins. The game has 6 players.
(game "Boolik" (players 6) (equipment {(board (rectangle 1 15) {(track "Track1" {0 1 2 3 4 5 6 7 8 9 10 11 12 13} loop:True P1) (track "Track2" {13 12 11 10 9 8 7 6 5 4 3 2 1 0} loop:True P2) (track "CaptureTrack1" {13 12 11 10 9 8 7 6 5 4 3 2 1 0} P1 directed:True) (track "CaptureTrack2" {0 1 2 3 4 5 6 7 8 9 10 11 12 13} P2 directed:True) (track "Track3" {0 1 2 3 4 5 6 7 8 9 10 11 12 13} loop:True P3) (track "Track4" {13 12 11 10 9 8 7 6 5 4 3 2 1 0} loop:True P4) (track "CaptureTrack3" {13 12 11 10 9 8 7 6 5 4 3 2 1 0} P3 directed:True) (track "CaptureTrack4" {0 1 2 3 4 5 6 7 8 9 10 11 12 13} P4 directed:True) (track "Track5" {0 1 2 3 4 5 6 7 8 9 10 11 12 13} loop:True P5) (track "Track6" {13 12 11 10 9 8 7 6 5 4 3 2 1 0} loop:True P6) (track "CaptureTrack5" {13 12 11 10 9 8 7 6 5 4 3 2 1 0} P5 directed:True) (track "CaptureTrack6" {0 1 2 3 4 5 6 7 8 9 10 11 12 13} P6 directed:True)} use:Edge) (piece "Stick" Each (or (if (= 0 (state at:(from) level:(level))) (move (from (from) level:(level)) (to (trackSite Move from:(from) "Track" steps:(mapEntry "Throw" (count Pips)))) (then (if (is In (last To) (sites Occupied by:Enemy top:False)) (forEach Level (last To) FromTop (and (if (is Enemy (who at:(last To) level:(level))) (set State at:(last To) level:(level) 2)) (if (is Friend (who at:(last To) level:(level))) (set State at:(last To) level:(level) 1)))))))) (if (= 1 (state at:(from) level:(level))) (if (!= (trackSite Move from:(from) "CaptureTrack" steps:(mapEntry "Throw" (count Pips))) -1) (move (from (from) level:(level)) (to (trackSite Move from:(from) "CaptureTrack" steps:(mapEntry "Throw" (count Pips)))) (then (and (forEach Level (last From) FromTop (if (= 2 (state at:(last From) level:(level))) (fromTo (from (last From) level:(level)) (to (last To))))) (forEach Level (last From) FromTop (if (is Friend (who at:(last From) level:(level))) (set State at:(last From) level:(level) 0)))))) (move Remove (from) level:(level) (then (and {(forEach Level (last From) FromTop (if (is Friend (who at:(last From) level:(level))) (set State at:(last From) level:(level) 0))) (forEach Level (last From) FromTop (if (= 2 (state at:(last From) level:(level))) (remove (last From) level:(level)))) (add (piece (id "Stick" Mover)) (to (handSite Mover)))}))))))) (regions "AllSites" (sites Board Vertex)) (map "Throw" {(pair 0 5) (pair 1 1) (pair 2 2) (pair 3 3) (pair 4 4)}) (map "Entry" {(pair 1 0) (pair 2 13) (pair 3 0) (pair 4 13) (pair 5 0) (pair 6 13) (pair 7 0) (pair 8 13) (pair 9 0) (pair 10 13) (pair 11 0) (pair 12 13) (pair 13 0) (pair 14 13) (pair 15 0) (pair 16 13)}) (dice d:2 from:0 num:4) (hand Each)}) (rules (start {(set Team 1 {P1 P3 P5}) (set Team 2 {P2 P4 P6}) (place Stack "Stick1" (handSite P1) count:5) (place Stack "Stick2" (handSite P2) count:5) (place Stack "Stick3" (handSite P3) count:5) (place Stack "Stick4" (handSite P4) count:5) (place Stack "Stick5" (handSite P5) count:5) (place Stack "Stick6" (handSite P6) count:5)}) (play (do (roll) next:(or {(if (and (< (count Pieces Mover in:(sites Board)) 1) (is Occupied (handSite Mover))) (move (from (handSite Mover)) (to (trackSite Move from:(mapEntry "Entry" (mover)) "Track" steps:(- (mapEntry "Throw" (count Pips)) 1))))) (forEach Piece)}) (then (if (and (not (no Pieces Mover)) (not (is Prev Mover))) (moveAgain))))) (end (if (no Pieces Enemy) (result TeamMover Win))))) 
Four squares, arranged in a cross shape. The game is played along the lines. Four pieces per player, which begin on the corners of a square, opposite the square where the opponent's pieces are arranged. Players alternate turns moving their pieces. Pieces move three spaces along the lines on the board, capturing any piece on the third. The first two spaces in the move must be empty. Pieces may change direction in a turn, as long as the lines are followed and there is no backtracking. The player who captures all of the opponent's pieces wins.
(game "Boxijn Barildaan" (players 2) (equipment {(board (merge {(shift 1 0 (rectangle 4 2)) (shift 0 1 (rectangle 2 4))}) use:Vertex) (piece "Marker" Each (move Step (to if:(and (= 0 (state at:(to))) (if (< (count MovesThisTurn) 2) (is Empty (to)) (is In (to) (union (sites Occupied by:Next) (sites Empty))))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (if (= 2 (count Sites in:(forEach (sites Board) if:(= 1 (state at:(site)))))) (forEach Site (sites Board) (if (= 1 (state at:(site))) (set State at:(site) 0))) (and (set State at:(last From) 1) (moveAgain))))))}) (rules (start {(place "Marker1" (expand (sites Bottom))) (place "Marker2" (expand (sites Top)))}) (play (if (is Prev Mover) (move Step (from (last To)) (to if:(and (= 0 (state at:(to))) (if (< (count MovesThisTurn) 2) (is Empty (to)) (is In (to) (union (sites Occupied by:Next) (sites Empty))))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (if (= 2 (count Sites in:(forEach (sites Board) if:(= 1 (state at:(site)))))) (forEach Site (sites Board) (if (= 1 (state at:(site))) (set State at:(site) 0))) (and (set State at:(last From) 1) (moveAgain))))) (forEach Piece))) (end (if (no Pieces Next) (result Next Loss))))) 
Six or more players (even number), played on two teams. The games Aj Sayil, Aj T'iwil, Aj Sina'anil, Aj Sakakil, and A K'aak'il are played in succession. The game has 6 players.
(match "Bul" (players 6) (games {(subgame "Aj Sayil" next:1) (subgame "Aj T'iwil" next:2) (subgame "Aj Sina'anil" next:3) (subgame "Aj Sakakil" next:4) (subgame "A K'aak'il")}) (end {(if (and (>= (count Trials) 5) (> (matchScore P1) (matchScore P4))) (result P1 Win)) (if (and (>= (count Trials) 5) (> (matchScore P1) (matchScore P4))) (result P2 Win)) (if (and (>= (count Trials) 5) (> (matchScore P1) (matchScore P4))) (result P3 Win)) (if (and (>= (count Trials) 5) (< (matchScore P1) (matchScore P4))) (result P4 Win)) (if (and (>= (count Trials) 5) (< (matchScore P1) (matchScore P4))) (result P5 Win)) (if (and (>= (count Trials) 5) (< (matchScore P1) (matchScore P4))) (result P6 Win))})) 
8x8 board. Four players. Two dice. Four pawns, one ship, one horse, one elephant, and one king per player. The king moves one square in any direction. Pawns move one square forward, and capture one square forward diagonally. Horses move three squares diagonally. Ships move two squares diagonally. The Elephant moves any number of squares orthogonally. Moves are determined by dice roll: 5= pawn or king, 4= elephant, 3= horse, 2= ship. Captures are made by moving onto the space occupied by an opponent's piece. If a ship moves into a space to make a 2x2 square with only ships, it captures the other three ships. Pawns may promote but only to the other piece that begins in that rank or file, including a king, and that piece must have already been captured. Points are awarded based on captures: pawns=1, ships=2, horses=3, elephants=4, kings=5. If a player captures their opponents' three kings while theirs remains, they receive 54 points. The player who accumulates the most points wins.  The rules are describing with the Wikipedia ruleset.
(game "Chaturaji" (players {(player N) (player W) (player S) (player E)}) (equipment {(board (square 8)) (dice d:4 from:2 num:1) (piece "Pawn" Each (or (move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (if (is Occupied (to)) (and (addScore Mover (value Piece at:(to))) (remove (to))))))) (then (if (is In (last To) (sites Mover "Promotion")) (and (moveAgain) (set Pending)))))) (piece "Boat" Each (move Hop Diagonal (to if:(not (is Friend (who at:(to)))) (apply (if (is Occupied (to)) (and (addScore Mover (value Piece at:(to))) (remove (to)))))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Occupied (to)) (and (addScore Mover (value Piece at:(to))) (remove (to)))))))) (piece "Elephant" Each (move Slide Orthogonal (between if:(is Empty (between))) (to if:(is Enemy (who at:(to))) (apply (if (is Occupied (to)) (and (addScore Mover (value Piece at:(to))) (remove (to)))))))) (piece "King_noCross" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Occupied (to)) (and (addScore Mover (value Piece at:(to))) (remove (to)))))))) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Left)) (regions "Promotion" P3 (sites Bottom)) (regions "Promotion" P4 (sites Right))}) (rules (start {(place "Pawn1" {"A2" "B2" "C2" "D2"} value:1) (place "Pawn2" {"G1" "G2" "G3" "G4"} value:1) (place "Pawn3" {"H7" "G7" "E7" "F7"} value:1) (place "Pawn4" {"B5" "B6" "B7" "B8"} value:1) (place "Boat1" coord:"A1" value:2) (place "Boat2" coord:"H1" value:2) (place "Boat3" coord:"H8" value:2) (place "Boat4" coord:"A8" value:2) (place "Knight1" coord:"B1" value:3) (place "Knight2" coord:"H2" value:3) (place "Knight3" coord:"G8" value:3) (place "Knight4" coord:"A7" value:3) (place "Elephant1" coord:"C1" value:4) (place "Elephant2" coord:"H3" value:4) (place "Elephant3" coord:"F8" value:4) (place "Elephant4" coord:"A6" value:4) (place "King_noCross1" coord:"D1" value:5) (place "King_noCross2" coord:"H4" value:5) (place "King_noCross3" coord:"E8" value:5) (place "King_noCross4" coord:"A5" value:5)}) (play (do (if (not (is Prev Mover)) (roll)) next:(if (and (is Prev Mover) (is Pending)) (or {(if (= (where "Boat" Mover) -1) (move Promote (last To) (piece "Boat") Mover (then (set Value at:(last To) 2)))) (if (= (where "Knight" Mover) -1) (move Promote (last To) (piece "Knight") Mover (then (set Value at:(last To) 3)))) (if (= (where "Elephant" Mover) -1) (move Promote (last To) (piece "Elephant") Mover (then (set Value at:(last To) 4)))) (if (= (where "King_noCross" Mover) -1) (move Promote (last To) (piece "King_noCross") Mover (then (set Value at:(last To) 5))))}) (forEach Die (if (= (pips) 5) (or (forEach Piece "Pawn") (forEach Piece "King_noCross")) (if (= (pips) 4) (forEach Piece "Elephant") (if (= (pips) 3) (forEach Piece "Knight") (if (= (pips) 2) (forEach Piece "Boat")))))) (then (if (can Move (forEach Die (if (= (pips) 5) (or (forEach Piece "Pawn") (forEach Piece "King_noCross")) (if (= (pips) 4) (forEach Piece "Elephant") (if (= (pips) 3) (forEach Piece "Knight") (if (= (pips) 2) (forEach Piece "Boat"))))))) (moveAgain)))))) (end (if (= (count Pieces Mover) (- (count Pieces All) 1)) (byScore))))) 
Twenty-three spaces are arranged in a line: the outer space on each side and the central space are a circular holes, the intervening spaces are vertically-oriented trenches. A stick is laid in each trench, and a stick is stuck into the ground in each end hole, one belonging to each player. They move their sticks toward the opposite end of the track and then go back to their starting point, according to the throw of four stick dice, with one flat and one convex side. The values of the throws are as follows: 4 convex sides up = 4, 3=0, 2=1, 1=0, 0=2. Players continue to throw and move until obtaining a result of 0. When the player passes the central hole, they remove the sticks from the trenches in which they land. If the player lands in the central hole, and throws a 0 on their next throw, they must then return to the space nearest to their home still containing a stick. If the player lands on the same place as the opponent, the opponent is sent back to the space nearest their home which still has a stick in it, thus eliminating this stick. The goal is to eliminate all of the sticks from the opponent's side of the board and then to land on the same space as the opponent's playing stick. If both players are in the end stage and trying to land on each other, and a player lands in the central space and then throws a 0, the game is a draw.
(game "Chukaray" (players 2) (equipment {(board (rectangle 1 25) {(track "Track1" {0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23} loop:True P1) (track "Track2" {23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0} loop:True P2)} use:Edge) (dice d:2 from:0 num:4) (piece "Stick" Each (move (from (from) level:(level)) (to (trackSite Move from:(from) steps:(mapEntry "Throw" (count Pips))) if:True (apply (and (if (is Enemy (who at:(to))) (if (= (if (= (who at:(to)) P1) (if (= (id "Stick" Neutral) (what at:1)) 1 (if (= (id "Stick" Neutral) (what at:2)) 2 (if (= (id "Stick" Neutral) (what at:3)) 3 (if (= (id "Stick" Neutral) (what at:4)) 4 (if (= (id "Stick" Neutral) (what at:5)) 5 (if (= (id "Stick" Neutral) (what at:6)) 6 (if (= (id "Stick" Neutral) (what at:7)) 7 (if (= (id "Stick" Neutral) (what at:8)) 8 (if (= (id "Stick" Neutral) (what at:9)) 9 (if (= (id "Stick" Neutral) (what at:10)) 10 (if (= (id "Stick" Neutral) (what at:11)) 11 -1))))))))))) (if (= (id "Stick" Neutral) (what at:22)) 22 (if (= (id "Stick" Neutral) (what at:21)) 21 (if (= (id "Stick" Neutral) (what at:20)) 20 (if (= (id "Stick" Neutral) (what at:19)) 19 (if (= (id "Stick" Neutral) (what at:18)) 18 (if (= (id "Stick" Neutral) (what at:17)) 17 (if (= (id "Stick" Neutral) (what at:16)) 16 (if (= (id "Stick" Neutral) (what at:15)) 15 (if (= (id "Stick" Neutral) (what at:14)) 14 (if (= (id "Stick" Neutral) (what at:13)) 13 (if (= (id "Stick" Neutral) (what at:12)) 12 -1)))))))))))) -1) (remove (to)) (fromTo (from (to)) (to (if (= (who at:(to)) P1) (if (= (id "Stick" Neutral) (what at:1)) 1 (if (= (id "Stick" Neutral) (what at:2)) 2 (if (= (id "Stick" Neutral) (what at:3)) 3 (if (= (id "Stick" Neutral) (what at:4)) 4 (if (= (id "Stick" Neutral) (what at:5)) 5 (if (= (id "Stick" Neutral) (what at:6)) 6 (if (= (id "Stick" Neutral) (what at:7)) 7 (if (= (id "Stick" Neutral) (what at:8)) 8 (if (= (id "Stick" Neutral) (what at:9)) 9 (if (= (id "Stick" Neutral) (what at:10)) 10 (if (= (id "Stick" Neutral) (what at:11)) 11 -1))))))))))) (if (= (id "Stick" Neutral) (what at:22)) 22 (if (= (id "Stick" Neutral) (what at:21)) 21 (if (= (id "Stick" Neutral) (what at:20)) 20 (if (= (id "Stick" Neutral) (what at:19)) 19 (if (= (id "Stick" Neutral) (what at:18)) 18 (if (= (id "Stick" Neutral) (what at:17)) 17 (if (= (id "Stick" Neutral) (what at:16)) 16 (if (= (id "Stick" Neutral) (what at:15)) 15 (if (= (id "Stick" Neutral) (what at:14)) 14 (if (= (id "Stick" Neutral) (what at:13)) 13 (if (= (id "Stick" Neutral) (what at:12)) 12 -1)))))))))))))))) (if (and {(is Occupied (to)) (= (what at:(to) level:0) (id "Stick" Neutral)) (is In (to) (sites Next "Side"))}) (remove (to) level:0))))))) (piece "Stick" Neutral) (map "Throw" {(pair 0 2) (pair 1 0) (pair 2 1) (pair 3 0) (pair 4 4)}) (regions "Side" P1 (sites {0 1 2 3 4 5 6 7 8 9 10 11})) (regions "Side" P2 (sites {13 14 15 16 17 18 19 20 21 22 23}))}) (rules (start {(place Stack "Stick1" 0) (place Stack "Stick2" 23) (place Stack "Stick0" (sites {1 2 3 4 5 6 7 8 9 10 11 13 14 15 16 17 18 19 20 21 22}))}) (play (do (roll) next:(if (!= 0 (mapEntry "Throw" (count Pips))) (forEach Piece) (if (= 12 (where "Stick" Mover)) (if (!= (if (= (mover) P1) (if (= (id "Stick" Neutral) (what at:1)) 1 (if (= (id "Stick" Neutral) (what at:2)) 2 (if (= (id "Stick" Neutral) (what at:3)) 3 (if (= (id "Stick" Neutral) (what at:4)) 4 (if (= (id "Stick" Neutral) (what at:5)) 5 (if (= (id "Stick" Neutral) (what at:6)) 6 (if (= (id "Stick" Neutral) (what at:7)) 7 (if (= (id "Stick" Neutral) (what at:8)) 8 (if (= (id "Stick" Neutral) (what at:9)) 9 (if (= (id "Stick" Neutral) (what at:10)) 10 (if (= (id "Stick" Neutral) (what at:11)) 11 -1))))))))))) (if (= (id "Stick" Neutral) (what at:22)) 22 (if (= (id "Stick" Neutral) (what at:21)) 21 (if (= (id "Stick" Neutral) (what at:20)) 20 (if (= (id "Stick" Neutral) (what at:19)) 19 (if (= (id "Stick" Neutral) (what at:18)) 18 (if (= (id "Stick" Neutral) (what at:17)) 17 (if (= (id "Stick" Neutral) (what at:16)) 16 (if (= (id "Stick" Neutral) (what at:15)) 15 (if (= (id "Stick" Neutral) (what at:14)) 14 (if (= (id "Stick" Neutral) (what at:13)) 13 (if (= (id "Stick" Neutral) (what at:12)) 12 -1)))))))))))) -1) (move (from (where "Stick" Mover)) (to (if (= (mover) P1) (if (= (id "Stick" Neutral) (what at:1)) 1 (if (= (id "Stick" Neutral) (what at:2)) 2 (if (= (id "Stick" Neutral) (what at:3)) 3 (if (= (id "Stick" Neutral) (what at:4)) 4 (if (= (id "Stick" Neutral) (what at:5)) 5 (if (= (id "Stick" Neutral) (what at:6)) 6 (if (= (id "Stick" Neutral) (what at:7)) 7 (if (= (id "Stick" Neutral) (what at:8)) 8 (if (= (id "Stick" Neutral) (what at:9)) 9 (if (= (id "Stick" Neutral) (what at:10)) 10 (if (= (id "Stick" Neutral) (what at:11)) 11 -1))))))))))) (if (= (id "Stick" Neutral) (what at:22)) 22 (if (= (id "Stick" Neutral) (what at:21)) 21 (if (= (id "Stick" Neutral) (what at:20)) 20 (if (= (id "Stick" Neutral) (what at:19)) 19 (if (= (id "Stick" Neutral) (what at:18)) 18 (if (= (id "Stick" Neutral) (what at:17)) 17 (if (= (id "Stick" Neutral) (what at:16)) 16 (if (= (id "Stick" Neutral) (what at:15)) 15 (if (= (id "Stick" Neutral) (what at:14)) 14 (if (= (id "Stick" Neutral) (what at:13)) 13 (if (= (id "Stick" Neutral) (what at:12)) 12 -1)))))))))))))) (if (and (= (if (= (mover) P1) (if (= (id "Stick" Neutral) (what at:1)) 1 (if (= (id "Stick" Neutral) (what at:2)) 2 (if (= (id "Stick" Neutral) (what at:3)) 3 (if (= (id "Stick" Neutral) (what at:4)) 4 (if (= (id "Stick" Neutral) (what at:5)) 5 (if (= (id "Stick" Neutral) (what at:6)) 6 (if (= (id "Stick" Neutral) (what at:7)) 7 (if (= (id "Stick" Neutral) (what at:8)) 8 (if (= (id "Stick" Neutral) (what at:9)) 9 (if (= (id "Stick" Neutral) (what at:10)) 10 (if (= (id "Stick" Neutral) (what at:11)) 11 -1))))))))))) (if (= (id "Stick" Neutral) (what at:22)) 22 (if (= (id "Stick" Neutral) (what at:21)) 21 (if (= (id "Stick" Neutral) (what at:20)) 20 (if (= (id "Stick" Neutral) (what at:19)) 19 (if (= (id "Stick" Neutral) (what at:18)) 18 (if (= (id "Stick" Neutral) (what at:17)) 17 (if (= (id "Stick" Neutral) (what at:16)) 16 (if (= (id "Stick" Neutral) (what at:15)) 15 (if (= (id "Stick" Neutral) (what at:14)) 14 (if (= (id "Stick" Neutral) (what at:13)) 13 (if (= (id "Stick" Neutral) (what at:12)) 12 -1)))))))))))) -1) (= (if (= (next) P1) (if (= (id "Stick" Neutral) (what at:1)) 1 (if (= (id "Stick" Neutral) (what at:2)) 2 (if (= (id "Stick" Neutral) (what at:3)) 3 (if (= (id "Stick" Neutral) (what at:4)) 4 (if (= (id "Stick" Neutral) (what at:5)) 5 (if (= (id "Stick" Neutral) (what at:6)) 6 (if (= (id "Stick" Neutral) (what at:7)) 7 (if (= (id "Stick" Neutral) (what at:8)) 8 (if (= (id "Stick" Neutral) (what at:9)) 9 (if (= (id "Stick" Neutral) (what at:10)) 10 (if (= (id "Stick" Neutral) (what at:11)) 11 -1))))))))))) (if (= (id "Stick" Neutral) (what at:22)) 22 (if (= (id "Stick" Neutral) (what at:21)) 21 (if (= (id "Stick" Neutral) (what at:20)) 20 (if (= (id "Stick" Neutral) (what at:19)) 19 (if (= (id "Stick" Neutral) (what at:18)) 18 (if (= (id "Stick" Neutral) (what at:17)) 17 (if (= (id "Stick" Neutral) (what at:16)) 16 (if (= (id "Stick" Neutral) (what at:15)) 15 (if (= (id "Stick" Neutral) (what at:14)) 14 (if (= (id "Stick" Neutral) (what at:13)) 13 (if (= (id "Stick" Neutral) (what at:12)) 12 -1)))))))))))) -1)) (move Pass (then (trigger "Draw" Mover))))))) (then (if (!= 0 (mapEntry "Throw" (count Pips))) (moveAgain))))) (end {(if (no Pieces Next) (result Next Loss)) (if (is Triggered "Draw" Mover) (result Mover Draw))}))) 
Each stone must move to any adjacent(orthogonal or diagonal) cell, which is occupied by an enemy stone. This stone is captured by replacement. After that, all adjacent enemy stones (orthogonal or diagonal) are converted to friendly ones. There are fewer and fewer stones on the board as the game proceeds, which is a major difference with Othello and Ataxx. The player which has more stones, after there is no valid move left, wins the game.
(game "Crusade" (players 2) (equipment {(board (square 8)) (piece "Ball" Each (move Step (to if:(is Enemy (who at:(to))) (apply (remove (to)))) (then (forEach Site (sites Around (last To)) (if (is Enemy (who at:(site))) (and (remove (site)) (add (piece (id "Ball" Mover)) (to (site)))))))))}) (rules (start {(place "Ball1" (sites Phase 1)) (place "Ball2" (sites Phase 0))}) (play (forEach Piece)) (end (if (no Moves Next) (byScore {(score P1 (count Pieces P1)) (score P2 (count Pieces P2))}))))) 
Three-row board, outer rows with sixteen holes and the central with seventeen. Sixteen pieces per player, which start the board in each of the holes in the outer row belonging to a player. Two four-sided dice, marked 2-4 and "A" for 1. The throw of double 1s gives the player an extra throw. Players move their pieces according to the throws of the dice, moving one piece the value of one of the dice and another the value of the other die, or one piece the value of both dice. A piece cannot be moved until it is "activated" with a throw of 1. When a piece is activated, it is rotated 90 degrees and moved one space. One player moves from left to right in their row into the central row, moving right to left down it and when reaching the end of the central row, proceed into the opponent's row, and move from left to right in it, returning to the central row upon reaching the end. The opponent follows the same track, except moving from right to left in their row. Opponent's pieces are taken when a player's piece lands in the same spot as the opponent's piece. When in the opponent's row, the player my captured as many pieces of the opponent as hypothetically allowed by the dice. Players may not move one of their pieces past one of their other pieces. The player who captures all of the opponent's pieces wins. 
(game "Daldos" (players 2) (equipment {(board (merge {(rectangle 1 16) (shift -1 1 (rectangle 1 17)) (shift 0 2 (rectangle 1 16))}) {(track "Track1" {0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16} loop:True P1) (track "Track2" {33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16} loop:True P2)} use:Vertex) (regions "AllSites" (sites Board)) (dice d:4 num:2) (piece "Minus" P1 (if (or (= (state at:(from)) 1) (and (= (state at:(from)) 0) (= 1 (pips)))) (move Slide "Track1" (between (exact (pips)) if:(is Empty (between))) (to if:(is Enemy (who at:(to))) (apply if:(not (is Friend (who at:(to)))) (remove (to)))) (then (if (= (state at:(last To)) 0) (set State at:(last To) 1)))))) (piece "Minus" P2 (if (or (= (state at:(from)) 1) (and (= (state at:(from)) 0) (= 1 (pips)))) (move Slide "Track2" (between (exact (pips)) if:(is Empty (between))) (to if:(is Enemy (who at:(to))) (apply if:(not (is Friend (who at:(to)))) (remove (to)))) (then (if (= (state at:(last To)) 0) (set State at:(last To) 1))))))}) (rules (start {(place "Minus1" (sites Bottom)) (place "Minus2" (sites Top))}) (play (do (if (not (is Prev Mover)) (roll)) next:(forEach Die replayDouble:(and (= (face 36) 1) (= (face 37) 1)) (forEach Piece (then (if (not (all DiceUsed)) (if (can Move (forEach Die (forEach Piece))) (moveAgain)))))))) (end (if (no Pieces Next) (result Next Loss))))) 
3x12 board, with the outer rows of holes slightly curved to form the appearance of an arc. Twelve pieces per player, which start on the board in each of the holes in the outer row belonging to a player. Two four-sided dice, marked 2-4 and "X" for 1. The throw of double 1s gives the player an extra throw. Players move their pieces according to the throws of the dice, moving one piece the value of one of the dice and another the value of the other die, or one piece the value of both dice. A piece cannot be moved until it is "activated" with a throw of 1. When a piece is activated, it is rotated 90 degrees and moved one space. One player moves from left to right in their row into the central row, moving right to left down it and when reaching the end of the central row, proceed into the opponent's row, and move from left to right in it, returning to the central row upon reaching the end. The opponent follows the same track, except moving from right to left in their row. Opponent's pieces are taken when a player's piece lands in the same spot as the opponent's piece. When in the opponent's row, the player may capture as many pieces of the opponent as hypothetically allowed by the dice. Players may not move one of their pieces past one of their other pieces. The player who captures all of the opponent's pieces wins. 
(game "Daldosa" (players 2) (equipment {(board (add (merge {(rectangle 1 8) (shift -4 1.5 (rectangle 1 12)) (shift 0 3 (rectangle 1 8))}) vertices:{{-1 0.1} {-2 0.3} {-2.9 0.5} {-3.6 0.8} {-1 2.9} {-2 2.7} {-2.9 2.5} {-3.6 2.2}}) {(track "Track1" {31 30 29 28 0 1 2 3 4 5 6 7 19 18 17 16 15 14 13 12 11 10 9 8 35 34 33 32 20 21 22 23 24 25 26 27 19 18 17 16 15 14 13 12 11 10 9 8} loop:True P1) (track "Track2" {35 34 33 32 20 21 22 23 24 25 26 27 19 18 17 16 15 14 13 12 11 10 9 8 31 30 29 28 0 1 2 3 4 5 6 7 19 18 17 16 15 14 13 12 11 10 9 8} loop:True P2)} use:Vertex) (regions "AllSites" (sites Board)) (dice d:4 num:2) (piece "Minus" P1 (if (or (= (state at:(from)) 1) (and (= (state at:(from)) 0) (= 1 (pips)))) (move Slide "Track1" (between (exact (pips)) if:(is Empty (between))) (to if:(is Enemy (who at:(to))) (apply if:(not (is Friend (who at:(to)))) (remove (to)))) (then (if (= (state at:(last To)) 0) (set State at:(last To) 1)))))) (piece "Minus" P2 (if (or (= (state at:(from)) 1) (and (= (state at:(from)) 0) (= 1 (pips)))) (move Slide "Track2" (between (exact (pips)) if:(is Empty (between))) (to if:(is Enemy (who at:(to))) (apply if:(not (is Friend (who at:(to)))) (remove (to)))) (then (if (= (state at:(last To)) 0) (set State at:(last To) 1))))))}) (rules (start {(place "Minus1" (sites {0 1 2 3 4 5 6 7 28 29 30 31})) (place "Minus2" (sites {20 21 22 23 24 25 26 27 32 33 34 35}))}) (play (do (if (not (is Prev Mover)) (roll)) next:(forEach Die replayDouble:(and (= (face 36) 1) (= (face 37) 1)) (forEach Piece (then (if (not (all DiceUsed)) (if (can Move (forEach Die (forEach Piece))) (moveAgain)))))))) (end (if (no Pieces Next) (result Next Loss))))) 
Board of intersecting lines: four horizontal and up to 100 vertical. Twenty is typical. Played on two teams with even-numbered players. One piece per vertical line, lined up on the outer rows. Four sticks, white on one side and black on the other, used as dice. The value of the throw is the number of white sides that land face up, when only black are face up, the value is 6. Each player must progress through the following three stages of throws to begin playing. In the first stage, they throw four sticks. A throw of 2 or 3 ends the turn, a throw of 4 or 6 gives another throw. A throw of 1 allows the player to progress to the next stage and to add 1 to their score. In the second stage, the player throws three sticks. If the player throws two or three black, they add 1 to their score and keep throwing, three white up allows the player to add 4 to their score and keep playing; one black face up allows the player to pass to the third stage. In the third stage, the player throws two sticks. If two black are thrown, all of the previously tabulated score is lost, the turn ends and the player must start again from the first stage in their next turn. If the player throws two white, the player scores 4 and reverts back to the second phase. When the player scores one white and one black, the player enters the game and plays the pieces according to their accumulated score. Each piece must be unlocked with a throw of 1 before being moved normally. From this point, players throw all four sticks. Throws of 2 or 3 end the turn, players continue to throw until they receive one of these values. Each throw must be assigned to move a piece and a single throw cannot be subdivided, though separate throws can be assigned to different pieces. Players may choose not to play a throw if they wish. Throws of 1 must be used to unlock a piece if there are any which are locked. Pieces move from left to right in their home row, right to left in the second row, left to right in the third row, right to left in their opponent's home row, returning to the third row and progressing from left to right, then to the second row progressing from right to left, and then back into the home row, proceeding from left to right, and so in a loop. Pieces may not pass the pieces of the opposing team. When a piece lands on the same space occupied by an opponent's piece, the opponent's piece is removed from the board. The team that captures all the pieces of the opposing team wins. The board has 20 columns.
(game "Deleb" (players 4) (equipment {(board (rectangle 4 20) {(track "Track1" "0,E,N1,W,N1,E,N1,W,S1,E,S1,W" loop:True P1) (track "Track2" "79,W,S1,E,S1,W,S1,E,N1,W,N1,E" loop:True P2) (track "Track3" "0,E,N1,W,N1,E,N1,W,S1,E,S1,W" loop:True P3) (track "Track4" "79,W,S1,E,S1,W,S1,E,N1,W,N1,E" loop:True P3)} use:Vertex) (dice d:2 from:0 num:4) (piece "Marker" P1 (move (from (from) if:(or (= (mapEntry "Throw" (count Pips)) 1) (= 1 (state at:(from))))) (to (trackSite Move from:(from) steps:(mapEntry "Throw" (count Pips))) if:(and (not (is Friend (who at:(to)))) (or (= 1 (mapEntry "Throw" (count Pips))) (= 0 (count Sites in:(intersection (sites Occupied by:Enemy) (sites Track Mover from:(trackSite Move from:(from) steps:1) to:(trackSite Move from:(from) steps:(- (mapEntry "Throw" (count Pips)) 1)))))))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (if (not (= 1 (state at:(last To)))) (set State at:(last To) 1))))) (piece "Marker" P2 (move (from (from) if:(or (= (mapEntry "Throw" (count Pips)) 1) (= 1 (state at:(from))))) (to (trackSite Move from:(from) steps:(mapEntry "Throw" (count Pips))) if:(and (not (is Friend (who at:(to)))) (or (= 1 (mapEntry "Throw" (count Pips))) (= 0 (count Sites in:(intersection (sites Occupied by:Enemy) (sites Track Mover from:(trackSite Move from:(from) steps:1) to:(trackSite Move from:(from) steps:(- (mapEntry "Throw" (count Pips)) 1)))))))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (if (not (= 1 (state at:(last To)))) (set State at:(last To) 1))))) (map "Throw" {(pair 0 6) (pair 1 1) (pair 2 2) (pair 3 3) (pair 4 4)})}) (rules (start {(set Team 1 {P1 P3}) (set Team 2 {P2 P4}) (place "Marker1" (sites Bottom)) (place "Marker2" (sites Top))}) phases:{(phase "StageOne" (play (do (roll) next:(move Pass) (then (if (or (= (mapEntry "Throw" (count Pips)) 6) (= (mapEntry "Throw" (count Pips)) 4)) (moveAgain) (if (= (mapEntry "Throw" (count Pips)) 1) (if (is Mover P1) (remember Value "ScoreP1" 1) (if (is Mover P2) (remember Value "ScoreP2" 1) (if (is Mover P3) (remember Value "ScoreP3" 1) (remember Value "ScoreP4" 1))))))))) (nextPhase Mover (= (mapEntry "Throw" (count Pips)) 1) "StageTwo")) (phase "StageTwo" (play (do (roll) next:(move Pass) (then (if (or (= 0 (+ (+ (face 80) (face 81)) (face 82))) (= 1 (+ (+ (face 80) (face 81)) (face 82)))) (and (moveAgain) (if (is Mover P1) (remember Value "ScoreP1" 1) (if (is Mover P2) (remember Value "ScoreP2" 1) (if (is Mover P3) (remember Value "ScoreP3" 1) (remember Value "ScoreP4" 1))))) (if (= 3 (+ (+ (face 80) (face 81)) (face 82))) (and (moveAgain) (if (is Mover P1) (remember Value "ScoreP1" 4) (if (is Mover P2) (remember Value "ScoreP2" 4) (if (is Mover P3) (remember Value "ScoreP3" 4) (remember Value "ScoreP4" 4)))))))))) (nextPhase Mover (= (+ (+ (face 80) (face 81)) (face 82)) 2) "StageThree")) (phase "StageThree" (play (do (roll) next:(move Pass) (then (if (= 0 (+ (face 80) (face 81))) (if (is Mover P1) (forget Value "ScoreP1" All) (if (is Mover P2) (forget Value "ScoreP2" All) (if (is Mover P3) (forget Value "ScoreP3" All) (forget Value "ScoreP4" All)))) (if (= 1 (+ (face 80) (face 81))) (moveAgain) (and (moveAgain) (if (is Mover P1) (remember Value "ScoreP1" 4) (if (is Mover P2) (remember Value "ScoreP2" 4) (if (is Mover P3) (remember Value "ScoreP3" 4) (remember Value "ScoreP4" 4)))))))))) {(nextPhase Mover (= 0 (+ (face 80) (face 81))) "StageOne") (nextPhase Mover (= 2 (+ (face 80) (face 81))) "StageTwo") (nextPhase Mover (= 1 (+ (face 80) (face 81))) "PlayingScore")}) (phase "PlayingScore" (play (if (can Move (if (or (is Mover P1) (is Mover P3)) (forEach Piece (forEach Value (if (is Mover P1) (values Remembered "ScoreP1") (if (is Mover P2) (values Remembered "ScoreP2") (if (is Mover P3) (values Remembered "ScoreP3") (values Remembered "ScoreP4")))) (move (from (from) if:(or (= (value) 1) (= 1 (state at:(from))))) (to (trackSite Move from:(from) steps:(value)) if:(and (not (is Friend (who at:(to)))) (or (= 1 (value)) (= 0 (count Sites in:(intersection (sites Occupied by:Enemy) (sites Track Mover from:(trackSite Move from:(from) steps:1) to:(trackSite Move from:(from) steps:(- (value) 1)))))))) (apply (and (if (is Mover P1) (forget Value "ScoreP1" (value)) (if (is Mover P2) (forget Value "ScoreP2" (value)) (if (is Mover P3) (forget Value "ScoreP3" (value)) (forget Value "ScoreP4" (value))))) (if (is Enemy (who at:(to))) (remove (to)))))) (then (if (not (= 1 (state at:(last To)))) (set State at:(last To) 1))))) P1) (forEach Piece (forEach Value (if (is Mover P1) (values Remembered "ScoreP1") (if (is Mover P2) (values Remembered "ScoreP2") (if (is Mover P3) (values Remembered "ScoreP3") (values Remembered "ScoreP4")))) (move (from (from) if:(or (= (value) 1) (= 1 (state at:(from))))) (to (trackSite Move from:(from) steps:(value)) if:(and (not (is Friend (who at:(to)))) (or (= 1 (value)) (= 0 (count Sites in:(intersection (sites Occupied by:Enemy) (sites Track Mover from:(trackSite Move from:(from) steps:1) to:(trackSite Move from:(from) steps:(- (value) 1)))))))) (apply (and (if (is Mover P1) (forget Value "ScoreP1" (value)) (if (is Mover P2) (forget Value "ScoreP2" (value)) (if (is Mover P3) (forget Value "ScoreP3" (value)) (forget Value "ScoreP4" (value))))) (if (is Enemy (who at:(to))) (remove (to)))))) (then (if (not (= 1 (state at:(last To)))) (set State at:(last To) 1))))) P2))) (if (or (is Mover P1) (is Mover P3)) (forEach Piece (forEach Value (if (is Mover P1) (values Remembered "ScoreP1") (if (is Mover P2) (values Remembered "ScoreP2") (if (is Mover P3) (values Remembered "ScoreP3") (values Remembered "ScoreP4")))) (move (from (from) if:(or (= (value) 1) (= 1 (state at:(from))))) (to (trackSite Move from:(from) steps:(value)) if:(and (not (is Friend (who at:(to)))) (or (= 1 (value)) (= 0 (count Sites in:(intersection (sites Occupied by:Enemy) (sites Track Mover from:(trackSite Move from:(from) steps:1) to:(trackSite Move from:(from) steps:(- (value) 1)))))))) (apply (and (if (is Mover P1) (forget Value "ScoreP1" (value)) (if (is Mover P2) (forget Value "ScoreP2" (value)) (if (is Mover P3) (forget Value "ScoreP3" (value)) (forget Value "ScoreP4" (value))))) (if (is Enemy (who at:(to))) (remove (to)))))) (then (if (not (= 1 (state at:(last To)))) (set State at:(last To) 1))))) P1) (forEach Piece (forEach Value (if (is Mover P1) (values Remembered "ScoreP1") (if (is Mover P2) (values Remembered "ScoreP2") (if (is Mover P3) (values Remembered "ScoreP3") (values Remembered "ScoreP4")))) (move (from (from) if:(or (= (value) 1) (= 1 (state at:(from))))) (to (trackSite Move from:(from) steps:(value)) if:(and (not (is Friend (who at:(to)))) (or (= 1 (value)) (= 0 (count Sites in:(intersection (sites Occupied by:Enemy) (sites Track Mover from:(trackSite Move from:(from) steps:1) to:(trackSite Move from:(from) steps:(- (value) 1)))))))) (apply (and (if (is Mover P1) (forget Value "ScoreP1" (value)) (if (is Mover P2) (forget Value "ScoreP2" (value)) (if (is Mover P3) (forget Value "ScoreP3" (value)) (forget Value "ScoreP4" (value))))) (if (is Enemy (who at:(to))) (remove (to)))))) (then (if (not (= 1 (state at:(last To)))) (set State at:(last To) 1))))) P2)) (move Pass (then (if (is Mover P1) (forget Value "ScoreP1" All) (if (is Mover P2) (forget Value "ScoreP2" All) (if (is Mover P3) (forget Value "ScoreP3" All) (forget Value "ScoreP4" All)))))) (then (if (!= 0 (size Array (if (is Mover P1) (values Remembered "ScoreP1") (if (is Mover P2) (values Remembered "ScoreP2") (if (is Mover P3) (values Remembered "ScoreP3") (values Remembered "ScoreP4")))))) (moveAgain))))) (nextPhase Mover (= 0 (size Array (if (is Mover P1) (values Remembered "ScoreP1") (if (is Mover P2) (values Remembered "ScoreP2") (if (is Mover P3) (values Remembered "ScoreP3") (values Remembered "ScoreP4")))))) "Playing")) (phase "Playing" (play (do (roll) next:(or (if (or (is Mover P1) (is Mover P3)) (forEach Piece P1) (forEach Piece P2)) (move Pass)) (then (if (and (!= 2 (mapEntry "Throw" (count Pips))) (!= 3 (mapEntry "Throw" (count Pips)))) (moveAgain))))))} (end (if (no Pieces Enemy) (result TeamMover Win))))) 
MOVE - On each turn, a player may do one of the following actions: - Drop a friendly stone at an empty cell, which is in a diagonal line of sight with another friendly stone, i.e., both stones must be separated by a diagonal line of empty cells. - Transform an enemy stone, at a diagonal line of sight of a friendly stone, into a wall (which is a neutral stone). GOAL - When there are no valid moves, wins the player with more friendly stones.
(game "Diagonals (2002)" (players 2) (equipment {(board (rectangle 5 10) use:Vertex) (piece "Ball" Each) (piece "Ball" Neutral)}) (rules (start {(place "Ball1" (intersection (expand (sites Bottom)) (sites Right))) (place "Ball2" (intersection (expand (sites Top)) (sites Left)))}) (play (or (move Add (to (intersection (sites Direction from:(sites Occupied by:Mover) Diagonal stop:(is Occupied (to))) (sites Empty)))) (move Select (from (forEach (sites Occupied by:Next) if:(!= 0 (count Sites in:(intersection (sites LineOfSight at:(site) Diagonal) (sites Occupied by:Mover)))))) (then (and (remove (last To)) (add (piece (id "Ball" Neutral)) (to (last To)))))))) (end (if (and (no Moves P1) (no Moves P2)) (byScore {(score P1 (count Pieces P1)) (score P2 (count Pieces P2))}))))) 
7x7 board, with diagonals in the square formed by the central 3x3 lines. 24 pieces per player. Black plays first. Players alternate turns placing a piece on one of the empty spots on the board. The first stone must be placed in the central spot. They attempt to orthogonally surround an empty point with four of their pieces, making a square. When all of the pieces are placed, players alternate turns removing one of their opponent's pieces from the board. They then move one of their pieces along the lines of the board to the place left vacant by the piece they removed. When a player makes a new square, they may remove another of the opponent's pieces from the board. Pieces that are in a square around an empty point may not be captured, and captures are not made in the placement phase. The player who captures all of the opponent's pieces wins.
(game "Fang" (players 2) (equipment {(board (add (square 7) edges:{{16 24} {24 32} {30 24} {24 18}}) use:Vertex) (piece "Marker" Each (move Step (to if:(is Empty (to))) (then (if (> (count Sites in:(forEach (sites Around (last To)) if:(if (is Empty (site)) (or (and {(is In (last To) (sites {(ahead (site) N) (ahead (site) S) (ahead (site) W) (ahead (site) E)})) (is Mover (who at:(ahead (site) N))) (is Mover (who at:(ahead (site) S))) (is Mover (who at:(ahead (site) W))) (is Mover (who at:(ahead (site) E)))}) (and {(is In (last To) (sites {(ahead (site) NE) (ahead (site) SE) (ahead (site) SW) (ahead (site) NW)})) (is Mover (who at:(ahead (site) NE))) (is Mover (who at:(ahead (site) SE))) (is Mover (who at:(ahead (site) SW))) (is Mover (who at:(ahead (site) NW)))}))))) 0) (and (set Value Mover (count Sites in:(forEach (sites Around (last To)) if:(if (is Empty (site)) (or (and {(is In (last To) (sites {(ahead (site) N) (ahead (site) S) (ahead (site) W) (ahead (site) E)})) (is Mover (who at:(ahead (site) N))) (is Mover (who at:(ahead (site) S))) (is Mover (who at:(ahead (site) W))) (is Mover (who at:(ahead (site) E)))}) (and {(is In (last To) (sites {(ahead (site) NE) (ahead (site) SE) (ahead (site) SW) (ahead (site) NW)})) (is Mover (who at:(ahead (site) NE))) (is Mover (who at:(ahead (site) SE))) (is Mover (who at:(ahead (site) SW))) (is Mover (who at:(ahead (site) NW)))})))))) (moveAgain)))))) (hand Each)}) (rules (start (place "Marker" "Hand" count:24)) phases:{(phase "FirstPlacement" P1 (play (move (from (handSite Mover)) (to (sites Centre)))) (nextPhase "Placement")) (phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Playing")) (phase "Playing" (play (if (is Prev Mover) (move Remove (sites Occupied by:Next) (then (if (> (value Player Mover) 1) (and (moveAgain) (set Value Mover (- (value Player Mover) 1))) (set Value Mover 0)))) (forEach Piece))))} (end (if (no Pieces Next) (result Next Loss))))) 
TURN - On each turn, each player slides (orthogonally or diagonally) a stone until it hits another stone or a wall. If it stops because of a stone, the moving stone and all adjacent stones (of either color) are removed. GOAL - The player with no stones onboard loses. The game is a draw if (i) the board becomes empty, or (ii) each player has just one stone, or (iii) the moving player has no valid moves.
(game "Fission" (players 2) (equipment {(board (square 8)) (piece "Ball" Each (move (from (from)) (to (sites LineOfSight Farthest at:(from)) if:(not (is In (to) (sites Around (from))))) (then (if (!= (ahead (last To) (directions Cell from:(last From) to:(last To))) (last To)) (remove (sites Around (last To) includeSelf:True))))))}) (rules (start {(place "Ball1" (intersection (sites Phase 1) (expand (sites Centre) steps:2 Orthogonal))) (place "Ball2" (intersection (sites Phase 0) (expand (sites Centre) steps:2 Orthogonal)))}) (play (forEach Piece)) (end {(if (and (not (no Pieces Mover)) (no Pieces Next)) (result Mover Win)) (if (or (no Moves Next) (and (= 1 (count Pieces P1)) (= 1 (count Pieces P2)))) (result Mover Draw))}))) 
Four players. Played with two six-sided dice. A throw of 5 is counted as 1, a throw of 6 is counted as 4.Throws move the pieces as follows: 1: Pawn or King, which move the same as in Shatranj; 2: Rook, which jumps to the second diagonal space; 3: Horse, which moves orthogonally one space and then diagonally another space, jumping over any intervening pieces; 4: Elephant, which moves orthogonally any distance. Kings may be captured. Pieces are assigned values, which award the players stakes at the end of the game: King=5, Elephant=4, Horse=3, Rook=2, Pawn=1. If a player captures all of the other Kings and is still in possession of their own King, the score awarded is 54. The player with the most points wins.
(game "Four-Player Chaturanga (al-Biruni)" (players {(player N) (player W) (player S) (player E)}) (equipment {(board (square 8)) (dice d:6 from:1 num:2) (piece "Pawn" Each (or (move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (if (is Occupied (to)) (and {(if (is In (to) (sites {(where "King" P1) (where "King" P2) (where "King" P3) (where "King" P4)})) (set Value Mover (+ (value Player Mover) 1))) (if (and (!= -1 (where "King" Mover)) (= (value Player Mover) 1)) (addScore Mover 54)) (addScore Mover (value Piece at:(to))) (remove (to))}))))))) (piece "Rook" Each (move Hop Diagonal (to if:(not (is Friend (who at:(to)))) (apply (if (is Occupied (to)) (and {(if (is In (to) (sites {(where "King" P1) (where "King" P2) (where "King" P3) (where "King" P4)})) (set Value Mover (+ (value Player Mover) 1))) (if (and (!= -1 (where "King" Mover)) (= (value Player Mover) 1)) (addScore Mover 54)) (addScore Mover (value Piece at:(to))) (remove (to))})))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Occupied (to)) (and {(if (is In (to) (sites {(where "King" P1) (where "King" P2) (where "King" P3) (where "King" P4)})) (set Value Mover (+ (value Player Mover) 1))) (if (and (!= -1 (where "King" Mover)) (= (value Player Mover) 1)) (addScore Mover 54)) (addScore Mover (value Piece at:(to))) (remove (to))})))))) (piece "Elephant" Each (move Slide Orthogonal (between if:(is Empty (between))) (to if:(is Enemy (who at:(to))) (apply (if (is Occupied (to)) (and {(if (is In (to) (sites {(where "King" P1) (where "King" P2) (where "King" P3) (where "King" P4)})) (set Value Mover (+ (value Player Mover) 1))) (if (and (!= -1 (where "King" Mover)) (= (value Player Mover) 1)) (addScore Mover 54)) (addScore Mover (value Piece at:(to))) (remove (to))})))))) (piece "King_noCross" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Occupied (to)) (and {(if (is In (to) (sites {(where "King" P1) (where "King" P2) (where "King" P3) (where "King" P4)})) (set Value Mover (+ (value Player Mover) 1))) (if (and (!= -1 (where "King" Mover)) (= (value Player Mover) 1)) (addScore Mover 54)) (addScore Mover (value Piece at:(to))) (remove (to))})))))) (map "Throw" {(pair 1 1) (pair 2 2) (pair 3 3) (pair 4 4) (pair 5 1) (pair 6 4)})}) (rules (start {(place "Pawn1" {"A2" "B2" "C2" "D2"} value:1) (place "Pawn2" {"G1" "G2" "G3" "G4"} value:1) (place "Pawn3" {"H7" "G7" "E7" "F7"} value:1) (place "Pawn4" {"B5" "B6" "B7" "B8"} value:1) (place "Rook1" coord:"A1" value:2) (place "Rook2" coord:"H1" value:2) (place "Rook3" coord:"H8" value:2) (place "Rook4" coord:"A8" value:2) (place "Knight1" coord:"B1" value:3) (place "Knight2" coord:"H2" value:3) (place "Knight3" coord:"G8" value:3) (place "Knight4" coord:"A7" value:3) (place "Elephant1" coord:"C1" value:4) (place "Elephant2" coord:"H3" value:4) (place "Elephant3" coord:"F8" value:4) (place "Elephant4" coord:"A6" value:4) (place "King_noCross1" coord:"D1" value:5) (place "King_noCross2" coord:"H4" value:5) (place "King_noCross3" coord:"E8" value:5) (place "King_noCross4" coord:"A5" value:5)}) (play (do (if (not (is Prev Mover)) (roll)) next:(forEach Die (if (= (mapEntry "Throw" (pips)) 1) (or (forEach Piece "Pawn") (forEach Piece "King_noCross")) (if (= (mapEntry "Throw" (pips)) 4) (forEach Piece "Elephant") (if (= (mapEntry "Throw" (pips)) 3) (forEach Piece "Knight") (if (= (mapEntry "Throw" (pips)) 2) (forEach Piece "Rook")))))) (then (if (can Move (forEach Die (if (= (mapEntry "Throw" (pips)) 1) (or (forEach Piece "Pawn") (forEach Piece "King_noCross")) (if (= (mapEntry "Throw" (pips)) 4) (forEach Piece "Elephant") (if (= (mapEntry "Throw" (pips)) 3) (forEach Piece "Knight") (if (= (mapEntry "Throw" (pips)) 2) (forEach Piece "Rook"))))))) (moveAgain))))) (end (if (= (count Pieces Mover) (- (count Pieces All) 2)) (byScore))))) 
There are three red ships and three black ships. The remainder of the cells contain white icebergs. The two players, Red and Black, take turns moving one of their own ships, one move per turn, starting with Red. Players are not allowed to pass. MOVES: You must move one of your ships to an adjacent cell which doesn't contain another ship. By moving to a cell containing an iceberg, you capture the iceberg, and your score increases by 1. MOVE DIRECTION: You must select one of your ships to move, and move it closer to its closest iceberg. Distance is measured by the number of cells between ship and iceberg along the shortest path of cells that connects them, going around other ships. If the ship you've chosen to move has icebergs adjacent to it, you must capture one of them. OBJECT OF THE GAME: The goal is to capture the majority of the icebergs. On the default size 5 board, there are 55 icebergs starting out. If you capture 28 of them, you win. A size 5 board is currently selected
(game "Icebreaker" (players 2) (equipment {(board (hex 5)) (piece "Disc" Each (move Step (to if:(and (or (= (id Neutral) (who at:(to))) (is Empty (to))) (= 1 (- (count Steps (step (to if:(or (= (id Neutral) (who at:(to))) (is Empty (to))))) (from) (intersection (sites Occupied by:Neutral) (sites Distance (step (to if:(or (= (id Neutral) (who at:(to))) (is Empty (to))))) from:(from) (exact (count Steps (step (to if:(or (= (id Neutral) (who at:(to))) (is Empty (to))))) (from) (sites Occupied by:Neutral)))))) (count Steps (step (to if:(or (= (id Neutral) (who at:(to))) (is Empty (to))))) (to) (intersection (sites Occupied by:Neutral) (sites Distance (step (to if:(or (= (id Neutral) (who at:(to))) (is Empty (to))))) from:(from) (exact (count Steps (step (to if:(or (= (id Neutral) (who at:(to))) (is Empty (to))))) (from) (sites Occupied by:Neutral))))))))) (apply (if (is Occupied (to)) (and (remove (to)) (addScore Mover 1))))))) (piece "Disc" Neutral)}) (rules (start {(place "Disc0" (difference (sites Board) (sites Corners))) (place "Disc1" (sites Around (centrePoint) distance:(- 5 1) NNW)) (place "Disc1" (sites Around (centrePoint) distance:(- 5 1) E)) (place "Disc1" (sites Around (centrePoint) distance:(- 5 1) SSW)) (place "Disc2" (sites Around (centrePoint) distance:(- 5 1) NNE)) (place "Disc2" (sites Around (centrePoint) distance:(- 5 1) W)) (place "Disc2" (sites Around (centrePoint) distance:(- 5 1) SSE))}) (play (forEach Piece Mover)) (end (if (or (< (/ (- (count Sites in:(sites Board)) 6) 2) (score P1)) (< (/ (- (count Sites in:(sites Board)) 6) 2) (score P2))) (byScore))))) 
4x12 board. Twelve pieces per player, which begin one in each space in the row closest to the player. Six stick dice, green on one side and white on the other. The value of the throws equals the number of green faces, with the following exceptions: four green faces up allows a piece to be moved for the first time and a move of 1, plus another throw is granted; six white faces = 4 plus another throw; six green = 6 plus another throw; five white faces = move 5 plus another throw. Pieces move from right to left in the player's home row, then into the second row, moving left to right, then into the third row moving right to left, and then into the opponent's home row moving left to right, then back into the third row moving right to left, to the second row moving left to right, and then back into the player's home row moving right to left. If a player's piece lands on a space occupied by one of the opponent's pieces, the opponent's piece is captured. The player who captures all of the opponent's pieces wins.
(game "Issiren" (players 2) (equipment {(board (rectangle 4 12) {(track "Track1" "11,W,N1,E,N1,W,N1,E,S1,W,S1,E" loop:True P1) (track "Track2" "36,E,S1,W,S1,E,S1,W,N1,E,N1,W" loop:True P2)}) (dice d:2 from:0 num:6) (piece "Marker" Each (move (from (from) if:(if (= (state at:(from)) 0) True (= (mapEntry (count Pips)) 1))) (to (trackSite Move steps:(mapEntry (count Pips))) if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (if (= 1 (state at:(last To))) (set State at:(last To) 0))))) (map {(pair 0 4) (pair 1 5) (pair 2 2) (pair 3 3) (pair 4 1) (pair 5 5) (pair 6 6)})}) (rules (start {(place "Marker1" (sites Bottom) state:1) (place "Marker2" (sites Top) state:1)}) (play (do (roll) next:(forEach Piece) (then (if (and (is In (mapEntry (count Pips)) (sites {1 4 6 5})) (!= 5 (count Pips))) (moveAgain))))) (end (if (no Pieces Next) (result Next Loss))))) 
Played on a board similar to Surakarta, but smaller. Players begin with four pieces, arranged in the square of spaces in their bottom right corner. Players take turns moving a piece to one adjacent spot. To capture an opponent's piece, you must move along the curved loops. The spot at the immediate end of the loop must be empty, but the piece may continue as far as the player wishes, including moving along successive loops, or until they make a capture or are stopped by their own piece. The pieces are placed in the corners.
(game "Ja-Jeon-Geo-Gonu" (players 2) (equipment {(board (square 4) {(track "Track1" {14 14 11 10 9 8 8 13 9 5 1 1 4 5 6 7 7 2 6 10} loop:True directed:True) (track "Track2" {11 11 14 10 6 2 2 7 6 5 4 4 1 5 9 13 13 8 9 10} loop:True directed:True)} use:Vertex) (piece "Disc" Each (or {(move Step Orthogonal (to if:(is Empty (to)))) (move Slide "AllTracks" (between if:(or (= (between) (from)) (is Empty (between)))) (to if:(is Enemy (who at:(to))) (apply if:False (remove (to)))))}))}) (rules (start {(place "Disc1" {"A3" "B3" "A4" "B4"}) (place "Disc2" {"C1" "D1" "C2" "D2"})}) (play (forEach Piece)) (end (if (no Pieces Next) (result Next Loss))))) 
4x22 board. 22 pieces per player, four kings and eighteen regular pieces. Kings have no difference in movement or power than regular pieces. Moves are determined by four two-sided sticks, black on one side and white on the other. The moves are determined by the number of white sides that land face up: 1= a move of 1. A throw of 1 is known as "tab." 2= a move of 2, 3=2, 4=6, 0=4. Throws of 1, 4, and 6 grant the player an additional throw. To begin, a player must roll tab to move their first piece, and every tab after that must be used to move a piece which has not moved yet. Pieces move from left to right in the home row, then circulate in a clockwise direction in the central two rows. Multiple pieces cannot occupy the same space. When a player's piece lands on a space occupied by an opponent's piece, that piece is captured. The player to capture all of the opponent's pieces wins.
(game "Kioz" (players 2) (equipment {(board (rectangle 4 22) {(track "Track1" "0,E,N1,W," P1 directed:True) (track "Track2" "87,W,S1,E" P2 directed:True) (track "MiddleTrack" "44,E,S1,W" loop:True)}) (dice d:2 from:0 num:4) (piece "Marker" Each) (piece "King" Each) (map "Throw" {(pair 0 4) (pair 1 1) (pair 2 2) (pair 3 2) (pair 4 6)}) (regions "Home" P1 (sites Bottom)) (regions "Home" P2 (sites Top))}) (rules (start {(place "Marker1" (intersection (sites Bottom) (expand (sites Left) steps:17))) (place "King1" (intersection (sites Bottom) (expand (sites Right) steps:3))) (place "Marker2" (intersection (sites Top) (expand (sites Right) steps:17))) (place "King2" (intersection (sites Top) (expand (sites Left) steps:3)))}) (play (do (roll) next:(if (= 1 (mapEntry "Throw" (count Pips))) (priority {(forEach Piece (if (and {(if (!= 0 (state at:(from))) True (= 1 (mapEntry "Throw" (count Pips)))) (not (!= 0 (state at:(from))))}) (if (is In (from) (sites Mover "Home")) (if (not (is Friend (who at:(trackSite Move "Track" steps:(mapEntry "Throw" (count Pips)))))) (move (from) (to (trackSite Move "Track" steps:(mapEntry "Throw" (count Pips))) (apply if:(is Enemy (who at:(to))) (remove (to)))) (then (if (and (not (!= 0 (state at:(last To)))) (= 1 (mapEntry "Throw" (count Pips)))) (set State at:(last To) 1))))) (if (not (is Friend (who at:(trackSite Move "MiddleTrack" steps:(mapEntry "Throw" (count Pips)))))) (move (from) (to (trackSite Move "MiddleTrack" steps:(mapEntry "Throw" (count Pips))) (apply if:(is Enemy (who at:(to))) (remove (to))))))))) (forEach Piece (if (and {(if (!= 0 (state at:(from))) True (= 1 (mapEntry "Throw" (count Pips))))}) (if (is In (from) (sites Mover "Home")) (if (not (is Friend (who at:(trackSite Move "Track" steps:(mapEntry "Throw" (count Pips)))))) (move (from) (to (trackSite Move "Track" steps:(mapEntry "Throw" (count Pips))) (apply if:(is Enemy (who at:(to))) (remove (to)))) (then (if (and (not (!= 0 (state at:(last To)))) (= 1 (mapEntry "Throw" (count Pips)))) (set State at:(last To) 1))))) (if (not (is Friend (who at:(trackSite Move "MiddleTrack" steps:(mapEntry "Throw" (count Pips)))))) (move (from) (to (trackSite Move "MiddleTrack" steps:(mapEntry "Throw" (count Pips))) (apply if:(is Enemy (who at:(to))) (remove (to)))))))))}) (forEach Piece (if (and {(if (!= 0 (state at:(from))) True (= 1 (mapEntry "Throw" (count Pips))))}) (if (is In (from) (sites Mover "Home")) (if (not (is Friend (who at:(trackSite Move "Track" steps:(mapEntry "Throw" (count Pips)))))) (move (from) (to (trackSite Move "Track" steps:(mapEntry "Throw" (count Pips))) (apply if:(is Enemy (who at:(to))) (remove (to)))) (then (if (and (not (!= 0 (state at:(last To)))) (= 1 (mapEntry "Throw" (count Pips)))) (set State at:(last To) 1))))) (if (not (is Friend (who at:(trackSite Move "MiddleTrack" steps:(mapEntry "Throw" (count Pips)))))) (move (from) (to (trackSite Move "MiddleTrack" steps:(mapEntry "Throw" (count Pips))) (apply if:(is Enemy (who at:(to))) (remove (to)))))))))) (then (if (is In (mapEntry "Throw" (count Pips)) (sites {1 4 6})) (moveAgain))))) (end (if (no Pieces Next) (result Next Loss))))) 
Rectangular board, divided into three sections lengthwise. Ten lines divide the outer two sections widthwide. Twelve pieces per player, which begin on the outer intersections closest to the player. Four stick dice, with front and back sides distinguished one from the other. Throws are as follows: Four backs up = kiust. Three backs up = 6; two backs up = 3; one back up = 2; four fronts up = four throws of 6. A throw of kiust is required to enter the opponent's inner row. The pieces of the left hand player move from left to right and then right to left in the next row, then left to right in the following row, then proceeding to circulate in the central two rows in a clockwise direction. The right hand player's pieces move from right to left in their home row, then left to right in the next row, then right to left in the third row, circulating in an anti-clockwise direction. Pieces landing on an opponent's piece with a throw of 2 in the central rows capture the opponent's piece. A player may only pass an opponent's piece without capture with a throw of 3. The player who captures all of the opponent's pieces wins.
(game "Kiust Oyun" (players 2) (equipment {(board (merge {(scale 2 1 (rectangle 12 2)) (shift 2 0 (scale 4 1 (rectangle 12 2))) (shift 6 0 (scale 2 1 (rectangle 12 2)))}) {(track "Track1" "22,S,E1,N,E1,S" P1 directed:True) (track "Track2" "47,S,W1,N,W1,S" P2 directed:True) (track "LoopTrack1" "1,N,E1,S" loop:True P1) (track "LoopTrack2" "24,N,W1,S" loop:True P2)} use:Vertex) (dice d:2 from:0 num:4) (piece "Marker" Each (if (is In (from) (difference (sites Board) (union (sites Left) (sites Right)))) (move (from (from)) (to (trackSite Move "LoopTrack" steps:(mapEntry "Throw" (count Pips))) if:(and {(if (is Enemy (who at:(to))) (= 2 (mapEntry "Throw" (count Pips))) (is Empty (to))) (if (is In (to) (sites Next "Home")) (= 1 (var "Kiust")) True) (if (or (and (= 2 (mapEntry "Throw" (count Pips))) (is Enemy (who at:(to)))) (= 3 (mapEntry "Throw" (count Pips)))) True (all Sites (sites Track from:(trackSite Move from:(from) "LoopTrack" steps:1) to:(trackSite Move from:(from) "LoopTrack" steps:(- (mapEntry "Throw" (count Pips)) 1))) if:(not (is Enemy (who at:(site))))))}) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (move (from (from)) (to (trackSite Move "Track" steps:(mapEntry "Throw" (count Pips))) if:(and {(if (is In (to) (difference (sites Board) (union (sites Left) (sites Right)))) (if (is Enemy (who at:(to))) (= 2 (mapEntry "Throw" (count Pips))) (is Empty (to))) (is Empty (to))) (if (is In (to) (sites Next "Home")) (= 1 (var "Kiust")) True) (if (or (and (= 2 (mapEntry "Throw" (count Pips))) (is Enemy (who at:(to)))) (= 3 (mapEntry "Throw" (count Pips)))) True (all Sites (sites Track from:(trackSite Move from:(from) "Track" steps:1) to:(trackSite Move from:(from) "Track" steps:(- (mapEntry "Throw" (count Pips)) 1))) if:(not (is Enemy (who at:(site))))))}) (apply (if (is Enemy (who at:(to))) (remove (to)))))) (then (and (if (= (count Pips) 4) (and (if (!= 1 (value Player Mover)) (moveAgain)) (if (<= (value Player Mover) 0) (set Value Mover 3) (set Value Mover (- (value Player Mover) 1))))) (set Var "Kiust" 0))))) (map "Throw" {(pair 0 0) (pair 3 6) (pair 2 3) (pair 1 2) (pair 4 6)}) (regions "Home" P1 (expand (sites Left))) (regions "Home" P2 (expand (sites Right)))}) (rules (start {(place "Marker1" (sites Left)) (place "Marker2" (sites Right))}) (play (do (if (or (= (var "Kiust") 1) (not (is Prev Mover))) (roll)) next:(if (= 0 (mapEntry "Throw" (count Pips))) (move Pass (then (and (moveAgain) (set Var "Kiust" 1)))) (forEach Piece)))) (end (if (no Pieces Next) (result Next Loss))))) 
The main track of the board is a row of eleven squares, with both end squares and the central square marked with an X. On the left side, a row of four squares runs under and adjacent to the first four squares of the central row. Perpendicular to the left end square of the central row, there is a square and then three triangles. On the opposite end, below and perpendicular to the right end of the central track is a row of four squares, curving slightly to the right. Above the end square of the central row, a triangular space, adjacent to an oval divided into three. Two teams with two players on each team. Players each start from a different point: one from the right square in the bottom left row, one from one of the triangle spaces on the left, one from the end of the curving track on the right, and the other from one of the spaces in the oval. Three pieces per player. Five sticks, with a flat side and a curved sides, used as dice. The value of a throw is equal to the number of flat sides that land face up; five curved sides up = 5. Players move their pieces from their entry points onto the central track of the board and progressing to the opposite end of the board from where they started. Pieces must move backward when they reach the end of the central track. When a player's piece lands on a space occupied by an opponent's piece, the opponent's piece is taken. A piece resting on a space marked with an X is safe from capture. The team to successfully capture all of their opponent's pieces wins.
(game "Los Palos" (players 4) (equipment {(board (merge {(shift 11.3 -3.7 (graph vertices:{{0 0} {1.3 -1} {2 0} {1.1 0.6}} edges:{{0 1} {1 2} {2 3} {3 0}})) (shift 10.4 -2.4 (graph vertices:{{0 0} {0.9 -1.3} {2 -0.7} {1 0.4}} edges:{{0 1} {1 2} {2 3} {3 0}})) (shift 10.1 -1.1 (graph vertices:{{0 0} {0.3 -1.3} {1.3 -0.9} {1 0.2}} edges:{{0 1} {1 2} {2 3} {3 0}})) (shift 10 0 (graph vertices:{{0 0} {0.1 -1.1} {1.1 -0.9} {1 0}} edges:{{0 1} {1 2} {2 3} {3 0}})) (shift 11 1.87 (graph vertices:{{0 0} {0.5 0.5} {0 1}} edges:{{0 1} {1 2} {2 0}})) (shift 10 1.87 (graph vertices:{{0 0} {-0.5 0.5} {0 1}} edges:{{0 1} {1 2} {2 0}})) (shift 10 1.87 (square 1)) (shift 10 1 (tri 1)) (shift 1 2 (graph vertices:{{1 0} {-0.5 0.87} {0 0}} edges:{{0 1} {1 2} {2 0}})) (shift 0 2 (graph vertices:{{-1 0} {0.5 0.87} {0 0}} edges:{{0 1} {1 2} {2 0}})) (shift 0 2 (tri 1)) (shift 0 1 (square 1)) (rectangle 1 11) (shift 0 -1 (rectangle 1 4))}) {(track "Track1" "20,W,N1,E" P1 directed:True) (track "Track2" "11,12,S2,E" P2 directed:True) (track "Track3" "6,E1,9,S1,W" P3 directed:True) (track "Track4" "0,1,2,3,4,W" P4 directed:True) (track "TrackRight" "14,E,W" directed:True) (track "TrackLeft" "4,W,E" directed:True)}) (dice d:2 from:0 num:5) (piece "Marker" Each (move (from (from)) (to (if (= (state at:(from)) 0) (trackSite Move "Track" steps:(mapEntry "Throw" (count Pips))) (if (= (state at:(from)) 1) (trackSite Move "TrackLeft" steps:(mapEntry "Throw" (count Pips))) (trackSite Move "TrackRight" steps:(mapEntry "Throw" (count Pips))))) if:(or (and (not (is In (to) (sites "SafeSites"))) (is Enemy (who at:(to)))) (is Empty (to))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (if (and (= (state at:(last To)) 0) (is In (last To) (sites "CentralTrack"))) (if (or (is Mover P1) (is Mover P2)) (set State at:(last To) 2) (set State at:(last To) 1)))))) (map "Throw" {(pair 0 5) (pair 1 1) (pair 2 2) (pair 3 3) (pair 4 4) (pair 5 5)}) (map "EntryPoint" {(pair 1 20) (pair 2 11) (pair 3 6) (pair 4 0)}) (regions "SafeSites" (sites {4 14 23})) (regions "CentralTrack" (sites {4 5 14 15 19 21 22 23 24 25 26}))}) (rules (start {(place "Marker1" (mapEntry "EntryPoint" P1) count:3) (place "Marker2" (mapEntry "EntryPoint" P2) count:3) (place "Marker3" (mapEntry "EntryPoint" P3) count:3) (place "Marker4" (mapEntry "EntryPoint" P4) count:3) (set Team 1 {P1 P3}) (set Team 2 {P2 P4})}) (play (do (roll) next:(forEach Piece))) (end (if (no Pieces Enemy) (result TeamMover Win))))) 
21 holes, arranged in an arc, the central hole larger than the others. Ten pieces per player, each player's pieces beginning on one side of the board, one in each hole. Four beans used as dice, with a black side and a white side. The throws are as follows: Four white sides up = 4; four black sides up = 3; two white/two black up = 2; three white or three black = player loses their turn. Players continue to throw until they lose their turn. If a piece lands in the central hole, and it cannot move from it on its next opportunity, it is removed from the game. Pieces moving into the opponent's side of the board capture any of the opponent's pieces which occupy a space on which they land. When a piece reaches the end of the track, they proceed back in the other direction. The player who captures all ten of the opponent's pieces wins.
(game "Mapuche Game" (players 2) (equipment {(board (remove (concentric {26}) vertices:{0 1 2 3 4}) {(track "TrackCW1" {0 2 4 6 8 10 12 14 16 18 20 19 17 15 13 11 9 7 5 3 1} P1 directed:True) (track "TrackCCW1" {1 3 5 7 9 11 13 15 17 19 20 18 16 14 12 10 8 6 4 2 0} P1 directed:True) (track "TrackCW2" {0 2 4 6 8 10 12 14 16 18 20 19 17 15 13 11 9 7 5 3 1} P2 directed:True) (track "TrackCCW2" {1 3 5 7 9 11 13 15 17 19 20 18 16 14 12 10 8 6 4 2 0} P2 directed:True)} use:Vertex) (regions "AllSitesExceptTop" (difference (sites Board) 20)) (piece "Marker" Each (if (!= (if (= 0 (state at:(from))) (trackSite Move "TrackCW" steps:(mapEntry "ThrowDiceValue" (count Pips))) (trackSite Move "TrackCCW" steps:(mapEntry "ThrowDiceValue" (count Pips)))) -1) (if (or (is In (if (= 0 (state at:(from))) (trackSite Move "TrackCW" steps:(mapEntry "ThrowDiceValue" (count Pips))) (trackSite Move "TrackCCW" steps:(mapEntry "ThrowDiceValue" (count Pips)))) (sites Empty)) (is Enemy (who at:(if (= 0 (state at:(from))) (trackSite Move "TrackCW" steps:(mapEntry "ThrowDiceValue" (count Pips))) (trackSite Move "TrackCCW" steps:(mapEntry "ThrowDiceValue" (count Pips))))))) (move (from) (to (if (= 0 (state at:(from))) (trackSite Move "TrackCW" steps:(mapEntry "ThrowDiceValue" (count Pips))) (trackSite Move "TrackCCW" steps:(mapEntry "ThrowDiceValue" (count Pips)))) (apply if:(is Enemy (who at:(to))) (remove (to)))))))) (dice d:2 from:0 num:4) (map "ThrowDiceValue" {(pair 0 4) (pair 1 0) (pair 2 2) (pair 3 0) (pair 4 3)}) (hand Each)}) (rules (start {(place "Marker1" (sites {0 2 4 6 8 10 12 14 16 18})) (place "Marker2" (sites {1 3 5 7 9 11 13 15 17 19}) state:1)}) (play (do (roll) next:(if (can Move (if (!= (mapEntry "ThrowDiceValue" (count Pips)) 0) (forEach Piece))) (forEach Piece (then (if (!= (mapEntry "ThrowDiceValue" (count Pips)) 0) (moveAgain)))) (move Pass (then (if (!= (mapEntry "ThrowDiceValue" (count Pips)) 0) (moveAgain))))) (then (and (if (and (is Occupied 20) (!= 20 (last To))) (remove 20)) (if (= (last To) (if (= 0 (state at:(last To))) (trackSite EndSite Mover "TrackCW") (trackSite EndSite Mover "TrackCCW"))) (if (= 0 (state at:(last To))) (set State at:(last To) 1) (set State at:(last To) 0))))))) (end {(if (no Pieces P1) (result P1 Loss)) (if (no Pieces P2) (result P2 Loss))}))) 
6 spherical pieces and 6 lion or lioness pieces per player. Up to six players. Four throwing sticks as dice. Players enter their spherical pieces on the board with a throw of one. They then race to the center of the spiral. The central space must be reached with an exact throw. To leave the central space, the player must throw two ones. The player then races in the opposite direction to leave the board. When a piece leaves the board, that player introduces a lion piece, that player being the only one to introduce lion pieces. The player introduces more lions with each piece this player moves off the board. The lion races to the central spot, doubling the number of the throws. The lion attempts to capture the other player's pieces by landing on them. The rules are describing with the Kendall ruleset.
(game "Mehen" (players 2) (equipment {(board (spiral turns:5 sites:88) {(track "NormalTrack" {87 86 85 84 83 82 81 80 79 78 77 76 75 74 73 72 71 70 69 68 67 66 65 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 -2} directed:True) (track "OppositeTrack" {0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 -2} directed:True)} use:Vertex) (dice d:2 from:0 num:4) (hand Each size:2) (piece "Disc" Each (if (and (= (trackSite Move steps:(count Pips)) -2) (is Empty 0)) (move Select (from) (then (and (remove (last To)) (add (piece (id "Marker" Mover)) (to 0))))) (if (!= (trackSite Move "NormalTrack" steps:(count Pips)) -1) (if (is In (trackSite Move "NormalTrack" steps:(count Pips)) (sites Empty)) (move (from) (to (trackSite Move "NormalTrack" steps:(count Pips)))))))) (piece "Marker" Each (if (= (trackSite Move "OppositeTrack" steps:(count Pips)) -2) (move Select (from) (then (and (remove (last To)) (add (piece (id "Lion" Mover)) (to (handSite Mover 1)))))) (if (!= (trackSite Move "OppositeTrack" steps:(count Pips)) -1) (if (is In (trackSite Move "OppositeTrack" steps:(count Pips)) (sites Empty)) (move (from) (to (trackSite Move "OppositeTrack" steps:(count Pips)))))))) (piece "Lion" Each (or (if (and (!= (trackSite Move "OppositeTrack" steps:(* (count Pips) 2)) -1) (!= (trackSite Move "OppositeTrack" steps:(* (count Pips) 2)) -2)) (if (not (is Friend (who at:(trackSite Move "OppositeTrack" steps:(mul (count Pips) 2))))) (move (from) (to (trackSite Move "OppositeTrack" steps:(mul (count Pips) 2)))))) (if (and (!= (trackSite Move "NormalTrack" steps:(* (count Pips) 2)) -1) (!= (trackSite Move "NormalTrack" steps:(* (count Pips) 2)) -2)) (if (not (is Friend (who at:(trackSite Move "NormalTrack" steps:(mul (count Pips) 2))))) (move (from) (to (trackSite Move "NormalTrack" steps:(mul (count Pips) 2))))))))}) (rules (start {(place "Disc1" (handSite P1) count:6) (place "Disc2" (handSite P2) count:6)}) (play (do (roll) next:(or {(if (and {(= (count Pips) 1) (is Empty 87) (is Occupied (handSite Mover))}) (move (from (handSite Mover)) (to 87))) (if (and {(= (count Pips) 1) (not (is Friend (who at:87))) (is Occupied (handSite Mover 1))}) (move (from (handSite Mover 1)) (to 87))) (forEach Piece)}))) (end (if (no Pieces Next) (result Next Loss))))) 
Pieces start from the centers of the rings to the colored positions and later move orthogonal forward, left or right. The total STEP-length is equal to the sum of the pips of a players color on all the positions occupied by their pieces. If you can move you have to do so, even if it is a bad move. If you stalemate yourself, the other player can move until you can move again. STARTER-generation: If you reach the same color of one of your own pieces in the opposite ring, you get a new starter to your base (center of the rings) from your reserve. This also works from the base with a start-move (base to own ring). To CAPTURE an enemy, you need to be able to reach the same color of the enemy-piece in the opposite ring, then the possibility to directly capture the enemy on its board-position will be available. Capturing is not mandatory, you can also just go to the opposite-color position (move 'into the shadow'). Capturing with a start-move from the base is not possible. RingCapture: with steplenght 8 you could theoretically move in a circle to your own position, but as normal move this is not allowed. But if there is an enemy-piece on the opposite same color, the (ring-)capture-move ist allowed! For steplengths of 12 or 14 etc this is also possible from some other positions. The captured pieces remain under the attacker in a stack and have to be brought to the Transmitter (field in the middle of the board) with the according steplength. If you reach the transmitter, your pieces in the stack go back to base as starters, and the enemies land in your prison. First player to make 3 prisoners wins. Only pieces with a captured enemy can land on the Transmitter for prisonertransport. (Exception: #LastMan) Single pieces just step over it. With high steplength you can move in circles or to the other side and back, but not turn 180 degrees. Special Rules to balance the Start: From the Start-situation (or later, when there are temporarily no picese on colored positions) you cannot copy the move of the enemy, ie move to the same color with your first piece. #CounterAttack: If your first starter is attacked immediately (by the first enemy move), you are allowed to start also to the colors in the enemy-ring with your second starter. In this case, there is no Starter generation, if you move to the opposite color of your first piece (to protect it from capturing). Special Rules for Endgame: #LastMan: If you are left with just a single piece on the colored board positions (and no starter on your base), you may enter the Transmitter to move the piece to your base and get a second starter (if you still have one in your reserve)! #PrisonerExchange: Move a prisoner to your (empty) homebase, and you get an additional Starter taken from your reserve & the prisoner goes back to his reserve. You have to move this new starter immediately: the PrisonerExchange itself counts not as a full move. History : 'Mensa Spiel' invented by Andreas Pichler (Mensa Austria). Ludii file implemented by Franz Pichler. (June 2022) Strategy : Early starter-generation is important to have more options. Indirect or dynamic defense is sometimes best: if you are captured, to be able to capture back or dominate the opponent with controlling many positions is vital. In general, a move that attacks an enemy-piece and would make possible a Starter-Generation in the next move simultaneously, is good. But be aware: almost all moves change the steplength and attack & defence-patterns, ie. the whole situation. This makes it complicated to calculate, but entertaining to play. White player starts the game. Transfer 3 enemy-pieces to your prison-cell.
(game "MensaSpiel" (players 2) (equipment {(board (remove (rectangle 5 7) cells:{2 4 7 8 9 11 12 13 17 31})) (regions "Base" P1 {13}) (regions "Base" P2 {17}) (regions "Prison" P1 {0}) (regions "Prison" P2 {4}) (regions "Reserve" P1 {1}) (regions "Reserve" P2 {3}) (regions "HomeRing" P1 {6 7 8 12 14 19 20 21}) (regions "HomeRing" P2 {9 10 11 16 18 22 23 24}) (regions "SitesLastMan" P1 {6 9 16 21 22}) (regions "SitesLastMan" P2 {7 9 14 21 22}) (regions "Rings" {6 7 8 9 10 11 12 14 16 18 19 20 21 22 23 24}) (regions "RingsplusT" {6 7 8 9 10 11 12 14 15 16 18 19 20 21 22 23 24}) (regions "RingsplusBase" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24}) (map "PipsP1" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {4 1 3 2 2 1 2 0 3 0 1 0 1 3 2 2 2 0 3}) (map "PipsP2" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {0 3 1 2 2 3 2 0 1 0 3 0 3 1 2 2 2 4 1}) (map "Attacks1" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {10 23 9 12 8 6 9 0 16 0 7 0 12 11 11 16 7 21 6}) (map "Attacks2" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {10 18 22 14 19 19 24 0 23 0 14 0 20 24 22 18 20 21 8}) (map "SameColor" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {23 24 18 20 21 14 22 0 11 0 19 0 8 16 9 10 12 6 7}) (map "Step1c" {14 16} {15 15}) (map "Step2a" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {19 14 6 22 18 24 20 0 20 0 23 0 23 21 14 19 24 18 11}) (map "Step2b" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {8 12 21 11 16 9 7 0 7 0 10 0 10 6 12 8 9 16 22}) (map "Step2c" {8 14 21 16 9 22} {15 16 15 14 15 15}) (map "Step3a" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {20 19 12 23 22 23 21 0 19 0 24 0 9 14 8 12 10 9 10}) (map "Step3b" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {14 21 20 18 24 16 8 0 6 0 11 0 22 7 6 7 18 11 16}) (map "Step3c" {7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23} {15 16 14 15 0 0 0 22 0 8 0 0 0 15 16 14 15}) (map "Step3d" {14 16} {9 21}) (map "Step4a" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {21 20 19 24 23 22 14 0 12 0 18 0 16 8 7 6 11 10 9}) (map "Step4b" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {15 16 9 8 14 15 0 0 10 0 7 0 0 15 16 9 8 14 15}) (map "Step4c" {8 14 21 9 16 22} {22 23 22 21 20 21}) (map "Step5c" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {16 9 10 7 8 14 15 0 11 0 6 0 15 16 9 10 7 8 14}) (map "Step5d" {7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23} {22 23 20 21 0 0 0 24 0 19 0 0 0 22 23 20 21}) (map "Step6c" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {9 10 11 6 7 8 16 0 18 0 12 0 14 9 10 11 6 7 8}) (map "Step6d" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {22 23 24 19 20 21 0 0 0 0 0 0 0 22 23 24 19 20 21}) (map "Step6e" {6 19 11 24} {15 15 15 15}) (map "Step7a" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {7 8 14 10 11 18 6 0 8 0 9 0 11 12 19 14 16 22 18}) (map "Step7b" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {12 6 7 16 9 10 19 0 21 0 22 0 24 20 21 20 23 24 23}) (map "Step7c" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {10 11 18 12 6 7 9 0 11 0 6 0 8 10 11 18 12 6 7}) (map "Step7d" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {23 24 0 0 19 20 22 0 24 0 19 0 21 23 24 0 0 19 20}) (map "Step7e" {6 19 7 20 10 23 11 24} {16 16 15 15 15 15 14 14}) (map "Step8a" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {11 18 11 6 12 6 10 0 10 0 7 0 7 11 18 11 6 12 6}) (map "Step8b" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {24 16 24 19 14 19 23 0 23 0 20 0 20 24 16 24 19 14 19}) (map "Step8c" {6 19 8 21 9 22 11 24} {9 9 15 15 15 15 8 8}) (map "Step8d" {6 19 11 24} {22 22 21 21}) (map "Step9c" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {18 11 10 7 6 12 11 0 9 0 8 0 6 18 11 10 7 6 12}) (map "Step9d" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {10 24 23 20 19 7 24 0 22 0 21 0 19 23 24 23 20 19 7}) (map "Step9e" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {23 9 16 14 8 20 0 0 15 0 15 0 0 10 9 16 14 8 20}) (map "Step9f" {20 7 10 23} {22 22 21 21}) (map "Step10c" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {11 10 9 8 7 6 18 0 16 0 14 0 12 11 10 9 8 7 6}) (map "Step10d" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {24 23 22 21 20 19 0 0 0 0 0 0 0 24 23 22 21 20 19}) (map "Step10e" {21 8 9 22} {15 15 15 15}) (map "Step11c" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {10 11 10 7 6 7 11 0 9 0 8 0 6 10 11 10 7 6 7}) (map "Step11d" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {23 24 23 20 19 20 24 0 22 0 21 0 19 23 24 23 20 19 20}) (map "Step11e" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {18 9 16 14 8 12 0 0 15 0 15 0 0 18 9 16 14 8 12}) (map "Step11f" {7 10 20 23} {22 21 22 21}) (map "Step11g" {7 10 20 23} {15 15 15 15}) (map "Step12b" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {11 18 11 6 12 6 10 0 10 0 7 0 7 11 18 11 6 12 6}) (map "Step12c" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {24 16 24 19 14 19 23 0 23 0 20 0 20 24 16 24 19 14 19}) (map "Step12d" {6 19 8 21 9 22 11 24} {9 9 9 9 8 8 8 8}) (map "Step12e" {6 19 8 21 9 22 11 24} {22 22 22 22 21 21 21 21}) (map "Step12f" {6 19 8 21 9 22 11 24} {15 15 15 15 15 15 15 15}) (map "Step12g" {14 16} {11 19}) (map "Step13c" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {10 11 10 7 6 7 9 0 11 0 6 0 8 10 11 10 7 6 7}) (map "Step13d" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {23 24 23 20 19 20 22 0 24 0 19 0 21 23 24 23 20 19 20}) (map "Step13e" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {16 9 14 16 8 14 15 0 8 0 9 0 15 16 9 14 16 8 14}) (map "Step13f" {7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23} {22 18 12 21 0 0 0 21 0 22 0 0 0 22 18 12 21}) (map "Step14c" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {9 10 11 6 7 8 16 0 18 0 12 0 14 9 10 11 6 7 8}) (map "Step14d" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {22 23 24 19 20 21 0 0 0 0 0 0 0 22 23 24 19 20 21}) (map "Step14e" {6 19 11 24} {15 15 15 15}) (map "Step14f" {8 9 21 22} {18 20 10 12}) (map "Step15c" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {10 11 18 12 6 7 9 0 11 0 11 0 8 10 11 18 12 6 7}) (map "Step15d" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {23 24 20 23 19 20 22 0 24 0 24 0 21 23 24 7 10 19 20}) (map "Step15e" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {16 21 10 7 22 16 15 0 6 0 6 0 15 16 8 10 7 9 16}) (map "Step15f" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {14 9 23 20 8 14 0 0 19 0 19 0 0 14 9 23 20 8 14}) (map "Step16c" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {9 20 15 15 23 8 14 0 12 0 18 0 16 9 7 15 15 10 8}) (map "Step16d" {6 19 8 21 9 22 11 24} {22 22 6 6 11 11 21 21}) (map "Step16e" {6 19 8 21 9 22 11 24} {8 8 9 9 8 8 9 9}) (map "Step16f" {6 19 8 21 9 22 11 24} {21 21 19 19 21 21 22 22}) (map "Step16g" {6 19 8 21 9 22 11 24} {15 15 22 22 24 24 15 15}) (map "Step17c" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {10 11 10 7 6 7 8 0 6 0 11 0 6 10 6 10 7 6 7}) (map "Step17d" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {23 9 12 14 8 12 11 0 9 0 8 0 9 23 9 12 14 8 10}) (map "Step17e" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {18 15 16 18 15 16 21 0 15 0 15 0 19 18 11 16 18 11 16}) (map "Step17f" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {14 19 23 20 19 20 24 0 19 0 21 0 22 14 15 23 20 15 12}) (map "Step17g" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {20 22 0 0 21 23 0 0 22 0 24 0 0 7 22 0 0 19 20}) (map "Step17h" {7 10 20 23} {24 24 24 21}) (map "Step18c" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {11 10 9 8 7 6 18 0 16 0 14 0 12 8 10 6 8 7 6}) (map "Step18d" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {21 23 15 15 20 19 0 0 0 0 0 0 0 11 23 9 11 20 9}) (map "Step18e" {6 19 8 21 22 9 11 24} {24 24 19 15 15 21 22 19}) (map "Step18f" {8 21 22 9} {22 22 21 24}) (map "Step18g" {6 19 11 24} {23 16 14 7}) (map "Step19c" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {7 6 7 7 6 7 6 0 8 0 8 0 6 10 9 10 7 6 7}) (map "Step19d" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {10 8 10 10 8 10 11 0 9 0 9 0 11 12 11 14 14 8 12}) (map "Step19e" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {12 9 14 14 9 12 19 0 15 0 15 0 19 18 15 16 16 15 18}) (map "Step19f" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {18 11 16 16 11 18 24 0 21 0 21 0 24 20 19 20 20 19 20}) (map "Step19g" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {23 15 23 20 15 20 0 0 22 0 22 0 0 23 21 23 23 21 23}) (map "Step19h" {7 10 20 23} {22 19 22 22}) (map "Step19i" {7 10 20 23} {24 21 24 24}) (map "Step20b" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {9 16 9 6 12 6 10 0 10 0 7 0 7 6 16 8 6 12 6}) (map "Step20c" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {11 18 11 8 14 8 23 0 23 0 20 0 20 9 18 9 8 14 8}) (map "Step20d" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {15 0 15 15 0 15 0 0 0 0 0 0 0 11 0 11 9 0 11}) (map "Step20e" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {19 0 21 19 0 19 0 0 0 0 0 0 0 15 0 15 15 0 15}) (map "Step20f" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {22 0 22 21 0 21 0 0 0 0 0 0 0 22 0 22 19 0 19}) (map "Step20g" {6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24} {24 0 24 22 0 24 0 0 0 0 0 0 0 24 0 24 21 0 21}) (piece "Prisoner" Each (if (and (no Pieces in:(sites Mover "Base")) (not (no Pieces in:(sites Mover "Reserve")))) (move (from) (to (sites Mover "Base"))) (then (and {(promote (last To) (piece "Starter") Mover) (remove (sites Mover "Reserve")) (add (piece (id "Reserve" Next)) (to (sites Next "Reserve")) stack:True) (moveAgain)})))) (piece "Starter" Each (if (= 1 (var "StartS")) (move (from (sites Mover "Base")) (to (difference (sites Mover "HomeRing") (mapEntry "SameColor" (last To)))) (then (and {(promote (last To) (piece {"Cone"}) Mover) (set Var "StartS" (+ 1 (var "StartS"))) (if (= 0 (var "StartS")) (set Var "St1Pos" (last To))) (if (and (= 1 (var "StartS")) (or (= (mapEntry "Attacks1" (last To)) (var "St1Pos")) (= (mapEntry "Attacks2" (last To)) (var "St1Pos")))) (set Var "CntrAttack" 1)) (if (> (var "StartS") 2) (set Var "CntrAttack" 0)) (if (and {(is Friend (who at:(mapEntry "SameColor" (last To)))) (!= 1 (var "CntrAttack")) (not (no Pieces in:(sites Mover "Reserve")))}) (and (add (piece (id "Starter" Mover)) (to (sites Mover "Base")) stack:True) (remove (sites Mover "Reserve")))) (set Value at:(last To) 1) (addScore Mover (if (= (id Mover) 1) (mapEntry "PipsP1" (last To)) (mapEntry "PipsP2" (last To))))}))) (if (and (= 2 (var "StartS")) (= 1 (var "CntrAttack"))) (move (from (sites Mover "Base")) (to (intersection (sites "Rings") (sites Empty))) (then (and {(promote (last To) (piece {"Cone"}) Mover) (set Var "StartS" (+ 1 (var "StartS"))) (if (= 0 (var "StartS")) (set Var "St1Pos" (last To))) (if (and (= 1 (var "StartS")) (or (= (mapEntry "Attacks1" (last To)) (var "St1Pos")) (= (mapEntry "Attacks2" (last To)) (var "St1Pos")))) (set Var "CntrAttack" 1)) (if (> (var "StartS") 2) (set Var "CntrAttack" 0)) (if (and {(is Friend (who at:(mapEntry "SameColor" (last To)))) (!= 1 (var "CntrAttack")) (not (no Pieces in:(sites Mover "Reserve")))}) (and (add (piece (id "Starter" Mover)) (to (sites Mover "Base")) stack:True) (remove (sites Mover "Reserve")))) (set Value at:(last To) 1) (addScore Mover (if (= (id Mover) 1) (mapEntry "PipsP1" (last To)) (mapEntry "PipsP2" (last To))))}))) (move (from (sites Mover "Base")) (to (intersection (sites Mover "HomeRing") (sites Empty))) (then (and {(promote (last To) (piece {"Cone"}) Mover) (set Var "StartS" (+ 1 (var "StartS"))) (if (= 0 (var "StartS")) (set Var "St1Pos" (last To))) (if (and (= 1 (var "StartS")) (or (= (mapEntry "Attacks1" (last To)) (var "St1Pos")) (= (mapEntry "Attacks2" (last To)) (var "St1Pos")))) (set Var "CntrAttack" 1)) (if (> (var "StartS") 2) (set Var "CntrAttack" 0)) (if (and {(is Friend (who at:(mapEntry "SameColor" (last To)))) (!= 1 (var "CntrAttack")) (not (no Pieces in:(sites Mover "Reserve")))}) (and (add (piece (id "Starter" Mover)) (to (sites Mover "Base")) stack:True) (remove (sites Mover "Reserve")))) (set Value at:(last To) 1) (addScore Mover (if (= (id Mover) 1) (mapEntry "PipsP1" (last To)) (mapEntry "PipsP2" (last To))))})))))) (piece "Reserve" Each) (piece "Cone" Each (if (and {(no Pieces in:(sites Mover "Base")) (= 1 (count Pieces in:(intersection (sites "Rings") (sites Occupied by:Mover)))) (= 1 (size Stack at:(regionSite (intersection (sites Occupied by:Mover) (sites Mover "SitesLastMan")) index:0))) (not (no Pieces in:(sites Mover "Reserve")))}) (or (move (from) (to 15) (then (and {(set Var "CntrAttack" 0) (set Score Mover 0) (remove 15) (remove (sites Mover "Reserve")) (add (piece (id "Starter" Mover)) (to (sites Mover "Base")) count:2 stack:True)}))) (if (< (score Mover) 16) (if (< (score Mover) 8) (if (< (score Mover) 4) (if (< (score Mover) 2) (if (= (score Mover) 1) (move (from) (to (union {(intersection {(difference (if (= 1 (size Stack at:(from))) (sites "Rings") (sites "RingsplusT")) (from)) (sites Empty) (sites {(mapEntry "Step7a" (from)) (mapEntry "Step7b" (from)) (mapEntry "Step1c" (from)) (mapEntry (from)) (mapEntry (from)) (mapEntry (from)) (mapEntry (from)) (mapEntry (from))})}) (intersection {(sites "Rings") (sites Occupied by:Next) (sites {(mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step7a" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step7b" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step1c" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry (from))})})})) stack:True (then (and {(set Var "StartS" 3) (set Var "CntrAttack" 0) (if (= 15 (last To)) (and {(add (piece (id "Starter" Mover)) (to (sites Mover "Base")) count:(count Stack at:(last To) if:(= (id "Cone" Mover) (what at:(to) level:(level)))) stack:True) (add (piece (id "Prisoner" Mover)) (to (sites Mover "Prison")) count:(count Stack at:(last To) if:(= (id "Cone" Next) (what at:(to) level:(level)))) stack:True) (remove 15 count:(count Stack at:(last To)))}) (if (and (is Friend (who at:(mapEntry "SameColor" (last To)))) (not (no Pieces in:(sites Mover "Reserve")))) (and (remove (sites Mover "Reserve")) (add (piece (id "Starter" Mover)) (to (sites Mover "Base")) stack:True)))) (set Value at:(last To) (count Stack at:(last To))) (addScore Mover (- (if (= (id Mover) 1) (mapEntry "PipsP1" (last To)) (mapEntry "PipsP2" (last To))) (if (= (id Mover) 1) (mapEntry "PipsP1" (last From)) (mapEntry "PipsP2" (last From))))) (if (> (size Stack at:(last To)) (value Piece at:(last To))) (addScore Next (- 0 (if (= (id Mover) 1) (mapEntry "PipsP2" (last To)) (mapEntry "PipsP1" (last To))))))})))) (if (= (score Mover) 2) (move (from) (to (union {(intersection {(difference (if (= 1 (size Stack at:(from))) (sites "Rings") (sites "RingsplusT")) (from)) (sites Empty) (sites {(mapEntry "Step2a" (from)) (mapEntry "Step2b" (from)) (mapEntry "Step2c" (from)) (mapEntry (from)) (mapEntry (from)) (mapEntry (from)) (mapEntry (from)) (mapEntry (from))})}) (intersection {(sites "Rings") (sites Occupied by:Next) (sites {(mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step2a" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step2b" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step2c" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry (from))})})})) stack:True (then (and {(set Var "StartS" 3) (set Var "CntrAttack" 0) (if (= 15 (last To)) (and {(add (piece (id "Starter" Mover)) (to (sites Mover "Base")) count:(count Stack at:(last To) if:(= (id "Cone" Mover) (what at:(to) level:(level)))) stack:True) (add (piece (id "Prisoner" Mover)) (to (sites Mover "Prison")) count:(count Stack at:(last To) if:(= (id "Cone" Next) (what at:(to) level:(level)))) stack:True) (remove 15 count:(count Stack at:(last To)))}) (if (and (is Friend (who at:(mapEntry "SameColor" (last To)))) (not (no Pieces in:(sites Mover "Reserve")))) (and (remove (sites Mover "Reserve")) (add (piece (id "Starter" Mover)) (to (sites Mover "Base")) stack:True)))) (set Value at:(last To) (count Stack at:(last To))) (addScore Mover (- (if (= (id Mover) 1) (mapEntry "PipsP1" (last To)) (mapEntry "PipsP2" (last To))) (if (= (id Mover) 1) (mapEntry "PipsP1" (last From)) (mapEntry "PipsP2" (last From))))) (if (> (size Stack at:(last To)) (value Piece at:(last To))) (addScore Next (- 0 (if (= (id Mover) 1) (mapEntry "PipsP2" (last To)) (mapEntry "PipsP1" (last To))))))}))) (move (from) (to (union {(intersection {(difference (if (= 1 (size Stack at:(from))) (sites "Rings") (sites "RingsplusT")) (from)) (sites Empty) (sites {(mapEntry "Step3a" (from)) (mapEntry "Step3b" (from)) (mapEntry "Step3c" (from)) (mapEntry "Step3d" (from)) (mapEntry (from)) (mapEntry (from)) (mapEntry (from)) (mapEntry (from))})}) (intersection {(sites "Rings") (sites Occupied by:Next) (sites {(mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step3a" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step3b" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step3c" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step3d" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry (from))})})})) stack:True (then (and {(set Var "StartS" 3) (set Var "CntrAttack" 0) (if (= 15 (last To)) (and {(add (piece (id "Starter" Mover)) (to (sites Mover "Base")) count:(count Stack at:(last To) if:(= (id "Cone" Mover) (what at:(to) level:(level)))) stack:True) (add (piece (id "Prisoner" Mover)) (to (sites Mover "Prison")) count:(count Stack at:(last To) if:(= (id "Cone" Next) (what at:(to) level:(level)))) stack:True) (remove 15 count:(count Stack at:(last To)))}) (if (and (is Friend (who at:(mapEntry "SameColor" (last To)))) (not (no Pieces in:(sites Mover "Reserve")))) (and (remove (sites Mover "Reserve")) (add (piece (id "Starter" Mover)) (to (sites Mover "Base")) stack:True)))) (set Value at:(last To) (count Stack at:(last To))) (addScore Mover (- (if (= (id Mover) 1) (mapEntry "PipsP1" (last To)) (mapEntry "PipsP2" (last To))) (if (= (id Mover) 1) (mapEntry "PipsP1" (last From)) (mapEntry "PipsP2" (last From))))) (if (> (size Stack at:(last To)) (value Piece at:(last To))) (addScore Next (- 0 (if (= (id Mover) 1) (mapEntry "PipsP2" (last To)) (mapEntry "PipsP1" (last To))))))}))))) (if (< (score Mover) 6) (if (= (score Mover) 4) (move (from) (to (union {(intersection {(difference (if (= 1 (size Stack at:(from))) (sites "Rings") (sites "RingsplusT")) (from)) (sites Empty) (sites {(mapEntry "Step4a" (from)) (mapEntry "Step4b" (from)) (mapEntry "Step4c" (from)) (mapEntry (from)) (mapEntry (from)) (mapEntry (from)) (mapEntry (from)) (mapEntry (from))})}) (intersection {(sites "Rings") (sites Occupied by:Next) (sites {(mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step4a" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step4b" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step4c" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry (from))})})})) stack:True (then (and {(set Var "StartS" 3) (set Var "CntrAttack" 0) (if (= 15 (last To)) (and {(add (piece (id "Starter" Mover)) (to (sites Mover "Base")) count:(count Stack at:(last To) if:(= (id "Cone" Mover) (what at:(to) level:(level)))) stack:True) (add (piece (id "Prisoner" Mover)) (to (sites Mover "Prison")) count:(count Stack at:(last To) if:(= (id "Cone" Next) (what at:(to) level:(level)))) stack:True) (remove 15 count:(count Stack at:(last To)))}) (if (and (is Friend (who at:(mapEntry "SameColor" (last To)))) (not (no Pieces in:(sites Mover "Reserve")))) (and (remove (sites Mover "Reserve")) (add (piece (id "Starter" Mover)) (to (sites Mover "Base")) stack:True)))) (set Value at:(last To) (count Stack at:(last To))) (addScore Mover (- (if (= (id Mover) 1) (mapEntry "PipsP1" (last To)) (mapEntry "PipsP2" (last To))) (if (= (id Mover) 1) (mapEntry "PipsP1" (last From)) (mapEntry "PipsP2" (last From))))) (if (> (size Stack at:(last To)) (value Piece at:(last To))) (addScore Next (- 0 (if (= (id Mover) 1) (mapEntry "PipsP2" (last To)) (mapEntry "PipsP1" (last To))))))}))) (move (from) (to (union {(intersection {(difference (if (= 1 (size Stack at:(from))) (sites "Rings") (sites "RingsplusT")) (from)) (sites Empty) (sites {(mapEntry "Step3a" (from)) (mapEntry "Step3b" (from)) (mapEntry "Step5c" (from)) (mapEntry "Step5d" (from)) (mapEntry (from)) (mapEntry (from)) (mapEntry (from)) (mapEntry (from))})}) (intersection {(sites "Rings") (sites Occupied by:Next) (sites {(mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step3a" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step3b" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step5c" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step5d" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry (from))})})})) stack:True (then (and {(set Var "StartS" 3) (set Var "CntrAttack" 0) (if (= 15 (last To)) (and {(add (piece (id "Starter" Mover)) (to (sites Mover "Base")) count:(count Stack at:(last To) if:(= (id "Cone" Mover) (what at:(to) level:(level)))) stack:True) (add (piece (id "Prisoner" Mover)) (to (sites Mover "Prison")) count:(count Stack at:(last To) if:(= (id "Cone" Next) (what at:(to) level:(level)))) stack:True) (remove 15 count:(count Stack at:(last To)))}) (if (and (is Friend (who at:(mapEntry "SameColor" (last To)))) (not (no Pieces in:(sites Mover "Reserve")))) (and (remove (sites Mover "Reserve")) (add (piece (id "Starter" Mover)) (to (sites Mover "Base")) stack:True)))) (set Value at:(last To) (count Stack at:(last To))) (addScore Mover (- (if (= (id Mover) 1) (mapEntry "PipsP1" (last To)) (mapEntry "PipsP2" (last To))) (if (= (id Mover) 1) (mapEntry "PipsP1" (last From)) (mapEntry "PipsP2" (last From))))) (if (> (size Stack at:(last To)) (value Piece at:(last To))) (addScore Next (- 0 (if (= (id Mover) 1) (mapEntry "PipsP2" (last To)) (mapEntry "PipsP1" (last To))))))})))) (if (= (score Mover) 6) (move (from) (to (union {(intersection {(difference (if (= 1 (size Stack at:(from))) (sites "Rings") (sites "RingsplusT")) (from)) (sites Empty) (sites {(mapEntry "Step2a" (from)) (mapEntry "Step2b" (from)) (mapEntry "Step6c" (from)) (mapEntry "Step6d" (from)) (mapEntry "Step6e" (from)) (mapEntry (from)) (mapEntry (from)) (mapEntry (from))})}) (intersection {(sites "Rings") (sites Occupied by:Next) (sites {(mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step2a" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step2b" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step6c" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step6d" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step6e" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry (from))})})})) stack:True (then (and {(set Var "StartS" 3) (set Var "CntrAttack" 0) (if (= 15 (last To)) (and {(add (piece (id "Starter" Mover)) (to (sites Mover "Base")) count:(count Stack at:(last To) if:(= (id "Cone" Mover) (what at:(to) level:(level)))) stack:True) (add (piece (id "Prisoner" Mover)) (to (sites Mover "Prison")) count:(count Stack at:(last To) if:(= (id "Cone" Next) (what at:(to) level:(level)))) stack:True) (remove 15 count:(count Stack at:(last To)))}) (if (and (is Friend (who at:(mapEntry "SameColor" (last To)))) (not (no Pieces in:(sites Mover "Reserve")))) (and (remove (sites Mover "Reserve")) (add (piece (id "Starter" Mover)) (to (sites Mover "Base")) stack:True)))) (set Value at:(last To) (count Stack at:(last To))) (addScore Mover (- (if (= (id Mover) 1) (mapEntry "PipsP1" (last To)) (mapEntry "PipsP2" (last To))) (if (= (id Mover) 1) (mapEntry "PipsP1" (last From)) (mapEntry "PipsP2" (last From))))) (if (> (size Stack at:(last To)) (value Piece at:(last To))) (addScore Next (- 0 (if (= (id Mover) 1) (mapEntry "PipsP2" (last To)) (mapEntry "PipsP1" (last To))))))}))) (move (from) (to (union {(intersection {(difference (if (= 1 (size Stack at:(from))) (sites "Rings") (sites "RingsplusT")) (from)) (sites Empty) (sites {(mapEntry "Step7a" (from)) (mapEntry "Step7b" (from)) (mapEntry "Step7c" (from)) (mapEntry "Step7d" (from)) (mapEntry "Step7e" (from)) (mapEntry (from)) (mapEntry (from)) (mapEntry (from))})}) (intersection {(sites "Rings") (sites Occupied by:Next) (sites {(mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step7a" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step7b" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step7c" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step7d" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step7e" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry (from))})})})) stack:True (then (and {(set Var "StartS" 3) (set Var "CntrAttack" 0) (if (= 15 (last To)) (and {(add (piece (id "Starter" Mover)) (to (sites Mover "Base")) count:(count Stack at:(last To) if:(= (id "Cone" Mover) (what at:(to) level:(level)))) stack:True) (add (piece (id "Prisoner" Mover)) (to (sites Mover "Prison")) count:(count Stack at:(last To) if:(= (id "Cone" Next) (what at:(to) level:(level)))) stack:True) (remove 15 count:(count Stack at:(last To)))}) (if (and (is Friend (who at:(mapEntry "SameColor" (last To)))) (not (no Pieces in:(sites Mover "Reserve")))) (and (remove (sites Mover "Reserve")) (add (piece (id "Starter" Mover)) (to (sites Mover "Base")) stack:True)))) (set Value at:(last To) (count Stack at:(last To))) (addScore Mover (- (if (= (id Mover) 1) (mapEntry "PipsP1" (last To)) (mapEntry "PipsP2" (last To))) (if (= (id Mover) 1) (mapEntry "PipsP1" (last From)) (mapEntry "PipsP2" (last From))))) (if (> (size Stack at:(last To)) (value Piece at:(last To))) (addScore Next (- 0 (if (= (id Mover) 1) (mapEntry "PipsP2" (last To)) (mapEntry "PipsP1" (last To))))))})))))) (if (< (score Mover) 12) (if (< (score Mover) 10) (if (= (score Mover) 8) (move (from) (to (union {(intersection {(difference (if (= 1 (size Stack at:(from))) (sites "Rings") (sites "RingsplusT")) (from)) (sites Empty) (sites {(mapEntry "Step8a" (from)) (mapEntry "Step8b" (from)) (mapEntry "Step8c" (from)) (mapEntry "Step8d" (from)) (mapEntry (from)) (mapEntry (from)) (mapEntry (from)) (mapEntry (from))})}) (intersection {(sites "Rings") (sites Occupied by:Next) (sites {(mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step8a" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step8b" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step8c" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step8d" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (from))})})})) stack:True (then (and {(set Var "StartS" 3) (set Var "CntrAttack" 0) (if (= 15 (last To)) (and {(add (piece (id "Starter" Mover)) (to (sites Mover "Base")) count:(count Stack at:(last To) if:(= (id "Cone" Mover) (what at:(to) level:(level)))) stack:True) (add (piece (id "Prisoner" Mover)) (to (sites Mover "Prison")) count:(count Stack at:(last To) if:(= (id "Cone" Next) (what at:(to) level:(level)))) stack:True) (remove 15 count:(count Stack at:(last To)))}) (if (and (is Friend (who at:(mapEntry "SameColor" (last To)))) (not (no Pieces in:(sites Mover "Reserve")))) (and (remove (sites Mover "Reserve")) (add (piece (id "Starter" Mover)) (to (sites Mover "Base")) stack:True)))) (set Value at:(last To) (count Stack at:(last To))) (addScore Mover (- (if (= (id Mover) 1) (mapEntry "PipsP1" (last To)) (mapEntry "PipsP2" (last To))) (if (= (id Mover) 1) (mapEntry "PipsP1" (last From)) (mapEntry "PipsP2" (last From))))) (if (> (size Stack at:(last To)) (value Piece at:(last To))) (addScore Next (- 0 (if (= (id Mover) 1) (mapEntry "PipsP2" (last To)) (mapEntry "PipsP1" (last To))))))}))) (move (from) (to (union {(intersection {(difference (if (= 1 (size Stack at:(from))) (sites "Rings") (sites "RingsplusT")) (from)) (sites Empty) (sites {(mapEntry "Step7a" (from)) (mapEntry "Step7b" (from)) (mapEntry "Step9c" (from)) (mapEntry "Step9d" (from)) (mapEntry "Step9e" (from)) (mapEntry "Step9f" (from)) (mapEntry (from)) (mapEntry (from))})}) (intersection {(sites "Rings") (sites Occupied by:Next) (sites {(mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step7a" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step7b" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step9c" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step9d" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step9e" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step9f" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry (from))})})})) stack:True (then (and {(set Var "StartS" 3) (set Var "CntrAttack" 0) (if (= 15 (last To)) (and {(add (piece (id "Starter" Mover)) (to (sites Mover "Base")) count:(count Stack at:(last To) if:(= (id "Cone" Mover) (what at:(to) level:(level)))) stack:True) (add (piece (id "Prisoner" Mover)) (to (sites Mover "Prison")) count:(count Stack at:(last To) if:(= (id "Cone" Next) (what at:(to) level:(level)))) stack:True) (remove 15 count:(count Stack at:(last To)))}) (if (and (is Friend (who at:(mapEntry "SameColor" (last To)))) (not (no Pieces in:(sites Mover "Reserve")))) (and (remove (sites Mover "Reserve")) (add (piece (id "Starter" Mover)) (to (sites Mover "Base")) stack:True)))) (set Value at:(last To) (count Stack at:(last To))) (addScore Mover (- (if (= (id Mover) 1) (mapEntry "PipsP1" (last To)) (mapEntry "PipsP2" (last To))) (if (= (id Mover) 1) (mapEntry "PipsP1" (last From)) (mapEntry "PipsP2" (last From))))) (if (> (size Stack at:(last To)) (value Piece at:(last To))) (addScore Next (- 0 (if (= (id Mover) 1) (mapEntry "PipsP2" (last To)) (mapEntry "PipsP1" (last To))))))})))) (if (= (score Mover) 10) (move (from) (to (union {(intersection {(difference (if (= 1 (size Stack at:(from))) (sites "Rings") (sites "RingsplusT")) (from)) (sites Empty) (sites {(mapEntry "Step2a" (from)) (mapEntry "Step2b" (from)) (mapEntry "Step10c" (from)) (mapEntry "Step10d" (from)) (mapEntry "Step10e" (from)) (mapEntry (from)) (mapEntry (from)) (mapEntry (from))})}) (intersection {(sites "Rings") (sites Occupied by:Next) (sites {(mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step2a" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step2b" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step10c" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step10d" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step10e" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry (from))})})})) stack:True (then (and {(set Var "StartS" 3) (set Var "CntrAttack" 0) (if (= 15 (last To)) (and {(add (piece (id "Starter" Mover)) (to (sites Mover "Base")) count:(count Stack at:(last To) if:(= (id "Cone" Mover) (what at:(to) level:(level)))) stack:True) (add (piece (id "Prisoner" Mover)) (to (sites Mover "Prison")) count:(count Stack at:(last To) if:(= (id "Cone" Next) (what at:(to) level:(level)))) stack:True) (remove 15 count:(count Stack at:(last To)))}) (if (and (is Friend (who at:(mapEntry "SameColor" (last To)))) (not (no Pieces in:(sites Mover "Reserve")))) (and (remove (sites Mover "Reserve")) (add (piece (id "Starter" Mover)) (to (sites Mover "Base")) stack:True)))) (set Value at:(last To) (count Stack at:(last To))) (addScore Mover (- (if (= (id Mover) 1) (mapEntry "PipsP1" (last To)) (mapEntry "PipsP2" (last To))) (if (= (id Mover) 1) (mapEntry "PipsP1" (last From)) (mapEntry "PipsP2" (last From))))) (if (> (size Stack at:(last To)) (value Piece at:(last To))) (addScore Next (- 0 (if (= (id Mover) 1) (mapEntry "PipsP2" (last To)) (mapEntry "PipsP1" (last To))))))}))) (move (from) (to (union {(intersection {(difference (if (= 1 (size Stack at:(from))) (sites "Rings") (sites "RingsplusT")) (from)) (sites Empty) (sites {(mapEntry "Step3a" (from)) (mapEntry "Step3b" (from)) (mapEntry "Step11c" (from)) (mapEntry "Step11d" (from)) (mapEntry "Step11e" (from)) (mapEntry "Step11f" (from)) (mapEntry "Step11g" (from)) (mapEntry (from))})}) (intersection {(sites "Rings") (sites Occupied by:Next) (sites {(mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step3a" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step3b" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step11c" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step11d" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step11e" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step11f" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step11g" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry (from))})})})) stack:True (then (and {(set Var "StartS" 3) (set Var "CntrAttack" 0) (if (= 15 (last To)) (and {(add (piece (id "Starter" Mover)) (to (sites Mover "Base")) count:(count Stack at:(last To) if:(= (id "Cone" Mover) (what at:(to) level:(level)))) stack:True) (add (piece (id "Prisoner" Mover)) (to (sites Mover "Prison")) count:(count Stack at:(last To) if:(= (id "Cone" Next) (what at:(to) level:(level)))) stack:True) (remove 15 count:(count Stack at:(last To)))}) (if (and (is Friend (who at:(mapEntry "SameColor" (last To)))) (not (no Pieces in:(sites Mover "Reserve")))) (and (remove (sites Mover "Reserve")) (add (piece (id "Starter" Mover)) (to (sites Mover "Base")) stack:True)))) (set Value at:(last To) (count Stack at:(last To))) (addScore Mover (- (if (= (id Mover) 1) (mapEntry "PipsP1" (last To)) (mapEntry "PipsP2" (last To))) (if (= (id Mover) 1) (mapEntry "PipsP1" (last From)) (mapEntry "PipsP2" (last From))))) (if (> (size Stack at:(last To)) (value Piece at:(last To))) (addScore Next (- 0 (if (= (id Mover) 1) (mapEntry "PipsP2" (last To)) (mapEntry "PipsP1" (last To))))))}))))) (if (< (score Mover) 14) (if (= (score Mover) 12) (move (from) (to (union {(intersection {(difference (if (= 1 (size Stack at:(from))) (sites "Rings") (sites "RingsplusT")) (from)) (sites Empty) (sites {(mapEntry "Step4a" (from)) (mapEntry "Step12b" (from)) (mapEntry "Step12c" (from)) (mapEntry "Step12d" (from)) (mapEntry "Step12e" (from)) (mapEntry "Step12f" (from)) (mapEntry (from)) (mapEntry (from))})}) (intersection {(sites "Rings") (sites Occupied by:Next) (sites {(mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step4a" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step12b" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step12c" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step12d" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step12e" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step12f" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "Step12g" (from))})})})) stack:True (then (and {(set Var "StartS" 3) (set Var "CntrAttack" 0) (if (= 15 (last To)) (and {(add (piece (id "Starter" Mover)) (to (sites Mover "Base")) count:(count Stack at:(last To) if:(= (id "Cone" Mover) (what at:(to) level:(level)))) stack:True) (add (piece (id "Prisoner" Mover)) (to (sites Mover "Prison")) count:(count Stack at:(last To) if:(= (id "Cone" Next) (what at:(to) level:(level)))) stack:True) (remove 15 count:(count Stack at:(last To)))}) (if (and (is Friend (who at:(mapEntry "SameColor" (last To)))) (not (no Pieces in:(sites Mover "Reserve")))) (and (remove (sites Mover "Reserve")) (add (piece (id "Starter" Mover)) (to (sites Mover "Base")) stack:True)))) (set Value at:(last To) (count Stack at:(last To))) (addScore Mover (- (if (= (id Mover) 1) (mapEntry "PipsP1" (last To)) (mapEntry "PipsP2" (last To))) (if (= (id Mover) 1) (mapEntry "PipsP1" (last From)) (mapEntry "PipsP2" (last From))))) (if (> (size Stack at:(last To)) (value Piece at:(last To))) (addScore Next (- 0 (if (= (id Mover) 1) (mapEntry "PipsP2" (last To)) (mapEntry "PipsP1" (last To))))))}))) (move (from) (to (union {(intersection {(difference (if (= 1 (size Stack at:(from))) (sites "Rings") (sites "RingsplusT")) (from)) (sites Empty) (sites {(mapEntry "Step3a" (from)) (mapEntry "Step3b" (from)) (mapEntry "Step13c" (from)) (mapEntry "Step13d" (from)) (mapEntry "Step13e" (from)) (mapEntry "Step13f" (from)) (mapEntry "Step11g" (from)) (mapEntry (from))})}) (intersection {(sites "Rings") (sites Occupied by:Next) (sites {(mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step3a" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step3b" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step13c" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step13d" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step13e" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step13f" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step11g" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry (from))})})})) stack:True (then (and {(set Var "StartS" 3) (set Var "CntrAttack" 0) (if (= 15 (last To)) (and {(add (piece (id "Starter" Mover)) (to (sites Mover "Base")) count:(count Stack at:(last To) if:(= (id "Cone" Mover) (what at:(to) level:(level)))) stack:True) (add (piece (id "Prisoner" Mover)) (to (sites Mover "Prison")) count:(count Stack at:(last To) if:(= (id "Cone" Next) (what at:(to) level:(level)))) stack:True) (remove 15 count:(count Stack at:(last To)))}) (if (and (is Friend (who at:(mapEntry "SameColor" (last To)))) (not (no Pieces in:(sites Mover "Reserve")))) (and (remove (sites Mover "Reserve")) (add (piece (id "Starter" Mover)) (to (sites Mover "Base")) stack:True)))) (set Value at:(last To) (count Stack at:(last To))) (addScore Mover (- (if (= (id Mover) 1) (mapEntry "PipsP1" (last To)) (mapEntry "PipsP2" (last To))) (if (= (id Mover) 1) (mapEntry "PipsP1" (last From)) (mapEntry "PipsP2" (last From))))) (if (> (size Stack at:(last To)) (value Piece at:(last To))) (addScore Next (- 0 (if (= (id Mover) 1) (mapEntry "PipsP2" (last To)) (mapEntry "PipsP1" (last To))))))})))) (if (= (score Mover) 14) (move (from) (to (union {(intersection {(difference (if (= 1 (size Stack at:(from))) (sites "Rings") (sites "RingsplusT")) (from)) (sites Empty) (sites {(mapEntry "Step2a" (from)) (mapEntry "Step2b" (from)) (mapEntry "Step14c" (from)) (mapEntry "Step14d" (from)) (mapEntry "Step14e" (from)) (mapEntry (from)) (mapEntry (from)) (mapEntry (from))})}) (intersection {(sites "Rings") (sites Occupied by:Next) (sites {(mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step2a" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step2b" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step14c" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step14d" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step14e" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "Step14f" (from))})})})) stack:True (then (and {(set Var "StartS" 3) (set Var "CntrAttack" 0) (if (= 15 (last To)) (and {(add (piece (id "Starter" Mover)) (to (sites Mover "Base")) count:(count Stack at:(last To) if:(= (id "Cone" Mover) (what at:(to) level:(level)))) stack:True) (add (piece (id "Prisoner" Mover)) (to (sites Mover "Prison")) count:(count Stack at:(last To) if:(= (id "Cone" Next) (what at:(to) level:(level)))) stack:True) (remove 15 count:(count Stack at:(last To)))}) (if (and (is Friend (who at:(mapEntry "SameColor" (last To)))) (not (no Pieces in:(sites Mover "Reserve")))) (and (remove (sites Mover "Reserve")) (add (piece (id "Starter" Mover)) (to (sites Mover "Base")) stack:True)))) (set Value at:(last To) (count Stack at:(last To))) (addScore Mover (- (if (= (id Mover) 1) (mapEntry "PipsP1" (last To)) (mapEntry "PipsP2" (last To))) (if (= (id Mover) 1) (mapEntry "PipsP1" (last From)) (mapEntry "PipsP2" (last From))))) (if (> (size Stack at:(last To)) (value Piece at:(last To))) (addScore Next (- 0 (if (= (id Mover) 1) (mapEntry "PipsP2" (last To)) (mapEntry "PipsP1" (last To))))))}))) (move (from) (to (union {(intersection {(difference (if (= 1 (size Stack at:(from))) (sites "Rings") (sites "RingsplusT")) (from)) (sites Empty) (sites {(mapEntry "Step7a" (from)) (mapEntry "Step7b" (from)) (mapEntry "Step15c" (from)) (mapEntry "Step15d" (from)) (mapEntry "Step15e" (from)) (mapEntry "Step15f" (from)) (mapEntry "Step11f" (from)) (mapEntry "Step11g" (from))})}) (intersection {(sites "Rings") (sites Occupied by:Next) (sites {(mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step7a" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step7b" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step15c" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step15d" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step15e" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step15f" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step11f" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step11g" (from))})) index:0)) (mapEntry (from))})})})) stack:True (then (and {(set Var "StartS" 3) (set Var "CntrAttack" 0) (if (= 15 (last To)) (and {(add (piece (id "Starter" Mover)) (to (sites Mover "Base")) count:(count Stack at:(last To) if:(= (id "Cone" Mover) (what at:(to) level:(level)))) stack:True) (add (piece (id "Prisoner" Mover)) (to (sites Mover "Prison")) count:(count Stack at:(last To) if:(= (id "Cone" Next) (what at:(to) level:(level)))) stack:True) (remove 15 count:(count Stack at:(last To)))}) (if (and (is Friend (who at:(mapEntry "SameColor" (last To)))) (not (no Pieces in:(sites Mover "Reserve")))) (and (remove (sites Mover "Reserve")) (add (piece (id "Starter" Mover)) (to (sites Mover "Base")) stack:True)))) (set Value at:(last To) (count Stack at:(last To))) (addScore Mover (- (if (= (id Mover) 1) (mapEntry "PipsP1" (last To)) (mapEntry "PipsP2" (last To))) (if (= (id Mover) 1) (mapEntry "PipsP1" (last From)) (mapEntry "PipsP2" (last From))))) (if (> (size Stack at:(last To)) (value Piece at:(last To))) (addScore Next (- 0 (if (= (id Mover) 1) (mapEntry "PipsP2" (last To)) (mapEntry "PipsP1" (last To))))))}))))))) (if (< (score Mover) 20) (if (< (score Mover) 18) (if (= (score Mover) 16) (move (from) (to (union {(intersection {(difference (if (= 1 (size Stack at:(from))) (sites "Rings") (sites "RingsplusT")) (from)) (sites Empty) (sites {(mapEntry "Step8a" (from)) (mapEntry "Step8b" (from)) (mapEntry "Step16c" (from)) (mapEntry "Step16d" (from)) (mapEntry "Step16e" (from)) (mapEntry "Step16f" (from)) (mapEntry "Step16g" (from)) (mapEntry (from))})}) (intersection {(sites "Rings") (sites Occupied by:Next) (sites {(mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step8a" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step8b" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step16c" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step16d" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step16e" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step16f" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step16g" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (from))})})})) stack:True (then (and {(set Var "StartS" 3) (set Var "CntrAttack" 0) (if (= 15 (last To)) (and {(add (piece (id "Starter" Mover)) (to (sites Mover "Base")) count:(count Stack at:(last To) if:(= (id "Cone" Mover) (what at:(to) level:(level)))) stack:True) (add (piece (id "Prisoner" Mover)) (to (sites Mover "Prison")) count:(count Stack at:(last To) if:(= (id "Cone" Next) (what at:(to) level:(level)))) stack:True) (remove 15 count:(count Stack at:(last To)))}) (if (and (is Friend (who at:(mapEntry "SameColor" (last To)))) (not (no Pieces in:(sites Mover "Reserve")))) (and (remove (sites Mover "Reserve")) (add (piece (id "Starter" Mover)) (to (sites Mover "Base")) stack:True)))) (set Value at:(last To) (count Stack at:(last To))) (addScore Mover (- (if (= (id Mover) 1) (mapEntry "PipsP1" (last To)) (mapEntry "PipsP2" (last To))) (if (= (id Mover) 1) (mapEntry "PipsP1" (last From)) (mapEntry "PipsP2" (last From))))) (if (> (size Stack at:(last To)) (value Piece at:(last To))) (addScore Next (- 0 (if (= (id Mover) 1) (mapEntry "PipsP2" (last To)) (mapEntry "PipsP1" (last To))))))}))) (move (from) (to (union {(intersection {(difference (if (= 1 (size Stack at:(from))) (sites "Rings") (sites "RingsplusT")) (from)) (sites Empty) (sites {(mapEntry "Step7a" (from)) (mapEntry "Step7b" (from)) (mapEntry "Step17c" (from)) (mapEntry "Step17d" (from)) (mapEntry "Step17e" (from)) (mapEntry "Step17f" (from)) (mapEntry "Step17g" (from)) (mapEntry "Step17h" (from))})}) (intersection {(sites "Rings") (sites Occupied by:Next) (sites {(mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step7a" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step7b" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step17c" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step17d" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step17e" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step17f" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step17g" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step17h" (from))})) index:0)) (mapEntry (from))})})})) stack:True (then (and {(set Var "StartS" 3) (set Var "CntrAttack" 0) (if (= 15 (last To)) (and {(add (piece (id "Starter" Mover)) (to (sites Mover "Base")) count:(count Stack at:(last To) if:(= (id "Cone" Mover) (what at:(to) level:(level)))) stack:True) (add (piece (id "Prisoner" Mover)) (to (sites Mover "Prison")) count:(count Stack at:(last To) if:(= (id "Cone" Next) (what at:(to) level:(level)))) stack:True) (remove 15 count:(count Stack at:(last To)))}) (if (and (is Friend (who at:(mapEntry "SameColor" (last To)))) (not (no Pieces in:(sites Mover "Reserve")))) (and (remove (sites Mover "Reserve")) (add (piece (id "Starter" Mover)) (to (sites Mover "Base")) stack:True)))) (set Value at:(last To) (count Stack at:(last To))) (addScore Mover (- (if (= (id Mover) 1) (mapEntry "PipsP1" (last To)) (mapEntry "PipsP2" (last To))) (if (= (id Mover) 1) (mapEntry "PipsP1" (last From)) (mapEntry "PipsP2" (last From))))) (if (> (size Stack at:(last To)) (value Piece at:(last To))) (addScore Next (- 0 (if (= (id Mover) 1) (mapEntry "PipsP2" (last To)) (mapEntry "PipsP1" (last To))))))})))) (if (= (score Mover) 18) (move (from) (to (union {(intersection {(difference (if (= 1 (size Stack at:(from))) (sites "Rings") (sites "RingsplusT")) (from)) (sites Empty) (sites {(mapEntry "Step2a" (from)) (mapEntry "Step2b" (from)) (mapEntry "Step18c" (from)) (mapEntry "Step18d" (from)) (mapEntry "Step18e" (from)) (mapEntry "Step18f" (from)) (mapEntry (from)) (mapEntry (from))})}) (intersection {(sites "Rings") (sites Occupied by:Next) (sites {(mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step2a" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step2b" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step18c" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step18d" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step18e" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step18f" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "Step18g" (from))})})})) stack:True (then (and {(set Var "StartS" 3) (set Var "CntrAttack" 0) (if (= 15 (last To)) (and {(add (piece (id "Starter" Mover)) (to (sites Mover "Base")) count:(count Stack at:(last To) if:(= (id "Cone" Mover) (what at:(to) level:(level)))) stack:True) (add (piece (id "Prisoner" Mover)) (to (sites Mover "Prison")) count:(count Stack at:(last To) if:(= (id "Cone" Next) (what at:(to) level:(level)))) stack:True) (remove 15 count:(count Stack at:(last To)))}) (if (and (is Friend (who at:(mapEntry "SameColor" (last To)))) (not (no Pieces in:(sites Mover "Reserve")))) (and (remove (sites Mover "Reserve")) (add (piece (id "Starter" Mover)) (to (sites Mover "Base")) stack:True)))) (set Value at:(last To) (count Stack at:(last To))) (addScore Mover (- (if (= (id Mover) 1) (mapEntry "PipsP1" (last To)) (mapEntry "PipsP2" (last To))) (if (= (id Mover) 1) (mapEntry "PipsP1" (last From)) (mapEntry "PipsP2" (last From))))) (if (> (size Stack at:(last To)) (value Piece at:(last To))) (addScore Next (- 0 (if (= (id Mover) 1) (mapEntry "PipsP2" (last To)) (mapEntry "PipsP1" (last To))))))}))) (and (move (from) (to (union {(intersection {(difference (if (= 1 (size Stack at:(from))) (sites "Rings") (sites "RingsplusT")) (from)) (sites Empty) (sites {(mapEntry "Step3a" (from)) (mapEntry "Step3b" (from)) (mapEntry "Step19c" (from)) (mapEntry "Step19d" (from)) (mapEntry "Step19e" (from)) (mapEntry "Step19f" (from)) (mapEntry "Step19g" (from)) (mapEntry "Step19h" (from))})}) (intersection {(sites "Rings") (sites Occupied by:Next) (sites {(mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step3a" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step3b" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step19c" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step19d" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step19e" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step19f" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step19g" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step19h" (from))})) index:0)) (mapEntry (from))})})})) stack:True (then (and {(set Var "StartS" 3) (set Var "CntrAttack" 0) (if (= 15 (last To)) (and {(add (piece (id "Starter" Mover)) (to (sites Mover "Base")) count:(count Stack at:(last To) if:(= (id "Cone" Mover) (what at:(to) level:(level)))) stack:True) (add (piece (id "Prisoner" Mover)) (to (sites Mover "Prison")) count:(count Stack at:(last To) if:(= (id "Cone" Next) (what at:(to) level:(level)))) stack:True) (remove 15 count:(count Stack at:(last To)))}) (if (and (is Friend (who at:(mapEntry "SameColor" (last To)))) (not (no Pieces in:(sites Mover "Reserve")))) (and (remove (sites Mover "Reserve")) (add (piece (id "Starter" Mover)) (to (sites Mover "Base")) stack:True)))) (set Value at:(last To) (count Stack at:(last To))) (addScore Mover (- (if (= (id Mover) 1) (mapEntry "PipsP1" (last To)) (mapEntry "PipsP2" (last To))) (if (= (id Mover) 1) (mapEntry "PipsP1" (last From)) (mapEntry "PipsP2" (last From))))) (if (> (size Stack at:(last To)) (value Piece at:(last To))) (addScore Next (- 0 (if (= (id Mover) 1) (mapEntry "PipsP2" (last To)) (mapEntry "PipsP1" (last To))))))}))) (move (from) (to (union {(intersection {(difference (if (= 1 (size Stack at:(from))) (sites "Rings") (sites "RingsplusT")) (from)) (sites Empty) (sites {(mapEntry "Step19i" (from)) (mapEntry (from)) (mapEntry (from)) (mapEntry (from)) (mapEntry (from)) (mapEntry (from)) (mapEntry (from)) (mapEntry (from))})}) (intersection {(sites "Rings") (sites Occupied by:Next) (sites {(mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step19i" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry (from))})})})) stack:True (then (and {(set Var "StartS" 3) (set Var "CntrAttack" 0) (if (= 15 (last To)) (and {(add (piece (id "Starter" Mover)) (to (sites Mover "Base")) count:(count Stack at:(last To) if:(= (id "Cone" Mover) (what at:(to) level:(level)))) stack:True) (add (piece (id "Prisoner" Mover)) (to (sites Mover "Prison")) count:(count Stack at:(last To) if:(= (id "Cone" Next) (what at:(to) level:(level)))) stack:True) (remove 15 count:(count Stack at:(last To)))}) (if (and (is Friend (who at:(mapEntry "SameColor" (last To)))) (not (no Pieces in:(sites Mover "Reserve")))) (and (remove (sites Mover "Reserve")) (add (piece (id "Starter" Mover)) (to (sites Mover "Base")) stack:True)))) (set Value at:(last To) (count Stack at:(last To))) (addScore Mover (- (if (= (id Mover) 1) (mapEntry "PipsP1" (last To)) (mapEntry "PipsP2" (last To))) (if (= (id Mover) 1) (mapEntry "PipsP1" (last From)) (mapEntry "PipsP2" (last From))))) (if (> (size Stack at:(last To)) (value Piece at:(last To))) (addScore Next (- 0 (if (= (id Mover) 1) (mapEntry "PipsP2" (last To)) (mapEntry "PipsP1" (last To))))))})))))) (if (= 20 (score Mover)) (move (from) (to (union {(intersection {(difference (if (= 1 (size Stack at:(from))) (sites "Rings") (sites "RingsplusT")) (from)) (sites Empty) (sites {(mapEntry "Step4a" (from)) (mapEntry "Step20b" (from)) (mapEntry "Step20c" (from)) (mapEntry "Step20d" (from)) (mapEntry "Step20e" (from)) (mapEntry "Step20f" (from)) (mapEntry "Step20g" (from)) (mapEntry (from))})}) (intersection {(sites "Rings") (sites Occupied by:Next) (sites {(mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step4a" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step20b" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step20c" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step20d" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step20e" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step20f" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step20g" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (from))})})})) stack:True (then (and {(set Var "StartS" 3) (set Var "CntrAttack" 0) (if (= 15 (last To)) (and {(add (piece (id "Starter" Mover)) (to (sites Mover "Base")) count:(count Stack at:(last To) if:(= (id "Cone" Mover) (what at:(to) level:(level)))) stack:True) (add (piece (id "Prisoner" Mover)) (to (sites Mover "Prison")) count:(count Stack at:(last To) if:(= (id "Cone" Next) (what at:(to) level:(level)))) stack:True) (remove 15 count:(count Stack at:(last To)))}) (if (and (is Friend (who at:(mapEntry "SameColor" (last To)))) (not (no Pieces in:(sites Mover "Reserve")))) (and (remove (sites Mover "Reserve")) (add (piece (id "Starter" Mover)) (to (sites Mover "Base")) stack:True)))) (set Value at:(last To) (count Stack at:(last To))) (addScore Mover (- (if (= (id Mover) 1) (mapEntry "PipsP1" (last To)) (mapEntry "PipsP2" (last To))) (if (= (id Mover) 1) (mapEntry "PipsP1" (last From)) (mapEntry "PipsP2" (last From))))) (if (> (size Stack at:(last To)) (value Piece at:(last To))) (addScore Next (- 0 (if (= (id Mover) 1) (mapEntry "PipsP2" (last To)) (mapEntry "PipsP1" (last To))))))}))))))) (if (< (score Mover) 16) (if (< (score Mover) 8) (if (< (score Mover) 4) (if (< (score Mover) 2) (if (= (score Mover) 1) (move (from) (to (union {(intersection {(difference (if (= 1 (size Stack at:(from))) (sites "Rings") (sites "RingsplusT")) (from)) (sites Empty) (sites {(mapEntry "Step7a" (from)) (mapEntry "Step7b" (from)) (mapEntry "Step1c" (from)) (mapEntry (from)) (mapEntry (from)) (mapEntry (from)) (mapEntry (from)) (mapEntry (from))})}) (intersection {(sites "Rings") (sites Occupied by:Next) (sites {(mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step7a" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step7b" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step1c" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry (from))})})})) stack:True (then (and {(set Var "StartS" 3) (set Var "CntrAttack" 0) (if (= 15 (last To)) (and {(add (piece (id "Starter" Mover)) (to (sites Mover "Base")) count:(count Stack at:(last To) if:(= (id "Cone" Mover) (what at:(to) level:(level)))) stack:True) (add (piece (id "Prisoner" Mover)) (to (sites Mover "Prison")) count:(count Stack at:(last To) if:(= (id "Cone" Next) (what at:(to) level:(level)))) stack:True) (remove 15 count:(count Stack at:(last To)))}) (if (and (is Friend (who at:(mapEntry "SameColor" (last To)))) (not (no Pieces in:(sites Mover "Reserve")))) (and (remove (sites Mover "Reserve")) (add (piece (id "Starter" Mover)) (to (sites Mover "Base")) stack:True)))) (set Value at:(last To) (count Stack at:(last To))) (addScore Mover (- (if (= (id Mover) 1) (mapEntry "PipsP1" (last To)) (mapEntry "PipsP2" (last To))) (if (= (id Mover) 1) (mapEntry "PipsP1" (last From)) (mapEntry "PipsP2" (last From))))) (if (> (size Stack at:(last To)) (value Piece at:(last To))) (addScore Next (- 0 (if (= (id Mover) 1) (mapEntry "PipsP2" (last To)) (mapEntry "PipsP1" (last To))))))})))) (if (= (score Mover) 2) (move (from) (to (union {(intersection {(difference (if (= 1 (size Stack at:(from))) (sites "Rings") (sites "RingsplusT")) (from)) (sites Empty) (sites {(mapEntry "Step2a" (from)) (mapEntry "Step2b" (from)) (mapEntry "Step2c" (from)) (mapEntry (from)) (mapEntry (from)) (mapEntry (from)) (mapEntry (from)) (mapEntry (from))})}) (intersection {(sites "Rings") (sites Occupied by:Next) (sites {(mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step2a" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step2b" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step2c" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry (from))})})})) stack:True (then (and {(set Var "StartS" 3) (set Var "CntrAttack" 0) (if (= 15 (last To)) (and {(add (piece (id "Starter" Mover)) (to (sites Mover "Base")) count:(count Stack at:(last To) if:(= (id "Cone" Mover) (what at:(to) level:(level)))) stack:True) (add (piece (id "Prisoner" Mover)) (to (sites Mover "Prison")) count:(count Stack at:(last To) if:(= (id "Cone" Next) (what at:(to) level:(level)))) stack:True) (remove 15 count:(count Stack at:(last To)))}) (if (and (is Friend (who at:(mapEntry "SameColor" (last To)))) (not (no Pieces in:(sites Mover "Reserve")))) (and (remove (sites Mover "Reserve")) (add (piece (id "Starter" Mover)) (to (sites Mover "Base")) stack:True)))) (set Value at:(last To) (count Stack at:(last To))) (addScore Mover (- (if (= (id Mover) 1) (mapEntry "PipsP1" (last To)) (mapEntry "PipsP2" (last To))) (if (= (id Mover) 1) (mapEntry "PipsP1" (last From)) (mapEntry "PipsP2" (last From))))) (if (> (size Stack at:(last To)) (value Piece at:(last To))) (addScore Next (- 0 (if (= (id Mover) 1) (mapEntry "PipsP2" (last To)) (mapEntry "PipsP1" (last To))))))}))) (move (from) (to (union {(intersection {(difference (if (= 1 (size Stack at:(from))) (sites "Rings") (sites "RingsplusT")) (from)) (sites Empty) (sites {(mapEntry "Step3a" (from)) (mapEntry "Step3b" (from)) (mapEntry "Step3c" (from)) (mapEntry "Step3d" (from)) (mapEntry (from)) (mapEntry (from)) (mapEntry (from)) (mapEntry (from))})}) (intersection {(sites "Rings") (sites Occupied by:Next) (sites {(mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step3a" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step3b" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step3c" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step3d" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry (from))})})})) stack:True (then (and {(set Var "StartS" 3) (set Var "CntrAttack" 0) (if (= 15 (last To)) (and {(add (piece (id "Starter" Mover)) (to (sites Mover "Base")) count:(count Stack at:(last To) if:(= (id "Cone" Mover) (what at:(to) level:(level)))) stack:True) (add (piece (id "Prisoner" Mover)) (to (sites Mover "Prison")) count:(count Stack at:(last To) if:(= (id "Cone" Next) (what at:(to) level:(level)))) stack:True) (remove 15 count:(count Stack at:(last To)))}) (if (and (is Friend (who at:(mapEntry "SameColor" (last To)))) (not (no Pieces in:(sites Mover "Reserve")))) (and (remove (sites Mover "Reserve")) (add (piece (id "Starter" Mover)) (to (sites Mover "Base")) stack:True)))) (set Value at:(last To) (count Stack at:(last To))) (addScore Mover (- (if (= (id Mover) 1) (mapEntry "PipsP1" (last To)) (mapEntry "PipsP2" (last To))) (if (= (id Mover) 1) (mapEntry "PipsP1" (last From)) (mapEntry "PipsP2" (last From))))) (if (> (size Stack at:(last To)) (value Piece at:(last To))) (addScore Next (- 0 (if (= (id Mover) 1) (mapEntry "PipsP2" (last To)) (mapEntry "PipsP1" (last To))))))}))))) (if (< (score Mover) 6) (if (= (score Mover) 4) (move (from) (to (union {(intersection {(difference (if (= 1 (size Stack at:(from))) (sites "Rings") (sites "RingsplusT")) (from)) (sites Empty) (sites {(mapEntry "Step4a" (from)) (mapEntry "Step4b" (from)) (mapEntry "Step4c" (from)) (mapEntry (from)) (mapEntry (from)) (mapEntry (from)) (mapEntry (from)) (mapEntry (from))})}) (intersection {(sites "Rings") (sites Occupied by:Next) (sites {(mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step4a" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step4b" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step4c" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry (from))})})})) stack:True (then (and {(set Var "StartS" 3) (set Var "CntrAttack" 0) (if (= 15 (last To)) (and {(add (piece (id "Starter" Mover)) (to (sites Mover "Base")) count:(count Stack at:(last To) if:(= (id "Cone" Mover) (what at:(to) level:(level)))) stack:True) (add (piece (id "Prisoner" Mover)) (to (sites Mover "Prison")) count:(count Stack at:(last To) if:(= (id "Cone" Next) (what at:(to) level:(level)))) stack:True) (remove 15 count:(count Stack at:(last To)))}) (if (and (is Friend (who at:(mapEntry "SameColor" (last To)))) (not (no Pieces in:(sites Mover "Reserve")))) (and (remove (sites Mover "Reserve")) (add (piece (id "Starter" Mover)) (to (sites Mover "Base")) stack:True)))) (set Value at:(last To) (count Stack at:(last To))) (addScore Mover (- (if (= (id Mover) 1) (mapEntry "PipsP1" (last To)) (mapEntry "PipsP2" (last To))) (if (= (id Mover) 1) (mapEntry "PipsP1" (last From)) (mapEntry "PipsP2" (last From))))) (if (> (size Stack at:(last To)) (value Piece at:(last To))) (addScore Next (- 0 (if (= (id Mover) 1) (mapEntry "PipsP2" (last To)) (mapEntry "PipsP1" (last To))))))}))) (move (from) (to (union {(intersection {(difference (if (= 1 (size Stack at:(from))) (sites "Rings") (sites "RingsplusT")) (from)) (sites Empty) (sites {(mapEntry "Step3a" (from)) (mapEntry "Step3b" (from)) (mapEntry "Step5c" (from)) (mapEntry "Step5d" (from)) (mapEntry (from)) (mapEntry (from)) (mapEntry (from)) (mapEntry (from))})}) (intersection {(sites "Rings") (sites Occupied by:Next) (sites {(mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step3a" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step3b" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step5c" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step5d" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry (from))})})})) stack:True (then (and {(set Var "StartS" 3) (set Var "CntrAttack" 0) (if (= 15 (last To)) (and {(add (piece (id "Starter" Mover)) (to (sites Mover "Base")) count:(count Stack at:(last To) if:(= (id "Cone" Mover) (what at:(to) level:(level)))) stack:True) (add (piece (id "Prisoner" Mover)) (to (sites Mover "Prison")) count:(count Stack at:(last To) if:(= (id "Cone" Next) (what at:(to) level:(level)))) stack:True) (remove 15 count:(count Stack at:(last To)))}) (if (and (is Friend (who at:(mapEntry "SameColor" (last To)))) (not (no Pieces in:(sites Mover "Reserve")))) (and (remove (sites Mover "Reserve")) (add (piece (id "Starter" Mover)) (to (sites Mover "Base")) stack:True)))) (set Value at:(last To) (count Stack at:(last To))) (addScore Mover (- (if (= (id Mover) 1) (mapEntry "PipsP1" (last To)) (mapEntry "PipsP2" (last To))) (if (= (id Mover) 1) (mapEntry "PipsP1" (last From)) (mapEntry "PipsP2" (last From))))) (if (> (size Stack at:(last To)) (value Piece at:(last To))) (addScore Next (- 0 (if (= (id Mover) 1) (mapEntry "PipsP2" (last To)) (mapEntry "PipsP1" (last To))))))})))) (if (= (score Mover) 6) (move (from) (to (union {(intersection {(difference (if (= 1 (size Stack at:(from))) (sites "Rings") (sites "RingsplusT")) (from)) (sites Empty) (sites {(mapEntry "Step2a" (from)) (mapEntry "Step2b" (from)) (mapEntry "Step6c" (from)) (mapEntry "Step6d" (from)) (mapEntry "Step6e" (from)) (mapEntry (from)) (mapEntry (from)) (mapEntry (from))})}) (intersection {(sites "Rings") (sites Occupied by:Next) (sites {(mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step2a" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step2b" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step6c" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step6d" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step6e" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry (from))})})})) stack:True (then (and {(set Var "StartS" 3) (set Var "CntrAttack" 0) (if (= 15 (last To)) (and {(add (piece (id "Starter" Mover)) (to (sites Mover "Base")) count:(count Stack at:(last To) if:(= (id "Cone" Mover) (what at:(to) level:(level)))) stack:True) (add (piece (id "Prisoner" Mover)) (to (sites Mover "Prison")) count:(count Stack at:(last To) if:(= (id "Cone" Next) (what at:(to) level:(level)))) stack:True) (remove 15 count:(count Stack at:(last To)))}) (if (and (is Friend (who at:(mapEntry "SameColor" (last To)))) (not (no Pieces in:(sites Mover "Reserve")))) (and (remove (sites Mover "Reserve")) (add (piece (id "Starter" Mover)) (to (sites Mover "Base")) stack:True)))) (set Value at:(last To) (count Stack at:(last To))) (addScore Mover (- (if (= (id Mover) 1) (mapEntry "PipsP1" (last To)) (mapEntry "PipsP2" (last To))) (if (= (id Mover) 1) (mapEntry "PipsP1" (last From)) (mapEntry "PipsP2" (last From))))) (if (> (size Stack at:(last To)) (value Piece at:(last To))) (addScore Next (- 0 (if (= (id Mover) 1) (mapEntry "PipsP2" (last To)) (mapEntry "PipsP1" (last To))))))}))) (move (from) (to (union {(intersection {(difference (if (= 1 (size Stack at:(from))) (sites "Rings") (sites "RingsplusT")) (from)) (sites Empty) (sites {(mapEntry "Step7a" (from)) (mapEntry "Step7b" (from)) (mapEntry "Step7c" (from)) (mapEntry "Step7d" (from)) (mapEntry "Step7e" (from)) (mapEntry (from)) (mapEntry (from)) (mapEntry (from))})}) (intersection {(sites "Rings") (sites Occupied by:Next) (sites {(mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step7a" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step7b" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step7c" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step7d" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step7e" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry (from))})})})) stack:True (then (and {(set Var "StartS" 3) (set Var "CntrAttack" 0) (if (= 15 (last To)) (and {(add (piece (id "Starter" Mover)) (to (sites Mover "Base")) count:(count Stack at:(last To) if:(= (id "Cone" Mover) (what at:(to) level:(level)))) stack:True) (add (piece (id "Prisoner" Mover)) (to (sites Mover "Prison")) count:(count Stack at:(last To) if:(= (id "Cone" Next) (what at:(to) level:(level)))) stack:True) (remove 15 count:(count Stack at:(last To)))}) (if (and (is Friend (who at:(mapEntry "SameColor" (last To)))) (not (no Pieces in:(sites Mover "Reserve")))) (and (remove (sites Mover "Reserve")) (add (piece (id "Starter" Mover)) (to (sites Mover "Base")) stack:True)))) (set Value at:(last To) (count Stack at:(last To))) (addScore Mover (- (if (= (id Mover) 1) (mapEntry "PipsP1" (last To)) (mapEntry "PipsP2" (last To))) (if (= (id Mover) 1) (mapEntry "PipsP1" (last From)) (mapEntry "PipsP2" (last From))))) (if (> (size Stack at:(last To)) (value Piece at:(last To))) (addScore Next (- 0 (if (= (id Mover) 1) (mapEntry "PipsP2" (last To)) (mapEntry "PipsP1" (last To))))))})))))) (if (< (score Mover) 12) (if (< (score Mover) 10) (if (= (score Mover) 8) (move (from) (to (union {(intersection {(difference (if (= 1 (size Stack at:(from))) (sites "Rings") (sites "RingsplusT")) (from)) (sites Empty) (sites {(mapEntry "Step8a" (from)) (mapEntry "Step8b" (from)) (mapEntry "Step8c" (from)) (mapEntry "Step8d" (from)) (mapEntry (from)) (mapEntry (from)) (mapEntry (from)) (mapEntry (from))})}) (intersection {(sites "Rings") (sites Occupied by:Next) (sites {(mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step8a" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step8b" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step8c" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step8d" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (from))})})})) stack:True (then (and {(set Var "StartS" 3) (set Var "CntrAttack" 0) (if (= 15 (last To)) (and {(add (piece (id "Starter" Mover)) (to (sites Mover "Base")) count:(count Stack at:(last To) if:(= (id "Cone" Mover) (what at:(to) level:(level)))) stack:True) (add (piece (id "Prisoner" Mover)) (to (sites Mover "Prison")) count:(count Stack at:(last To) if:(= (id "Cone" Next) (what at:(to) level:(level)))) stack:True) (remove 15 count:(count Stack at:(last To)))}) (if (and (is Friend (who at:(mapEntry "SameColor" (last To)))) (not (no Pieces in:(sites Mover "Reserve")))) (and (remove (sites Mover "Reserve")) (add (piece (id "Starter" Mover)) (to (sites Mover "Base")) stack:True)))) (set Value at:(last To) (count Stack at:(last To))) (addScore Mover (- (if (= (id Mover) 1) (mapEntry "PipsP1" (last To)) (mapEntry "PipsP2" (last To))) (if (= (id Mover) 1) (mapEntry "PipsP1" (last From)) (mapEntry "PipsP2" (last From))))) (if (> (size Stack at:(last To)) (value Piece at:(last To))) (addScore Next (- 0 (if (= (id Mover) 1) (mapEntry "PipsP2" (last To)) (mapEntry "PipsP1" (last To))))))}))) (move (from) (to (union {(intersection {(difference (if (= 1 (size Stack at:(from))) (sites "Rings") (sites "RingsplusT")) (from)) (sites Empty) (sites {(mapEntry "Step7a" (from)) (mapEntry "Step7b" (from)) (mapEntry "Step9c" (from)) (mapEntry "Step9d" (from)) (mapEntry "Step9e" (from)) (mapEntry "Step9f" (from)) (mapEntry (from)) (mapEntry (from))})}) (intersection {(sites "Rings") (sites Occupied by:Next) (sites {(mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step7a" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step7b" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step9c" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step9d" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step9e" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step9f" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry (from))})})})) stack:True (then (and {(set Var "StartS" 3) (set Var "CntrAttack" 0) (if (= 15 (last To)) (and {(add (piece (id "Starter" Mover)) (to (sites Mover "Base")) count:(count Stack at:(last To) if:(= (id "Cone" Mover) (what at:(to) level:(level)))) stack:True) (add (piece (id "Prisoner" Mover)) (to (sites Mover "Prison")) count:(count Stack at:(last To) if:(= (id "Cone" Next) (what at:(to) level:(level)))) stack:True) (remove 15 count:(count Stack at:(last To)))}) (if (and (is Friend (who at:(mapEntry "SameColor" (last To)))) (not (no Pieces in:(sites Mover "Reserve")))) (and (remove (sites Mover "Reserve")) (add (piece (id "Starter" Mover)) (to (sites Mover "Base")) stack:True)))) (set Value at:(last To) (count Stack at:(last To))) (addScore Mover (- (if (= (id Mover) 1) (mapEntry "PipsP1" (last To)) (mapEntry "PipsP2" (last To))) (if (= (id Mover) 1) (mapEntry "PipsP1" (last From)) (mapEntry "PipsP2" (last From))))) (if (> (size Stack at:(last To)) (value Piece at:(last To))) (addScore Next (- 0 (if (= (id Mover) 1) (mapEntry "PipsP2" (last To)) (mapEntry "PipsP1" (last To))))))})))) (if (= (score Mover) 10) (move (from) (to (union {(intersection {(difference (if (= 1 (size Stack at:(from))) (sites "Rings") (sites "RingsplusT")) (from)) (sites Empty) (sites {(mapEntry "Step2a" (from)) (mapEntry "Step2b" (from)) (mapEntry "Step10c" (from)) (mapEntry "Step10d" (from)) (mapEntry "Step10e" (from)) (mapEntry (from)) (mapEntry (from)) (mapEntry (from))})}) (intersection {(sites "Rings") (sites Occupied by:Next) (sites {(mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step2a" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step2b" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step10c" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step10d" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step10e" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry (from))})})})) stack:True (then (and {(set Var "StartS" 3) (set Var "CntrAttack" 0) (if (= 15 (last To)) (and {(add (piece (id "Starter" Mover)) (to (sites Mover "Base")) count:(count Stack at:(last To) if:(= (id "Cone" Mover) (what at:(to) level:(level)))) stack:True) (add (piece (id "Prisoner" Mover)) (to (sites Mover "Prison")) count:(count Stack at:(last To) if:(= (id "Cone" Next) (what at:(to) level:(level)))) stack:True) (remove 15 count:(count Stack at:(last To)))}) (if (and (is Friend (who at:(mapEntry "SameColor" (last To)))) (not (no Pieces in:(sites Mover "Reserve")))) (and (remove (sites Mover "Reserve")) (add (piece (id "Starter" Mover)) (to (sites Mover "Base")) stack:True)))) (set Value at:(last To) (count Stack at:(last To))) (addScore Mover (- (if (= (id Mover) 1) (mapEntry "PipsP1" (last To)) (mapEntry "PipsP2" (last To))) (if (= (id Mover) 1) (mapEntry "PipsP1" (last From)) (mapEntry "PipsP2" (last From))))) (if (> (size Stack at:(last To)) (value Piece at:(last To))) (addScore Next (- 0 (if (= (id Mover) 1) (mapEntry "PipsP2" (last To)) (mapEntry "PipsP1" (last To))))))}))) (move (from) (to (union {(intersection {(difference (if (= 1 (size Stack at:(from))) (sites "Rings") (sites "RingsplusT")) (from)) (sites Empty) (sites {(mapEntry "Step3a" (from)) (mapEntry "Step3b" (from)) (mapEntry "Step11c" (from)) (mapEntry "Step11d" (from)) (mapEntry "Step11e" (from)) (mapEntry "Step11f" (from)) (mapEntry "Step11g" (from)) (mapEntry (from))})}) (intersection {(sites "Rings") (sites Occupied by:Next) (sites {(mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step3a" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step3b" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step11c" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step11d" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step11e" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step11f" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step11g" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry (from))})})})) stack:True (then (and {(set Var "StartS" 3) (set Var "CntrAttack" 0) (if (= 15 (last To)) (and {(add (piece (id "Starter" Mover)) (to (sites Mover "Base")) count:(count Stack at:(last To) if:(= (id "Cone" Mover) (what at:(to) level:(level)))) stack:True) (add (piece (id "Prisoner" Mover)) (to (sites Mover "Prison")) count:(count Stack at:(last To) if:(= (id "Cone" Next) (what at:(to) level:(level)))) stack:True) (remove 15 count:(count Stack at:(last To)))}) (if (and (is Friend (who at:(mapEntry "SameColor" (last To)))) (not (no Pieces in:(sites Mover "Reserve")))) (and (remove (sites Mover "Reserve")) (add (piece (id "Starter" Mover)) (to (sites Mover "Base")) stack:True)))) (set Value at:(last To) (count Stack at:(last To))) (addScore Mover (- (if (= (id Mover) 1) (mapEntry "PipsP1" (last To)) (mapEntry "PipsP2" (last To))) (if (= (id Mover) 1) (mapEntry "PipsP1" (last From)) (mapEntry "PipsP2" (last From))))) (if (> (size Stack at:(last To)) (value Piece at:(last To))) (addScore Next (- 0 (if (= (id Mover) 1) (mapEntry "PipsP2" (last To)) (mapEntry "PipsP1" (last To))))))}))))) (if (< (score Mover) 14) (if (= (score Mover) 12) (move (from) (to (union {(intersection {(difference (if (= 1 (size Stack at:(from))) (sites "Rings") (sites "RingsplusT")) (from)) (sites Empty) (sites {(mapEntry "Step4a" (from)) (mapEntry "Step12b" (from)) (mapEntry "Step12c" (from)) (mapEntry "Step12d" (from)) (mapEntry "Step12e" (from)) (mapEntry "Step12f" (from)) (mapEntry (from)) (mapEntry (from))})}) (intersection {(sites "Rings") (sites Occupied by:Next) (sites {(mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step4a" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step12b" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step12c" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step12d" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step12e" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step12f" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "Step12g" (from))})})})) stack:True (then (and {(set Var "StartS" 3) (set Var "CntrAttack" 0) (if (= 15 (last To)) (and {(add (piece (id "Starter" Mover)) (to (sites Mover "Base")) count:(count Stack at:(last To) if:(= (id "Cone" Mover) (what at:(to) level:(level)))) stack:True) (add (piece (id "Prisoner" Mover)) (to (sites Mover "Prison")) count:(count Stack at:(last To) if:(= (id "Cone" Next) (what at:(to) level:(level)))) stack:True) (remove 15 count:(count Stack at:(last To)))}) (if (and (is Friend (who at:(mapEntry "SameColor" (last To)))) (not (no Pieces in:(sites Mover "Reserve")))) (and (remove (sites Mover "Reserve")) (add (piece (id "Starter" Mover)) (to (sites Mover "Base")) stack:True)))) (set Value at:(last To) (count Stack at:(last To))) (addScore Mover (- (if (= (id Mover) 1) (mapEntry "PipsP1" (last To)) (mapEntry "PipsP2" (last To))) (if (= (id Mover) 1) (mapEntry "PipsP1" (last From)) (mapEntry "PipsP2" (last From))))) (if (> (size Stack at:(last To)) (value Piece at:(last To))) (addScore Next (- 0 (if (= (id Mover) 1) (mapEntry "PipsP2" (last To)) (mapEntry "PipsP1" (last To))))))}))) (move (from) (to (union {(intersection {(difference (if (= 1 (size Stack at:(from))) (sites "Rings") (sites "RingsplusT")) (from)) (sites Empty) (sites {(mapEntry "Step3a" (from)) (mapEntry "Step3b" (from)) (mapEntry "Step13c" (from)) (mapEntry "Step13d" (from)) (mapEntry "Step13e" (from)) (mapEntry "Step13f" (from)) (mapEntry "Step11g" (from)) (mapEntry (from))})}) (intersection {(sites "Rings") (sites Occupied by:Next) (sites {(mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step3a" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step3b" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step13c" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step13d" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step13e" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step13f" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step11g" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry (from))})})})) stack:True (then (and {(set Var "StartS" 3) (set Var "CntrAttack" 0) (if (= 15 (last To)) (and {(add (piece (id "Starter" Mover)) (to (sites Mover "Base")) count:(count Stack at:(last To) if:(= (id "Cone" Mover) (what at:(to) level:(level)))) stack:True) (add (piece (id "Prisoner" Mover)) (to (sites Mover "Prison")) count:(count Stack at:(last To) if:(= (id "Cone" Next) (what at:(to) level:(level)))) stack:True) (remove 15 count:(count Stack at:(last To)))}) (if (and (is Friend (who at:(mapEntry "SameColor" (last To)))) (not (no Pieces in:(sites Mover "Reserve")))) (and (remove (sites Mover "Reserve")) (add (piece (id "Starter" Mover)) (to (sites Mover "Base")) stack:True)))) (set Value at:(last To) (count Stack at:(last To))) (addScore Mover (- (if (= (id Mover) 1) (mapEntry "PipsP1" (last To)) (mapEntry "PipsP2" (last To))) (if (= (id Mover) 1) (mapEntry "PipsP1" (last From)) (mapEntry "PipsP2" (last From))))) (if (> (size Stack at:(last To)) (value Piece at:(last To))) (addScore Next (- 0 (if (= (id Mover) 1) (mapEntry "PipsP2" (last To)) (mapEntry "PipsP1" (last To))))))})))) (if (= (score Mover) 14) (move (from) (to (union {(intersection {(difference (if (= 1 (size Stack at:(from))) (sites "Rings") (sites "RingsplusT")) (from)) (sites Empty) (sites {(mapEntry "Step2a" (from)) (mapEntry "Step2b" (from)) (mapEntry "Step14c" (from)) (mapEntry "Step14d" (from)) (mapEntry "Step14e" (from)) (mapEntry (from)) (mapEntry (from)) (mapEntry (from))})}) (intersection {(sites "Rings") (sites Occupied by:Next) (sites {(mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step2a" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step2b" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step14c" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step14d" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step14e" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "Step14f" (from))})})})) stack:True (then (and {(set Var "StartS" 3) (set Var "CntrAttack" 0) (if (= 15 (last To)) (and {(add (piece (id "Starter" Mover)) (to (sites Mover "Base")) count:(count Stack at:(last To) if:(= (id "Cone" Mover) (what at:(to) level:(level)))) stack:True) (add (piece (id "Prisoner" Mover)) (to (sites Mover "Prison")) count:(count Stack at:(last To) if:(= (id "Cone" Next) (what at:(to) level:(level)))) stack:True) (remove 15 count:(count Stack at:(last To)))}) (if (and (is Friend (who at:(mapEntry "SameColor" (last To)))) (not (no Pieces in:(sites Mover "Reserve")))) (and (remove (sites Mover "Reserve")) (add (piece (id "Starter" Mover)) (to (sites Mover "Base")) stack:True)))) (set Value at:(last To) (count Stack at:(last To))) (addScore Mover (- (if (= (id Mover) 1) (mapEntry "PipsP1" (last To)) (mapEntry "PipsP2" (last To))) (if (= (id Mover) 1) (mapEntry "PipsP1" (last From)) (mapEntry "PipsP2" (last From))))) (if (> (size Stack at:(last To)) (value Piece at:(last To))) (addScore Next (- 0 (if (= (id Mover) 1) (mapEntry "PipsP2" (last To)) (mapEntry "PipsP1" (last To))))))}))) (move (from) (to (union {(intersection {(difference (if (= 1 (size Stack at:(from))) (sites "Rings") (sites "RingsplusT")) (from)) (sites Empty) (sites {(mapEntry "Step7a" (from)) (mapEntry "Step7b" (from)) (mapEntry "Step15c" (from)) (mapEntry "Step15d" (from)) (mapEntry "Step15e" (from)) (mapEntry "Step15f" (from)) (mapEntry "Step11f" (from)) (mapEntry "Step11g" (from))})}) (intersection {(sites "Rings") (sites Occupied by:Next) (sites {(mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step7a" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step7b" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step15c" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step15d" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step15e" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step15f" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step11f" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step11g" (from))})) index:0)) (mapEntry (from))})})})) stack:True (then (and {(set Var "StartS" 3) (set Var "CntrAttack" 0) (if (= 15 (last To)) (and {(add (piece (id "Starter" Mover)) (to (sites Mover "Base")) count:(count Stack at:(last To) if:(= (id "Cone" Mover) (what at:(to) level:(level)))) stack:True) (add (piece (id "Prisoner" Mover)) (to (sites Mover "Prison")) count:(count Stack at:(last To) if:(= (id "Cone" Next) (what at:(to) level:(level)))) stack:True) (remove 15 count:(count Stack at:(last To)))}) (if (and (is Friend (who at:(mapEntry "SameColor" (last To)))) (not (no Pieces in:(sites Mover "Reserve")))) (and (remove (sites Mover "Reserve")) (add (piece (id "Starter" Mover)) (to (sites Mover "Base")) stack:True)))) (set Value at:(last To) (count Stack at:(last To))) (addScore Mover (- (if (= (id Mover) 1) (mapEntry "PipsP1" (last To)) (mapEntry "PipsP2" (last To))) (if (= (id Mover) 1) (mapEntry "PipsP1" (last From)) (mapEntry "PipsP2" (last From))))) (if (> (size Stack at:(last To)) (value Piece at:(last To))) (addScore Next (- 0 (if (= (id Mover) 1) (mapEntry "PipsP2" (last To)) (mapEntry "PipsP1" (last To))))))}))))))) (if (< (score Mover) 20) (if (< (score Mover) 18) (if (= (score Mover) 16) (move (from) (to (union {(intersection {(difference (if (= 1 (size Stack at:(from))) (sites "Rings") (sites "RingsplusT")) (from)) (sites Empty) (sites {(mapEntry "Step8a" (from)) (mapEntry "Step8b" (from)) (mapEntry "Step16c" (from)) (mapEntry "Step16d" (from)) (mapEntry "Step16e" (from)) (mapEntry "Step16f" (from)) (mapEntry "Step16g" (from)) (mapEntry (from))})}) (intersection {(sites "Rings") (sites Occupied by:Next) (sites {(mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step8a" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step8b" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step16c" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step16d" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step16e" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step16f" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step16g" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (from))})})})) stack:True (then (and {(set Var "StartS" 3) (set Var "CntrAttack" 0) (if (= 15 (last To)) (and {(add (piece (id "Starter" Mover)) (to (sites Mover "Base")) count:(count Stack at:(last To) if:(= (id "Cone" Mover) (what at:(to) level:(level)))) stack:True) (add (piece (id "Prisoner" Mover)) (to (sites Mover "Prison")) count:(count Stack at:(last To) if:(= (id "Cone" Next) (what at:(to) level:(level)))) stack:True) (remove 15 count:(count Stack at:(last To)))}) (if (and (is Friend (who at:(mapEntry "SameColor" (last To)))) (not (no Pieces in:(sites Mover "Reserve")))) (and (remove (sites Mover "Reserve")) (add (piece (id "Starter" Mover)) (to (sites Mover "Base")) stack:True)))) (set Value at:(last To) (count Stack at:(last To))) (addScore Mover (- (if (= (id Mover) 1) (mapEntry "PipsP1" (last To)) (mapEntry "PipsP2" (last To))) (if (= (id Mover) 1) (mapEntry "PipsP1" (last From)) (mapEntry "PipsP2" (last From))))) (if (> (size Stack at:(last To)) (value Piece at:(last To))) (addScore Next (- 0 (if (= (id Mover) 1) (mapEntry "PipsP2" (last To)) (mapEntry "PipsP1" (last To))))))}))) (move (from) (to (union {(intersection {(difference (if (= 1 (size Stack at:(from))) (sites "Rings") (sites "RingsplusT")) (from)) (sites Empty) (sites {(mapEntry "Step7a" (from)) (mapEntry "Step7b" (from)) (mapEntry "Step17c" (from)) (mapEntry "Step17d" (from)) (mapEntry "Step17e" (from)) (mapEntry "Step17f" (from)) (mapEntry "Step17g" (from)) (mapEntry "Step17h" (from))})}) (intersection {(sites "Rings") (sites Occupied by:Next) (sites {(mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step7a" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step7b" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step17c" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step17d" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step17e" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step17f" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step17g" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step17h" (from))})) index:0)) (mapEntry (from))})})})) stack:True (then (and {(set Var "StartS" 3) (set Var "CntrAttack" 0) (if (= 15 (last To)) (and {(add (piece (id "Starter" Mover)) (to (sites Mover "Base")) count:(count Stack at:(last To) if:(= (id "Cone" Mover) (what at:(to) level:(level)))) stack:True) (add (piece (id "Prisoner" Mover)) (to (sites Mover "Prison")) count:(count Stack at:(last To) if:(= (id "Cone" Next) (what at:(to) level:(level)))) stack:True) (remove 15 count:(count Stack at:(last To)))}) (if (and (is Friend (who at:(mapEntry "SameColor" (last To)))) (not (no Pieces in:(sites Mover "Reserve")))) (and (remove (sites Mover "Reserve")) (add (piece (id "Starter" Mover)) (to (sites Mover "Base")) stack:True)))) (set Value at:(last To) (count Stack at:(last To))) (addScore Mover (- (if (= (id Mover) 1) (mapEntry "PipsP1" (last To)) (mapEntry "PipsP2" (last To))) (if (= (id Mover) 1) (mapEntry "PipsP1" (last From)) (mapEntry "PipsP2" (last From))))) (if (> (size Stack at:(last To)) (value Piece at:(last To))) (addScore Next (- 0 (if (= (id Mover) 1) (mapEntry "PipsP2" (last To)) (mapEntry "PipsP1" (last To))))))})))) (if (= (score Mover) 18) (move (from) (to (union {(intersection {(difference (if (= 1 (size Stack at:(from))) (sites "Rings") (sites "RingsplusT")) (from)) (sites Empty) (sites {(mapEntry "Step2a" (from)) (mapEntry "Step2b" (from)) (mapEntry "Step18c" (from)) (mapEntry "Step18d" (from)) (mapEntry "Step18e" (from)) (mapEntry "Step18f" (from)) (mapEntry (from)) (mapEntry (from))})}) (intersection {(sites "Rings") (sites Occupied by:Next) (sites {(mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step2a" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step2b" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step18c" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step18d" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step18e" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step18f" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "Step18g" (from))})})})) stack:True (then (and {(set Var "StartS" 3) (set Var "CntrAttack" 0) (if (= 15 (last To)) (and {(add (piece (id "Starter" Mover)) (to (sites Mover "Base")) count:(count Stack at:(last To) if:(= (id "Cone" Mover) (what at:(to) level:(level)))) stack:True) (add (piece (id "Prisoner" Mover)) (to (sites Mover "Prison")) count:(count Stack at:(last To) if:(= (id "Cone" Next) (what at:(to) level:(level)))) stack:True) (remove 15 count:(count Stack at:(last To)))}) (if (and (is Friend (who at:(mapEntry "SameColor" (last To)))) (not (no Pieces in:(sites Mover "Reserve")))) (and (remove (sites Mover "Reserve")) (add (piece (id "Starter" Mover)) (to (sites Mover "Base")) stack:True)))) (set Value at:(last To) (count Stack at:(last To))) (addScore Mover (- (if (= (id Mover) 1) (mapEntry "PipsP1" (last To)) (mapEntry "PipsP2" (last To))) (if (= (id Mover) 1) (mapEntry "PipsP1" (last From)) (mapEntry "PipsP2" (last From))))) (if (> (size Stack at:(last To)) (value Piece at:(last To))) (addScore Next (- 0 (if (= (id Mover) 1) (mapEntry "PipsP2" (last To)) (mapEntry "PipsP1" (last To))))))}))) (and (move (from) (to (union {(intersection {(difference (if (= 1 (size Stack at:(from))) (sites "Rings") (sites "RingsplusT")) (from)) (sites Empty) (sites {(mapEntry "Step3a" (from)) (mapEntry "Step3b" (from)) (mapEntry "Step19c" (from)) (mapEntry "Step19d" (from)) (mapEntry "Step19e" (from)) (mapEntry "Step19f" (from)) (mapEntry "Step19g" (from)) (mapEntry "Step19h" (from))})}) (intersection {(sites "Rings") (sites Occupied by:Next) (sites {(mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step3a" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step3b" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step19c" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step19d" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step19e" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step19f" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step19g" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step19h" (from))})) index:0)) (mapEntry (from))})})})) stack:True (then (and {(set Var "StartS" 3) (set Var "CntrAttack" 0) (if (= 15 (last To)) (and {(add (piece (id "Starter" Mover)) (to (sites Mover "Base")) count:(count Stack at:(last To) if:(= (id "Cone" Mover) (what at:(to) level:(level)))) stack:True) (add (piece (id "Prisoner" Mover)) (to (sites Mover "Prison")) count:(count Stack at:(last To) if:(= (id "Cone" Next) (what at:(to) level:(level)))) stack:True) (remove 15 count:(count Stack at:(last To)))}) (if (and (is Friend (who at:(mapEntry "SameColor" (last To)))) (not (no Pieces in:(sites Mover "Reserve")))) (and (remove (sites Mover "Reserve")) (add (piece (id "Starter" Mover)) (to (sites Mover "Base")) stack:True)))) (set Value at:(last To) (count Stack at:(last To))) (addScore Mover (- (if (= (id Mover) 1) (mapEntry "PipsP1" (last To)) (mapEntry "PipsP2" (last To))) (if (= (id Mover) 1) (mapEntry "PipsP1" (last From)) (mapEntry "PipsP2" (last From))))) (if (> (size Stack at:(last To)) (value Piece at:(last To))) (addScore Next (- 0 (if (= (id Mover) 1) (mapEntry "PipsP2" (last To)) (mapEntry "PipsP1" (last To))))))}))) (move (from) (to (union {(intersection {(difference (if (= 1 (size Stack at:(from))) (sites "Rings") (sites "RingsplusT")) (from)) (sites Empty) (sites {(mapEntry "Step19i" (from)) (mapEntry (from)) (mapEntry (from)) (mapEntry (from)) (mapEntry (from)) (mapEntry (from)) (mapEntry (from)) (mapEntry (from))})}) (intersection {(sites "Rings") (sites Occupied by:Next) (sites {(mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step19i" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry (from))})})})) stack:True (then (and {(set Var "StartS" 3) (set Var "CntrAttack" 0) (if (= 15 (last To)) (and {(add (piece (id "Starter" Mover)) (to (sites Mover "Base")) count:(count Stack at:(last To) if:(= (id "Cone" Mover) (what at:(to) level:(level)))) stack:True) (add (piece (id "Prisoner" Mover)) (to (sites Mover "Prison")) count:(count Stack at:(last To) if:(= (id "Cone" Next) (what at:(to) level:(level)))) stack:True) (remove 15 count:(count Stack at:(last To)))}) (if (and (is Friend (who at:(mapEntry "SameColor" (last To)))) (not (no Pieces in:(sites Mover "Reserve")))) (and (remove (sites Mover "Reserve")) (add (piece (id "Starter" Mover)) (to (sites Mover "Base")) stack:True)))) (set Value at:(last To) (count Stack at:(last To))) (addScore Mover (- (if (= (id Mover) 1) (mapEntry "PipsP1" (last To)) (mapEntry "PipsP2" (last To))) (if (= (id Mover) 1) (mapEntry "PipsP1" (last From)) (mapEntry "PipsP2" (last From))))) (if (> (size Stack at:(last To)) (value Piece at:(last To))) (addScore Next (- 0 (if (= (id Mover) 1) (mapEntry "PipsP2" (last To)) (mapEntry "PipsP1" (last To))))))})))))) (if (= 20 (score Mover)) (move (from) (to (union {(intersection {(difference (if (= 1 (size Stack at:(from))) (sites "Rings") (sites "RingsplusT")) (from)) (sites Empty) (sites {(mapEntry "Step4a" (from)) (mapEntry "Step20b" (from)) (mapEntry "Step20c" (from)) (mapEntry "Step20d" (from)) (mapEntry "Step20e" (from)) (mapEntry "Step20f" (from)) (mapEntry "Step20g" (from)) (mapEntry (from))})}) (intersection {(sites "Rings") (sites Occupied by:Next) (sites {(mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step4a" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step20b" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step20c" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step20d" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step20e" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step20f" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry "Step20g" (from))})) index:0)) (mapEntry "SameColor" (arrayValue (intersection (array (sites Empty)) (array {(mapEntry (from))})) index:0)) (mapEntry "SameColor" (from))})})})) stack:True (then (and {(set Var "StartS" 3) (set Var "CntrAttack" 0) (if (= 15 (last To)) (and {(add (piece (id "Starter" Mover)) (to (sites Mover "Base")) count:(count Stack at:(last To) if:(= (id "Cone" Mover) (what at:(to) level:(level)))) stack:True) (add (piece (id "Prisoner" Mover)) (to (sites Mover "Prison")) count:(count Stack at:(last To) if:(= (id "Cone" Next) (what at:(to) level:(level)))) stack:True) (remove 15 count:(count Stack at:(last To)))}) (if (and (is Friend (who at:(mapEntry "SameColor" (last To)))) (not (no Pieces in:(sites Mover "Reserve")))) (and (remove (sites Mover "Reserve")) (add (piece (id "Starter" Mover)) (to (sites Mover "Base")) stack:True)))) (set Value at:(last To) (count Stack at:(last To))) (addScore Mover (- (if (= (id Mover) 1) (mapEntry "PipsP1" (last To)) (mapEntry "PipsP2" (last To))) (if (= (id Mover) 1) (mapEntry "PipsP1" (last From)) (mapEntry "PipsP2" (last From))))) (if (> (size Stack at:(last To)) (value Piece at:(last To))) (addScore Next (- 0 (if (= (id Mover) 1) (mapEntry "PipsP2" (last To)) (mapEntry "PipsP1" (last To))))))}))))))))}) (rules (start {(place Stack "Starter1" 13 count:3) (place Stack "Starter2" 17 count:3) (place Stack "Reserve1" 1 count:6) (place Stack "Reserve2" 3 count:6)}) (play (do (if (no Pieces All in:(sites "Rings")) (and {(set Var "StartS" 0) (set Var "CntrAttack" 0)})) next:(if (is Prev Mover) (if (= 1 (var "StartS")) (move (from (sites Mover "Base")) (to (difference (sites Mover "HomeRing") (mapEntry "SameColor" (last To)))) (then (and {(promote (last To) (piece {"Cone"}) Mover) (set Var "StartS" (+ 1 (var "StartS"))) (if (= 0 (var "StartS")) (set Var "St1Pos" (last To))) (if (and (= 1 (var "StartS")) (or (= (mapEntry "Attacks1" (last To)) (var "St1Pos")) (= (mapEntry "Attacks2" (last To)) (var "St1Pos")))) (set Var "CntrAttack" 1)) (if (> (var "StartS") 2) (set Var "CntrAttack" 0)) (if (and {(is Friend (who at:(mapEntry "SameColor" (last To)))) (!= 1 (var "CntrAttack")) (not (no Pieces in:(sites Mover "Reserve")))}) (and (add (piece (id "Starter" Mover)) (to (sites Mover "Base")) stack:True) (remove (sites Mover "Reserve")))) (set Value at:(last To) 1) (addScore Mover (if (= (id Mover) 1) (mapEntry "PipsP1" (last To)) (mapEntry "PipsP2" (last To))))}))) (if (and (= 2 (var "StartS")) (= 1 (var "CntrAttack"))) (move (from (sites Mover "Base")) (to (intersection (sites "Rings") (sites Empty))) (then (and {(promote (last To) (piece {"Cone"}) Mover) (set Var "StartS" (+ 1 (var "StartS"))) (if (= 0 (var "StartS")) (set Var "St1Pos" (last To))) (if (and (= 1 (var "StartS")) (or (= (mapEntry "Attacks1" (last To)) (var "St1Pos")) (= (mapEntry "Attacks2" (last To)) (var "St1Pos")))) (set Var "CntrAttack" 1)) (if (> (var "StartS") 2) (set Var "CntrAttack" 0)) (if (and {(is Friend (who at:(mapEntry "SameColor" (last To)))) (!= 1 (var "CntrAttack")) (not (no Pieces in:(sites Mover "Reserve")))}) (and (add (piece (id "Starter" Mover)) (to (sites Mover "Base")) stack:True) (remove (sites Mover "Reserve")))) (set Value at:(last To) 1) (addScore Mover (if (= (id Mover) 1) (mapEntry "PipsP1" (last To)) (mapEntry "PipsP2" (last To))))}))) (move (from (sites Mover "Base")) (to (intersection (sites Mover "HomeRing") (sites Empty))) (then (and {(promote (last To) (piece {"Cone"}) Mover) (set Var "StartS" (+ 1 (var "StartS"))) (if (= 0 (var "StartS")) (set Var "St1Pos" (last To))) (if (and (= 1 (var "StartS")) (or (= (mapEntry "Attacks1" (last To)) (var "St1Pos")) (= (mapEntry "Attacks2" (last To)) (var "St1Pos")))) (set Var "CntrAttack" 1)) (if (> (var "StartS") 2) (set Var "CntrAttack" 0)) (if (and {(is Friend (who at:(mapEntry "SameColor" (last To)))) (!= 1 (var "CntrAttack")) (not (no Pieces in:(sites Mover "Reserve")))}) (and (add (piece (id "Starter" Mover)) (to (sites Mover "Base")) stack:True) (remove (sites Mover "Reserve")))) (set Value at:(last To) 1) (addScore Mover (if (= (id Mover) 1) (mapEntry "PipsP1" (last To)) (mapEntry "PipsP2" (last To))))}))))) (forEach Piece top:True)))) (end {(if (and {(no Moves Next) (= 0 (count Sites in:(intersection (sites Occupied by:Next) (sites "RingsplusBase")))) (< (count Sites in:(sites Occupied by:Next)) 2)}) (result Mover Win)) (if (>= (count Pieces Mover in:(sites "Prison")) 3) (result Mover Win))}))) 
Oust is a game for two players, played on a hexagonally patterned board which is initially empty. The two players, Black and White, take turns placing stones of their color onto unoccupied cells on the board. A group is a set of interconnected, like-colored stones. A group can be a singleton, a single stone which is not connected to any other stones of its color. A group includes all the stones of its own color connected to it. There are two types of moves - non-capturing placements and capturing placements. Non-capturing placements either forms no connections (adjacencies) with any stones, or forms one or more connections with only enemy stones. A non-capturing placement does not form any connection with stones of its own color. Making a non-capturing placement concludes your turn. When you place a stone which forms one or more connections with your own groups, you will create a new, larger group of your own stones. You can only make such a placement if said new group will have one or more connections with enemy groups upon its creation and if all said enemy groups are smaller than said new group. Upon making such a placement, all said enemy groups are removed from the board. After capturing one or more enemy groups and while it is still your turn, you must continue to add stones until you make a non-capturing placement, at which time your turn is concluded. If you have a placement available on your turn you must make one. If you don't have any placements available, you must pass your turn. There will always be a placement available for at least one player. You win by making a placement which captures all of the enemy stones on the board. The game is played on a size 7 board
(game "Oust" (players 2) (equipment {(board (hex 7)) (piece "Disc" Each)}) (rules (play (or (move Add (to (sites Empty) if:(= 0 (count Sites in:(sites Around (to) Own))))) (do (move Add (to (sites Empty) if:(< 0 (count Sites in:(sites Around (to) Own))))) ifAfterwards:(and (all Sites (sites Around (sites Group at:(last To)) Enemy) if:(> (size Group at:(last To)) (size Group at:(site)))) (< 0 (count Sites in:(sites Around (sites Group at:(last To)) Enemy)))) (then (and (forEach Site (sites Around (sites Group at:(last To)) Enemy) (remove (sites Group at:(site)))) (moveAgain)))))) (end (if (and (< 2 (count Moves)) (= 0 (count Sites in:(sites Occupied by:Enemy)))) (result Mover Win))))) 
Ten corn kernels are placed in a line; the spaces between the kernels are the playing spaces. Four kernels of corn are used as dice, blackened on one side. The throws are as follows: Two of the same side up = 2, three of the same side up = 3; four black sides up = 4; four unblackened sides up = 5. Five pieces per player. Players take turns moving pieces according to the throws of the corn, with two throws per turn. When a player reaches the opposite end of the board, they move to the start and continue moving in the same direction. If a piece lands on a space occupied by an opponent's piece, the player then moves in the reverse direction, carrying the opponent's piece with it in an attempt to move past the starting points and off the board. Upon moving off the board, the opponent's piece is captured. The player then enters their piece again on their next turn. However, if the opponent lands on a piece carrying one of their pieces away, they then start carrying both of those pieces back to their starting point, freeing the captured piece and capturing the other player's piece. The player who captures all of the opponent's pieces wins.
(game "Puluc" (players 2) (equipment {(board (rectangle 1 10) {(track "Track1" {0 1 2 3 4 5 6 7 8} loop:True P1) (track "Track2" {8 7 6 5 4 3 2 1 0} loop:True P2) (track "CaptureTrack1" {8 7 6 5 4 3 2 1 0} P1 directed:True) (track "CaptureTrack2" {0 1 2 3 4 5 6 7 8} P2 directed:True)} use:Edge) (piece "Marker" Each (or (if (= 0 (state at:(from) level:(level))) (move (from (from) level:(level)) (to (trackSite Move from:(from) "Track" steps:(mapEntry "Throw" (count Pips)))) (then (if (is In (last To) (sites Occupied by:Enemy top:False)) (forEach Level (last To) FromTop (and (if (is Enemy (who at:(last To) level:(level))) (set State at:(last To) level:(level) 2)) (if (is Friend (who at:(last To) level:(level))) (set State at:(last To) level:(level) 1)))))))) (if (= 1 (state at:(from) level:(level))) (if (!= (trackSite Move from:(from) "CaptureTrack" steps:(mapEntry "Throw" (count Pips))) -1) (move (from (from) level:(level)) (to (trackSite Move from:(from) "CaptureTrack" steps:(mapEntry "Throw" (count Pips)))) (then (and (forEach Level (last From) FromTop (if (= 2 (state at:(last From) level:(level))) (fromTo (from (last From) level:(level)) (to (last To))))) (forEach Level (last From) FromTop (if (is Friend (who at:(last From) level:(level))) (set State at:(last From) level:(level) 0)))))) (move Remove (from) level:(level) (then (and {(forEach Level (last From) FromTop (if (is Friend (who at:(last From) level:(level))) (set State at:(last From) level:(level) 0))) (forEach Level (last From) FromTop (if (= 2 (state at:(last From) level:(level))) (remove (last From) level:(level)))) (add (piece (id "Marker" Mover)) (to (handSite Mover)))}))))))) (regions "AllSites" (sites Board Vertex)) (map "Throw" {(pair 0 5) (pair 1 3) (pair 2 2) (pair 3 3) (pair 4 4)}) (map "Entry" {(pair 1 0) (pair 2 8)}) (dice d:2 from:0 num:4) (hand Each)}) (rules (start {(place Stack "Marker1" (handSite P1) count:5) (place Stack "Marker2" (handSite P2) count:5)}) (play (do (roll) next:(or {(if (is Occupied (handSite Mover)) (move (from (handSite Mover)) (to (trackSite Move from:(mapEntry "Entry" (mover)) "Track" steps:(- (mapEntry "Throw" (count Pips)) 1))))) (forEach Piece)}) (then (if (not (is Prev Mover)) (moveAgain))))) (end {(if (no Pieces P2) (result P2 Loss)) (if (no Pieces P1) (result P1 Loss))}))) 
MOVES - A move consists of either: - A growth, i.e., a drop of a stone on an empty adjacent (orthogonal or diagonal) to friendly cell; - An orthogonal or diagonal slide of a stone already on board (like a chess Queen) to an empty cell; - A drop of a stone on any empty cell. - Any opponent adjacent stones to the new piece (either through growth or slide) are flipped to the moving player's colour. Notice that the third option (simple drop) do not flip the colour of adjacent stones. GOAL - Wins the player with most stones when the board is filled.
(game "Quad Wrangle" (players 2) (equipment {(board (square 8)) (piece "Ball" Each (move Slide (then (forEach Site (sites Around (last To)) (if (is Enemy (who at:(site))) (and (remove (site)) (add (piece (id "Ball" Mover)) (to (site)))))))))}) (rules (start {(place "Ball1" (difference (union (sites Top) (sites Right)) (union {(sites Left) (sites Bottom) (intersection (sites Top) (sites Right))}))) (place "Ball2" (difference (union (sites Bottom) (sites Left)) (union {(sites Right) (sites Top) (intersection (sites Bottom) (sites Left))})))}) (play (or {(move Add (to (sites Around (sites Occupied by:Mover) Empty)) (then (forEach Site (sites Around (last To)) (if (is Enemy (who at:(site))) (and (remove (site)) (add (piece (id "Ball" Mover)) (to (site)))))))) (forEach Piece) (move Add (to (difference (sites Empty) (sites Around (sites Occupied by:Mover) Empty))))})) (end (if (is Full) (byScore {(score P1 (count Pieces P1)) (score P2 (count Pieces P2))}))))) 
Play starts with black. On his turn a player may either drop a stone of his color or remove a dead enemy group. Players may only legally drop stones adjacent to at least one of their stones already on the board. For boards sized 11x11 and smaller a group is considered dead if any stone within it meets the following criteria. a)The stone has no empty points orthogonally adjacent b)The stone has at least one enemy stone adjacent For boards larger than 11x11 only the first criterion applies when determining if a group is dead. You may never remove your own dead groups. If a player has no legal move on his turn he must pass. Passing is otherwise not permitted. The player to remove all opposing groups from the board wins. A size 13 board is currently selected
(game "Rampart" (players 2) (equipment {(board (square 13) use:Vertex) (piece "Disc" Each)}) (rules (start {(place "Disc1" (forEach (sites Phase 0) if:(and {(is Even (row of:(site))) (!= 0 (% (site) 4)) (= 0 (% (row of:(site)) 4))}))) (place "Disc2" (forEach (sites Phase 0) if:(and {(is Even (row of:(site))) (!= 0 (% (site) 4)) (= 2 (% (row of:(site)) 4))})))}) (play (or (move Add (to (sites Around (sites Occupied by:Mover) Empty Orthogonal))) (move Select (from (sites Occupied by:Enemy) if:(not (all Sites (sites Group at:(from)) if:(not (and (= 0 (count Sites in:(sites Around (site) Empty Orthogonal))) (if (>= 11 13) (< 0 (count Sites in:(sites Around (site) Own Orthogonal))) True)))))) (then (forEach Site (sites Group at:(last From) Orthogonal) (remove (site))))))) (end (if (no Pieces Next) (result Next Loss))))) 
3x15 board, with the central spot marked. Fifteen pieces per player, arranged along the outer two rows of the board. Another piece, the Gonagas ("king"), begins on the central marked square. Three four-sided dice, marked: X (=sáhkku; counts as 1), 2, 3, and blank, =0. To move, a player must throw three sáhkku with the three dice; they are given three throws to do so and may set aside any dice on which they throw sáhkku. Doing so activates a piece, which may then move according to the throws of the dice. The three throws of sáhkku may be used to activate up to three pieces, and use the remainder to move as normal. Dice throws can be used individually for different pieces, or all be used for one piece, but the values of single dice cannot be subdivided. Pieces move along the track, from left to right in their home row, right to left down the central row, left to right in the opponent's home row, right to left down the central row, and then back to the player's home row. When a piece lands on a spot occupied by the opponent's piece(s) which has been activated, the opponent's piece(s) are captured. The first player to reach the spot with the Gonagas controls it. The Gonagas may move orthogonally in any direction according to the throws of the dice. It cannot change direction while moving the value of one of the dice. If the opponent lands on the space with the Gonagas, the opponent then controls the Gonagas. Capturing all of the opponent's pieces is a win.
(game "Sahkku" (players 2) (equipment {(board (rectangle 3 15) {(track "Track1" "0,E,N1,W,N1,E,S1,W" loop:True P1) (track "Track2" "44,W,S1,E,S1,W,N1,E" loop:True P2)}) (dice d:4 from:0 num:3) (piece "Marker" Each (forEach Die if:(!= (pips) 0) (move (from (from) level:(level) if:(or (= 1 (state at:(from) level:(level))) (= 1 (pips)))) (to (trackSite Move from:(from) steps:(pips)) if:(or {(= (id "Gonagas" Shared) (what at:(to))) (is Empty (to)) (and (is Enemy (who at:(to))) (= 1 (state at:(to) level:(topLevel at:(to)))))}) (apply (and {(if (not (= 1 (state at:(from) level:(level)))) (set State at:(from) level:(level) 1)) (forget Value "Pips" (pips)) (if (= (what at:(to)) (id "Gonagas" Shared)) (set State at:(to) (mover)) (if (is Enemy (who at:(to))) (remove (to))))}))) (then (if (not (all DiceUsed)) (moveAgain)))))) (piece "Gonagas" Shared (forEach Die if:(!= (pips) 0) (move Slide (from (from) level:(level) if:(= (state at:(from) level:(level)) (mover))) Orthogonal (between (exact (pips)) if:True) (to (apply if:(or (is Empty (to)) (and (is Enemy (who at:(to))) (= 1 (state at:(to) level:(topLevel at:(to)))))))) (then (and (forEach Level (last To) (if (!= (topLevel at:(last To)) (level)) (remove (last To) level:(level)))) (if (not (all DiceUsed)) (moveAgain)))))))}) (rules (start {(place Stack "Marker1" (sites Bottom)) (place Stack "Marker2" (sites Top)) (place Stack "Gonagas" (centrePoint))}) phases:{(phase "Opening" (play (do (and (roll) (if (and (!= 0 (value Player Mover)) (= 0 (count MovesThisTurn))) (set Value Mover 0))) next:(move Pass (then (and (if (is AnyDie 1) (set Value Mover (+ (if (and (= 1 (face 45)) (all DiceEqual)) 3 (if (or {(and {(not (= 1 (face 45))) (= 1 (face 46)) (= 1 (face 47))}) (and {(= 1 (face 45)) (not (= 1 (face 46))) (= 1 (face 47))}) (and {(= 1 (face 45)) (= 1 (face 46)) (not (= 1 (face 47)))})}) 2 (if (or {(and {(not (= 1 (face 45))) (not (= 1 (face 46))) (= 1 (face 47))}) (and {(= 1 (face 45)) (not (= 1 (face 46))) (not (= 1 (face 47)))}) (and {(not (= 1 (face 45))) (= 1 (face 46)) (not (= 1 (face 47)))})}) 1 0))) (value Player Mover)))) (forEach Die (if (!= 0 (pips)) (remember Value "Pips" (pips))))))) (then (if (or (<= 3 (value Player Mover)) (!= 2 (count MovesThisTurn))) (moveAgain) (and (forget Value "Pips" All) (set Value Mover 0)))))) (nextPhase Mover (<= 3 (value Player Mover)) "PlayingPips")) (phase "PlayingPips" (play (do (if (not (is Prev Mover)) (roll)) next:(or (forEach Piece (forEach Value (values Remembered "Pips") (move (from (from) level:(level) if:(or (= 1 (state at:(from) level:(level))) (= 1 (value)))) (to (trackSite Move from:(from) steps:(value)) if:(or {(= (id "Gonagas" Shared) (what at:(to))) (is Empty (to)) (and (is Enemy (who at:(to))) (= 1 (state at:(to) level:(topLevel at:(to)))))}) (apply (and {(if (not (= 1 (state at:(from) level:(level)))) (set State at:(from) level:(level) 1)) (forget Value "Pips" (value)) (if (= (what at:(to)) (id "Gonagas" Shared)) (set State at:(to) (mover)) (if (is Enemy (who at:(to))) (remove (to))))}))) (then (if (!= 0 (size Array (values Remembered "Pips"))) (moveAgain)))))) (forEach Piece (forEach Value (values Remembered "Pips") (move Slide (from (from) level:(level) if:(= (state at:(from) level:(level)) (mover))) Orthogonal (between (exact (value)) if:True) (to (apply if:(or (is Empty (to)) (and (is Enemy (who at:(to))) (= 1 (state at:(to) level:(topLevel at:(to)))))))) (then (and {(forEach Level (last To) (if (!= (topLevel at:(last To)) (level)) (remove (last To) level:(level)))) (forget Value "Pips" (count Steps (last From) (last To))) (if (!= 1 (size Array (values Remembered "Pips"))) (moveAgain))})))) Shared)))) (nextPhase Mover (= 0 (size Array (values Remembered "Pips"))) "Playing")) (phase "Playing" (play (do (if (not (is Prev Mover)) (roll)) next:(or (forEach Piece) (forEach Piece Shared)))))} (end (if (no Pieces Next) (result Next Loss))))) 
3x6 board. Six pieces per player, which begin one in each space in the row closest to the player. Six sticks, used as dice. One side is polished, and the other is rough. The value of a throw is equal to the number of polished sides which land face up. A throw of sig (five polished or five rough sides up) must be made to move a piece that has not yet been moved; a throw of sig moves it 1 and grants the player another throw. If six polished sides up are thrown, the player gets another throw. If this throw is a sig, the player's throw = 7 and the player may either free the first piece and move it seven spaces or free all six pieces, moving them each one, and moving the first piece the remaining one space. Also, if the player throws six rough sides on their first turn, they get three extra throws. If any of these three throws is a sig, the value of the throw = 13, and the player may free the first piece and move it thirteen spaces, or free all of the player's pieces, moving them each one space, and then moving the first piece the remainder of the spaces. Pieces move from left to right in the player's home row, right to left in the central row, left to right in the opponent's home row, right to left in the central row, and then left to right in the player's home row. When a player's piece lands on a space occupied by an opponent's piece, the opponent's piece is captured. The player who captures all of their opponent's pieces wins.
(game "Sig (El Oued Capture)" (players 2) (equipment {(board (rectangle 3 6) {(track "Track1" "0,E,N1,W,N1,E,S1,W" loop:True P1) (track "Track2" "17,W,S1,E,S1,W,N1,E" P2 directed:True)}) (piece "Marker" Each) (hand Each) (dice d:2 from:0 num:6) (map "ExtraThrow" {(pair 0 3) (pair 1 1) (pair 2 0) (pair 3 0) (pair 4 0) (pair 5 1) (pair 6 1)})}) (rules (start {(place "Marker1" (sites Bottom)) (place "Marker2" (sites Top))}) (play (do (roll) next:(priority (forEach Piece (move (from (from) if:(and (not (= (state at:(from)) 1)) (or (or (= 1 (count Pips)) (= 5 (count Pips))) (= 1 (var "SpecialSig"))))) (to (trackSite Move steps:1) if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (and (set State at:(last To) 1) (if (= 1 (var "SpecialSig")) (and {(moveAgain) (set Var (+ (var) 1))})))))) (forEach Piece (move (from (from) if:(= (state at:(from)) 1)) (to (trackSite Move steps:(if (= 1 (var "SpecialSig")) (+ 1 (count Pips)) (count Pips))) if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))) (then (if (!= 0 (mapEntry "ExtraThrow" (count Pips))) (and (if (= 3 (mapEntry "ExtraThrow" (count Pips))) (if (<= (var) 0) (set Var 2))) (if (!= (mover) (prev)) (and (moveAgain) (if (!= 1 (count Pips)) (set Var "SpecialSig" 1))))) (if (> (var) 0) (and {(set Var (- (var) 1)) (moveAgain)}) (set Var "SpecialSig" 0)))))) (end (if (no Pieces Next) (result Next Loss))))) 
The board consists of four rows of any number of holes. Two to twelve players, who play on two equal teams. The number of pieces per team is equal to the number of holes in one row. One team plays as pieces of camel dung, the other as sticks. The pieces begin, one in each hole, in the outer rows of the board. Eight sticks, used as dice, with a marked side and a blank side. The values of the throws are equal to the number of marked sides which land face up. A throw of 4 grants the player another throw. Pieces can only be moved for the first time with a throw of 1 or 8. One piece may move one space on a throw of 1, or eight pieces may each move one space on a throw of 8. Once a piece has made its initial move, it may move according to the throws of the sticks. The bottom team's pieces move from right to left in the home row, left to right in the next row, right to left in the third row, and then into the opponent's home row. The top team moves left to right (from their perspective) in their home row, right to left in the next row, left to right in the next row, and into the bottom player's home row. When a team's piece lands on a space in the central two rows occupied by an opponent's piece, the opponent's piece is captured. Pieces cannot be captured in the home rows. When a piece moves into the opponent's home row, they move back into the central two rows, moving in the opposite direction as before. After moving into the home row a piece can no longer be captured, even when it is in the central two rows. Play continues until both team's pieces have moved out of their home row and can no longer be captured. Players then alternate turns throwing the sticks, removing one of the opponent's pieces every time a 4 is thrown. A team wins when only their pieces are left on the board. The game involves 4 players. Each row has 20 Holes.
(game "Sig (Mauritania)" (players 4) (equipment {(board (rectangle 4 20) {(track "Track1" "19,W,N1,E,N1,W,N1,E" P1 directed:True) (track "Track2" "79,W,S1,E,S1,W,S1,E" P2 directed:True) (track "LoopTrack1" "40,E,S1,W" loop:True P1) (track "LoopTrack2" "20,E,N1,W" loop:True P2) (track "GoBackTrack1" "79,W,S1,E,S1,W" P1 directed:True) (track "GoBackTrack2" "19,W,N1,E,N1,W" P2 directed:True)} use:Vertex) (dice d:2 from:0 num:8) (piece "Marker" P1 (if (< (state at:(from)) 2) (or (if (<= (var) 0) (move (from (from) if:(if (< 0 (state at:(from))) True (is In (count Pips) (sites {1 8})))) (to (trackSite Move "Track" steps:(count Pips)) if:(if (is In (to) (difference (sites Board) (union (sites Top) (sites Bottom)))) (or (is Empty (to)) (and (is Enemy (who at:(to))) (< (state at:(to)) 2))) (is Empty (to))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (if (not (< 0 (state at:(last To)))) (set State at:(last To) 1))))) (if (or (= (count Pips) 8) (> (var) 0)) (move (from (from)) (to (trackSite Move "Track" steps:1) if:(if (is In (to) (difference (sites Board) (union (sites Top) (sites Bottom)))) (or (is Empty (to)) (and (is Enemy (who at:(to))) (< (state at:(to)) 2))) (is Empty (to))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (and (if (not (< 0 (state at:(last To)))) (set State at:(last To) 1)) (if (> (var) 0) (and (if (> (var) 1) (moveAgain)) (set Var (- (var) 1))) (and (set Var (- (count Pips) 1)) (moveAgain))))))) (then (if (is In (last To) (if (is In (mover) (players Team1)) (sites Top) (sites Bottom))) (set State at:(last To) 2)))) (if (= (state at:(from)) 2) (move (from (from)) (to (trackSite Move "GoBackTrack" steps:(count Pips)) if:(if (is In (to) (difference (sites Board) (union (sites Top) (sites Bottom)))) (not (is Friend (who at:(to)))) (is Empty (to))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (if (is In (last To) (difference (sites Board) (union (sites Top) (sites Bottom)))) (set State at:(last To) 3)))) (if (= (state at:(from)) 3) (move (from (from)) (to (trackSite Move "LoopTrack" steps:(count Pips)) if:(if (is In (to) (difference (sites Board) (union (sites Top) (sites Bottom)))) (not (is Friend (who at:(to)))) (is Empty (to))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))))) (piece "Stick" P2 (if (< (state at:(from)) 2) (or (if (<= (var) 0) (move (from (from) if:(if (< 0 (state at:(from))) True (is In (count Pips) (sites {1 8})))) (to (trackSite Move "Track" steps:(count Pips)) if:(if (is In (to) (difference (sites Board) (union (sites Top) (sites Bottom)))) (or (is Empty (to)) (and (is Enemy (who at:(to))) (< (state at:(to)) 2))) (is Empty (to))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (if (not (< 0 (state at:(last To)))) (set State at:(last To) 1))))) (if (or (= (count Pips) 8) (> (var) 0)) (move (from (from)) (to (trackSite Move "Track" steps:1) if:(if (is In (to) (difference (sites Board) (union (sites Top) (sites Bottom)))) (or (is Empty (to)) (and (is Enemy (who at:(to))) (< (state at:(to)) 2))) (is Empty (to))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (and (if (not (< 0 (state at:(last To)))) (set State at:(last To) 1)) (if (> (var) 0) (and (if (> (var) 1) (moveAgain)) (set Var (- (var) 1))) (and (set Var (- (count Pips) 1)) (moveAgain))))))) (then (if (is In (last To) (if (is In (mover) (players Team1)) (sites Top) (sites Bottom))) (set State at:(last To) 2)))) (if (= (state at:(from)) 2) (move (from (from)) (to (trackSite Move "GoBackTrack" steps:(count Pips)) if:(if (is In (to) (difference (sites Board) (union (sites Top) (sites Bottom)))) (not (is Friend (who at:(to)))) (is Empty (to))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (if (is In (last To) (difference (sites Board) (union (sites Top) (sites Bottom)))) (set State at:(last To) 3)))) (if (= (state at:(from)) 3) (move (from (from)) (to (trackSite Move "LoopTrack" steps:(count Pips)) if:(if (is In (to) (difference (sites Board) (union (sites Top) (sites Bottom)))) (not (is Friend (who at:(to)))) (is Empty (to))) (apply (if (is Enemy (who at:(to))) (remove (to))))))))))}) (rules (start {(place "Marker1" (sites Bottom)) (place "Stick2" (sites Top)) (set Team 1 {P1 P3}) (set Team 2 {P2 P4})}) phases:{(phase "MovingPhase" (play (do (if (<= (var) 0) (roll)) next:(if (is In (mover) (players Team1)) (forEach Piece P1) (forEach Piece P2)) (then (if (= (count Pips) 4) (moveAgain))))) (nextPhase (and (= 0 (count Sites in:(difference (sites Occupied by:All) (difference (sites Board) (union (sites Top) (sites Bottom)))))) (= 0 (count Sites in:(forEach (sites Occupied by:All) if:(< (state at:(site)) 2))))) "RemovingPhase")) (phase "RemovingPhase" (play (do (roll) next:(if (= (count Pips) 4) (move Remove (sites Occupied by:Enemy))))))} (end (if (no Pieces Enemy) (result TeamMover Win))))) 
Four rows of holes, of any number. Each player has as many pieces as are in one row. The pieces start in the outer row of the board for each player. Six sticks used as dice, with a green side and a white side. The throws are as follows: one white up = 0; two white up = 2; three white up = 1; four white up = 4; five white up = 0; zero white or six white up = 6. Each piece's first move must be with a throw of 1 or 6. This first throw moves the piece one space only. Play moves from left to right in the player's home row, from right to left in the second row, left to right in the third row, and right to left in the opponent's home row. When a player's piece lands on a space occupied by an opponent's piece, the opponent's piece is removed from the board. The player who captures all of the opponent's pieces wins. Each row has 20 holes.
(game "Sig (Mzab)" (players 2) (equipment {(board (rectangle 4 20) {(track "Track1" "0,E,N1,W,N1,E,N1,W" P1 directed:True) (track "Track2" "79,W,S1,E,S1,W,S1,E" P2 directed:True)} use:Vertex) (piece "Stick" Each (if (or (= (state at:(from)) 0) (and (or (= 1 (mapEntry (count Pips))) (= 6 (mapEntry (count Pips)))) (= (state at:(from)) 1))) (if (!= (trackSite Move steps:(if (= (state at:(from)) 1) 1 (mapEntry (count Pips)))) -1) (if (or (is In (trackSite Move steps:(if (= (state at:(from)) 1) 1 (mapEntry (count Pips)))) (sites Empty)) (is Enemy (who at:(trackSite Move steps:(if (= (state at:(from)) 1) 1 (mapEntry (count Pips))))))) (move (from) (to (trackSite Move steps:(if (= (state at:(from)) 1) 1 (mapEntry (count Pips)))) (apply if:(is Enemy (who at:(to))) (remove (to)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0)))))) (regions "AllSites" (sites Board)) (dice d:2 from:0 num:6) (map {(pair 0 6) (pair 1 0) (pair 2 2) (pair 3 1) (pair 4 1) (pair 5 0) (pair 6 6)}) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Stick1" (sites Bottom) state:1) (place "Stick2" (sites Top) state:1)}) (play (do (roll) next:(forEach Piece))) (end {(if (no Pieces Next) (result Next Loss)) (if (and (= (count Sites in:(difference (sites Occupied by:P1) (sites P2))) 0) (= (count Sites in:(difference (sites Occupied by:P2) (sites P1))) 0)) (result Mover Draw))}))) 
Three rows of holes, arranged vertically, the outer two have twelve holes and the central one has thirteen. Twelve pieces per player, which begin in the outer rows. Four sticks, black on one side and white on the other, the number of white faces up is the value of the throw; all black faces up = 6. A player must throw a 1 (sig) to unlock a piece, which moves from the top hole in the player's row to the top hole of the central row. When a piece reaches the thirteenth space in the central row, they must throw a sig to enter the opponent's home row, at the bottom hole in that row, and proceed up that row to the top and then back into the central row. When entering the opponent's row, the opponent's piece in their bottom hole is sent to the next available hole in their row. In the central row, when a piece lands on a hole with an opponent's piece, the opponent's piece is sent back to start in their home row. A player landing on a hole occupied by an opponent in the home row captures the opponent's piece. The player who captures all of the opponent's pieces wins. The game is played with 4 dice.
(game "Sig (Tidikelt)" (players 2) (equipment {(board (merge {(rectangle 12 3) (shift 1 -1 (rectangle 13 1))}) {(track "HomeTrack1" "0,N,E1,S" P1 directed:True) (track "HomeTrack2" "2,N,W1,S" P2 directed:True) (track "EnemyTrack1" "2,N,W1,S" P1 directed:True) (track "EnemyTrack2" "0,N,E1,S" P2 directed:True)} use:Vertex) (piece "Stick" Each) (regions "AllSites" (sites Board)) (dice d:2 from:0 num:4) (map "Throw" {(pair 0 6) (pair 1 1) (pair 2 2) (pair 3 3) (pair 4 4)}) (map "FirstEnemySite" {(pair P1 2) (pair P2 0)}) (regions "Home" P1 (sites Left)) (regions "Home" P2 (sites Right))}) (rules (start {(place "Stick1" (sites Left)) (place "Stick2" (sites Right))}) (play (do (roll) next:(or (if (and (= 1 (mapEntry "Throw" (count Pips))) (= (mover) (who at:36))) (move (from 36) (to (mapEntry "FirstEnemySite" (mover)) if:(not (is Friend (mapEntry "FirstEnemySite" (mover)))) (apply if:(is Enemy (who at:(to))) (if (= (min (array (intersection (sites Empty) (sites Next "Home")))) -1) (remove (to)) (fromTo (from (to)) (to (min (array (intersection (sites Empty) (sites Next "Home"))))))))))) (forEach Piece (or (if (is In (from) (sites Track Mover "HomeTrack")) (if (if (!= 0 (state at:(from))) True (= 1 (mapEntry "Throw" (count Pips)))) (if (not (is Friend (who at:(trackSite Move "HomeTrack" steps:(mapEntry "Throw" (count Pips)))))) (move (from) (to (trackSite Move "HomeTrack" steps:(mapEntry "Throw" (count Pips))) (apply if:(is Enemy (who at:(to))) (if (is In (to) (sites Next "Home")) (remove (to)) (if (= (min (array (intersection (sites Empty) (sites Next "Home")))) -1) (remove (to)) (fromTo (from (to)) (to (min (array (intersection (sites Empty) (sites Next "Home")))))))))) (then (if (and (not (!= 0 (state at:(last To)))) (= 1 (mapEntry "Throw" (count Pips)))) (set State at:(last To) 1))))))) (if (is In (from) (sites Track Mover "EnemyTrack")) (if (not (is Friend (who at:(trackSite Move "EnemyTrack" steps:(mapEntry "Throw" (count Pips)))))) (move (from) (to (trackSite Move "EnemyTrack" steps:(mapEntry "Throw" (count Pips))) (apply if:(is Enemy (who at:(to))) (if (is In (to) (sites Next "Home")) (remove (to)) (if (= (min (array (intersection (sites Empty) (sites Next "Home")))) -1) (remove (to)) (fromTo (from (to)) (to (min (array (intersection (sites Empty) (sites Next "Home")))))))))))))))))) (end (if (no Pieces Next) (result Next Loss))))) 
4x13 board. Thirteen pieces per player, arranged on the outer rows of the board. Played with six sticks which function as dice. Pieces move according to the throws of the dice. Play progresses from left to right in the player's home row, and then from right to left in the second row, left to right in the third row, and then right to left in the opponent's row. A throw of 1 is required for each piece to being moving it. When a player's piece lands on a space occupied by a piece belonging to the opponent, the opponent's piece is captured. The player who captures all of the opponent's pieces wins. 
(game "Sig (Tozeur)" (players 2) (equipment {(board (rectangle 4 13) {(track "Track1" "0,E,N1,W,N1,E,N1,W" P1 directed:True) (track "Track2" "51,W,S1,E,S1,W,S1,E" P2 directed:True)} use:Vertex) (piece "Stick" Each (if (or (= (state at:(from)) 0) (and (= (count Pips) 1) (= (state at:(from)) 1))) (if (!= (trackSite Move steps:(count Pips)) -1) (if (or (is In (trackSite Move steps:(count Pips)) (sites Empty)) (is Enemy (who at:(trackSite Move steps:(count Pips))))) (move (from) (to (trackSite Move steps:(count Pips)) (apply if:(is Enemy (who at:(to))) (remove (to)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0)))))) (regions "AllSites" (sites Board)) (dice d:2 from:0 num:6) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Stick1" (sites Bottom) state:1) (place "Stick2" (sites Top) state:1)}) (play (do (roll) next:(forEach Piece))) (end {(if (no Pieces Next) (result Next Loss)) (if (and (= (count Sites in:(difference (sites Occupied by:P1) (sites P2))) 0) (= (count Sites in:(difference (sites Occupied by:P2) (sites P1))) 0)) (result Mover Draw))}))) 
4x20-25 board. Player on two teams of two players. Each team has a number of pieces which are equal to the number of holes in one of the rows. Pieces baring in the outer rows of the board. Eight sticks used as dice, painted red on one side. The throws are as follows: All sides of one color = 8; seven of one color = 1; six of one color = 6; five of one color = 5; four of one color= 4. Throws of 4 and 1 allow the player another throw. Pieces are moved after the throws are made. Each throw must be used to move a piece; the value of a throw cannot be subdivided between pieces. Pieces move from left to right in the team's home row, the right to left in the second row, left to right in the third row, and then right to left in the opposing team's home row. Pieces may not move past other pieces belonging to the team, but may move past the opponent's pieces. Then a piece lands in a spot occupied by a piece belonging to the opposing team, the opposing team's piece is captured. Once a player places their pieces in the opponent's home row, they cannot be taken. The team continue until all of the pieces are in the opponents' home rows, and the team with the most remaining pieces wins. Each row has 20 holes.
(game "Sig (Western Sahara)" (players 4) (equipment {(board (rectangle 4 20) {(track "Track1" "0,E,N1,W,N1,E,N1,W" P1 directed:True) (track "Track2" "79,W,S1,E,S1,W,S1,E" P2 directed:True) (track "Track3" "0,E,N1,W,N1,E,N1,W" P3 directed:True) (track "Track4" "79,W,S1,E,S1,W,S1,E" P4 directed:True)} use:Vertex) (piece "Stick" Each) (regions "AllSites" (sites Board)) (dice d:2 from:0 num:8) (map "Throw" {(pair 0 8) (pair 1 1) (pair 2 6) (pair 3 5) (pair 4 4) (pair 5 5) (pair 6 6) (pair 7 1) (pair 8 8)}) (regions "Home" P1 (sites Bottom)) (regions "Home" P2 (sites Top)) (regions "Home" P3 (sites Bottom)) (regions "Home" P4 (sites Top))}) (rules (start {(set Team 1 {P1 P3}) (set Team 2 {P2 P4}) (place "Stick1" (sites Bottom)) (place "Stick2" (sites Top))}) (play (do (roll) next:(if (or (is Mover P1) (is Mover P3)) (forEach Site (sites Occupied by:Team1) (move (from (site)) (to (trackSite Move steps:(mapEntry (count Pips))) if:(and (or (is Empty (to)) (and (not (is In (to) (sites Next "Home"))) (is Enemy (who at:(to))))) (= 1 (count Sites in:(intersection (sites Occupied by:Team1) (sites Track Mover "Track" from:(from) to:(trackSite Move steps:(mapEntry (count Pips)))))))) (apply if:(is Enemy (who at:(to))) (remove (to)))))) (forEach Site (sites Occupied by:Team2) (move (from (site)) (to (trackSite Move steps:(mapEntry (count Pips))) if:(and (or (is Empty (to)) (and (not (is In (to) (sites Next "Home"))) (is Enemy (who at:(to))))) (= 1 (count Sites in:(intersection (sites Occupied by:Team2) (sites Track Mover "Track" from:(from) to:(trackSite Move steps:(mapEntry (count Pips)))))))) (apply if:(is Enemy (who at:(to))) (remove (to))))))) (then (if (is In (mapEntry (count Pips)) (sites {1 4})) (moveAgain))))) (end (if (and (= 0 (count Sites in:(difference (sites Occupied by:Team1) (sites P2 "Home")))) (= 0 (count Sites in:(difference (sites Occupied by:Team2) (sites P1 "Home"))))) {(if (= (count Sites in:(sites Occupied by:Team1)) (count Sites in:(sites Occupied by:Team2))) (result Mover Draw)) (if (< (count Sites in:(sites Occupied by:Team1)) (count Sites in:(sites Occupied by:Team2))) (result Team2 Win)) (if (> (count Sites in:(sites Occupied by:Team1)) (count Sites in:(sites Occupied by:Team2))) (result Team1 Win))})))) 
4 or 6x10 board. Six pieces per player, with one piece placed on each of the three spaces on either end of the long row closest to the player. Three casting sticks, each with a round and a flat side, are used as dice. The throws are as follows: One flat side up = 1; two flat sides up = 2; three flat sides up = 4, zero flat sides up = 6. A player must throw a 1 to move each piece for the first time. Players move according to the throws, except on throws of 1, which are tabulated for use later. Players continue to throw until they throw 2. Pieces move along a boustrophedon path, beginning from left to right in the row closest to them. Pieces are captured when an player's piece lands on a spot occupied by an opponent's piece. Players may used tabulated throws to supplement a throw in order to make a capture. The player who captured the most pieces wins. 6 rows.
(game "Sijat El Taba" (players 2) (equipment {(board (rectangle 6 10) {(track "Track1" "0,E,N1,W,N1,E,N1,W,N1,E,N1,W" P1 directed:True) (track "Track2" "59,W,S1,E,S1,W,S1,E,S1,W,S1,E" P2 directed:True)}) (piece "Marker" Each (if (= (state at:(from)) 1) (or (if (!= (trackSite Move steps:(mapEntry (count Pips))) -1) (if (or (is In (trackSite Move steps:(mapEntry (count Pips))) (sites Empty)) (is Enemy (who at:(trackSite Move steps:(mapEntry (count Pips)))))) (move (from) (to (trackSite Move steps:(mapEntry (count Pips))) (apply if:(is Enemy (who at:(to))) (remove (to) (then (addScore Mover 1)))))))) (if (!= (trackSite Move steps:(+ (value Player Mover) (mapEntry (count Pips)))) -1) (if (is Enemy (who at:(trackSite Move steps:(+ (value Player Mover) (mapEntry (count Pips)))))) (move (from) (to (trackSite Move steps:(+ (value Player Mover) (mapEntry (count Pips)))) (apply if:(is Enemy (who at:(to))) (remove (to) (then (addScore Mover 1))))) (then (set Value Mover 0)))))))) (dice d:2 from:0 num:3) (map {(pair 1 1) (pair 2 2) (pair 3 4) (pair 0 6)})}) (rules (start {(place "Marker1" (union (intersection (sites Bottom) (expand (sites Left) steps:2)) (intersection (sites Bottom) (expand (sites Right) steps:2)))) (place "Marker2" (union (intersection (sites Top) (expand (sites Left) steps:2)) (intersection (sites Top) (expand (sites Right) steps:2))))}) (play (do (roll) next:(if (= (mapEntry (count Pips)) 1) (or (move Pass (then (and (if (> (value Player Mover) 0) (set Value Mover (+ 1 (value Player Mover))) (set Value Mover 1)) (moveAgain)))) (move Select (from (sites Occupied by:Mover) if:(= (state at:(from)) 0)) (then (and (set State at:(last From) 1) (moveAgain))))) (if (= (mapEntry (count Pips)) 2) (forEach Piece) (forEach Piece (then (moveAgain))))))) (end (if (and (= (count Sites in:(difference (sites Occupied by:P1) (sites Top))) 0) (= (count Sites in:(difference (sites Occupied by:P2) (sites Bottom))) 0)) (byScore))))) 
4x12 board. Twelve pieces per player, one playing as sticks and the other as stones. Pieces begin on the board, one each in every space of the outer rows. Six sticks, with one black side and one white side, used as dice. Players choose who will play as black and who will play as white, and the throws are as follows: six black or white up = 6, five black or white up (called sir)= 5 plus another throw; four black or white up = 0, three black and three white up = 3. A player must throw sir in their colour to unlock a piece before moving it. Pieces move from left to right in their home row, right to left in the next row, left to right in the row following that, and then return to the second row. When a player's piece lands on a spot occupied by an opponent's piece, the opponent's piece is captured. The player who captures all of the opponent's pieces wins.
(game "Siryu (War)" (players 2) (equipment {(board (rectangle 4 12) {(track "Track1" "0,E,N1,W,N1,E,23,E,W,N1,E,23,W,N1,E,23,W,N1,E,23,W,N1,E,23,W,N1,E,23,W,N1,E,23" loop:True P1) (track "Track2" "47,W,S1,E,S1,W,24,E,N1,W,24,E,N1,W,24,E,N1,W,24,E,N1,W,24,E,N1,W,24,E,N1,W,24" loop:True P2)} use:Vertex) (piece "Stick" P1 (if (or (= (state at:(from)) 0) (and (= (count Pips) (mapEntry "Sir" (mover))) (= (state at:(from)) 1))) (if (!= (trackSite Move steps:(mapEntry "ThrowDiceValue" (count Pips))) -1) (if (or (is In (trackSite Move steps:(mapEntry "ThrowDiceValue" (count Pips))) (sites Empty)) (is Enemy (who at:(trackSite Move steps:(mapEntry "ThrowDiceValue" (count Pips)))))) (move (from) (to (trackSite Move steps:(mapEntry "ThrowDiceValue" (count Pips))) (apply if:(is Enemy (who at:(to))) (remove (to)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0)))))) (piece "Marker" P2 (if (or (= (state at:(from)) 0) (and (= (count Pips) (mapEntry "Sir" (mover))) (= (state at:(from)) 1))) (if (!= (trackSite Move steps:(mapEntry "ThrowDiceValue" (count Pips))) -1) (if (or (is In (trackSite Move steps:(mapEntry "ThrowDiceValue" (count Pips))) (sites Empty)) (is Enemy (who at:(trackSite Move steps:(mapEntry "ThrowDiceValue" (count Pips)))))) (move (from) (to (trackSite Move steps:(mapEntry "ThrowDiceValue" (count Pips))) (apply if:(is Enemy (who at:(to))) (remove (to)))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0)))))) (regions "AllSites" (sites Board)) (dice d:2 from:0 num:6) (map "ThrowDiceValue" {(pair 0 6) (pair 1 5) (pair 2 0) (pair 3 3) (pair 4 0) (pair 5 5) (pair 6 6)}) (map "Sir" {(pair 1 1) (pair 2 5)})}) (rules (start {(place "Stick1" (sites Bottom) state:1) (place "Marker2" (sites Top) state:1)}) (play (do (roll) next:(if (can Move (forEach Piece)) (forEach Piece (then (if (= (mapEntry "ThrowDiceValue" (count Pips)) 5) (moveAgain)))) (move Pass (then (if (= (mapEntry "ThrowDiceValue" (count Pips)) 5) (moveAgain))))))) (end (if (no Pieces Next) (result Next Loss))))) 
The rules are the same as in Chess, without checkmate. The game is won either after 100 turns or when one player can no longer move, by the player with the most pieces.
(game "Skirmish (GDL)" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (or {(move Step Forward (to if:(is Empty (to)))) (move Step (directions {FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (or (if (is In (from) (sites Start (piece (what at:(from))))) (move Slide Forward (between (exact 2) if:(is Empty (between))) (to if:(is Empty (to))) (then (set Pending (ahead (last To) Backward))))) (move Step (directions {FR FL}) (to if:(and (is Pending) (= (to) (value Pending)))) (then (remove (ahead (last To) Backward)))))} (then (if (is In (last To) (sites Mover "Promotion")) (moveAgain))))) (piece "Rook" Each (move Slide Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "King" Each (move Step (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))) (then (if (= (state at:(last To)) 1) (set State at:(last To) 0))))) (piece "Bishop" Each (move Slide Diagonal (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (piece "Knight" Each (move Leap {{F F R F} {F F L F}} (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to))))))) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to)))))) (map "King" {(pair 1 "E1") (pair 2 "E8")}) (map "RookLeft" {(pair 1 "A1") (pair 2 "A8")}) (map "RookRight" {(pair 1 "H1") (pair 2 "H8")}) (regions "Promotion" P1 (sites Top)) (regions "Promotion" P2 (sites Bottom))}) (rules (start {(place "Pawn1" (sites Row 1)) (place "Pawn2" (sites Row 6)) (place "Rook1" {"A1" "H1"} state:1) (place "Knight1" {"B1" "G1"}) (place "Bishop1" {"C1" "F1"}) (place "Queen1" coord:"D1") (place "King1" coord:"E1" state:1) (place "Rook2" {"A8" "H8"} state:1) (place "Knight2" {"B8" "G8"}) (place "Bishop2" {"C8" "F8"}) (place "Queen2" coord:"D8") (place "King2" coord:"E8" state:1)}) (play (if (is Prev Mover) (move Promote (last To) (piece {"Queen" "Knight" "Bishop" "Rook"}) Mover) (or (forEach Piece) (if (and {(= (what at:(mapEntry "King" (mover))) (id "King" Mover)) (= (state at:(mapEntry "King" (mover))) 1)}) (or (if (and (= (state at:(mapEntry "RookLeft" (mover))) 1) (can Move (move Slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:(is Empty (to)))))) (move Slide (from (mapEntry "King" (mover))) W (between (exact 2) if:(is Empty (to))) (then (and (set State at:(last To) 0) (move Slide (from (mapEntry "RookLeft" (mover))) E (between (exact 3) if:True)))))) (if (and (= (state at:(mapEntry "RookRight" (mover))) 1) (can Move (move Slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:(is Empty (to)))))) (move Slide (from (mapEntry "King" (mover))) E (between (exact 2) if:(is Empty (to))) (then (and (set State at:(last To) 0) (move Slide (from (mapEntry "RookRight" (mover))) W (between (exact 2) if:True))))))))))) (end (if (or (no Moves Next) (= (count Moves) 100)) (byScore {(score P1 (count Pieces P1)) (score P2 (count Pieces P2))}))))) 
Played on a 6x6 board with corner loops. Each player has 12 pieces. Play is made on the intersections of the lines. pieces are captured by moving via the outer loops and occupying a space held by another player. The goal is to capture all of the opponent's pieces. If no further captures are possible, the player with the most remaining pieces wins. The pieces can step to an empty site. The pieces can slide to capture. The mover win if the next player does not have any piece. The game is played on the Awithlaknan Mosona board.
(game "Surakarta" (players 2) (equipment {(surakartaBoard (square 6)) (piece "Marker" Each (or {(move Step All (to if:(is Empty (to)))) (move Slide "AllTracks" (between if:(or (= (between) (from)) (is Empty (between)))) (to if:(is Enemy (who at:(to))) (apply if:False (remove (to)))) (then (set Counter)))}))}) (rules (start {(place "Marker1" (expand (sites Bottom))) (place "Marker2" (expand (sites Top)))}) (play (if (is Proposed "End") (or (move Vote "End") (move Vote "No" (then (set Counter)))) (or (if (>= (counter) 101) (move Propose "End" (then (vote "End")))) (forEach Piece)))) (end {(if (is Decided "End") (byScore {(score P1 (count Pieces P1)) (score P2 (count Pieces P2))})) (if (no Pieces Next) (result Next Loss))}))) 
By far the easiest of the variants so far, Sweep Burrow's template is simply the two orthogonal directions involved in making the initial capture. The only further convention here is that if the capture was made with just movement in one direction, you cannot employ a second direction. The player may not end his turn until the capturing piece have no further captures available.
(game "Sweep Burrow" (players 2) (equipment {(board (square 8)) (piece "Disc" Each (if (= 0 (count MovesThisTurn)) (or {(move (from if:(= (* (from) (if (< 0 (count MovesThisTurn)) 1 0)) (* (last To) (if (< 0 (count MovesThisTurn)) 1 0)))) (to (sites Direction from:(from) N stop:(is Occupied (to)) stopIncluded:True) if:(= (next) (who at:(to))) (apply (remove (to)))) (then (set Var 1))) (move (from if:(= (* (from) (if (< 0 (count MovesThisTurn)) 1 0)) (* (last To) (if (< 0 (count MovesThisTurn)) 1 0)))) (to (sites Direction from:(from) E stop:(is Occupied (to)) stopIncluded:True) if:(= (next) (who at:(to))) (apply (remove (to)))) (then (set Var 2))) (move (from if:(= (* (from) (if (< 0 (count MovesThisTurn)) 1 0)) (* (last To) (if (< 0 (count MovesThisTurn)) 1 0)))) (to (sites Direction from:(from) S stop:(is Occupied (to)) stopIncluded:True) if:(= (next) (who at:(to))) (apply (remove (to)))) (then (set Var 3))) (move (from if:(= (* (from) (if (< 0 (count MovesThisTurn)) 1 0)) (* (last To) (if (< 0 (count MovesThisTurn)) 1 0)))) (to (sites Direction from:(from) W stop:(is Occupied (to)) stopIncluded:True) if:(= (next) (who at:(to))) (apply (remove (to)))) (then (set Var 4))) (move (from if:(= (* (from) (if (< 0 (count MovesThisTurn)) 1 0)) (* (last To) (if (< 0 (count MovesThisTurn)) 1 0)))) (to (intersection (sites Occupied by:Enemy) (union (expand (union (sites {(from)}) (sites Distance (step (directions {N E}) (to if:(is Empty (to)))) from:(from) (range 1 Infinity))) N) (expand (union (sites {(from)}) (sites Distance (step (directions {N E}) (to if:(is Empty (to)))) from:(from) (range 1 Infinity))) E))) if:(and (> (row of:(to)) (row of:(from))) (> (column of:(to)) (column of:(from)))) (apply (remove (to)))) (then (set Var 5))) (move (from if:(= (* (from) (if (< 0 (count MovesThisTurn)) 1 0)) (* (last To) (if (< 0 (count MovesThisTurn)) 1 0)))) (to (intersection (sites Occupied by:Enemy) (union (expand (union (sites {(from)}) (sites Distance (step (directions {S E}) (to if:(is Empty (to)))) from:(from) (range 1 Infinity))) S) (expand (union (sites {(from)}) (sites Distance (step (directions {S E}) (to if:(is Empty (to)))) from:(from) (range 1 Infinity))) E))) if:(and (< (row of:(to)) (row of:(from))) (> (column of:(to)) (column of:(from)))) (apply (remove (to)))) (then (set Var 6))) (move (from if:(= (* (from) (if (< 0 (count MovesThisTurn)) 1 0)) (* (last To) (if (< 0 (count MovesThisTurn)) 1 0)))) (to (intersection (sites Occupied by:Enemy) (union (expand (union (sites {(from)}) (sites Distance (step (directions {N W}) (to if:(is Empty (to)))) from:(from) (range 1 Infinity))) N) (expand (union (sites {(from)}) (sites Distance (step (directions {N W}) (to if:(is Empty (to)))) from:(from) (range 1 Infinity))) W))) if:(and (> (row of:(to)) (row of:(from))) (< (column of:(to)) (column of:(from)))) (apply (remove (to)))) (then (set Var 7))) (move (from if:(= (* (from) (if (< 0 (count MovesThisTurn)) 1 0)) (* (last To) (if (< 0 (count MovesThisTurn)) 1 0)))) (to (intersection (sites Occupied by:Enemy) (union (expand (union (sites {(from)}) (sites Distance (step (directions {S W}) (to if:(is Empty (to)))) from:(from) (range 1 Infinity))) S) (expand (union (sites {(from)}) (sites Distance (step (directions {S W}) (to if:(is Empty (to)))) from:(from) (range 1 Infinity))) W))) if:(and (< (row of:(to)) (row of:(from))) (< (column of:(to)) (column of:(from)))) (apply (remove (to)))) (then (set Var 8)))}) (if (= 1 (var)) (move (from if:(= (* (from) (if (< 0 (count MovesThisTurn)) 1 0)) (* (last To) (if (< 0 (count MovesThisTurn)) 1 0)))) (to (sites Direction from:(from) N stop:(is Occupied (to)) stopIncluded:True) if:(= (next) (who at:(to))) (apply (remove (to))))) (if (= 2 (var)) (move (from if:(= (* (from) (if (< 0 (count MovesThisTurn)) 1 0)) (* (last To) (if (< 0 (count MovesThisTurn)) 1 0)))) (to (sites Direction from:(from) E stop:(is Occupied (to)) stopIncluded:True) if:(= (next) (who at:(to))) (apply (remove (to))))) (if (= 3 (var)) (move (from if:(= (* (from) (if (< 0 (count MovesThisTurn)) 1 0)) (* (last To) (if (< 0 (count MovesThisTurn)) 1 0)))) (to (sites Direction from:(from) S stop:(is Occupied (to)) stopIncluded:True) if:(= (next) (who at:(to))) (apply (remove (to))))) (if (= 4 (var)) (move (from if:(= (* (from) (if (< 0 (count MovesThisTurn)) 1 0)) (* (last To) (if (< 0 (count MovesThisTurn)) 1 0)))) (to (sites Direction from:(from) W stop:(is Occupied (to)) stopIncluded:True) if:(= (next) (who at:(to))) (apply (remove (to))))) (if (= 5 (var)) (move (from if:(= (* (from) (if (< 0 (count MovesThisTurn)) 1 0)) (* (last To) (if (< 0 (count MovesThisTurn)) 1 0)))) (to (intersection (sites Occupied by:Enemy) (union (expand (union (sites {(from)}) (sites Distance (step (directions {N E}) (to if:(is Empty (to)))) from:(from) (range 1 Infinity))) N) (expand (union (sites {(from)}) (sites Distance (step (directions {N E}) (to if:(is Empty (to)))) from:(from) (range 1 Infinity))) E))) (apply (remove (to))))) (if (= 6 (var)) (move (from if:(= (* (from) (if (< 0 (count MovesThisTurn)) 1 0)) (* (last To) (if (< 0 (count MovesThisTurn)) 1 0)))) (to (intersection (sites Occupied by:Enemy) (union (expand (union (sites {(from)}) (sites Distance (step (directions {S E}) (to if:(is Empty (to)))) from:(from) (range 1 Infinity))) S) (expand (union (sites {(from)}) (sites Distance (step (directions {S E}) (to if:(is Empty (to)))) from:(from) (range 1 Infinity))) E))) (apply (remove (to))))) (if (= 7 (var)) (move (from if:(= (* (from) (if (< 0 (count MovesThisTurn)) 1 0)) (* (last To) (if (< 0 (count MovesThisTurn)) 1 0)))) (to (intersection (sites Occupied by:Enemy) (union (expand (union (sites {(from)}) (sites Distance (step (directions {N W}) (to if:(is Empty (to)))) from:(from) (range 1 Infinity))) N) (expand (union (sites {(from)}) (sites Distance (step (directions {N W}) (to if:(is Empty (to)))) from:(from) (range 1 Infinity))) W))) (apply (remove (to))))) (move (from if:(= (* (from) (if (< 0 (count MovesThisTurn)) 1 0)) (* (last To) (if (< 0 (count MovesThisTurn)) 1 0)))) (to (intersection (sites Occupied by:Enemy) (union (expand (union (sites {(from)}) (sites Distance (step (directions {S W}) (to if:(is Empty (to)))) from:(from) (range 1 Infinity))) S) (expand (union (sites {(from)}) (sites Distance (step (directions {S W}) (to if:(is Empty (to)))) from:(from) (range 1 Infinity))) W))) (apply (remove (to)))))))))))) (then (if (< 0 (count Sites in:(if (= 1 (var)) (intersection (sites Occupied by:Enemy) (sites Direction from:(last To) N stop:(is Occupied (to)) stopIncluded:True)) (if (= 2 (var)) (intersection (sites Occupied by:Enemy) (sites Direction from:(last To) E stop:(is Occupied (to)) stopIncluded:True)) (if (= 3 (var)) (intersection (sites Occupied by:Enemy) (sites Direction from:(last To) S stop:(is Occupied (to)) stopIncluded:True)) (if (= 4 (var)) (intersection (sites Occupied by:Enemy) (sites Direction from:(last To) W stop:(is Occupied (to)) stopIncluded:True)) (if (= 5 (var)) (intersection (sites Occupied by:Enemy) (union (expand (union (sites {(last To)}) (sites Distance (step (directions {N E}) (to if:(is Empty (to)))) from:(last To) (range 1 Infinity))) N) (expand (union (sites {(last To)}) (sites Distance (step (directions {N E}) (to if:(is Empty (to)))) from:(last To) (range 1 Infinity))) E))) (if (= 6 (var)) (intersection (sites Occupied by:Enemy) (union (expand (union (sites {(last To)}) (sites Distance (step (directions {S E}) (to if:(is Empty (to)))) from:(last To) (range 1 Infinity))) S) (expand (union (sites {(last To)}) (sites Distance (step (directions {S E}) (to if:(is Empty (to)))) from:(last To) (range 1 Infinity))) E))) (if (= 7 (var)) (intersection (sites Occupied by:Enemy) (union (expand (union (sites {(last To)}) (sites Distance (step (directions {N W}) (to if:(is Empty (to)))) from:(last To) (range 1 Infinity))) N) (expand (union (sites {(last To)}) (sites Distance (step (directions {N W}) (to if:(is Empty (to)))) from:(last To) (range 1 Infinity))) W))) (intersection (sites Occupied by:Enemy) (union (expand (union (sites {(last To)}) (sites Distance (step (directions {S W}) (to if:(is Empty (to)))) from:(last To) (range 1 Infinity))) S) (expand (union (sites {(last To)}) (sites Distance (step (directions {S W}) (to if:(is Empty (to)))) from:(last To) (range 1 Infinity))) W)))))))))))) (moveAgain)))))}) (rules (start {(place "Disc1" (forEach (sites Board) if:(or (and (is Even (row of:(site))) (> 2 (% (site) 4))) (and (is Odd (row of:(site))) (< 1 (% (site) 4)))))) (place "Disc2" (forEach (sites Board) if:(or (and (is Odd (row of:(site))) (> 2 (% (site) 4))) (and (is Even (row of:(site))) (< 1 (% (site) 4))))))}) (play (forEach Piece)) (end (if (no Pieces Next) (result Next Loss))))) 
4x7-15 (odd number only) board. One piece in each hole in the outer row. Four palm branches used as dice, with one side white and the other side yellow. The throws are equal to the number of white sides that fall up; when only yellow sides are up, the score is 6. When a player throws 1, 4, or 6, the player throws again. Players take turns throwing, until one throws 1, and that player begins to play. Each player moves in a boustrophedon path, from left to right in the row closest to them, right to left in the second row, and left to right in the third row. From there, the player may move again into the second row and continue as before, or move into the fourth row, proceeding from right to left, as long as at least one of the opponent's pieces remains there. The piece may enter the third row again upon reaching the end of the fourth row, but only when the player has either no pieces in their first row, or one group of pieces in the same spot (see below). When a piece has moved out of the fourth row, it may not enter it again during the game. When a player's piece lands in the same spot as another piece belonging to the player, the pieces may move as one piece. When a player's piece lands on a space occupied by an opponent's, piece, the opponent's piece is captured. The player who captures all of the opponent's pieces wins. Each row has 7 holes.
(game "Tab" (players 2) (equipment {(board (rectangle 4 7) {(track "HomeTrack1" "0,E,N1,W" P1 directed:True) (track "HomeTrack2" "27,W,S1,E" P2 directed:True) (track "MiddleTrack" "13,W,N1,E" loop:True) (track "EnemyTrack1" "14,E,N1,W,S1,E" P1 directed:True) (track "EnemyTrack2" "13,W,S1,E,N1,W" P2 directed:True)} use:Vertex) (piece "Stick" Each) (regions "AllSites" (sites Board)) (dice d:2 from:0 num:4) (map "Throw" {(pair 0 6) (pair 1 1) (pair 2 2) (pair 3 3) (pair 4 4)}) (regions "Home" P1 (sites Bottom)) (regions "Home" P2 (sites Top))}) (rules (start {(place "Stick1" (sites Bottom)) (place "Stick2" (sites Top))}) phases:{(phase "InitGame" (play (do (roll) next:(move Pass) (then (if (= 1 (mapEntry (count Pips))) (moveAgain))))) (nextPhase (= 1 (mapEntry (count Pips))) "Play")) (phase "Play" (play (do (roll) next:(forEach Site (sites Occupied by:Mover) (or {(if (is In (site) (sites Track Mover "HomeTrack")) (move (from (site)) (to (trackSite Move from:(site) "HomeTrack" steps:(mapEntry (count Pips))) (apply if:(is Enemy (who at:(to))) (remove (to) count:(count at:(to))))) count:(count at:(site)))) (if (is In (site) (sites Track Mover "MiddleTrack")) (move (from (site)) (to (trackSite Move from:(site) "MiddleTrack" steps:(mapEntry (count Pips))) (apply if:(is Enemy (who at:(to))) (remove (to) count:(count at:(to))))) count:(count at:(site)))) (if (is In (site) (sites Track Mover "EnemyTrack")) (if (if (is In (site) (sites Next "Home")) True (and (!= 0 (count Pieces Next in:(sites Next "Home"))) (= 0 (state at:(site))))) (move (from (site)) (to (trackSite Move from:(site) "EnemyTrack" steps:(mapEntry (count Pips))) (apply if:(is Enemy (who at:(to))) (remove (to) count:(count at:(to))))) count:(count at:(site)) (then (if (and (is In (last To) (sites Next "Home")) (= 0 (state at:(last To)))) (set State at:(last To) 1))))))})) (then (if (is In (mapEntry (count Pips)) (sites {1 4 6})) (moveAgain))))))} (end (if (no Pieces Next) (result Next Loss))))) 
Seven players. Heptagonal board, with seven semi-circular socket as spaces on each side. Seven pieces per player, which begin on the leftmost spot on their side. Players are as follows: Saturn = black; Jupiter = green; Mars = red; the sun = yellow; Venus = purple; Mercury = multi-colored; the moon is white. Pieces move in an anti-clockwise direction around the board. Three seven-sided die. Players move according to the number on each die by moving one piece the value on one die then another piece the value on the other die, or by moving one piece the value of one die and then the value of the other. When a piece lands on a space with a single piece belonging to an opponent, the opponent's piece is removed from the board. Play continues until one player remains, who becomes the winner.
(game "Tablas Astronomias" (players 7) (equipment {(board (concentric {49}) {(track "Track" {48 46 44 42 40 38 36 34 32 30 28 26 24 22 20 18 16 14 12 10 8 6 4 2 0 1 3 5 7 9 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47} loop:True)} use:Vertex) (dice d:7 num:3) (piece "Disc" Each)}) (rules (start {(place Stack "Disc1" 14 count:7) (place Stack "Disc2" 0 count:7) (place Stack "Disc3" 13 count:7) (place Stack "Disc4" 27 count:7) (place Stack "Disc5" 41 count:7) (place Stack "Disc6" 42 count:7) (place Stack "Disc7" 28 count:7)}) (play (do (if (not (is Prev Mover)) (roll)) next:(forEach Die if:(!= (pips) 0) (forEach Site (sites Occupied by:Mover) (move (from (site)) (to (trackSite Move from:(site) steps:(pips)) if:(or (and (is Enemy (who at:(to))) (= (topLevel at:(to)) 0)) (not (is Enemy (who at:(to))))) (apply if:(is Enemy (who at:(to))) (remove (to)))))) (then (if (not (all DiceUsed)) (moveAgain)))))) (end (forEach NonMover if:(no Pieces Player) (result Player Loss))))) 
Each player controls a tank with three health and an initial shooting range of two spaces. Each player gains one action point at the start of their turn. Players may use an action point during their turn to perform one of four actions: - Move their tank to an adjacent space. - Shoot at another tank within shooting range, deducting one point of health. - Trade with another tank within shooting range, increasing the owning players action points by one. - Increase the shooting range of their tank by one space. Players can pass to conserve action points between turns. A player loses if their tank reaches zero health. 2 players. The game is played on a 5x10 board.
(game "Tank Tactics" (players 2) (equipment {(board (rectangle 5 10)) (hand Each) (piece "Tank" Each (or {(move Step (to if:(is Empty (to))) (then (if (> (score Mover) 1) (and (addScore Mover -1) (moveAgain))))) (move Select (from) (to (intersection (sites Occupied by:Enemy container:"Board") (sites Distance from:(from) (range 1 (state at:(from)))))) (then (and (if (= (value Piece at:(last To)) 1) (remove (last To)) (set Value at:(last To) (- (value Piece at:(last To)) 1))) (if (> (score Mover) 1) (and (addScore Mover -1) (moveAgain)))))) (move Select (from) (to (intersection (sites Occupied by:Enemy container:"Board") (sites Distance from:(from) (range 1 (state at:(from)))))) (then (and (addScore (player (who at:(last To))) 1) (if (> (score Mover) 1) (and (addScore Mover -1) (moveAgain)))))) (move Select (from) (to) (then (and (if (< (state at:(last To)) 100) (set State at:(last To) (+ 1 (state at:(last To))))) (if (> (score Mover) 1) (and (addScore Mover -1) (moveAgain))))))}) maxState:100)}) (rules (meta (passEnd NoEnd)) (start {(set Score Each 1) (place "Tank1" (handSite P1) state:2 value:3) (place "Tank2" (handSite P2) state:2 value:3)}) phases:{(phase "Placement" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (or (forEach Piece) (move Pass (then (addScore Mover 1))))))} (end (forEach NonMover if:(no Pieces Player) (result Player Loss))))) 
8x8 board, 32 pieces per player. There's a diagonal in the centre of the chessboard, but it's not an edge. The game is played by white first and is divided into three main stage: Layout, Battle and Fly. Layout stage: When placing a piece, both player must first place a piece on the diagonal of the middle square of the board, and then two players alternately put a piece on any point of the board until the board is full of chess pieces. Battle Stage: At the end of the Layout stage, the first player removes the pieces on the Jiu-ti (diagonal line in the middle square of the board), and then the player who secondly place pieces in the Layout stage starts the first move and enters the Battle Stage; During the move, the opponent's pieces are taken by using the Square capture, Jumping capture. Flying Stage: Later in the game, if a player's number of pieces is less than 8, the player enters the Flying Pieces phase, where the player moves pieces without the one-step-per-frame limit, and pieces can land on any empty square. The opponent's pieces are taken by using the Square capture, Jumping capture, but the rules of the Jumping capture have changed a little. Jumping capture: Pieces capture opponent's pieces by jumping them in a forward direction if they are adjacent. Multiple captures are allowed. But in the Flying Stage, single captures are forbidden, you can only do multiple captures. Square capture: Use four adjacent friendly chess pieces to make a square. When a player makes a new square, they may remove another of the opponent's pieces from the board. Multiple captures are allowed. The goal: One player wins if the number of pieces of the opponent is less than 4.
(game "Tibetan Jiuqi" (players 2) (equipment {(board (add (square 8)) use:Vertex) (piece "Marker" Each (or (move Step (to if:(is Empty (to))) (then (if (> (count Sites in:(forEach (sites Around (last To)) if:(if (is In (last To) (sites {(ahead (site) S)})) (if (not (is In (site) (sites {"H2" "H3" "H4" "H5" "H6" "H7" "H8"}))) (and {(is Mover (who at:(ahead (site) E))) (is Mover (who at:(ahead (site) SE))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) W)})) (if (not (is In (site) (sites {"B1" "C1" "D1" "E1" "F1" "G1" "H1"}))) (and {(is Mover (who at:(ahead (site) S))) (is Mover (who at:(ahead (site) SW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) N)})) (if (not (is In (site) (sites {"A1" "A2" "A3" "A4" "A5" "A6" "A7"}))) (and {(is Mover (who at:(ahead (site) W))) (is Mover (who at:(ahead (site) NW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) E)})) (if (not (is In (site) (sites {"A8" "B8" "C8" "D8" "E8" "F8" "G8"}))) (and {(is Mover (who at:(ahead (site) N))) (is Mover (who at:(ahead (site) NE))) (is Mover (who at:(site)))})))))))) 0) (and (set Value Mover (count Sites in:(forEach (sites Around (last To)) if:(if (is In (last To) (sites {(ahead (site) S)})) (if (not (is In (site) (sites {"H2" "H3" "H4" "H5" "H6" "H7" "H8"}))) (and {(is Mover (who at:(ahead (site) E))) (is Mover (who at:(ahead (site) SE))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) W)})) (if (not (is In (site) (sites {"B1" "C1" "D1" "E1" "F1" "G1" "H1"}))) (and {(is Mover (who at:(ahead (site) S))) (is Mover (who at:(ahead (site) SW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) N)})) (if (not (is In (site) (sites {"A1" "A2" "A3" "A4" "A5" "A6" "A7"}))) (and {(is Mover (who at:(ahead (site) W))) (is Mover (who at:(ahead (site) NW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) E)})) (if (not (is In (site) (sites {"A8" "B8" "C8" "D8" "E8" "F8" "G8"}))) (and {(is Mover (who at:(ahead (site) N))) (is Mover (who at:(ahead (site) NE))) (is Mover (who at:(site)))}))))))))) (moveAgain))))) (move Hop (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (remove (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (and (set Value Mover (count Sites in:(forEach (sites Around (last To)) if:(if (is In (last To) (sites {(ahead (site) S)})) (if (not (is In (site) (sites {"H2" "H3" "H4" "H5" "H6" "H7" "H8"}))) (and {(is Mover (who at:(ahead (site) E))) (is Mover (who at:(ahead (site) SE))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) W)})) (if (not (is In (site) (sites {"B1" "C1" "D1" "E1" "F1" "G1" "H1"}))) (and {(is Mover (who at:(ahead (site) S))) (is Mover (who at:(ahead (site) SW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) N)})) (if (not (is In (site) (sites {"A1" "A2" "A3" "A4" "A5" "A6" "A7"}))) (and {(is Mover (who at:(ahead (site) W))) (is Mover (who at:(ahead (site) NW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) E)})) (if (not (is In (site) (sites {"A8" "B8" "C8" "D8" "E8" "F8" "G8"}))) (and {(is Mover (who at:(ahead (site) N))) (is Mover (who at:(ahead (site) NE))) (is Mover (who at:(site)))}))))))))) (moveAgain)) (if (> (count Sites in:(forEach (sites Around (last To)) if:(if (is In (last To) (sites {(ahead (site) S)})) (if (not (is In (site) (sites {"H2" "H3" "H4" "H5" "H6" "H7" "H8"}))) (and {(is Mover (who at:(ahead (site) E))) (is Mover (who at:(ahead (site) SE))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) W)})) (if (not (is In (site) (sites {"B1" "C1" "D1" "E1" "F1" "G1" "H1"}))) (and {(is Mover (who at:(ahead (site) S))) (is Mover (who at:(ahead (site) SW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) N)})) (if (not (is In (site) (sites {"A1" "A2" "A3" "A4" "A5" "A6" "A7"}))) (and {(is Mover (who at:(ahead (site) W))) (is Mover (who at:(ahead (site) NW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) E)})) (if (not (is In (site) (sites {"A8" "B8" "C8" "D8" "E8" "F8" "G8"}))) (and {(is Mover (who at:(ahead (site) N))) (is Mover (who at:(ahead (site) NE))) (is Mover (who at:(site)))})))))))) 0) (and (set Value Mover (count Sites in:(forEach (sites Around (last To)) if:(if (is In (last To) (sites {(ahead (site) S)})) (if (not (is In (site) (sites {"H2" "H3" "H4" "H5" "H6" "H7" "H8"}))) (and {(is Mover (who at:(ahead (site) E))) (is Mover (who at:(ahead (site) SE))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) W)})) (if (not (is In (site) (sites {"B1" "C1" "D1" "E1" "F1" "G1" "H1"}))) (and {(is Mover (who at:(ahead (site) S))) (is Mover (who at:(ahead (site) SW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) N)})) (if (not (is In (site) (sites {"A1" "A2" "A3" "A4" "A5" "A6" "A7"}))) (and {(is Mover (who at:(ahead (site) W))) (is Mover (who at:(ahead (site) NW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) E)})) (if (not (is In (site) (sites {"A8" "B8" "C8" "D8" "E8" "F8" "G8"}))) (and {(is Mover (who at:(ahead (site) N))) (is Mover (who at:(ahead (site) NE))) (is Mover (who at:(site)))}))))))))) (moveAgain)))))))) (hand Each)}) (rules (start (place "Marker" "Hand" count:32)) phases:{(phase "FirstPlacement" (play (or (move (from (handSite Mover)) (to (sites "D4") if:(is Empty (to)))) (move (from (handSite Mover)) (to (sites "E5") if:(is Empty (to)))))) (nextPhase Mover "Layout")) (phase "Layout" (play (move (from (handSite Mover)) (to (sites Empty)))) (nextPhase Mover (all Sites (sites Hand Mover) if:(= 0 (count Cell at:(site)))) "RemoveCentre")) (phase "RemoveCentre" (play (move Remove (sites {"D4" "E5"}) (then (if (not (and (is Empty 27) (is Empty 36))) (moveAgain))))) (nextPhase All (and (is Empty 27) (is Empty 36)) "Battle")) (phase "Battle" (play (if (is Prev Mover) (if (> (value Player Mover) 0) (or (move Remove (sites Occupied by:Next) (then (if (> (value Player Mover) 1) (and (moveAgain) (set Value Mover (- (value Player Mover) 1))) (set Value Mover 0)))) (if (is Mover (who at:(last To))) (move Hop (from (last To)) (between if:(and {(not (is In (between) (sites ToClear))) (is Enemy (who at:(between))) (!= (between) (var "Between"))}) (apply (and (remove (between)) (remove (var "Between"))))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (and (set Value Mover (count Sites in:(forEach (sites Around (last To)) if:(if (is In (last To) (sites {(ahead (site) S)})) (if (not (is In (site) (sites {"H2" "H3" "H4" "H5" "H6" "H7" "H8"}))) (and {(is Mover (who at:(ahead (site) E))) (is Mover (who at:(ahead (site) SE))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) W)})) (if (not (is In (site) (sites {"B1" "C1" "D1" "E1" "F1" "G1" "H1"}))) (and {(is Mover (who at:(ahead (site) S))) (is Mover (who at:(ahead (site) SW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) N)})) (if (not (is In (site) (sites {"A1" "A2" "A3" "A4" "A5" "A6" "A7"}))) (and {(is Mover (who at:(ahead (site) W))) (is Mover (who at:(ahead (site) NW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) E)})) (if (not (is In (site) (sites {"A8" "B8" "C8" "D8" "E8" "F8" "G8"}))) (and {(is Mover (who at:(ahead (site) N))) (is Mover (who at:(ahead (site) NE))) (is Mover (who at:(site)))}))))))))) (moveAgain)) (if (> (count Sites in:(forEach (sites Around (last To)) if:(if (is In (last To) (sites {(ahead (site) S)})) (if (not (is In (site) (sites {"H2" "H3" "H4" "H5" "H6" "H7" "H8"}))) (and {(is Mover (who at:(ahead (site) E))) (is Mover (who at:(ahead (site) SE))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) W)})) (if (not (is In (site) (sites {"B1" "C1" "D1" "E1" "F1" "G1" "H1"}))) (and {(is Mover (who at:(ahead (site) S))) (is Mover (who at:(ahead (site) SW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) N)})) (if (not (is In (site) (sites {"A1" "A2" "A3" "A4" "A5" "A6" "A7"}))) (and {(is Mover (who at:(ahead (site) W))) (is Mover (who at:(ahead (site) NW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) E)})) (if (not (is In (site) (sites {"A8" "B8" "C8" "D8" "E8" "F8" "G8"}))) (and {(is Mover (who at:(ahead (site) N))) (is Mover (who at:(ahead (site) NE))) (is Mover (who at:(site)))})))))))) 0) (and (set Value Mover (count Sites in:(forEach (sites Around (last To)) if:(if (is In (last To) (sites {(ahead (site) S)})) (if (not (is In (site) (sites {"H2" "H3" "H4" "H5" "H6" "H7" "H8"}))) (and {(is Mover (who at:(ahead (site) E))) (is Mover (who at:(ahead (site) SE))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) W)})) (if (not (is In (site) (sites {"B1" "C1" "D1" "E1" "F1" "G1" "H1"}))) (and {(is Mover (who at:(ahead (site) S))) (is Mover (who at:(ahead (site) SW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) N)})) (if (not (is In (site) (sites {"A1" "A2" "A3" "A4" "A5" "A6" "A7"}))) (and {(is Mover (who at:(ahead (site) W))) (is Mover (who at:(ahead (site) NW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) E)})) (if (not (is In (site) (sites {"A8" "B8" "C8" "D8" "E8" "F8" "G8"}))) (and {(is Mover (who at:(ahead (site) N))) (is Mover (who at:(ahead (site) NE))) (is Mover (who at:(site)))}))))))))) (moveAgain)))))))) (or (if (is Mover (who at:(last To))) (move Hop (from (last To)) (between if:(and {(not (is In (between) (sites ToClear))) (is Enemy (who at:(between))) (!= (between) (var "Between"))}) (apply (and (remove (between)) (remove (var "Between"))))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (and (set Value Mover (count Sites in:(forEach (sites Around (last To)) if:(if (is In (last To) (sites {(ahead (site) S)})) (if (not (is In (site) (sites {"H2" "H3" "H4" "H5" "H6" "H7" "H8"}))) (and {(is Mover (who at:(ahead (site) E))) (is Mover (who at:(ahead (site) SE))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) W)})) (if (not (is In (site) (sites {"B1" "C1" "D1" "E1" "F1" "G1" "H1"}))) (and {(is Mover (who at:(ahead (site) S))) (is Mover (who at:(ahead (site) SW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) N)})) (if (not (is In (site) (sites {"A1" "A2" "A3" "A4" "A5" "A6" "A7"}))) (and {(is Mover (who at:(ahead (site) W))) (is Mover (who at:(ahead (site) NW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) E)})) (if (not (is In (site) (sites {"A8" "B8" "C8" "D8" "E8" "F8" "G8"}))) (and {(is Mover (who at:(ahead (site) N))) (is Mover (who at:(ahead (site) NE))) (is Mover (who at:(site)))}))))))))) (moveAgain)) (if (> (count Sites in:(forEach (sites Around (last To)) if:(if (is In (last To) (sites {(ahead (site) S)})) (if (not (is In (site) (sites {"H2" "H3" "H4" "H5" "H6" "H7" "H8"}))) (and {(is Mover (who at:(ahead (site) E))) (is Mover (who at:(ahead (site) SE))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) W)})) (if (not (is In (site) (sites {"B1" "C1" "D1" "E1" "F1" "G1" "H1"}))) (and {(is Mover (who at:(ahead (site) S))) (is Mover (who at:(ahead (site) SW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) N)})) (if (not (is In (site) (sites {"A1" "A2" "A3" "A4" "A5" "A6" "A7"}))) (and {(is Mover (who at:(ahead (site) W))) (is Mover (who at:(ahead (site) NW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) E)})) (if (not (is In (site) (sites {"A8" "B8" "C8" "D8" "E8" "F8" "G8"}))) (and {(is Mover (who at:(ahead (site) N))) (is Mover (who at:(ahead (site) NE))) (is Mover (who at:(site)))})))))))) 0) (and (set Value Mover (count Sites in:(forEach (sites Around (last To)) if:(if (is In (last To) (sites {(ahead (site) S)})) (if (not (is In (site) (sites {"H2" "H3" "H4" "H5" "H6" "H7" "H8"}))) (and {(is Mover (who at:(ahead (site) E))) (is Mover (who at:(ahead (site) SE))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) W)})) (if (not (is In (site) (sites {"B1" "C1" "D1" "E1" "F1" "G1" "H1"}))) (and {(is Mover (who at:(ahead (site) S))) (is Mover (who at:(ahead (site) SW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) N)})) (if (not (is In (site) (sites {"A1" "A2" "A3" "A4" "A5" "A6" "A7"}))) (and {(is Mover (who at:(ahead (site) W))) (is Mover (who at:(ahead (site) NW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) E)})) (if (not (is In (site) (sites {"A8" "B8" "C8" "D8" "E8" "F8" "G8"}))) (and {(is Mover (who at:(ahead (site) N))) (is Mover (who at:(ahead (site) NE))) (is Mover (who at:(site)))}))))))))) (moveAgain))))))) (move Pass))) (forEach Piece))) (nextPhase All (or (< (count Pieces Mover) 9) (< (count Pieces Next) 9)) "Fly")) (phase "Fly" (play (if (is Prev Mover) (if (> (value Player Mover) 0) (or (move Remove (sites Occupied by:Next) (then (if (> (value Player Mover) 1) (and (moveAgain) (set Value Mover (- (value Player Mover) 1))) (set Value Mover 0)))) (if (is Mover (who at:(last To))) (move Hop (from (last To)) (between if:(and {(not (is In (between) (sites ToClear))) (is Enemy (who at:(between))) (!= (between) (var "Between"))}) (apply (and (remove (between)) (remove (var "Between"))))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (and (set Value Mover (count Sites in:(forEach (sites Around (last To)) if:(if (is In (last To) (sites {(ahead (site) S)})) (if (not (is In (site) (sites {"H2" "H3" "H4" "H5" "H6" "H7" "H8"}))) (and {(is Mover (who at:(ahead (site) E))) (is Mover (who at:(ahead (site) SE))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) W)})) (if (not (is In (site) (sites {"B1" "C1" "D1" "E1" "F1" "G1" "H1"}))) (and {(is Mover (who at:(ahead (site) S))) (is Mover (who at:(ahead (site) SW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) N)})) (if (not (is In (site) (sites {"A1" "A2" "A3" "A4" "A5" "A6" "A7"}))) (and {(is Mover (who at:(ahead (site) W))) (is Mover (who at:(ahead (site) NW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) E)})) (if (not (is In (site) (sites {"A8" "B8" "C8" "D8" "E8" "F8" "G8"}))) (and {(is Mover (who at:(ahead (site) N))) (is Mover (who at:(ahead (site) NE))) (is Mover (who at:(site)))}))))))))) (moveAgain)) (if (> (count Sites in:(forEach (sites Around (last To)) if:(if (is In (last To) (sites {(ahead (site) S)})) (if (not (is In (site) (sites {"H2" "H3" "H4" "H5" "H6" "H7" "H8"}))) (and {(is Mover (who at:(ahead (site) E))) (is Mover (who at:(ahead (site) SE))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) W)})) (if (not (is In (site) (sites {"B1" "C1" "D1" "E1" "F1" "G1" "H1"}))) (and {(is Mover (who at:(ahead (site) S))) (is Mover (who at:(ahead (site) SW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) N)})) (if (not (is In (site) (sites {"A1" "A2" "A3" "A4" "A5" "A6" "A7"}))) (and {(is Mover (who at:(ahead (site) W))) (is Mover (who at:(ahead (site) NW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) E)})) (if (not (is In (site) (sites {"A8" "B8" "C8" "D8" "E8" "F8" "G8"}))) (and {(is Mover (who at:(ahead (site) N))) (is Mover (who at:(ahead (site) NE))) (is Mover (who at:(site)))})))))))) 0) (and (set Value Mover (count Sites in:(forEach (sites Around (last To)) if:(if (is In (last To) (sites {(ahead (site) S)})) (if (not (is In (site) (sites {"H2" "H3" "H4" "H5" "H6" "H7" "H8"}))) (and {(is Mover (who at:(ahead (site) E))) (is Mover (who at:(ahead (site) SE))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) W)})) (if (not (is In (site) (sites {"B1" "C1" "D1" "E1" "F1" "G1" "H1"}))) (and {(is Mover (who at:(ahead (site) S))) (is Mover (who at:(ahead (site) SW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) N)})) (if (not (is In (site) (sites {"A1" "A2" "A3" "A4" "A5" "A6" "A7"}))) (and {(is Mover (who at:(ahead (site) W))) (is Mover (who at:(ahead (site) NW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) E)})) (if (not (is In (site) (sites {"A8" "B8" "C8" "D8" "E8" "F8" "G8"}))) (and {(is Mover (who at:(ahead (site) N))) (is Mover (who at:(ahead (site) NE))) (is Mover (who at:(site)))}))))))))) (moveAgain)))))))) (or (if (is Mover (who at:(last To))) (move Hop (from (last To)) (between if:(and {(not (is In (between) (sites ToClear))) (is Enemy (who at:(between))) (!= (between) (var "Between"))}) (apply (and (remove (between)) (remove (var "Between"))))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between))))) (to if:(is Empty (to))))) (and (set Value Mover (count Sites in:(forEach (sites Around (last To)) if:(if (is In (last To) (sites {(ahead (site) S)})) (if (not (is In (site) (sites {"H2" "H3" "H4" "H5" "H6" "H7" "H8"}))) (and {(is Mover (who at:(ahead (site) E))) (is Mover (who at:(ahead (site) SE))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) W)})) (if (not (is In (site) (sites {"B1" "C1" "D1" "E1" "F1" "G1" "H1"}))) (and {(is Mover (who at:(ahead (site) S))) (is Mover (who at:(ahead (site) SW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) N)})) (if (not (is In (site) (sites {"A1" "A2" "A3" "A4" "A5" "A6" "A7"}))) (and {(is Mover (who at:(ahead (site) W))) (is Mover (who at:(ahead (site) NW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) E)})) (if (not (is In (site) (sites {"A8" "B8" "C8" "D8" "E8" "F8" "G8"}))) (and {(is Mover (who at:(ahead (site) N))) (is Mover (who at:(ahead (site) NE))) (is Mover (who at:(site)))}))))))))) (moveAgain)) (if (> (count Sites in:(forEach (sites Around (last To)) if:(if (is In (last To) (sites {(ahead (site) S)})) (if (not (is In (site) (sites {"H2" "H3" "H4" "H5" "H6" "H7" "H8"}))) (and {(is Mover (who at:(ahead (site) E))) (is Mover (who at:(ahead (site) SE))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) W)})) (if (not (is In (site) (sites {"B1" "C1" "D1" "E1" "F1" "G1" "H1"}))) (and {(is Mover (who at:(ahead (site) S))) (is Mover (who at:(ahead (site) SW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) N)})) (if (not (is In (site) (sites {"A1" "A2" "A3" "A4" "A5" "A6" "A7"}))) (and {(is Mover (who at:(ahead (site) W))) (is Mover (who at:(ahead (site) NW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) E)})) (if (not (is In (site) (sites {"A8" "B8" "C8" "D8" "E8" "F8" "G8"}))) (and {(is Mover (who at:(ahead (site) N))) (is Mover (who at:(ahead (site) NE))) (is Mover (who at:(site)))})))))))) 0) (and (set Value Mover (count Sites in:(forEach (sites Around (last To)) if:(if (is In (last To) (sites {(ahead (site) S)})) (if (not (is In (site) (sites {"H2" "H3" "H4" "H5" "H6" "H7" "H8"}))) (and {(is Mover (who at:(ahead (site) E))) (is Mover (who at:(ahead (site) SE))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) W)})) (if (not (is In (site) (sites {"B1" "C1" "D1" "E1" "F1" "G1" "H1"}))) (and {(is Mover (who at:(ahead (site) S))) (is Mover (who at:(ahead (site) SW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) N)})) (if (not (is In (site) (sites {"A1" "A2" "A3" "A4" "A5" "A6" "A7"}))) (and {(is Mover (who at:(ahead (site) W))) (is Mover (who at:(ahead (site) NW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) E)})) (if (not (is In (site) (sites {"A8" "B8" "C8" "D8" "E8" "F8" "G8"}))) (and {(is Mover (who at:(ahead (site) N))) (is Mover (who at:(ahead (site) NE))) (is Mover (who at:(site)))}))))))))) (moveAgain))))))) (move Pass))) (if (< (count Pieces Mover) 9) (forEach Piece (or (move Hop (from (sites Occupied by:Mover)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (set Var "Between" (between)))) (to if:(is Empty (to))) (then (if (can Move (hop (from (last To)) (between if:(and {(not (is In (between) (sites ToClear))) (is Enemy (who at:(between))) (!= (between) (var "Between"))})) (to if:(is Empty (to))))) (and (set Value Mover (count Sites in:(forEach (sites Around (last To)) if:(if (is In (last To) (sites {(ahead (site) S)})) (if (not (is In (site) (sites {"H2" "H3" "H4" "H5" "H6" "H7" "H8"}))) (and {(is Mover (who at:(ahead (site) E))) (is Mover (who at:(ahead (site) SE))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) W)})) (if (not (is In (site) (sites {"B1" "C1" "D1" "E1" "F1" "G1" "H1"}))) (and {(is Mover (who at:(ahead (site) S))) (is Mover (who at:(ahead (site) SW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) N)})) (if (not (is In (site) (sites {"A1" "A2" "A3" "A4" "A5" "A6" "A7"}))) (and {(is Mover (who at:(ahead (site) W))) (is Mover (who at:(ahead (site) NW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) E)})) (if (not (is In (site) (sites {"A8" "B8" "C8" "D8" "E8" "F8" "G8"}))) (and {(is Mover (who at:(ahead (site) N))) (is Mover (who at:(ahead (site) NE))) (is Mover (who at:(site)))}))))))))) (moveAgain)) (if (> (count Sites in:(forEach (sites Around (last To)) if:(if (is In (last To) (sites {(ahead (site) S)})) (if (not (is In (site) (sites {"H2" "H3" "H4" "H5" "H6" "H7" "H8"}))) (and {(is Mover (who at:(ahead (site) E))) (is Mover (who at:(ahead (site) SE))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) W)})) (if (not (is In (site) (sites {"B1" "C1" "D1" "E1" "F1" "G1" "H1"}))) (and {(is Mover (who at:(ahead (site) S))) (is Mover (who at:(ahead (site) SW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) N)})) (if (not (is In (site) (sites {"A1" "A2" "A3" "A4" "A5" "A6" "A7"}))) (and {(is Mover (who at:(ahead (site) W))) (is Mover (who at:(ahead (site) NW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) E)})) (if (not (is In (site) (sites {"A8" "B8" "C8" "D8" "E8" "F8" "G8"}))) (and {(is Mover (who at:(ahead (site) N))) (is Mover (who at:(ahead (site) NE))) (is Mover (who at:(site)))})))))))) 0) (and (set Value Mover (count Sites in:(forEach (sites Around (last To)) if:(if (is In (last To) (sites {(ahead (site) S)})) (if (not (is In (site) (sites {"H2" "H3" "H4" "H5" "H6" "H7" "H8"}))) (and {(is Mover (who at:(ahead (site) E))) (is Mover (who at:(ahead (site) SE))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) W)})) (if (not (is In (site) (sites {"B1" "C1" "D1" "E1" "F1" "G1" "H1"}))) (and {(is Mover (who at:(ahead (site) S))) (is Mover (who at:(ahead (site) SW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) N)})) (if (not (is In (site) (sites {"A1" "A2" "A3" "A4" "A5" "A6" "A7"}))) (and {(is Mover (who at:(ahead (site) W))) (is Mover (who at:(ahead (site) NW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) E)})) (if (not (is In (site) (sites {"A8" "B8" "C8" "D8" "E8" "F8" "G8"}))) (and {(is Mover (who at:(ahead (site) N))) (is Mover (who at:(ahead (site) NE))) (is Mover (who at:(site)))}))))))))) (moveAgain)))))) (move (from (sites Occupied by:Mover)) (to (sites Empty)) (then (if (> (count Sites in:(forEach (sites Around (last To)) if:(if (is In (last To) (sites {(ahead (site) S)})) (if (not (is In (site) (sites {"H2" "H3" "H4" "H5" "H6" "H7" "H8"}))) (and {(is Mover (who at:(ahead (site) E))) (is Mover (who at:(ahead (site) SE))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) W)})) (if (not (is In (site) (sites {"B1" "C1" "D1" "E1" "F1" "G1" "H1"}))) (and {(is Mover (who at:(ahead (site) S))) (is Mover (who at:(ahead (site) SW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) N)})) (if (not (is In (site) (sites {"A1" "A2" "A3" "A4" "A5" "A6" "A7"}))) (and {(is Mover (who at:(ahead (site) W))) (is Mover (who at:(ahead (site) NW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) E)})) (if (not (is In (site) (sites {"A8" "B8" "C8" "D8" "E8" "F8" "G8"}))) (and {(is Mover (who at:(ahead (site) N))) (is Mover (who at:(ahead (site) NE))) (is Mover (who at:(site)))})))))))) 0) (and (set Value Mover (count Sites in:(forEach (sites Around (last To)) if:(if (is In (last To) (sites {(ahead (site) S)})) (if (not (is In (site) (sites {"H2" "H3" "H4" "H5" "H6" "H7" "H8"}))) (and {(is Mover (who at:(ahead (site) E))) (is Mover (who at:(ahead (site) SE))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) W)})) (if (not (is In (site) (sites {"B1" "C1" "D1" "E1" "F1" "G1" "H1"}))) (and {(is Mover (who at:(ahead (site) S))) (is Mover (who at:(ahead (site) SW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) N)})) (if (not (is In (site) (sites {"A1" "A2" "A3" "A4" "A5" "A6" "A7"}))) (and {(is Mover (who at:(ahead (site) W))) (is Mover (who at:(ahead (site) NW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) E)})) (if (not (is In (site) (sites {"A8" "B8" "C8" "D8" "E8" "F8" "G8"}))) (and {(is Mover (who at:(ahead (site) N))) (is Mover (who at:(ahead (site) NE))) (is Mover (who at:(site)))}))))))))) (moveAgain))))))) (forEach Piece (or (move Step (to if:(is Empty (to))) (then (if (> (count Sites in:(forEach (sites Around (last To)) if:(if (is In (last To) (sites {(ahead (site) S)})) (if (not (is In (site) (sites {"H2" "H3" "H4" "H5" "H6" "H7" "H8"}))) (and {(is Mover (who at:(ahead (site) E))) (is Mover (who at:(ahead (site) SE))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) W)})) (if (not (is In (site) (sites {"B1" "C1" "D1" "E1" "F1" "G1" "H1"}))) (and {(is Mover (who at:(ahead (site) S))) (is Mover (who at:(ahead (site) SW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) N)})) (if (not (is In (site) (sites {"A1" "A2" "A3" "A4" "A5" "A6" "A7"}))) (and {(is Mover (who at:(ahead (site) W))) (is Mover (who at:(ahead (site) NW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) E)})) (if (not (is In (site) (sites {"A8" "B8" "C8" "D8" "E8" "F8" "G8"}))) (and {(is Mover (who at:(ahead (site) N))) (is Mover (who at:(ahead (site) NE))) (is Mover (who at:(site)))})))))))) 0) (and (set Value Mover (count Sites in:(forEach (sites Around (last To)) if:(if (is In (last To) (sites {(ahead (site) S)})) (if (not (is In (site) (sites {"H2" "H3" "H4" "H5" "H6" "H7" "H8"}))) (and {(is Mover (who at:(ahead (site) E))) (is Mover (who at:(ahead (site) SE))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) W)})) (if (not (is In (site) (sites {"B1" "C1" "D1" "E1" "F1" "G1" "H1"}))) (and {(is Mover (who at:(ahead (site) S))) (is Mover (who at:(ahead (site) SW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) N)})) (if (not (is In (site) (sites {"A1" "A2" "A3" "A4" "A5" "A6" "A7"}))) (and {(is Mover (who at:(ahead (site) W))) (is Mover (who at:(ahead (site) NW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) E)})) (if (not (is In (site) (sites {"A8" "B8" "C8" "D8" "E8" "F8" "G8"}))) (and {(is Mover (who at:(ahead (site) N))) (is Mover (who at:(ahead (site) NE))) (is Mover (who at:(site)))}))))))))) (moveAgain))))) (move Hop (from (sites Occupied by:Mover)) (between if:(and (not (is In (between) (sites ToClear))) (is Enemy (who at:(between)))) (apply (set Var "Between" (between)))) (to if:(and (is Empty (to)) (can Move (hop (from (to)) (between if:(and {(not (is In (between) (sites ToClear))) (is Enemy (who at:(between))) (!= (between) (var "Between"))})) (to if:(is Empty (to))))))) (then (if (can Move (hop (from (last To)) (between if:(and {(not (is In (between) (sites ToClear))) (is Enemy (who at:(between))) (!= (between) (var "Between"))})) (to if:(is Empty (to))))) (and (set Value Mover (count Sites in:(forEach (sites Around (last To)) if:(if (is In (last To) (sites {(ahead (site) S)})) (if (not (is In (site) (sites {"H2" "H3" "H4" "H5" "H6" "H7" "H8"}))) (and {(is Mover (who at:(ahead (site) E))) (is Mover (who at:(ahead (site) SE))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) W)})) (if (not (is In (site) (sites {"B1" "C1" "D1" "E1" "F1" "G1" "H1"}))) (and {(is Mover (who at:(ahead (site) S))) (is Mover (who at:(ahead (site) SW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) N)})) (if (not (is In (site) (sites {"A1" "A2" "A3" "A4" "A5" "A6" "A7"}))) (and {(is Mover (who at:(ahead (site) W))) (is Mover (who at:(ahead (site) NW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) E)})) (if (not (is In (site) (sites {"A8" "B8" "C8" "D8" "E8" "F8" "G8"}))) (and {(is Mover (who at:(ahead (site) N))) (is Mover (who at:(ahead (site) NE))) (is Mover (who at:(site)))}))))))))) (moveAgain)) (if (> (count Sites in:(forEach (sites Around (last To)) if:(if (is In (last To) (sites {(ahead (site) S)})) (if (not (is In (site) (sites {"H2" "H3" "H4" "H5" "H6" "H7" "H8"}))) (and {(is Mover (who at:(ahead (site) E))) (is Mover (who at:(ahead (site) SE))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) W)})) (if (not (is In (site) (sites {"B1" "C1" "D1" "E1" "F1" "G1" "H1"}))) (and {(is Mover (who at:(ahead (site) S))) (is Mover (who at:(ahead (site) SW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) N)})) (if (not (is In (site) (sites {"A1" "A2" "A3" "A4" "A5" "A6" "A7"}))) (and {(is Mover (who at:(ahead (site) W))) (is Mover (who at:(ahead (site) NW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) E)})) (if (not (is In (site) (sites {"A8" "B8" "C8" "D8" "E8" "F8" "G8"}))) (and {(is Mover (who at:(ahead (site) N))) (is Mover (who at:(ahead (site) NE))) (is Mover (who at:(site)))})))))))) 0) (and (set Value Mover (count Sites in:(forEach (sites Around (last To)) if:(if (is In (last To) (sites {(ahead (site) S)})) (if (not (is In (site) (sites {"H2" "H3" "H4" "H5" "H6" "H7" "H8"}))) (and {(is Mover (who at:(ahead (site) E))) (is Mover (who at:(ahead (site) SE))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) W)})) (if (not (is In (site) (sites {"B1" "C1" "D1" "E1" "F1" "G1" "H1"}))) (and {(is Mover (who at:(ahead (site) S))) (is Mover (who at:(ahead (site) SW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) N)})) (if (not (is In (site) (sites {"A1" "A2" "A3" "A4" "A5" "A6" "A7"}))) (and {(is Mover (who at:(ahead (site) W))) (is Mover (who at:(ahead (site) NW))) (is Mover (who at:(site)))})) (if (is In (last To) (sites {(ahead (site) E)})) (if (not (is In (site) (sites {"A8" "B8" "C8" "D8" "E8" "F8" "G8"}))) (and {(is Mover (who at:(ahead (site) N))) (is Mover (who at:(ahead (site) NE))) (is Mover (who at:(site)))}))))))))) (moveAgain))))))))))))} (end (if (<= (count Pieces Next) 3) (result Next Loss))))) 
Two concentric circles, with two perpendicular diameters intersecting both circles, and four other lines, positioned diagonally, connecting the circumferences of the two circles. Six pieces per player. which begin on opposite sides of the circle from the other player, three on each circle. Players alternate turns moving their pieces. Pieces move three spaces along the lines on the board, regardless of whether they are occupied, capturing any piece on the third. Pieces may change direction in a turn, as long as the lines are followed and there is no backtracking. The player who captures all of the opponent's pieces wins.
(game "Toono" (players 2) (equipment {(board (add (concentric {1 0 8 8}) edges:{{0 2} {0 4} {0 6} {0 8}}) use:Vertex) (piece "Marker" Each (move (from) (to (sites Distance from:(from) (exact 3)) if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (remove (to)))))))}) (rules (start {(place "Marker1" (difference (expand (sites Bottom) steps:2) (expand (sites Top) steps:2))) (place "Marker2" (difference (expand (sites Top) steps:2) (expand (sites Bottom) steps:2)))}) (play (forEach Piece)) (end (if (no Pieces Next) (result Next Loss))))) 
Each turn the current player must move, capture and drop. The current player must move one of their pieces in a straight line in any of the six hexagonal directions to land on a vacant foreign cell; any intervening cells must also be empty. The opponent who owns the landing cell becomes the candidate and the other opponent becomes the bunny. All opponents' pieces immediately adjacent to the landing cell are captured and removed from the board. The current player must make the move that captures the most pieces each turn, but may choose amongst equals. This is called the max capture rule. The moving player must then drop a bunny piece on any empty cell, unless a player has just been eliminated. The candidate becomes the next player to move. Goal: Play stops the moment any player is eliminated. The game is won by the player with the most pieces left, else is a tie between the two remaining players if they are both left with the same number of pieces.
(game "Triad" (players 3) (equipment {(board (hex 5)) (piece "Marker" Each (move Slide Orthogonal (to (apply if:(!= (mover) (mapEntry "PlayerPhase" (phase of:(to)))))) (then (and {(forEach Site (sites Around (last To) Orthogonal) (if (is Enemy (what at:(site))) (remove (site)))) (set Var (mapEntry "PlayerPhase" (phase of:(last To)))) (moveAgain)})))) (map "PlayerPhase" {(pair 1 1) (pair 0 2) (pair 2 3)})}) (rules (start {(place "Marker1" (expand origin:(coord "A5") steps:2)) (place "Marker2" (expand origin:(coord "I9") steps:2)) (place "Marker3" (expand origin:(coord "E1") steps:2))}) (play (if (is Prev Mover) (move Add (piece (if (= (mover) 1) (if (= (var) 2) 3 2) (if (= (mover) 2) (if (= (var) 1) 3 1) (if (= (var) 1) 2 1)))) (to (sites Empty)) (then (set NextPlayer (player (var))))) (max Captures (forEach Piece)))) (end (if (or {(no Pieces P1) (no Pieces P2) (no Pieces P3)}) (byScore {(score P1 (count Pieces P1)) (score P2 (count Pieces P2)) (score P3 (count Pieces P3))}))))) 
Players take turns moving a piece of their colour as follows: 1. A piece on a vertex can move either: 1a. To an adjacent empty vertex. The edge it travels over may be empty or occupied (if occupied by an enemy piece, that piece is captured and removed). 1b. To an empty cell that vertex is part of. 2. A piece on an edge can move either: 2a. To a connected empty edge. The vertex it travels over may be empty or occupied (if occupied by an enemy piece, that piece is captured and removed). 2b. To an empty cell that edge is part of. 3. A piece in a cell can move either: 3a. To a neighbouring empty cell which may be connected by an edge or a vertex. The connecting edge or vertex that the piece travels over may be empty or occupied (if occupied by an enemy piece, that piece is captured and removed). 3b. To step over one of its empty edges into an adjacent cell containing an enemy piece (which is captured), then step out over a different empty edge to another empty cell. 3c. To an empty vertex or edge belonging to that cell. Aim: A player wins if their opponent is reduced to a single piece. An empty edge has no piece on its midpoint. An empty cell has no piece on its centroid. Three Player Version: In the three player version, any player reduced to a single piece is removed from the game (along with their piece). Last remaining player wins. The game is played with 2 players.
(game "Triple Tangle" (players 2) (equipment {(board (tiling T3464 1) use:Vertex) (piece "Disc" Each)}) (rules (start {(place "Disc1" (sites {4 5 0 1})) (place "Disc1" Cell 1) (place "Disc1" Edge (sites {0 3 4 9})) (place "Disc2" (sites {16 17 12 13})) (place "Disc2" Cell 11) (place "Disc2" Edge (sites {25 29 26 20}))}) (play (if (is Prev Mover) (move (from Cell (last To)) (to Cell (intersection (sites Empty Cell) (sites Incident Cell of:Cell at:(from))) if:(and (= 1 (count Sites in:(intersection {(sites Empty Edge) (sites Incident Edge of:Cell at:(from)) (sites Incident Edge of:Cell at:(to))}))) (!= (last From) (to))))) (or {(forEach Piece on:Vertex (or (move Step (from Vertex) (to if:(is Empty Vertex (to))) (then (forEach Site (intersection (sites Incident Edge of:Vertex at:(last From)) (sites Incident Edge of:Vertex at:(last To))) (if (is Enemy (who Edge at:(site))) (remove Edge (site)))))) (move (from Vertex) (to Cell (intersection (sites Empty Cell) (sites Incident Cell of:Vertex at:(from))))))) (forEach Piece on:Edge (or (move Step (from Edge) (to if:(is Empty Edge (to))) (then (forEach Site (intersection (sites Incident Vertex of:Edge at:(last From)) (sites Incident Vertex of:Edge at:(last To))) (if (is Enemy (who Vertex at:(site))) (remove Vertex (site)))))) (move (from Edge) (to Cell (intersection (sites Empty Cell) (sites Incident Cell of:Edge at:(from))))))) (forEach Piece on:Cell (or {(move (from Cell) (to Cell (intersection (sites Empty Cell) (sites Incident Cell of:Cell at:(from)))) (then (forEach Site (intersection (sites Incident Edge of:Cell at:(last From)) (sites Incident Edge of:Cell at:(last To))) (if (is Enemy (who Edge at:(site))) (remove Edge (site)))))) (move (from Cell) (to Cell (sites Incident Cell of:Cell at:(from)) if:(and (is Enemy (who Cell at:(to))) (= 1 (count Sites in:(intersection {(sites Empty Edge) (sites Incident Edge of:Cell at:(from)) (sites Incident Edge of:Cell at:(to))})))) (apply (remove Cell (to)))) (then (moveAgain))) (move (from Cell) (to Cell (forEach (sites Empty Cell) if:(= 1 (count Sites in:(intersection (sites Incident Vertex of:Cell at:(from)) (sites Incident Vertex of:Cell at:(site))))))) (then (forEach Site (intersection (sites Incident Vertex of:Cell at:(last From)) (sites Incident Vertex of:Cell at:(last To))) (if (is Enemy (who Vertex at:(site))) (remove Vertex (site)))))) (move (from Cell) (to Edge (intersection (sites Empty Edge) (sites Incident Edge of:Cell at:(from))))) (move (from Cell) (to Vertex (intersection (sites Empty Vertex) (sites Incident Vertex of:Cell at:(from)))))}))}))) (end (if (>= 1 (+ {(count Pieces Vertex Next) (count Pieces Edge Next) (count Pieces Cell Next)})) (result Mover Win))))) 
Played on a Chaupar board. Two players. Four pieces per player. Seven cowries, used as dice. The throws are as follows: one face up = 10; two faces up = 2; three faces up = 3; four faces up = 4; five faces up = 25; six faces up = 36; seven faces up = 14; all faces down = 7. Players start from opposite ends of the board. In this game, the divisions of the arms of the board are ignored; each arm is considered one space, and the spaces between the arms are also considered a space, making eight total spaces. Players sit opposite each other, and the point in front of them is the starting point for that player. Play proceeds in an anti-clockwise direction. When one player's piece lands on a space occupied by an opponent's piece, the opponent's piece is captured. A player wins by capturing all of the opponent's pieces. 6 faces up = 36.
(game "Udat Pagada" (players 2) (equipment {(board (add (add (hole (merge (shift 0 8 (rectangle 4 20)) (shift 8 0 (rectangle 20 4))) (poly {{8 8} {8 11} {11 11} {11 8}})) cells:{{8 28 48 68 69 70 71 51 31 11 10 9}}) vertices:{{9.5 4} {15 4} {15 9.5} {15 15} {9.5 15} {4 15} {4 9.5} {4 4}}) {(track "Track" {144 145 146 147 148 149 150 151} loop:True)} use:Vertex) (dice d:2 from:0 num:7) (piece "Pawn" Each (move (from (from) level:(level)) (to (trackSite Move from:(from) "Track" steps:(mapEntry "ThrowDiceValue" (count Pips))) (apply (if (is Enemy (who at:(to))) (forEach Level (to) FromTop (remove (to) level:(level)))))))) (hand Each) (map "Throw" {(pair 0 7) (pair 1 10) (pair 2 2) (pair 3 3) (pair 4 4) (pair 5 25) (pair 6 36) (pair 7 14)}) (map "Entry" {(pair P1 144) (pair P2 148)})}) (rules (start {(place Stack "Pawn1" (handSite P1) count:4) (place Stack "Pawn2" (handSite P2) count:4)}) (play (do (roll) next:(or (if (is Occupied (handSite Mover)) (move (from (handSite Mover)) (to (trackSite Move from:(mapEntry "Entry" Mover) "Track" steps:(- (mapEntry "ThrowDiceValue" (count Pips)) 1)) (apply (if (is Enemy (who at:(to))) (forEach Level (to) FromTop (remove (to) level:(level)))))))) (forEach Piece)))) (end (if (no Pieces Next) (result Next Loss))))) 
On your turn you have to options: • Noncapturing move: Step kingwise away from the center of the line you are stepping along. • Capturing move: Capture queenwise any enemy not farther away from the center of the line you are moving along. Only if you have no moves may you pass. The game is over when only one player has pieces left. That player is the winner. A 6x6 board is currently selected
(game "Zola" (players 2) (equipment {(board (square 6)) (piece "Disc" Each)}) (rules (start {(place "Disc1" (sites Phase 0)) (place "Disc2" (sites Phase 1))}) (play (forEach Piece (or {(move (from) (to (intersection (sites Occupied by:Next) (sites Direction from:(from) (directions {N S}) stop:(is Occupied (to)) stopIncluded:True)) if:(not (> (min (count Sites in:(sites Direction from:(from) N)) (count Sites in:(sites Direction from:(from) S))) (min (count Sites in:(sites Direction from:(to) N)) (count Sites in:(sites Direction from:(to) S))))) (apply (remove (to))))) (move (from) (to (intersection (sites Occupied by:Next) (sites Direction from:(from) (directions {NE SW}) stop:(is Occupied (to)) stopIncluded:True)) if:(not (> (min (count Sites in:(sites Direction from:(from) NE)) (count Sites in:(sites Direction from:(from) SW))) (min (count Sites in:(sites Direction from:(to) NE)) (count Sites in:(sites Direction from:(to) SW))))) (apply (remove (to))))) (move (from) (to (intersection (sites Occupied by:Next) (sites Direction from:(from) (directions {E W}) stop:(is Occupied (to)) stopIncluded:True)) if:(not (> (min (count Sites in:(sites Direction from:(from) E)) (count Sites in:(sites Direction from:(from) W))) (min (count Sites in:(sites Direction from:(to) E)) (count Sites in:(sites Direction from:(to) W))))) (apply (remove (to))))) (move (from) (to (intersection (sites Occupied by:Next) (sites Direction from:(from) (directions {SE NW}) stop:(is Occupied (to)) stopIncluded:True)) if:(not (> (min (count Sites in:(sites Direction from:(from) SE)) (count Sites in:(sites Direction from:(from) NW))) (min (count Sites in:(sites Direction from:(to) SE)) (count Sites in:(sites Direction from:(to) NW))))) (apply (remove (to))))) (move Step (from) (to if:(and {(is Empty (to)) (or {(and (or (= (from) (+ (to) 6)) (= (from) (- (to) 6))) (< (max (count Sites in:(sites Direction from:(from) N)) (count Sites in:(sites Direction from:(from) S))) (max (count Sites in:(sites Direction from:(to) N)) (count Sites in:(sites Direction from:(to) S))))) (and (or (= (from) (+ (to) 1)) (= (from) (- (to) 1))) (< (max (count Sites in:(sites Direction from:(from) E)) (count Sites in:(sites Direction from:(from) W))) (max (count Sites in:(sites Direction from:(to) E)) (count Sites in:(sites Direction from:(to) W))))) (and (or (= (from) (+ (to) (+ 6 1))) (= (from) (- (to) (+ 6 1)))) (< (max (count Sites in:(sites Direction from:(from) SW)) (count Sites in:(sites Direction from:(from) NE))) (max (count Sites in:(sites Direction from:(to) SW)) (count Sites in:(sites Direction from:(to) NE))))) (and (or (= (from) (+ (to) (- 6 1))) (= (from) (- (to) (- 6 1)))) (< (max (count Sites in:(sites Direction from:(from) SE)) (count Sites in:(sites Direction from:(from) NW))) (max (count Sites in:(sites Direction from:(to) SE)) (count Sites in:(sites Direction from:(to) NW)))))})})))}))) (end (if (or (no Pieces P1) (no Pieces P2)) (result Mover Win))))) 
The objective of Cannon is to capture or shoot the opponent's Town. The player also wins the game if his opponent doesn't have legal moves. Players move alternately. On their first turns both players put a special piece called "Town" anywhere on the rows closest to them excluding corners. Once placed, Towns don't move during the entire game. A soldier may move one step forward or diagonally forward to an adjacent empty point. A soldier may capture an enemy piece (a soldier or the Town) standing on an adjacent point by moving one step sideways, forward or diagonally forward. A soldier can retreat two points backwards or diagonally backwards if it is adjacent to an enemy soldier and if the target and intermediate spots are empty. Cannon is a (orthogonal or diagonal) line of 3 adjacent friendly soldiers. A cannon may slide along its line in either direction if the target spot is empty. A cannon may make a capture without sliding, i.e. to "shoot" an enemy piece (either a soldier or the Town) standing on the same line as the shooting cannon if there is one or two empty points between the cannon's front soldier and the enemy piece.
(game "Cannon" (players {(player N) (player S)}) (equipment {(board (square 10) use:Vertex) (piece "Pawn" Each (or {(move Step (directions Forwards of:All) (to if:(is Empty (to)))) (move Step (directions {Forwards Rightward Leftward} of:All) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (if (not (all Sites (sites Around (from) All) if:(not (is Enemy (who at:(site)))))) (move Hop (directions Backwards of:All) (between if:(is Empty (between))) (to if:(is Empty (to))))) (move Hop All (between (exact 2) if:(= (what at:(between)) (id "Pawn" Mover))) (to if:(is Empty (to)))) (forEach Direction All (if (and {(and (= (what at:(to)) (id "Pawn" Mover)) (= (what at:(ahead (from) steps:2 (directions Vertex from:(from) to:(to)))) (id "Pawn" Mover))) (is Empty (ahead (from) steps:3 (directions Vertex from:(from) to:(to))))}) (if (is Enemy (who at:(ahead (from) steps:4 (directions Vertex from:(from) to:(to))))) (move Remove (ahead (from) steps:4 (directions Vertex from:(from) to:(to)))) (if (and (is Empty (ahead (from) steps:4 (directions Vertex from:(from) to:(to)))) (is Enemy (who at:(ahead (from) steps:5 (directions Vertex from:(from) to:(to)))))) (move Remove (ahead (from) steps:5 (directions Vertex from:(from) to:(to))))))))})) (piece "Town" Each) (hand Each) (regions "Home" P1 (sites Bottom)) (regions "Home" P2 (sites Top))}) (rules (start {(place "Town" "Hand") (place "Pawn1" (forEach (difference (expand (sites Row 2)) (sites Right)) if:(is Even (column of:(site))))) (place "Pawn2" (forEach (difference (expand (sites Row 7)) (sites Left)) if:(is Odd (column of:(site)))))}) phases:{(phase "Placing" (play (move (from (handSite Mover)) (to (difference (sites Mover "Home") (sites Corners))))) (nextPhase Mover "Moving")) (phase "Moving" (play (forEach Piece)) (end (if (or (= (where "Town" Next) -1) (no Moves Next)) (result Mover Win))))})) 
The goal is to capture the black queen with the white pieces.
(game "Capture the Queen" (players 2) (equipment {(board (square 8)) (piece "Queen" Each (move Slide (to if:(is Enemy (who at:(to))) (apply (remove (to))))))}) (rules (start {(place "Queen2" coord:"D8") (place "Queen1" {"B1" "C1" "E1" "F1"})}) (play (forEach Piece)) (end {(if (no Pieces P2) (result P2 Loss)) (if (= (count Moves) 100) (result P2 Win))}))) 
GOAL Get your king into the enemy home square, or kill the enemy king. MOVES Players make one move per turn, starting with Red. There are three possible types of moves, explained below. Players will always have a move available, and must make one. Passing is not allowed. NON-CAPTURING MOVES Kings and courtesans can move to an adjacent, unoccupied square in any of the three forward directions. CAPTURING MOVES Kings and courtesans can move to an adjacent, enemy occupied square in any of eight directions, capturing the enemy king or courtesan by replacement. EXCHANGE MOVE You can transfer the top checker of your king onto an adjacent, friendly courtesan in any of the three forward directions, thus exchanging king and courtesan. In the Ludii implementation, the king is controlled like this: To make an exchange move you must drag or click the top piece. To make a step/capture move, you must drag or click the bottom piece. A size 6 board is currently selected
(game "King And Courtesan" (players {(player N) (player S)}) (equipment {(board (rotate 45 (square 6))) (piece "Disc" Each (or {(move Step Forwards (to if:(is Empty (to))) stack:True) (move Step (to if:(is Enemy (who at:(to))) (apply (and (if (= 2 (size Stack at:(to))) (set Var "NextLoss" 1)) (remove (to) count:(size Stack at:(to)))))) stack:True) (move Step (from if:(= 2 (size Stack at:(from)))) Forwards (to if:(is Mover (who at:(to)))))}))}) (rules (start {(place "Disc1" (expand (sites Bottom) steps:(- 6 2) Orthogonal)) (place "Disc2" (expand (sites Top) steps:(- 6 2) Orthogonal)) (place Stack "Disc1" (sites Bottom)) (place Stack "Disc2" (sites Top))}) (play (forEach Piece top:True)) (end {(if (= 1 (var "NextLoss")) (result Next Loss)) (if (or (and (= (id P1) (who at:(- (* 6 6) 1))) (= 2 (size Stack at:(- (* 6 6) 1)))) (and (= (id P2) (who at:0)) (= 2 (size Stack at:0)))) (result Mover Win))}))) 
<a href="https://www.researchgate.net/publication/273947007_Die_Auftritte_des_Krieges_sinnlich_machen_Johann_C_L_Hellwig_und_das_Braunschweiger_Kriegsspiel" target="_blank" class="style1" style="color: #0000EE" />Modern translation of the original rules (German)</a>
(game "Kriegsspiel" (players 2) (equipment {(board (rectangle 33 49)) (hand Each size:6) (piece "Mountain" Neutral) (piece "Town" Neutral) (piece "Forest" Neutral) (piece "Triangle" Neutral) (piece "Square" Neutral) (regions "HomeP1" P1 (expand (sites Left) steps:15)) (regions "HomeP2" P2 (expand (sites Right) steps:15)) (piece "CannonOutline" Each (or {(move Slide (from (from) if:(and {(= (state at:(from)) 3) (is In (from) (sites Around (var "FromArtillerySite") Orthogonal))})) Orthogonal (between (range 1 6) if:(is In (between) (difference (sites Empty) (difference (sites "WaterRegion") (sites (values Remembered "Bridges")))))) (to if:False (apply if:(is In (to) (sites Around (var "ToArtillerySite") Orthogonal)))) (then (and (set Var "FromArtillerySite" -1) (set Var "ToArtillerySite" -1)))) (move Select (from (from) if:(and {(= (state at:(from)) 1) (< 0 (count Sites in:(intersection (sites Around (from) Orthogonal) (sites Occupied by:Mover container:"Board" components:{"TinSoldier" "Bishop"}))))})) (to (intersection (union (sites Occupied by:Enemy container:"Board" components:{"TinSoldier" "RiderOutline" "Bishop" "CannonOutline" "RegimentalOutline" "WagonOutline"}) (sites Occupied by:All container:"Board" components:{"Triangle"})) (union (expand origin:(ahead (from)) Orthogonal) (expand origin:(ahead (from) steps:2) Orthogonal))) if:(or (not (= 1 (count Sites in:(intersection (sites Direction from:(to) (directions Cell from:(ahead (from)) to:(from)) distance:1) (forEach (sites Occupied by:All container:"Board" components:{"Triangle"}) if:(and (= (% (+ (rotation at:(site)) 4) 8) (rotation at:(from))) (= (value Piece at:(site)) (who at:(to))))))))) (is In (to) (sites Occupied by:Mover container:"Board" components:{"RiderOutline"})))) (then (remove (last To)))) (move Select (from (from) if:(and {(= (state at:(from)) 1) (< 0 (count Sites in:(intersection (sites Around (from) Orthogonal) (sites Occupied by:Mover container:"Board" components:{"TinSoldier" "Bishop"}))))})) (to (intersection (sites (values Remembered "Bridges")) (union (expand origin:(ahead (from)) Orthogonal) (expand origin:(ahead (from) steps:2) Orthogonal))) if:(not (= 1 (count Sites in:(intersection (sites Direction from:(to) (directions Cell from:(ahead (from)) to:(from)) distance:1) (forEach (sites Occupied by:All container:"Board" components:{"Triangle"}) if:(and (= (% (+ (rotation at:(site)) 4) 8) (rotation at:(from))) (= (value Piece at:(site)) (who at:(to)))))))))) (then (forget Value "Bridges" (last To)))) (if (and (= (state at:(from)) 1) (< 0 (count Sites in:(intersection (sites Around (from) Orthogonal) (sites Occupied by:Mover container:"Board" components:{"TinSoldier" "Bishop"}))))) (move Set Rotation {0 2 4 6} previous:False next:False))}) maxState:100 maxValue:10000) (piece "RegimentalOutline" Each (or {(move Slide (from (from) if:(and {(= (state at:(from)) 3) (is In (from) (sites Around (var "FromArtillerySite") Orthogonal))})) Orthogonal (between (range 1 8) if:(is In (between) (difference (sites Empty) (difference (sites "WaterRegion") (sites (values Remembered "Bridges")))))) (to if:False (apply if:(is In (to) (sites Around (var "ToArtillerySite") Orthogonal)))) (then (and (set Var "FromArtillerySite" -1) (set Var "ToArtillerySite" -1)))) (move Select (from (from) if:(and {(= (state at:(from)) 1) (< 0 (count Sites in:(intersection (sites Around (from) Orthogonal) (sites Occupied by:Mover container:"Board" components:{"TinSoldier" "Bishop"}))))})) (to (intersection (union (sites Occupied by:Enemy container:"Board" components:{"TinSoldier" "RiderOutline" "Bishop" "RegimentalOutline" "WagonOutline"}) (sites Occupied by:All container:"Board" components:{"Triangle"})) (expand origin:(ahead (from)) Orthogonal)) if:(or (not (= 1 (count Sites in:(intersection (sites Direction from:(to) (directions Cell from:(ahead (from)) to:(from)) distance:1) (forEach (sites Occupied by:All container:"Board" components:{"Triangle"}) if:(and (= (% (+ (rotation at:(site)) 4) 8) (rotation at:(from))) (= (value Piece at:(site)) (who at:(to))))))))) (is In (to) (sites Occupied by:Mover container:"Board" components:{"RiderOutline"})))) (then (remove (last To)))) (move Select (from (from) if:(and {(= (state at:(from)) 1) (< 0 (count Sites in:(intersection (sites Around (from) Orthogonal) (sites Occupied by:Mover container:"Board" components:{"TinSoldier" "Bishop"}))))})) (to (intersection (union (sites Occupied by:Enemy container:"Board" components:{"TinSoldier" "RiderOutline" "Bishop" "CannonOutline" "RegimentalOutline" "WagonOutline"}) (sites Occupied by:All container:"Board" components:{"Triangle"})) (expand origin:(ahead (from)) Orthogonal)) if:(and (or (not (= 1 (count Sites in:(intersection (sites Direction from:(to) (directions Cell from:(ahead (from)) to:(from)) distance:1) (forEach (sites Occupied by:All container:"Board" components:{"Triangle"}) if:(and (= (% (+ (rotation at:(site)) 4) 8) (rotation at:(from))) (= (value Piece at:(site)) (who at:(to))))))))) (is In (to) (sites Occupied by:Mover container:"Board" components:{"RiderOutline"}))) (= 1 (count Sites in:(intersection (sites Direction from:(from) (directions Cell from:(ahead (to)) to:(to)) distance:1) (forEach (sites Occupied by:All container:"Board" components:{"Triangle"}) if:(and (= (% (+ (rotation at:(site)) 4) 8) (rotation at:(to))) (= (value Piece at:(site)) (who at:(from)))))))))) (then (remove (last To)))) (move Select (from (from) if:(and {(= (state at:(from)) 1) (< 0 (count Sites in:(intersection (sites Around (from) Orthogonal) (sites Occupied by:Mover container:"Board" components:{"TinSoldier" "Bishop"}))))})) (to (intersection (sites (values Remembered "Bridges")) (expand origin:(ahead (from)) Orthogonal)) if:(not (= 1 (count Sites in:(intersection (sites Direction from:(to) (directions Cell from:(ahead (from)) to:(from)) distance:1) (forEach (sites Occupied by:All container:"Board" components:{"Triangle"}) if:(and (= (% (+ (rotation at:(site)) 4) 8) (rotation at:(from))) (= (value Piece at:(site)) (who at:(to)))))))))) (then (forget Value "Bridges" (last To)))) (if (and (= (state at:(from)) 1) (< 0 (count Sites in:(intersection (sites Around (from) Orthogonal) (sites Occupied by:Mover container:"Board" components:{"TinSoldier" "Bishop"}))))) (move Set Rotation {0 2 4 6} previous:False next:False))})) (piece "TinSoldier" Each (or {(move Slide (from (from) if:(= (state at:(from)) 3)) (between (range 1 8) if:(or {(is In (between) (difference (sites Empty) (difference (sites "WaterRegion") (sites (values Remembered "Bridges"))))) (is In (between) (sites "TownRegion"))})) (to if:False (apply if:(if (is Occupied (to)) (not (is In (to) (sites "TownRegion"))) True))) (then (and (set Var "FromArtillerySite" (last From)) (set Var "ToArtillerySite" (last To))))) (move Step (from (from) if:(= (state at:(from)) 1)) (directions {Forward FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Select (from (from) if:(= (state at:(from)) 1)) (to (intersection (forEach (sites Occupied by:Enemy container:"Board" components:{"TinSoldier" "RiderOutline" "Bishop"}) if:(not (= (% (+ (rotation at:(site)) 4) 8) (rotation at:(from))))) (expand origin:(ahead (from)) Orthogonal)) if:(or (not (= 1 (count Sites in:(intersection (sites Direction from:(to) (directions Cell from:(ahead (from)) to:(from)) distance:1) (forEach (sites Occupied by:All container:"Board" components:{"Triangle"}) if:(and (= (% (+ (rotation at:(site)) 4) 8) (rotation at:(from))) (= (value Piece at:(site)) (who at:(to))))))))) (is In (to) (sites Occupied by:Mover container:"Board" components:{"RiderOutline"})))) (then (remove (last To)))) (move Select (from (from) if:(= (state at:(from)) 1)) (to (intersection (sites Occupied by:Enemy container:"Board" components:{"TinSoldier" "RiderOutline" "Bishop"}) (expand origin:(ahead (from)) Orthogonal)) if:(= 1 (count Sites in:(intersection (sites Direction from:(from) (directions Cell from:(ahead (to)) to:(to)) distance:1) (forEach (sites Occupied by:All container:"Board" components:{"Triangle"}) if:(and (= (% (+ (rotation at:(site)) 4) 8) (rotation at:(to))) (= (value Piece at:(site)) (who at:(from))))))))) (then (remove (last To)))) (move Select (from (from) if:(and (= (state at:(from)) 1) (is In (ahead (from)) (sites Occupied by:Mover container:"Board" components:{"TinSoldier" "Bishop"})))) (to (intersection (expand origin:(ahead (from)) Orthogonal) (sites Occupied by:Enemy container:"Board" components:{"TinSoldier" "RiderOutline" "Bishop"})) if:(or (not (= 1 (count Sites in:(intersection (sites Direction from:(to) (directions Cell from:(ahead (from)) to:(from)) distance:1) (forEach (sites Occupied by:All container:"Board" components:{"Triangle"}) if:(and (= (% (+ (rotation at:(site)) 4) 8) (rotation at:(from))) (= (value Piece at:(site)) (who at:(to))))))))) (is In (to) (sites Occupied by:Mover container:"Board" components:{"RiderOutline"})))) (then (remove (last To)))) (move Select (from (from) if:(= (state at:(from)) 1)) (to (difference (intersection (sites Around (from)) (difference (sites Empty) (difference (sites "WaterRegion") (sites (values Remembered "Bridges"))))) (union {(sites Around (sites Occupied by:Enemy container:"Board") includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"TinSoldier" "Bishop"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"RegimentalOutline"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"CannonOutline"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"CannonOutline"}) Forward distance:2) Orthogonal includeSelf:True)}))) (then (and {(add (piece "Triangle0") (to (last To))) (set Rotation (to (last To)) {0} previous:False next:False) (set Value at:(last To) (id Mover))}))) (move Select (from (from) if:(= (state at:(from)) 1)) (to (difference (intersection (sites Around (from)) (difference (sites Empty) (difference (sites "WaterRegion") (sites (values Remembered "Bridges"))))) (union {(sites Around (sites Occupied by:Enemy container:"Board") includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"TinSoldier" "Bishop"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"RegimentalOutline"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"CannonOutline"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"CannonOutline"}) Forward distance:2) Orthogonal includeSelf:True)}))) (then (and {(add (piece "Triangle0") (to (last To))) (set Rotation (to (last To)) {2} previous:False next:False) (set Value at:(last To) (id Mover))}))) (move Select (from (from) if:(= (state at:(from)) 1)) (to (difference (intersection (sites Around (from)) (difference (sites Empty) (difference (sites "WaterRegion") (sites (values Remembered "Bridges"))))) (union {(sites Around (sites Occupied by:Enemy container:"Board") includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"TinSoldier" "Bishop"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"RegimentalOutline"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"CannonOutline"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"CannonOutline"}) Forward distance:2) Orthogonal includeSelf:True)}))) (then (and {(add (piece "Triangle0") (to (last To))) (set Rotation (to (last To)) {4} previous:False next:False) (set Value at:(last To) (id Mover))}))) (move Select (from (from) if:(= (state at:(from)) 1)) (to (difference (intersection (sites Around (from)) (difference (sites Empty) (difference (sites "WaterRegion") (sites (values Remembered "Bridges"))))) (union {(sites Around (sites Occupied by:Enemy container:"Board") includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"TinSoldier" "Bishop"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"RegimentalOutline"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"CannonOutline"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"CannonOutline"}) Forward distance:2) Orthogonal includeSelf:True)}))) (then (and {(add (piece "Triangle0") (to (last To))) (set Rotation (to (last To)) {6} previous:False next:False) (set Value at:(last To) (id Mover))}))) (if (= (state at:(from)) 1) (move Set Rotation {0 2 4 6} previous:False next:False)) (move Select (from (from) if:(= (state at:(from)) 1)) (to (intersection (sites Occupied by:All container:"Board" components:{"Triangle"}) (sites Around (from))) if:(and (= (value Piece at:(to)) (id Mover)) (not (is In (to) (union {(sites Around (sites Occupied by:Enemy container:"Board") includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"TinSoldier" "Bishop"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"RegimentalOutline"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"CannonOutline"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"CannonOutline"}) Forward distance:2) Orthogonal includeSelf:True)}))))) (then (remove (last To)))) (move Select (from (from) if:(= (state at:(from)) 1)) (to (intersection (sites Occupied by:All container:"Board" components:{"CannonOutline" "RegimentalOutline"}) (sites Around (from) Orthogonal)) if:(> (state at:(to)) 0)) (then (remove (last To)))) (move Select (from (from) if:(= (state at:(from)) 1)) (to (intersection {(sites Occupied by:All container:"Board" components:{"WagonOutline"}) (sites Around (from)) (union {(forEach (sites Occupied by:All container:"Board" components:{"Triangle"}) if:(= (value Piece at:(site)) 0)) (forEach (sites Occupied by:P1 container:"Board" components:{"CannonOutline" "RegimentalOutline" "WagonOutline"}) if:(= 0 (count Sites in:(intersection (sites Around (site) Orthogonal) (sites Occupied by:P1 container:"Board" components:{"TinSoldier" "Bishop"}))))) (forEach (sites Occupied by:P2 container:"Board" components:{"CannonOutline" "RegimentalOutline" "WagonOutline"}) if:(= 0 (count Sites in:(intersection (sites Around (site) Orthogonal) (sites Occupied by:P2 container:"Board" components:{"TinSoldier" "Bishop"})))))})})) (then (remove (last To)))) (move Select (from (from) if:(= (state at:(from)) 1)) (to (intersection (sites (values Remembered "Bridges")) (sites Around (from))) if:(not (is In (to) (union {(sites Around (sites Occupied by:Enemy container:"Board") includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"TinSoldier" "Bishop"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"RegimentalOutline"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"CannonOutline"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"CannonOutline"}) Forward distance:2) Orthogonal includeSelf:True)})))) (then (forget Value "Bridges" (last To)))) (move Select (from (from) if:(= (state at:(from)) 1)) (to (intersection (sites (values Remembered "Bridges")) (sites Around (from)))) (then (if (= (id Mover) 1) (remember Value "Fires1" (last To)) (remember Value "Fires2" (last To)))))})) (piece "Bishop" Each (or {(move Slide (from (from) if:(= (state at:(from)) 3)) (between (range 1 8) if:(or {(is In (between) (difference (sites Empty) (difference (sites "WaterRegion") (sites (values Remembered "Bridges"))))) (is In (between) (sites "TownRegion"))})) (to if:False (apply if:(if (is Occupied (to)) (not (is In (to) (sites "TownRegion"))) True))) (then (and (set Var "FromArtillerySite" (last From)) (set Var "ToArtillerySite" (last To))))) (move Step (from (from) if:(= (state at:(from)) 1)) (directions {Forward FR FL}) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Select (from (from) if:(= (state at:(from)) 1)) (to (intersection (forEach (sites Occupied by:Enemy container:"Board" components:{"TinSoldier" "RiderOutline" "Bishop"}) if:(not (= (% (+ (rotation at:(site)) 4) 8) (rotation at:(from))))) (expand origin:(ahead (from)) Orthogonal)) if:(or (not (= 1 (count Sites in:(intersection (sites Direction from:(to) (directions Cell from:(ahead (from)) to:(from)) distance:1) (forEach (sites Occupied by:All container:"Board" components:{"Triangle"}) if:(and (= (% (+ (rotation at:(site)) 4) 8) (rotation at:(from))) (= (value Piece at:(site)) (who at:(to))))))))) (is In (to) (sites Occupied by:Mover container:"Board" components:{"RiderOutline"})))) (then (remove (last To)))) (move Select (from (from) if:(= (state at:(from)) 1)) (to (intersection (sites Occupied by:Enemy container:"Board" components:{"TinSoldier" "RiderOutline" "Bishop"}) (expand origin:(ahead (from)) Orthogonal)) if:(= 1 (count Sites in:(intersection (sites Direction from:(from) (directions Cell from:(ahead (to)) to:(to)) distance:1) (forEach (sites Occupied by:All container:"Board" components:{"Triangle"}) if:(and (= (% (+ (rotation at:(site)) 4) 8) (rotation at:(to))) (= (value Piece at:(site)) (who at:(from))))))))) (then (remove (last To)))) (move Select (from (from) if:(and (= (state at:(from)) 1) (is In (ahead (from)) (sites Occupied by:Mover container:"Board" components:{"TinSoldier" "Bishop"})))) (to (intersection (expand origin:(ahead (from)) Orthogonal) (sites Occupied by:Enemy container:"Board" components:{"TinSoldier" "RiderOutline" "Bishop"})) if:(or (not (= 1 (count Sites in:(intersection (sites Direction from:(to) (directions Cell from:(ahead (from)) to:(from)) distance:1) (forEach (sites Occupied by:All container:"Board" components:{"Triangle"}) if:(and (= (% (+ (rotation at:(site)) 4) 8) (rotation at:(from))) (= (value Piece at:(site)) (who at:(to))))))))) (is In (to) (sites Occupied by:Mover container:"Board" components:{"RiderOutline"})))) (then (remove (last To)))) (move Select (from (from) if:(= (state at:(from)) 1)) (to (difference (intersection (sites Around (from)) (difference (sites Empty) (difference (sites "WaterRegion") (sites (values Remembered "Bridges"))))) (union {(sites Around (sites Occupied by:Enemy container:"Board") includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"TinSoldier" "Bishop"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"RegimentalOutline"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"CannonOutline"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"CannonOutline"}) Forward distance:2) Orthogonal includeSelf:True)}))) (then (and {(add (piece "Triangle0") (to (last To))) (set Rotation (to (last To)) {0} previous:False next:False) (set Value at:(last To) (id Mover))}))) (move Select (from (from) if:(= (state at:(from)) 1)) (to (difference (intersection (sites Around (from)) (difference (sites Empty) (difference (sites "WaterRegion") (sites (values Remembered "Bridges"))))) (union {(sites Around (sites Occupied by:Enemy container:"Board") includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"TinSoldier" "Bishop"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"RegimentalOutline"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"CannonOutline"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"CannonOutline"}) Forward distance:2) Orthogonal includeSelf:True)}))) (then (and {(add (piece "Triangle0") (to (last To))) (set Rotation (to (last To)) {2} previous:False next:False) (set Value at:(last To) (id Mover))}))) (move Select (from (from) if:(= (state at:(from)) 1)) (to (difference (intersection (sites Around (from)) (difference (sites Empty) (difference (sites "WaterRegion") (sites (values Remembered "Bridges"))))) (union {(sites Around (sites Occupied by:Enemy container:"Board") includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"TinSoldier" "Bishop"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"RegimentalOutline"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"CannonOutline"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"CannonOutline"}) Forward distance:2) Orthogonal includeSelf:True)}))) (then (and {(add (piece "Triangle0") (to (last To))) (set Rotation (to (last To)) {4} previous:False next:False) (set Value at:(last To) (id Mover))}))) (move Select (from (from) if:(= (state at:(from)) 1)) (to (difference (intersection (sites Around (from)) (difference (sites Empty) (difference (sites "WaterRegion") (sites (values Remembered "Bridges"))))) (union {(sites Around (sites Occupied by:Enemy container:"Board") includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"TinSoldier" "Bishop"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"RegimentalOutline"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"CannonOutline"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"CannonOutline"}) Forward distance:2) Orthogonal includeSelf:True)}))) (then (and {(add (piece "Triangle0") (to (last To))) (set Rotation (to (last To)) {6} previous:False next:False) (set Value at:(last To) (id Mover))}))) (if (= (state at:(from)) 1) (move Set Rotation {0 2 4 6} previous:False next:False)) (move Select (from (from) if:(= (state at:(from)) 1)) (to (intersection (sites Occupied by:All container:"Board" components:{"Triangle"}) (sites Around (from))) if:(and (= (value Piece at:(to)) (id Mover)) (not (is In (to) (union {(sites Around (sites Occupied by:Enemy container:"Board") includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"TinSoldier" "Bishop"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"RegimentalOutline"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"CannonOutline"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"CannonOutline"}) Forward distance:2) Orthogonal includeSelf:True)}))))) (then (remove (last To)))) (move Select (from (from) if:(= (state at:(from)) 1)) (to (intersection (sites Occupied by:All container:"Board" components:{"CannonOutline" "RegimentalOutline"}) (sites Around (from) Orthogonal)) if:(> (state at:(to)) 0)) (then (remove (last To)))) (move Select (from (from) if:(= (state at:(from)) 1)) (to (intersection {(sites Occupied by:All container:"Board" components:{"WagonOutline"}) (sites Around (from)) (union {(forEach (sites Occupied by:All container:"Board" components:{"Triangle"}) if:(= (value Piece at:(site)) 0)) (forEach (sites Occupied by:P1 container:"Board" components:{"CannonOutline" "RegimentalOutline" "WagonOutline"}) if:(= 0 (count Sites in:(intersection (sites Around (site) Orthogonal) (sites Occupied by:P1 container:"Board" components:{"TinSoldier" "Bishop"}))))) (forEach (sites Occupied by:P2 container:"Board" components:{"CannonOutline" "RegimentalOutline" "WagonOutline"}) if:(= 0 (count Sites in:(intersection (sites Around (site) Orthogonal) (sites Occupied by:P2 container:"Board" components:{"TinSoldier" "Bishop"})))))})})) (then (remove (last To)))) (move Select (from (from) if:(= (state at:(from)) 1)) (to (intersection (sites (values Remembered "Bridges")) (sites Around (from))) if:(not (is In (to) (union {(sites Around (sites Occupied by:Enemy container:"Board") includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"TinSoldier" "Bishop"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"RegimentalOutline"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"CannonOutline"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"CannonOutline"}) Forward distance:2) Orthogonal includeSelf:True)})))) (then (forget Value "Bridges" (last To)))) (move Select (from (from) if:(= (state at:(from)) 1)) (to (intersection (sites (values Remembered "Bridges")) (sites Around (from)))) (then (if (= (id Mover) 1) (remember Value "Fires1" (last To)) (remember Value "Fires2" (last To))))) (if (= (state at:(from)) 1) (move Promote (from) (piece {"RiderOutline"}) Mover))}) maxState:100) (piece "RiderOutline" Each (or {(move Slide (from (from) if:(= (state at:(from)) 3)) (between (range 1 12) if:(or {(is In (between) (difference (sites Empty) (difference (sites "WaterRegion") (sites (values Remembered "Bridges"))))) (is In (between) (sites "TownRegion"))})) (to if:False (apply if:(if (is Occupied (to)) (not (is In (to) (sites "TownRegion"))) True)))) (move Slide (from (from) if:(= (state at:(from)) 1)) (between (range 1 12) if:(or {(is In (between) (difference (sites Empty) (difference (sites "WaterRegion") (sites (values Remembered "Bridges"))))) (is In (between) (sites "TownRegion")) (is In (between) (sites Occupied by:Enemy container:"Board" components:{"TinSoldier" "Bishop"}))}) (apply (remove (between)))) (to if:(and (< 0 (count Sites in:(intersection (sites Around (to) Orthogonal) (sites Occupied by:Enemy container:"Board")))) (is In (to) (sites Occupied by:Enemy container:"Board" components:{"TinSoldier" "Bishop"}))) (apply if:(and (not (is In (to) (sites "TownRegion"))) (is In (to) (sites Occupied by:Enemy container:"Board"))) (remove (to))))) (move Slide (from (from) if:(= (state at:(from)) 1)) (directions {Forward FR FL}) (between (range 1 12) if:(or {(is In (between) (difference (sites Empty) (difference (sites "WaterRegion") (sites (values Remembered "Bridges"))))) (is In (between) (sites "TownRegion")) (is In (between) (sites Occupied by:Enemy container:"Board" components:{"TinSoldier" "RiderOutline" "Bishop"}))}) (apply if:(is In (between) (sites Occupied by:Enemy container:"Board" components:{"TinSoldier" "RiderOutline" "Bishop"})) (remove (between)))) (to if:(and (< 0 (count Sites in:(intersection (sites Around (to) Orthogonal) (sites Occupied by:Enemy container:"Board")))) (is In (to) (sites Occupied by:Enemy container:"Board" components:{"TinSoldier" "RiderOutline" "Bishop"}))) (apply if:(and (not (is In (to) (sites "TownRegion"))) (is In (to) (sites Occupied by:Enemy container:"Board"))) (remove (to))))) (if (= (state at:(from)) 1) (move Set Rotation {0 2 4 6} previous:False next:False)) (move Select (from (from) if:(= (state at:(from)) 1)) (to (intersection (sites Occupied by:All container:"Board" components:{"Triangle"}) (sites Around (from))) if:(and (= (value Piece at:(to)) (id Mover)) (not (is In (to) (union {(sites Around (sites Occupied by:Enemy container:"Board") includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"TinSoldier" "Bishop"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"RegimentalOutline"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"CannonOutline"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"CannonOutline"}) Forward distance:2) Orthogonal includeSelf:True)}))))) (then (remove (last To)))) (move Select (from (from) if:(= (state at:(from)) 1)) (to (intersection (sites Occupied by:All container:"Board" components:{"CannonOutline" "RegimentalOutline"}) (sites Around (from) Orthogonal)) if:(> (state at:(to)) 0)) (then (remove (last To)))) (move Select (from (from) if:(= (state at:(from)) 1)) (to (intersection {(sites Occupied by:All container:"Board" components:{"WagonOutline"}) (sites Around (from)) (union {(forEach (sites Occupied by:All container:"Board" components:{"Triangle"}) if:(= (value Piece at:(site)) 0)) (forEach (sites Occupied by:P1 container:"Board" components:{"CannonOutline" "RegimentalOutline" "WagonOutline"}) if:(= 0 (count Sites in:(intersection (sites Around (site) Orthogonal) (sites Occupied by:P1 container:"Board" components:{"TinSoldier" "Bishop"}))))) (forEach (sites Occupied by:P2 container:"Board" components:{"CannonOutline" "RegimentalOutline" "WagonOutline"}) if:(= 0 (count Sites in:(intersection (sites Around (site) Orthogonal) (sites Occupied by:P2 container:"Board" components:{"TinSoldier" "Bishop"})))))})})) (then (remove (last To)))) (move Select (from (from) if:(= (state at:(from)) 1)) (to (intersection (sites (values Remembered "Bridges")) (sites Around (from))) if:(not (is In (to) (union {(sites Around (sites Occupied by:Enemy container:"Board") includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"TinSoldier" "Bishop"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"RegimentalOutline"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"CannonOutline"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"CannonOutline"}) Forward distance:2) Orthogonal includeSelf:True)})))) (then (forget Value "Bridges" (last To)))) (move Select (from (from) if:(= (state at:(from)) 1)) (to (intersection (sites (values Remembered "Bridges")) (sites Around (from)))) (then (if (= (id Mover) 1) (remember Value "Fires1" (last To)) (remember Value "Fires2" (last To))))) (if (= (state at:(from)) 1) (move Promote (from) (piece {"Bishop"}) Mover))})) (piece "WagonOutline" Each (or {(move Slide (from (from) if:(and {(= (state at:(from)) 3) (is In (from) (sites Around (var "FromArtillerySite") Orthogonal))})) Orthogonal (between (range 1 8) if:(is In (between) (difference (sites Empty) (difference (sites "WaterRegion") (sites (values Remembered "Bridges")))))) (to if:False (apply if:(is In (to) (sites Around (var "ToArtillerySite") Orthogonal)))) (then (and (set Var "FromArtillerySite" -1) (set Var "ToArtillerySite" -1)))) (move Select (from (from) if:(and {(= (state at:(from)) 1) (< 0 (value Piece at:(from))) (< 0 (count Sites in:(intersection (sites Around (from) Orthogonal) (sites Occupied by:Mover container:"Board" components:{"TinSoldier" "Bishop"}))))})) (to (forEach (union (sites Around (from)) (sites Around (sites Group from:(forEach (sites Around (from)) if:(is In (site) (sites (values Remembered "Bridges")))) if:(is In (to) (sites (values Remembered "Bridges")))))) if:(and {(is In (site) (difference (sites "WaterRegion") (sites (values Remembered "Bridges")))) (not (is In (site) (union {(sites Around (sites Occupied by:Enemy container:"Board") includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"TinSoldier" "Bishop"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"RegimentalOutline"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"CannonOutline"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Enemy container:"Board" components:{"CannonOutline"}) Forward distance:2) Orthogonal includeSelf:True)})))}))) (then (and {(remember Value "Bridges" (last To)) (set Value at:(last From) (- (value Piece at:(last From)) 1))}))) (move Select (from (from) if:(and {(= (state at:(from)) 1) (> 4 (value Piece at:(from))) (< 0 (count Sites in:(intersection (sites Around (from) Orthogonal) (sites Occupied by:Mover container:"Board" components:{"TinSoldier" "Bishop"}))))})) (to (forEach (union (sites Around (from)) (sites Around (sites Group from:(forEach (sites Around (from)) if:(is In (site) (sites (values Remembered "Bridges")))) if:(is In (to) (sites (values Remembered "Bridges")))))) if:(and {(is In (site) (sites (values Remembered "Bridges"))) (is In (site) (union (sites Empty) (union {(forEach (sites Occupied by:All container:"Board" components:{"Triangle"}) if:(= (value Piece at:(site)) 0)) (forEach (sites Occupied by:P1 container:"Board" components:{"CannonOutline" "RegimentalOutline" "WagonOutline"}) if:(= 0 (count Sites in:(intersection (sites Around (site) Orthogonal) (sites Occupied by:P1 container:"Board" components:{"TinSoldier" "Bishop"}))))) (forEach (sites Occupied by:P2 container:"Board" components:{"CannonOutline" "RegimentalOutline" "WagonOutline"}) if:(= 0 (count Sites in:(intersection (sites Around (site) Orthogonal) (sites Occupied by:P2 container:"Board" components:{"TinSoldier" "Bishop"})))))})))}))) (then (and {(forget Value "Bridges" (last To)) (set Value at:(last From) (+ (value Piece at:(last From)) 1)) (remove (last To))}))) (move Select (from (from) if:(and {(= (state at:(from)) 1) (< 0 (value Piece at:(from))) (< 0 (count Sites in:(intersection (sites Around (from) Orthogonal) (sites Occupied by:Mover container:"Board" components:{"TinSoldier" "Bishop"}))))})) (to (intersection (sites Around (from)) (difference (sites Empty) (sites "WaterRegion")))) (then (and {(add (piece "Square0") (to (last To))) (set Value at:(last From) (- (value Piece at:(last From)) 1))}))) (move Select (from (from) if:(and {(= (state at:(from)) 1) (> 4 (value Piece at:(from))) (< 0 (count Sites in:(intersection (sites Around (from) Orthogonal) (sites Occupied by:Mover container:"Board" components:{"TinSoldier" "Bishop"}))))})) (to (intersection (sites Around (from)) (sites Occupied by:Neutral container:"Board" components:{"Square"}))) (then (and {(set Value at:(last From) (+ (value Piece at:(last From)) 1)) (remove (last To))}))) (if (and (= (state at:(from)) 1) (< 0 (count Sites in:(intersection (sites Around (from) Orthogonal) (sites Occupied by:Mover container:"Board" components:{"TinSoldier" "Bishop"}))))) (move Set Rotation {0 2 4 6} previous:False next:False))})) (regions "WaterRegion" (sites {343 344 345 346 347 348 349 350 301 302 303 254 205 156 107 58 9 10 59 255 256 399 448 497 498 547 596 645 694 695 744 793 842 841 840 839 838 837 836 835 834 833 882 883 884 933 934 885 886 935 887 891 940 989 1038 1037 1036 1035 1034 1033 1032 1031 1030 1029 1079 1128 1083 1132 1181 1230 1087 1136 1185 1088 1186 1234 1233 1232 1281 1282 1283 1332 1331 1330 1379 1380 1381 1430 1431 1479 1528 1529 1578 1577 1569 1570 1571 1572 1573 1574 1575 1576 1520 1471 1524 1475 1426 1377 1376 1375 1326 1277 1228 1229 1279 1328 1089 1090 1091 1140 1189 1190 1239 1240 1289 1338 1339 1388 1437 1486 1535 1584 1042 1043 1044 1045 1046 997 948 949 950 951 952 953 1002 1003 1004 955 1005 1006 1055 1007 1008 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1300 1251 1202 1153 1104 1352 1401 1450 1499 1500 1501 1353 1354 1355 1306 1257 1208 1159 1110 1061 1012 963 1356 1357 1358 1359 1360 1361 1362 1411 1460 1509 1558 1557 1606 1607 1313 1314 1315 1266 1267 1268 1269 1270 1271 1272 1273 1217 1168 1119 1070 1118 1069 1020 971 922 921 872 823 774 775 776 777 778 779 780 781 782 783 734 733 732 731 730 729 725 681 682 683 676 627 578 579 580 581 582 583 584 585 586 587 537 488 529 480 431 382 333 284 235 186 137 88 39 87 38 185 40 41 42 43 44 45 46 47 96 145 92 141 190 239 288 337 386 435 484 533 236 237 286 335 384 383 334 285 240 241 290 339 388 387 430 528 527 526 525 476 427 574 573 572 571 570 619 668 667 666 665 664 663 614 613 612 661 710 759 808 857 906 611 610 561 609 608 607 512 426 377 376 327 278 277 276 275 274 273 272 271 270 269 268 267 266 265 264 263 262 261 260 259 258 257 463 414 365 316 604 653 555 506 457 408 359 310 215 166 117 116 228 179 130 81 32})) (regions "MountainRegion" (sites {395 444 493 542 591 784 701 702 703 752 751 750 565 516 913 864 865 914 915 866 1299 1250 1296 1247 1394 1443 1492 1397 1446 1495 1502 1551 1503})) (regions "TownRegion" (sites {449 450 451 452 400 351 352 562 513 563 564 515 1052 1101 1053 1054 1103 1264 1265 1216 1167 1166 1165 1164})) (regions "ForestRegion" (sites {499 500 501 790 791 1432 1433 1201 1200 1395 1396 415 416 220 221 184 183 825 826 1117 1116 1115})) (regions "EntrenchmentRegion1" (sites {939 988 1086 1135 1184 1180 1131 1082 1425 1474 1523 1527 1478 1429})) (regions "EntrenchmentRegion2" (sites {932 936 888 889 890 1081})) (regions "EntrenchmentRegion3" (sites {677 628 530 481 432 534 485 436 191 142 93 187 138 89})) (regions "EntrenchmentRegion4" (sites {726 727 728 680 684 535}))}) (rules (meta (passEnd NoEnd)) (start {(place "Mountain0" (sites "MountainRegion")) (place "Town0" (sites "TownRegion")) (place "Forest0" (sites "ForestRegion")) (place "Triangle0" (sites "EntrenchmentRegion1") rotation:2 value:0) (place "Triangle0" (sites "EntrenchmentRegion2") rotation:4 value:0) (place "Triangle0" (sites "EntrenchmentRegion3") rotation:6 value:0) (place "Triangle0" (sites "EntrenchmentRegion4") rotation:0 value:0) (place "TinSoldier1" 1617 count:76 state:3) (place "TinSoldier2" 1623 count:76 state:3) (place "RiderOutline1" 1618 count:20 state:3) (place "RiderOutline2" 1624 count:20 state:3) (place "CannonOutline1" 1619 count:10 state:3) (place "CannonOutline2" 1625 count:10 state:3) (place "RegimentalOutline1" 1620 count:5 state:3) (place "RegimentalOutline2" 1626 count:5 state:3) (place "WagonOutline1" 1621 count:10 state:3) (place "WagonOutline2" 1627 count:10 state:3) (place "Square0" 1622 count:20 state:3) (place "Square0" 1628 count:20 state:3) (set Hidden (sites Hand P1) to:P2) (set Hidden (sites Hand P2) to:P1) (set Hidden (sites P2 "Home") to:P1) (set Hidden (sites P1 "Home") to:P2)}) phases:{(phase "Placement" (play (or {(move (from (sites Occupied by:Mover container:(mover) components:{"TinSoldier" "RiderOutline" "CannonOutline" "RegimentalOutline" "WagonOutline"})) (to (intersection (sites Mover "Home") (difference (sites Empty) (sites "WaterRegion")))) (then (set Rotation (to (last To)) 0 previous:False next:False))) (move (from (sites Occupied by:Mover container:(mover) components:{"TinSoldier" "RiderOutline" "CannonOutline" "RegimentalOutline" "WagonOutline"})) (to (intersection (sites Mover "Home") (difference (sites Empty) (sites "WaterRegion")))) (then (set Rotation (to (last To)) 2 previous:False next:False))) (move (from (sites Occupied by:Mover container:(mover) components:{"TinSoldier" "RiderOutline" "CannonOutline" "RegimentalOutline" "WagonOutline"})) (to (intersection (sites Mover "Home") (difference (sites Empty) (sites "WaterRegion")))) (then (set Rotation (to (last To)) 4 previous:False next:False))) (move (from (sites Occupied by:Mover container:(mover) components:{"TinSoldier" "RiderOutline" "CannonOutline" "RegimentalOutline" "WagonOutline"})) (to (intersection (sites Mover "Home") (difference (sites Empty) (sites "WaterRegion")))) (then (set Rotation (to (last To)) 6 previous:False next:False)))})) (nextPhase (= 20 (count in:(sites Hand P2))) "BridgePlacement")) (phase "BridgePlacement" (play (or (move (from (sites Occupied by:Neutral container:(mover) components:{"Square"})) (to (intersection {(sites Mover "Home") (sites "WaterRegion") (sites Empty)})) (then (if (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) (and {(set Hidden (sites Board) False to:All) (set Var "FromArtillerySite" -1) (set Var "ToArtillerySite" -1) (forEach Site (sites Occupied by:All container:"Board" components:{"Square"}) (and (remember Value "Bridges" (site)) (remove (site))))}) (pass)))) (move Select (from (sites Occupied by:Neutral container:(mover) components:{"Square"})) (to (intersection (sites Mover "Home") (sites Occupied by:Mover container:"Board" components:{"WagonOutline"})) if:(< (value Piece at:(to)) 4)) (then (do (and (set Value at:(last To) (+ (value Piece at:(last To)) 1)) (set Count at:(last From) (- (count at:(last From)) 1))) next:(if (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) (and {(set Hidden (sites Board) False to:All) (set Var "FromArtillerySite" -1) (set Var "ToArtillerySite" -1) (forEach Site (sites Occupied by:All container:"Board" components:{"Square"}) (and (remember Value "Bridges" (site)) (remove (site))))}) (pass))))))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "FireSpread")) (phase "FireSpread" (play (if (= (id Mover) 1) (or (move Select (from (sites (values Remembered "Fires1"))) (to (from)) (then (and {(forEach Site (intersection (sites Around (last From)) (sites (values Remembered "Bridges"))) (remember Value "FireTemp" (site))) (moveAgain)}))) (move Pass (then (and {(forEach Site (sites (values Remembered "Fires1")) (and (forget Value "Fires1" (site)) (forget Value "Bridges" (site)))) (forEach Site (sites "FireTemp") (and (remember Value "Fires1" (site)) (forget Value "FireTemp" (site)))) (moveAgain)})))) (or (move Select (from (sites (values Remembered "Fires2"))) (to (from)) (then (and {(forEach Site (intersection (sites Around (last From)) (sites (values Remembered "Bridges"))) (remember Value "FireTemp" (site))) (moveAgain)}))) (move Pass (then (and {(forEach Site (sites (values Remembered "Fires2")) (and (forget Value "Fires2" (site)) (forget Value "Bridges" (site)))) (forEach Site (sites "FireTemp") (and (remember Value "Fires2" (site)) (forget Value "FireTemp" (site)))) (moveAgain)})))))) (nextPhase (was Pass) "Movement")) (phase "Movement" (play (or (forEach Piece (then (and {(set State at:(last To) 0) (moveAgain)}))) (move Pass (then (and {(forEach Site (sites Occupied by:Mover container:"Board") (if (= (state at:(site)) 3) (set State at:(site) 1))) (and (forEach Site (sites Occupied by:All container:"Board" components:{"Triangle"}) (if (and (not (is In (site) (union {(sites Around (sites Occupied by:Mover container:"Board") includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Mover container:"Board" components:{"TinSoldier" "Bishop"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Mover container:"Board" components:{"RegimentalOutline"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Mover container:"Board" components:{"CannonOutline"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Mover container:"Board" components:{"CannonOutline"}) Forward distance:2) Orthogonal includeSelf:True)}))) (= (value Piece at:(site)) (id Mover))) (set Value at:(site) 0))) (forEach Site (sites Occupied by:All container:"Board" components:{"Triangle"}) (if (and (is In (site) (union {(sites Around (sites Occupied by:Mover container:"Board") includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Mover container:"Board" components:{"TinSoldier" "Bishop"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Mover container:"Board" components:{"RegimentalOutline"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Mover container:"Board" components:{"CannonOutline"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Mover container:"Board" components:{"CannonOutline"}) Forward distance:2) Orthogonal includeSelf:True)})) (= (value Piece at:(site)) 0)) (set Value at:(site) (id Mover))))) (moveAgain)}))))) (nextPhase (was Pass) "Actions")) (phase "Actions" (play (or (forEach Piece (then (and {(set State at:(last To) 0) (set State at:(last From) 0) (moveAgain)}))) (move Pass (then (and {(forEach Site (sites Occupied by:Mover container:"Board") (set State at:(site) 3)) (and (forEach Site (sites Occupied by:All container:"Board" components:{"Triangle"}) (if (and (not (is In (site) (union {(sites Around (sites Occupied by:Mover container:"Board") includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Mover container:"Board" components:{"TinSoldier" "Bishop"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Mover container:"Board" components:{"RegimentalOutline"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Mover container:"Board" components:{"CannonOutline"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Mover container:"Board" components:{"CannonOutline"}) Forward distance:2) Orthogonal includeSelf:True)}))) (= (value Piece at:(site)) (id Mover))) (set Value at:(site) 0))) (forEach Site (sites Occupied by:All container:"Board" components:{"Triangle"}) (if (and (is In (site) (union {(sites Around (sites Occupied by:Mover container:"Board") includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Mover container:"Board" components:{"TinSoldier" "Bishop"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Mover container:"Board" components:{"RegimentalOutline"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Mover container:"Board" components:{"CannonOutline"}) Forward distance:1) Orthogonal includeSelf:True) (sites Around (sites Direction from:(sites Occupied by:Mover container:"Board" components:{"CannonOutline"}) Forward distance:2) Orthogonal includeSelf:True)})) (= (value Piece at:(site)) 0)) (set Value at:(site) (id Mover))))) (if (= (id Mover) 1) (forEach Site (sites (values Remembered "Fires1")) (remove (site))) (forEach Site (sites (values Remembered "Fires2")) (remove (site))))}))))) (nextPhase (was Pass) "FireSpread"))} (end {(if (is In 1323 (sites Occupied by:P2 container:"Board")) (result P2 Win)) (if (is In 293 (sites Occupied by:P1 container:"Board")) (result P1 Win))}))) 
Played on a board of 10x10 squares. The board has three 2x2 zones which cannot be entered, represented as water on the battlefield. each player controls 36 pieces which have individual army ranks. The goal is to capture the opponent's flag. Pieces can move only one space orthogonally. the Scout piece can move any number of spaces orthogonally. Pieces may attempt to capture an opposing piece; when doing so the ranks are revealed and the lower ranking piece is captured; if they are of equal rank they are both removed. There are bomb pieces which cannot move. Bombs eliminate other pieces attacking it and can only be removed by a miner. The spy can only attack the Marshall or the Flag. The scouts can not take each other, and winning is only possible in capturing the opponent flag
(game "L'attaque" (players 2) (equipment {(board (hole (hole (hole (rectangle 10 9) (poly {{2 4} {2 6} {3 6} {3 4}})) (poly {{4 4} {4 6} {5 6} {5 4}})) (poly {{6 4} {6 6} {7 6} {7 4}}))) (hand Each size:12) (piece "Marshal" Each) (piece "General" Each) (piece "Colonel" Each) (piece "Major" Each) (piece "Captain" Each) (piece "Lieutenant" Each) (piece "Sergeant" Each) (piece "Miner" Each) (piece "Scout" Each) (piece "Spy" Each) (piece "Flag" Each) (piece "Bomb" Each) (regions "HomeP1" P1 (expand (sites Bottom) steps:3)) (regions "HomeP2" P2 (expand (sites Top) steps:3)) (map {(pair 1 84) (pair 2 96) (pair 3 85) (pair 4 97) (pair 5 86) (pair 6 98) (pair 7 87) (pair 8 99) (pair 9 88) (pair 10 100) (pair 11 89) (pair 12 101) (pair 13 90) (pair 14 102) (pair 15 91) (pair 16 103) (pair 17 92) (pair 18 104) (pair 19 93) (pair 20 105) (pair 21 94) (pair 22 106) (pair 23 95) (pair 24 107)})}) (rules (start {(place "Marshal1" 84 value:10) (place "General1" 85 value:9) (place "Colonel1" 86 count:2 value:8) (place "Major1" 87 count:2 value:7) (place "Captain1" 88 count:4 value:6) (place "Lieutenant1" 89 count:4 value:5) (place "Sergeant1" 90 count:4 value:4) (place "Miner1" 91 count:4 value:3) (place "Scout1" 92 count:8 value:2) (place "Spy1" 93 value:1) (place "Flag1" 94) (place "Bomb1" 95 count:4) (set Hidden (sites Hand P1) to:P2) (place "Marshal2" 96 value:10) (place "General2" 97 value:9) (place "Colonel2" 98 count:2 value:8) (place "Major2" 99 count:2 value:7) (place "Captain2" 100 count:4 value:6) (place "Lieutenant2" 101 count:4 value:5) (place "Sergeant2" 102 count:4 value:4) (place "Miner2" 103 count:4 value:3) (place "Scout2" 104 count:8 value:2) (place "Spy2" 105 value:1) (place "Flag2" 106) (place "Bomb2" 107 count:4) (set Hidden (sites Hand P2) to:P1)}) phases:{(phase "Placement" (play (move (from (sites Occupied by:Mover container:(mover))) (to (intersection (sites Mover "Home") (sites Empty))) (then (if (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) (and {(set Hidden (sites P2 "Home") False to:P1) (set Hidden (sites P1 "Home") False to:P2) (set Hidden What (sites P2 "Home") to:P1) (set Hidden What (sites P1 "Home") to:P2) (set Hidden Value (sites P2 "Home") to:P1) (set Hidden Value (sites P1 "Home") to:P2)}))))) (nextPhase (all Sites (sites Hand P2) if:(= 0 (count Cell at:(site)))) "Movement")) (phase "Movement" (play (or (forEach Piece {"Marshal" "General" "Colonel" "Major" "Captain" "Lieutenant" "Sergeant" "Miner" "Spy"} (move Step Orthogonal (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (and (if (and (not (= (what at:(to)) (id "Bomb" Next))) (not (= (what at:(to)) (id "Flag" Next)))) (if (= (value Piece at:(to)) (value Piece at:(from))) (and {(fromTo (from) (to (mapEntry (what at:(from))))) (fromTo (from (to)) (to (mapEntry (what at:(to))))) (set Hidden What at:(mapEntry (what at:(from))) False to:P1) (set Hidden What at:(mapEntry (what at:(from))) False to:P2) (set Hidden What at:(mapEntry (what at:(to))) False to:P1) (set Hidden What at:(mapEntry (what at:(to))) False to:P2) (set Hidden Value at:(mapEntry (what at:(from))) False to:P1) (set Hidden Value at:(mapEntry (what at:(from))) False to:P2) (set Hidden Value at:(mapEntry (what at:(to))) False to:P1) (set Hidden Value at:(mapEntry (what at:(to))) False to:P2)}) (if (< (value Piece at:(to)) (value Piece at:(from))) (and {(fromTo (from (to)) (to (mapEntry (what at:(to))))) (fromTo (from) (to)) (set Hidden What at:(mapEntry (what at:(to))) False to:P1) (set Hidden What at:(mapEntry (what at:(to))) False to:P2) (set Hidden What at:(to) False to:Next) (set Hidden Value at:(mapEntry (what at:(to))) False to:P1) (set Hidden Value at:(mapEntry (what at:(to))) False to:P2) (set Hidden Value at:(to) False to:Next)}) (if (< (value Piece at:(from)) (value Piece at:(to))) (if (and (= (what at:(from)) (id "Spy" Mover)) (= (what at:(to)) (id "Marshal" Next))) (and {(fromTo (from (to)) (to (mapEntry (what at:(to))))) (fromTo (from) (to)) (set Hidden What at:(mapEntry (what at:(to))) False to:P1) (set Hidden What at:(mapEntry (what at:(to))) False to:P2) (set Hidden What at:(from) False to:Next) (set Hidden Value at:(mapEntry (what at:(to))) False to:P1) (set Hidden Value at:(mapEntry (what at:(to))) False to:P2) (set Hidden Value at:(from) False to:Next)}) (and {(fromTo (from) (to (mapEntry (what at:(from))))) (set Hidden What at:(mapEntry (what at:(from))) False to:P1) (set Hidden What at:(mapEntry (what at:(from))) False to:P2) (set Hidden What at:(to) False to:Mover) (set Hidden Value at:(mapEntry (what at:(from))) False to:P1) (set Hidden Value at:(mapEntry (what at:(from))) False to:P2) (set Hidden Value at:(to) False to:Mover)}))))) (if (= (what at:(to)) (id "Bomb" Next)) (if (= (what at:(from)) (id "Miner" Mover)) (and {(fromTo (from (to)) (to (mapEntry (what at:(to))))) (set Hidden What at:(mapEntry (what at:(to))) False to:P1) (set Hidden What at:(mapEntry (what at:(to))) False to:P2) (set Hidden Value at:(mapEntry (what at:(to))) False to:P1) (set Hidden Value at:(mapEntry (what at:(to))) False to:P2) (fromTo (from) (to)) (set Hidden What at:(from) False to:Next) (set Hidden Value at:(from) False to:Next)}) (and {(fromTo (from) (to (mapEntry (what at:(from))))) (set Hidden What at:(mapEntry (what at:(from))) False to:P1) (set Hidden What at:(mapEntry (what at:(from))) False to:P2) (set Hidden What at:(to) False to:Mover) (set Hidden Value at:(mapEntry (what at:(from))) False to:P1) (set Hidden Value at:(mapEntry (what at:(from))) False to:P2) (set Hidden Value at:(to) False to:Mover)})) (if (= (what at:(to)) (id "Flag" Next)) (and (trigger "FlagCaptured" (next)) (remove (to)))))) (note player:Mover "attacks" to:Next))))))) (forEach Piece "Scout" (or (move Select (from) (to (sites LineOfSight Empty at:(from) Orthogonal)) (then (fromTo (from (last From)) (to (last To))))) (move Select (from) (to (sites LineOfSight Piece at:(from) Orthogonal) if:(is Enemy (who at:(to)))) (then (and (if (and (not (= (what at:(last To)) (id "Bomb" Next))) (not (= (what at:(last To)) (id "Flag" Next)))) (if (= (value Piece at:(last To)) (value Piece at:(last From))) (and {(set Hidden What at:(last To) False to:Mover) (set Hidden What at:(last From) False to:Next) (set Hidden Value at:(last To) False to:Mover) (set Hidden Value at:(last From) False to:Next)}) (if (< (value Piece at:(last To)) (value Piece at:(last From))) (and {(fromTo (from (last To)) (to (mapEntry (what at:(last To))))) (fromTo (from (last From)) (to (last To))) (set Hidden What at:(mapEntry (what at:(last To))) False to:P1) (set Hidden What at:(mapEntry (what at:(last To))) False to:P2) (set Hidden What at:(last To) False to:Next) (set Hidden Value at:(mapEntry (what at:(last To))) False to:P1) (set Hidden Value at:(mapEntry (what at:(last To))) False to:P2) (set Hidden Value at:(last To) False to:Next)}) (and {(fromTo (from (last From)) (to (mapEntry (what at:(last From))))) (set Hidden What at:(mapEntry (what at:(last From))) False to:P1) (set Hidden What at:(mapEntry (what at:(last From))) False to:P2) (set Hidden What at:(last To) False to:Mover) (set Hidden Value at:(mapEntry (what at:(last From))) False to:P1) (set Hidden Value at:(mapEntry (what at:(last From))) False to:P2) (set Hidden Value at:(last To) False to:Mover)}))) (if (= (what at:(last To)) (id "Bomb" Next)) (and {(fromTo (from (last From)) (to (mapEntry (what at:(last From))))) (set Hidden What at:(mapEntry (what at:(last From))) False to:P1) (set Hidden What at:(mapEntry (what at:(last From))) False to:P2) (set Hidden What at:(last To) False to:Mover) (set Hidden Value at:(mapEntry (what at:(last From))) False to:P1) (set Hidden Value at:(mapEntry (what at:(last From))) False to:P2) (set Hidden Value at:(last To) False to:Mover)}) (and {(trigger "FlagCaptured" (next)) (remove (last To)) (fromTo (from (last From)) (to (last To)))}))) (note player:Mover "attacks" to:Next)))))))) (end (if (is Triggered "FlagCaptured" (next)) (result Mover Win))))})) 
Each player starts the game with four pieces: - a Lion (king) in the center of the home row - a Giraffe (rook) to the right of the king - an Elephant (bishop) to the left of the king - a Chick (pawn) in front of the king Each piece moves as in standard shogi, but is limited to moving one square per turn. If the Chick advances to reach the final rank, it promotes to a Hen, which can move one square any way except diagonally backwards (like the gold general in shogi). As in shogi, if a Hen is captured, it may only be dropped back into play as a Chick. However, standard restrictions on where one may drop a Chick, such as not being allowed to give immediate checkmate, have two Chicks on a file, or drop the Chick on the final rank, do not apply. A chick dropped on the final rank, however, does not promote (and may make no further moves until it is recaptured). If the players play the same position three turns in a row, the game is a draw.
(game "Let's Catch the Lion" (players {(player N) (player S)}) (equipment {(board (rectangle 4 3)) (tile "Giraffe" Each (move Step Orthogonal (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (if (= (what at:(to)) (id "Lion" Next)) (remove (to)) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to))))))))))) (tile "Elephant" Each (move Step Diagonal (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (if (= (what at:(to)) (id "Lion" Next)) (remove (to)) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to))))))))))) (tile "Chick" Each (move Step Forward (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (if (= (what at:(to)) (id "Lion" Next)) (remove (to)) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to))))))))) (then (if (is In (last To) (sites Mover "LastRank")) (move Promote (last To) (piece (id "Chicken" Mover))))))) (tile "Chicken" Each (move Step (directions {Forward Backward Rightward Leftward FL FR}) (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (if (= (what at:(to)) (id "Lion" Next)) (remove (to)) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to))))))))))) (tile "Lion" Each (move Step Adjacent (to if:(not (is Friend (who at:(to)))) (apply (if (is Enemy (who at:(to))) (if (= (what at:(to)) (id "Lion" Next)) (remove (to)) (add (piece (mapEntry "Captured" (what at:(to)))) (to (mapEntry "Where" (what at:(to))))))))))) (map "Captured" {(pair (id "Giraffe" P1) (id "Giraffe" P2)) (pair (id "Giraffe" P2) (id "Giraffe" P1)) (pair (id "Elephant" P1) (id "Elephant" P2)) (pair (id "Elephant" P2) (id "Elephant" P1)) (pair (id "Chick" P1) (id "Chick" P2)) (pair (id "Chick" P2) (id "Chick" P1)) (pair (id "Chicken" P1) (id "Chick" P2)) (pair (id "Chicken" P2) (id "Chick" P1))}) (map "Where" {(pair (id "Giraffe" P1) (handSite P2)) (pair (id "Giraffe" P2) (handSite P1)) (pair (id "Elephant" P1) (handSite P2 1)) (pair (id "Elephant" P2) (handSite P1 1)) (pair (id "Chick" P1) (handSite P2 2)) (pair (id "Chick" P2) (handSite P1 2)) (pair (id "Chicken" P1) (handSite P2 2)) (pair (id "Chicken" P2) (handSite P1 2))}) (regions "LastRank" P1 (sites Top)) (regions "LastRank" P2 (sites Bottom)) (hand Each size:3)}) (rules (start {(place "Giraffe1" coord:"C1") (place "Giraffe2" coord:"A4") (place "Chick1" coord:"B2") (place "Chick2" coord:"B3") (place "Lion1" coord:"B1") (place "Lion2" coord:"B4") (place "Elephant1" coord:"A1") (place "Elephant2" coord:"C4")}) (play (or (move (from (sites Occupied by:Mover container:"Hand" components:{"Giraffe" "Chick" "Elephant"})) (to (sites Empty))) (forEach Piece))) (end {(if (is Cycle) (result Mover Draw)) (if (or (= (where "Lion" Next) -1) (is In (where "Lion" Mover) (sites Mover "LastRank"))) (result Mover Win))}))) 
Each turn you must move one of your stacks, in a straight line orthogonally or diagonally, a distance exactly equal to the size of that stack. If it lands on an empty space, the stack grows by 1. If it lands on an enemy, the enemy is removed and your stack shrinks down to size 1. It is not legal to land on a friendly stack. Jumping over stacks is allowed. Stacks may also jump off the board, removing themselves from the game. Passing is not allowed. Definitions for crown and king: In this implementation, the king-stack will have a red stroke color. This red ring is the crown. Which stack has the crown is determined like this: After your move, if there is, among your stacks, a unique stack of the biggest size, the crown will be on that stack. There is no other way the crown can change heads. The piece with a crown on it is the king. Goal: If the enemy king is removed from the game, you win. Note: In this implementation, jumping off the board is only possible if the stack can reach exactly 1 row or column beyond the perimeter. But it seems to always be the case that it is possible to jump off the board when a stack is big enough. Please let Michael know if you encounter a scenario where a piece is stuck. This should not be allowed according to the rules of the game.
(game "Lielow" (players 2) (equipment {(board (square 10)) (piece "Disc" Each)}) (rules (start {(place "Disc1" (difference (difference (expand (sites Bottom) steps:2) (expand (sites Bottom) steps:1)) (sites Outer))) (place "Disc2" (difference (difference (expand (sites Top) steps:2) (expand (sites Top) steps:1)) (sites Outer)))}) (play (forEach Piece (or (move (from) (to (sites Around (from) Empty distance:(size Stack at:(from))) (apply (if (and {(= 1 (state at:(from))) (is In (to) (sites Outer))}) (set Var "MoverHasLost" 1)))) count:(size Stack at:(from)) stack:True (then (add (to (last To) level:0) stack:True))) (move (from) (to (sites Around (from) Enemy distance:(size Stack at:(from))) (apply (and {(if (= 1 (state at:(to))) (set Var "MoverHasWon" 1)) (set Var (state at:(from))) (remove (to) count:(size Stack at:(to)))}))) count:(size Stack at:(from)) stack:True (then (if (< 1 (size Stack at:(last To))) (and (remove (last To) count:(- (size Stack at:(last To)) 1)) (set State at:(last To) (var))))))) Mover top:True (then (do (remove (sites Outer) count:(size Stack at:(last To))) next:(if (= 1 (count Sites in:(forEach (sites Occupied by:Mover) if:(= (size Stack at:(site)) (max (results from:(sites Occupied by:Mover) to:0 (size Stack at:(from)))))))) (forEach Piece (if (= (size Stack at:(from)) (max (results from:(sites Occupied by:Mover) to:0 (size Stack at:(from))))) (set State at:(from) 1) (set State at:(from) 0)) Mover top:True)))))) (end {(if (= 1 (var "MoverHasLost")) (result Mover Loss)) (if (= 1 (var "MoverHasWon")) (result Mover Win))}))) 
//------------------------------------------------------------------------------ <b>General Rules:</b> <u>The following rules apply to all units, unless stated otherwise in their description:</u> - All units move and measure distance orthogonally. - Units may move up to their maximum movement limit and can then attack an adjacent site. - Attacking a unit will deal damage to it (see damage calculation section). - If an attacked unit's health reaches zero, it will be removed from the battlefield. - Defending units that survive an attack, will then deal counter damage to their attacker. - Units can reinforce an adjacent unit of the same type, instead of attacking. - Both units must be owned by the same player. - Reinforcing will convert health from one unit to the other, transferring as much health as possible. - Any units that are left with zero health after reinforcing are removed. - A unit which has been reinforced cannot perform any further actions this turn. <u>The following rules apply to all buildings:</u> - There are five types of building: Town, Factory, Airport, Dock and Base. - Attacking a building will deal damage to it (see damage calculation section). - If an attacked building's health reaches zero, it will gain 50 health and change ownership to the player who attacked it. - Buildings that are attacked, will not deal counter damage. - Units can heal at an adjacent building that you own, instead of attacking. - Healing at a building, will convert health from the building to the unit, transferring as much health as possible. - Additional units can be purchased using gold at their corresponding production building. - To purchase a unit, drag it from your hand to an available site next to a production building that you own. - The cost of purchasing a unit is represented by its count. - Purchased units cannot move, attack or heal, on the same turn they are purchased. - Each player receives 10 gold for every Town they own and 20 gold for every Base they own, at the start of their turn. - Buildings gain 10 health at the end of the owning player's turn, up to a maximum of 100. - Grey buildings are neutral, and are not owned by any player. - If a player loses ownership of all their Bases, they lose the game. //------------------------------------------------------------------------------ <b>Units:</b> <u>Human</u> (Purchased from Towns) Soldier Move: 3 Health: 30 Cost: 30 Damage Factor: 50% Motorbike Move: 5 Health: 40 Cost: 50 Damage Factor: 50% <u>Vehicle</u> (Purchased from Factories) Speeder Move: 6 Health: 60 Cost: 60 Damage Factor: 40% Shooter Move: 4 Health: 60 Cost: 80 Damage Factor: 40% - Deals double damage against Humans. Tank Move: 4 Health: 80 Cost: 100 Damage Factor: 50% Anti-Aircraft Move: 4 Health: 50 Cost: 80 Damage Factor: 100% - Can only attack Aircraft. - Can attack units 1-2 spaces away. - Does not deal or receive counter damage during an attack. Missile Launcher Move: 3 Health: 50 Cost: 80 Damage Factor: 50% - Cannot attack Aircraft. - Can only attack units 2-3 spaces away. - Does not deal or receive counter damage during an attack. Artillery Move: 3 Health: 40 Cost: 100 Damage Factor: 100% - Cannot attack Aircraft. - Can only attack units 3-5 spaces away. - Does not deal or receive counter damage during an attack. - Cannot attack or heal in the same turn that it moved. <u>Aircraft</u> (Purchased from Airports) Helicopter Move: 4 Health: 40 Cost: 60 Damage Factor: 70% Fighter Jet Move: 6 Health: 100 Cost: 100 Damage Factor: 100% - Can only attack Aircraft. Bomber Move: 5 Health: 100 Cost: 120 Damage Factor: 80% - Cannot attack Aircraft. <u>Boat</u> (Purchased from Docks) Cruiser Move: 5 Health: 70 Cost: 60 Damage Factor: 50% Submarine Move: 5 Health: 100 Cost: 100 Damage Factor: 80% - Can only attack Boats. Battleship Move: 4 Health: 120 Cost: 120 Damage Factor: 50% - Cannot attack Aircraft. - Can only attack units 2-4 spaces away. - Does not deal or receive counter damage during an attack. //------------------------------------------------------------------------------ <b>Movement Restrictions:</b> Humans may travel across plains, forests, and shallow water. They may also move 1 space into mountains instead of their regular movement. Vehicles may travel across plains. They may also move 1 space into forests or shallow water instead of their regular movement. Aircraft may travel across all spaces. Boats may travel across shallow and deep water. Buildings cannot move (obviously). Units cannot move over enemy or neutral occupied spaces. //------------------------------------------------------------------------------ <b>Damage Calculation:</b> An attacking unit deals damage equal to its health, multiplied by its damage factor. For example, A submarine has a damage factor of 80%, so a submarine with 20 health will deal 16 damage when it attacks (20 x 0.8). If the defending unit is in shallow or deep water, it takes 25% more damage. If the defending unit is in a forest, it takes 25% less damage. Aircraft are unaffected by terrain when calculating damage against them. All damage values are rounded down to the nearest whole number. //------------------------------------------------------------------------------ <b>Fog of War:</b> (Optional) All friendly units and buildings can see tiles up to 2 spaces away. Aircraft can see tiles up to 3 spaces away. Boats can see shallow and deep water tiles up to 3 spaces away. Humans on a mountain can see tiles up to 3 spaces away. Forest and mountain tiles can only be seen if adjacent to them. Enemy units and buildings that are not visible cannot be attacked, and have their type and health hidden. //------------------------------------------------------------------------------ <b>Army Doctrine:</b> At the start of the game (selected via the game options) you may pick a doctrine for your army. None - No effect. Special Forces - Human units do 50% more damage, all other units do 25% less damage. Brute Strength - Direct Vehicle units (no range on their attack distance) do 50% more damage, all other units do 25% less damage. Sharpshooter - Indirect Vehicle units (range on their attack distance) do 50% more damage, all other units do 25% less damage. Ace Pilot - Aircraft units do 50% more damage, all other units do 25% less damage. Sea Dog - Boat units do 50% more damage, all other units do 25% less damage. Guerrilla Warfare - Attacks against buildings deal 50% more damage, but attacks against units deal 25% less damage. Foreign Invader - Attacks against buildings deal 50% less damage, but attacks against units deal 25% more damage. Conscription - Units cost 50% less gold, but do 50% less damage. Elite Training - Units cost 50% more gold, but do 50% more damage. Glass Cannon - Units do 50% more damage, but take 50% more damage. Hardened Resolve - Units do 50% less damage, but take 50% less damage. Preemptive Strike - Units do 50% more damage when attacking, but never deal counter damage. Retaliation - Units do 50% less damage when attacking, but deal 100% more counter damage. Lady Luck - All attack damage is randomly selected between 50% and 150% of the normal amount. //------------------------------------------------------------------------------ Scenario - First Encounter No Fog of War. Player 1 - No Doctrine. Player 2 - No Doctrine. Player 3 - No Doctrine. Player 4 - No Doctrine.
(game "Mini Wars" (players 2) (equipment {(board (hex 5)) (regions "ShallowWater" (sites {"A3" "B3" "C3" "C1"})) (regions "DeepWater" (sites {"A1" "A2" "B2" "B1"})) (regions "Forest" (sites {"I9" "H9" "G9" "A4" "A5" "D1" "E1" "E7" "D2" "E2"})) (regions "Mountain" (sites {"I8" "H7" "G7" "F6"})) (hand Shared size:14) (piece "Base" Each) (piece "Factory" Each) (piece "Town" Each) (piece "Airport" Each) (piece "Dock" Each) (piece "Soldier" Each (or {(or (move (from (from) if:(> (state at:(from)) 1)) (to (sites Distance (step Orthogonal (to if:(is In (to) (difference (union (sites Empty) (sites Occupied by:Friend container:"Board")) (union (sites "DeepWater") (sites "Mountain")))))) from:(from) (range 1 (- (state at:(from)) 1))) if:(is Empty (to)) (apply (set State at:(from) 1)))) (move (from (from) if:(> (state at:(from)) 1)) (to (sites Distance (step Orthogonal (to if:(is In (to) (intersection (sites Empty) (sites "Mountain"))))) from:(from) (range 1 (- 2 1))) if:(is Empty (to)) (apply (set State at:(from) 1))))) (move Select (from (from) if:(> (state at:(from)) 0)) (to (sites Distance Orthogonal from:(from) (range 1 1)) if:(and {(if (is In (from) (sites Occupied by:Mover container:"Board" components:{"Bomber" "Battleship" "Artillery" "Launcher"})) (is In (to) (union (sites Occupied by:Enemy container:"Board" components:{"Soldier" "Motorbike" "Tank" "Speeder" "Shooter" "Launcher" "Antiair" "Battleship" "Artillery" "Base" "Town" "Factory" "Dock" "Airport" "Cruiser" "Submarine"}) (sites Occupied by:Neutral container:"Board"))) (is In (to) (union (sites Occupied by:Enemy container:"Board") (sites Occupied by:Neutral container:"Board")))) (if (is In (from) (sites Occupied by:Mover container:"Board" components:{"Antiair" "Fighter"})) (is In (to) (sites Occupied by:Enemy container:"Board" components:{"Fighter" "Helicopter" "Bomber"})) (is In (to) (union (sites Occupied by:Enemy container:"Board") (sites Occupied by:Neutral container:"Board")))) (if (is In (from) (sites Occupied by:Mover container:"Board" components:{"Submarine"})) (is In (to) (sites Occupied by:Enemy container:"Board" components:{"Submarine" "Battleship" "Cruiser"})) (is In (to) (union (sites Occupied by:Enemy container:"Board") (sites Occupied by:Neutral container:"Board"))))})) (then (do (and (set Value at:(last To) (max 0 (- (value Piece at:(last To)) (/ (* (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (max (/ (* (* (value Piece at:(last From)) 4) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (if (and (is In (last To) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (is In (last From) (sites Occupied by:All component:"Shooter"))) (if (is In (last To) (sites "Forest")) (max (/ (* (* (value Piece at:(last From)) 6) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (if (is In (last To) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last From)) 10) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (max (/ (* (* (value Piece at:(last From)) 8) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1))) (if (is In (last To) (sites "Forest")) (max (/ (* (* (value Piece at:(last From)) 3) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (if (is In (last To) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last From)) 5) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (max (/ (* (* (value Piece at:(last From)) 4) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1))))) (* {(if (is In (last From) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 1) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 1) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 1) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 1) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Tank" "Speeder" "Shooter"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 2) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 2) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 2) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 2) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Launcher" "Antiair" "Artillery"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 3) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 3) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 3) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 3) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 4) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 4) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 4) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 4) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Submarine" "Cruiser" "Battleship"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 5) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 5) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 5) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 5) 0)))) 4))))) (if (and (= 8 (state at:(last To))) (!= (mover) (who at:(last To)))) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 6) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 6) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 6) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 6) 0)))) 5) (if (> (who at:(last To)) 0) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 8) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 8) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 8) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 8) 0)))) 4) (if False (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 10) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 10) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 10) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 10) 0)))) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 9) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 9) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 9) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 9) 0))))) (value Random (range (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 11) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 11) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 11) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 11) 0)))) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 12) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 12) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 12) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 12) 0))))))})) 128000)))) (set State at:(last From) 0)) next:(if (and (= 8 (state at:(last To))) (!= (mover) (who at:(last To)))) (if (= (value Piece at:(last To)) 0) (and {(take Control of:All by:Mover at:(last To)) (set Value at:(last To) 50)}) (set Value at:(last To) (value Piece at:(last To)))) (if (= (value Piece at:(last To)) 0) (remove (last To)) (if (and {(= 0 (count Sites in:(intersection (sites {(last To) (last From)}) (sites Occupied by:All components:{"Launcher" "Artillery" "Battleship" "Antiair"})))) (if (is In (last To) (sites Occupied by:Enemy components:{"Bomber" "Battleship" "Artillery" "Launcher"})) (is In (last From) (union (sites Occupied by:Mover components:{"Soldier" "Motorbike" "Tank" "Speeder" "Shooter" "Launcher" "Antiair" "Battleship" "Artillery" "Base" "Town" "Factory" "Dock" "Airport" "Cruiser" "Submarine"}) (sites Occupied by:Neutral container:"Board"))) (is In (last From) (union (sites Occupied by:Mover) (sites Occupied by:Neutral container:"Board")))) (if (is In (last To) (sites Occupied by:Enemy components:{"Antiair" "Fighter"})) (is In (last From) (sites Occupied by:Mover components:{"Fighter" "Helicopter" "Bomber"})) (is In (last From) (union (sites Occupied by:Mover) (sites Occupied by:Neutral container:"Board")))) (if (is In (last To) (sites Occupied by:Enemy components:{"Submarine"})) (is In (last From) (sites Occupied by:Mover components:{"Submarine" "Battleship" "Cruiser"})) (is In (last From) (union (sites Occupied by:Mover) (sites Occupied by:Neutral container:"Board"))))}) (if (<= (- (value Piece at:(last From)) (/ (* (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (and (is In (last From) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (is In (last To) (sites Occupied by:All component:"Shooter"))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 6) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 10) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 8) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 3) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 5) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))))) (* {(if (is In (last To) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 1) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Tank" "Speeder" "Shooter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 2) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Launcher" "Antiair" "Artillery"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 3) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 4) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Submarine" "Cruiser" "Battleship"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 5) 0)))) 4))))) (if (and (= 8 (state at:(last From))) (!= (mover) (who at:(last From)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 6) 0)))) 5) (if (> (who at:(last From)) 0) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 8) 0)))) 4) (if True (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 10) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 9) 0))))) (value Random (range (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 11) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 12) 0))))))})) 128000)) 0) (remove (last From)) (set Value at:(last From) (- (value Piece at:(last From)) (/ (* (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (and (is In (last From) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (is In (last To) (sites Occupied by:All component:"Shooter"))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 6) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 10) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 8) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 3) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 5) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))))) (* {(if (is In (last To) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 1) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Tank" "Speeder" "Shooter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 2) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Launcher" "Antiair" "Artillery"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 3) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 4) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Submarine" "Cruiser" "Battleship"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 5) 0)))) 4))))) (if (and (= 8 (state at:(last From))) (!= (mover) (who at:(last From)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 6) 0)))) 5) (if (> (who at:(last From)) 0) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 8) 0)))) 4) (if True (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 10) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 9) 0))))) (value Random (range (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 11) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 12) 0))))))})) 128000)))) (set Value at:(last From) (value Piece at:(last From))))))))) (move Select (from (from) if:(and (> (state at:(from)) 0) (< (value Piece at:(from)) (mapEntry "MaxHealth" (what at:(from)))))) (to (sites Around (from) Orthogonal if:(is In (to) (sites Occupied by:Mover container:"Board" components:{"Town" "Dock" "Base" "Factory" "Airport"})))) (then (and {(set Value at:(last From) (min (mapEntry "MaxHealth" (what at:(last From))) (- (+ (value Piece at:(last From)) (value Piece at:(last To))) 1))) (set Value at:(last To) (max (- (value Piece at:(last To)) (- (mapEntry "MaxHealth" (what at:(last From))) (value Piece at:(last From)))) 1)) (set State at:(last From) 0)}))) (move Select (from (from) if:(> (state at:(from)) 0)) (to (sites Around (from) Orthogonal if:(and (= (what at:(from)) (what at:(to))) (< (value Piece at:(to)) (mapEntry "MaxHealth" (what at:(to))))))) (then (and {(if (<= (+ (value Piece at:(last To)) (value Piece at:(last From))) (mapEntry "MaxHealth" (what at:(last From)))) (and (set Value at:(last To) (min (mapEntry "MaxHealth" (what at:(last From))) (+ (value Piece at:(last From)) (value Piece at:(last To))))) (remove (last From))) (and (set Value at:(last To) (min (mapEntry "MaxHealth" (what at:(last From))) (- (+ (value Piece at:(last From)) (value Piece at:(last To))) 1))) (set Value at:(last From) (max (- (value Piece at:(last To)) (- (mapEntry "MaxHealth" (what at:(last From))) (value Piece at:(last From)))) 1)))) (set State at:(last From) 0) (set State at:(last To) 0)})))})) (piece "Motorbike" Each (or {(or (move (from (from) if:(> (state at:(from)) 1)) (to (sites Distance (step Orthogonal (to if:(is In (to) (difference (union (sites Empty) (sites Occupied by:Friend container:"Board")) (union (sites "DeepWater") (sites "Mountain")))))) from:(from) (range 1 (- (state at:(from)) 1))) if:(is Empty (to)) (apply (set State at:(from) 1)))) (move (from (from) if:(> (state at:(from)) 1)) (to (sites Distance (step Orthogonal (to if:(is In (to) (intersection (sites Empty) (sites "Mountain"))))) from:(from) (range 1 (- 2 1))) if:(is Empty (to)) (apply (set State at:(from) 1))))) (move Select (from (from) if:(> (state at:(from)) 0)) (to (sites Distance Orthogonal from:(from) (range 1 1)) if:(and {(if (is In (from) (sites Occupied by:Mover container:"Board" components:{"Bomber" "Battleship" "Artillery" "Launcher"})) (is In (to) (union (sites Occupied by:Enemy container:"Board" components:{"Soldier" "Motorbike" "Tank" "Speeder" "Shooter" "Launcher" "Antiair" "Battleship" "Artillery" "Base" "Town" "Factory" "Dock" "Airport" "Cruiser" "Submarine"}) (sites Occupied by:Neutral container:"Board"))) (is In (to) (union (sites Occupied by:Enemy container:"Board") (sites Occupied by:Neutral container:"Board")))) (if (is In (from) (sites Occupied by:Mover container:"Board" components:{"Antiair" "Fighter"})) (is In (to) (sites Occupied by:Enemy container:"Board" components:{"Fighter" "Helicopter" "Bomber"})) (is In (to) (union (sites Occupied by:Enemy container:"Board") (sites Occupied by:Neutral container:"Board")))) (if (is In (from) (sites Occupied by:Mover container:"Board" components:{"Submarine"})) (is In (to) (sites Occupied by:Enemy container:"Board" components:{"Submarine" "Battleship" "Cruiser"})) (is In (to) (union (sites Occupied by:Enemy container:"Board") (sites Occupied by:Neutral container:"Board"))))})) (then (do (and (set Value at:(last To) (max 0 (- (value Piece at:(last To)) (/ (* (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (max (/ (* (* (value Piece at:(last From)) 4) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (if (and (is In (last To) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (is In (last From) (sites Occupied by:All component:"Shooter"))) (if (is In (last To) (sites "Forest")) (max (/ (* (* (value Piece at:(last From)) 6) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (if (is In (last To) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last From)) 10) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (max (/ (* (* (value Piece at:(last From)) 8) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1))) (if (is In (last To) (sites "Forest")) (max (/ (* (* (value Piece at:(last From)) 3) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (if (is In (last To) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last From)) 5) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (max (/ (* (* (value Piece at:(last From)) 4) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1))))) (* {(if (is In (last From) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 1) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 1) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 1) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 1) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Tank" "Speeder" "Shooter"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 2) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 2) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 2) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 2) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Launcher" "Antiair" "Artillery"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 3) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 3) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 3) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 3) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 4) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 4) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 4) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 4) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Submarine" "Cruiser" "Battleship"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 5) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 5) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 5) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 5) 0)))) 4))))) (if (and (= 8 (state at:(last To))) (!= (mover) (who at:(last To)))) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 6) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 6) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 6) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 6) 0)))) 5) (if (> (who at:(last To)) 0) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 8) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 8) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 8) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 8) 0)))) 4) (if False (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 10) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 10) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 10) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 10) 0)))) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 9) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 9) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 9) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 9) 0))))) (value Random (range (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 11) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 11) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 11) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 11) 0)))) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 12) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 12) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 12) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 12) 0))))))})) 128000)))) (set State at:(last From) 0)) next:(if (and (= 8 (state at:(last To))) (!= (mover) (who at:(last To)))) (if (= (value Piece at:(last To)) 0) (and {(take Control of:All by:Mover at:(last To)) (set Value at:(last To) 50)}) (set Value at:(last To) (value Piece at:(last To)))) (if (= (value Piece at:(last To)) 0) (remove (last To)) (if (and {(= 0 (count Sites in:(intersection (sites {(last To) (last From)}) (sites Occupied by:All components:{"Launcher" "Artillery" "Battleship" "Antiair"})))) (if (is In (last To) (sites Occupied by:Enemy components:{"Bomber" "Battleship" "Artillery" "Launcher"})) (is In (last From) (union (sites Occupied by:Mover components:{"Soldier" "Motorbike" "Tank" "Speeder" "Shooter" "Launcher" "Antiair" "Battleship" "Artillery" "Base" "Town" "Factory" "Dock" "Airport" "Cruiser" "Submarine"}) (sites Occupied by:Neutral container:"Board"))) (is In (last From) (union (sites Occupied by:Mover) (sites Occupied by:Neutral container:"Board")))) (if (is In (last To) (sites Occupied by:Enemy components:{"Antiair" "Fighter"})) (is In (last From) (sites Occupied by:Mover components:{"Fighter" "Helicopter" "Bomber"})) (is In (last From) (union (sites Occupied by:Mover) (sites Occupied by:Neutral container:"Board")))) (if (is In (last To) (sites Occupied by:Enemy components:{"Submarine"})) (is In (last From) (sites Occupied by:Mover components:{"Submarine" "Battleship" "Cruiser"})) (is In (last From) (union (sites Occupied by:Mover) (sites Occupied by:Neutral container:"Board"))))}) (if (<= (- (value Piece at:(last From)) (/ (* (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (and (is In (last From) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (is In (last To) (sites Occupied by:All component:"Shooter"))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 6) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 10) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 8) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 3) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 5) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))))) (* {(if (is In (last To) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 1) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Tank" "Speeder" "Shooter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 2) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Launcher" "Antiair" "Artillery"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 3) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 4) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Submarine" "Cruiser" "Battleship"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 5) 0)))) 4))))) (if (and (= 8 (state at:(last From))) (!= (mover) (who at:(last From)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 6) 0)))) 5) (if (> (who at:(last From)) 0) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 8) 0)))) 4) (if True (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 10) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 9) 0))))) (value Random (range (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 11) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 12) 0))))))})) 128000)) 0) (remove (last From)) (set Value at:(last From) (- (value Piece at:(last From)) (/ (* (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (and (is In (last From) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (is In (last To) (sites Occupied by:All component:"Shooter"))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 6) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 10) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 8) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 3) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 5) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))))) (* {(if (is In (last To) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 1) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Tank" "Speeder" "Shooter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 2) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Launcher" "Antiair" "Artillery"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 3) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 4) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Submarine" "Cruiser" "Battleship"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 5) 0)))) 4))))) (if (and (= 8 (state at:(last From))) (!= (mover) (who at:(last From)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 6) 0)))) 5) (if (> (who at:(last From)) 0) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 8) 0)))) 4) (if True (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 10) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 9) 0))))) (value Random (range (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 11) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 12) 0))))))})) 128000)))) (set Value at:(last From) (value Piece at:(last From))))))))) (move Select (from (from) if:(and (> (state at:(from)) 0) (< (value Piece at:(from)) (mapEntry "MaxHealth" (what at:(from)))))) (to (sites Around (from) Orthogonal if:(is In (to) (sites Occupied by:Mover container:"Board" components:{"Town" "Dock" "Base" "Factory" "Airport"})))) (then (and {(set Value at:(last From) (min (mapEntry "MaxHealth" (what at:(last From))) (- (+ (value Piece at:(last From)) (value Piece at:(last To))) 1))) (set Value at:(last To) (max (- (value Piece at:(last To)) (- (mapEntry "MaxHealth" (what at:(last From))) (value Piece at:(last From)))) 1)) (set State at:(last From) 0)}))) (move Select (from (from) if:(> (state at:(from)) 0)) (to (sites Around (from) Orthogonal if:(and (= (what at:(from)) (what at:(to))) (< (value Piece at:(to)) (mapEntry "MaxHealth" (what at:(to))))))) (then (and {(if (<= (+ (value Piece at:(last To)) (value Piece at:(last From))) (mapEntry "MaxHealth" (what at:(last From)))) (and (set Value at:(last To) (min (mapEntry "MaxHealth" (what at:(last From))) (+ (value Piece at:(last From)) (value Piece at:(last To))))) (remove (last From))) (and (set Value at:(last To) (min (mapEntry "MaxHealth" (what at:(last From))) (- (+ (value Piece at:(last From)) (value Piece at:(last To))) 1))) (set Value at:(last From) (max (- (value Piece at:(last To)) (- (mapEntry "MaxHealth" (what at:(last From))) (value Piece at:(last From)))) 1)))) (set State at:(last From) 0) (set State at:(last To) 0)})))})) (piece "Speeder" Each (or {(or (move (from (from) if:(> (state at:(from)) 1)) (to (sites Distance (step Orthogonal (to if:(is In (to) (difference (union (sites Empty) (sites Occupied by:Friend container:"Board")) (union (union (sites "Mountain") (sites "DeepWater")) (union (sites "Forest") (sites "ShallowWater"))))))) from:(from) (range 1 (- (state at:(from)) 1))) if:(is Empty (to)) (apply (set State at:(from) 1)))) (move (from (from) if:(> (state at:(from)) 1)) (to (sites Distance (step Orthogonal (to if:(is In (to) (intersection (sites Empty) (union (sites "Forest") (sites "ShallowWater")))))) from:(from) (range 1 (- 2 1))) if:(is Empty (to)) (apply (set State at:(from) 1))))) (move Select (from (from) if:(> (state at:(from)) 0)) (to (sites Distance Orthogonal from:(from) (range 1 1)) if:(and {(if (is In (from) (sites Occupied by:Mover container:"Board" components:{"Bomber" "Battleship" "Artillery" "Launcher"})) (is In (to) (union (sites Occupied by:Enemy container:"Board" components:{"Soldier" "Motorbike" "Tank" "Speeder" "Shooter" "Launcher" "Antiair" "Battleship" "Artillery" "Base" "Town" "Factory" "Dock" "Airport" "Cruiser" "Submarine"}) (sites Occupied by:Neutral container:"Board"))) (is In (to) (union (sites Occupied by:Enemy container:"Board") (sites Occupied by:Neutral container:"Board")))) (if (is In (from) (sites Occupied by:Mover container:"Board" components:{"Antiair" "Fighter"})) (is In (to) (sites Occupied by:Enemy container:"Board" components:{"Fighter" "Helicopter" "Bomber"})) (is In (to) (union (sites Occupied by:Enemy container:"Board") (sites Occupied by:Neutral container:"Board")))) (if (is In (from) (sites Occupied by:Mover container:"Board" components:{"Submarine"})) (is In (to) (sites Occupied by:Enemy container:"Board" components:{"Submarine" "Battleship" "Cruiser"})) (is In (to) (union (sites Occupied by:Enemy container:"Board") (sites Occupied by:Neutral container:"Board"))))})) (then (do (and (set Value at:(last To) (max 0 (- (value Piece at:(last To)) (/ (* (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (max (/ (* (* (value Piece at:(last From)) 4) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (if (and (is In (last To) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (is In (last From) (sites Occupied by:All component:"Shooter"))) (if (is In (last To) (sites "Forest")) (max (/ (* (* (value Piece at:(last From)) 6) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (if (is In (last To) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last From)) 10) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (max (/ (* (* (value Piece at:(last From)) 8) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1))) (if (is In (last To) (sites "Forest")) (max (/ (* (* (value Piece at:(last From)) 3) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (if (is In (last To) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last From)) 5) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (max (/ (* (* (value Piece at:(last From)) 4) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1))))) (* {(if (is In (last From) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 1) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 1) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 1) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 1) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Tank" "Speeder" "Shooter"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 2) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 2) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 2) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 2) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Launcher" "Antiair" "Artillery"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 3) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 3) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 3) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 3) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 4) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 4) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 4) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 4) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Submarine" "Cruiser" "Battleship"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 5) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 5) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 5) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 5) 0)))) 4))))) (if (and (= 8 (state at:(last To))) (!= (mover) (who at:(last To)))) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 6) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 6) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 6) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 6) 0)))) 5) (if (> (who at:(last To)) 0) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 8) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 8) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 8) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 8) 0)))) 4) (if False (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 10) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 10) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 10) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 10) 0)))) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 9) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 9) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 9) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 9) 0))))) (value Random (range (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 11) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 11) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 11) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 11) 0)))) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 12) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 12) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 12) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 12) 0))))))})) 128000)))) (set State at:(last From) 0)) next:(if (and (= 8 (state at:(last To))) (!= (mover) (who at:(last To)))) (if (= (value Piece at:(last To)) 0) (and {(take Control of:All by:Mover at:(last To)) (set Value at:(last To) 50)}) (set Value at:(last To) (value Piece at:(last To)))) (if (= (value Piece at:(last To)) 0) (remove (last To)) (if (and {(= 0 (count Sites in:(intersection (sites {(last To) (last From)}) (sites Occupied by:All components:{"Launcher" "Artillery" "Battleship" "Antiair"})))) (if (is In (last To) (sites Occupied by:Enemy components:{"Bomber" "Battleship" "Artillery" "Launcher"})) (is In (last From) (union (sites Occupied by:Mover components:{"Soldier" "Motorbike" "Tank" "Speeder" "Shooter" "Launcher" "Antiair" "Battleship" "Artillery" "Base" "Town" "Factory" "Dock" "Airport" "Cruiser" "Submarine"}) (sites Occupied by:Neutral container:"Board"))) (is In (last From) (union (sites Occupied by:Mover) (sites Occupied by:Neutral container:"Board")))) (if (is In (last To) (sites Occupied by:Enemy components:{"Antiair" "Fighter"})) (is In (last From) (sites Occupied by:Mover components:{"Fighter" "Helicopter" "Bomber"})) (is In (last From) (union (sites Occupied by:Mover) (sites Occupied by:Neutral container:"Board")))) (if (is In (last To) (sites Occupied by:Enemy components:{"Submarine"})) (is In (last From) (sites Occupied by:Mover components:{"Submarine" "Battleship" "Cruiser"})) (is In (last From) (union (sites Occupied by:Mover) (sites Occupied by:Neutral container:"Board"))))}) (if (<= (- (value Piece at:(last From)) (/ (* (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (and (is In (last From) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (is In (last To) (sites Occupied by:All component:"Shooter"))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 6) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 10) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 8) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 3) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 5) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))))) (* {(if (is In (last To) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 1) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Tank" "Speeder" "Shooter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 2) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Launcher" "Antiair" "Artillery"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 3) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 4) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Submarine" "Cruiser" "Battleship"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 5) 0)))) 4))))) (if (and (= 8 (state at:(last From))) (!= (mover) (who at:(last From)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 6) 0)))) 5) (if (> (who at:(last From)) 0) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 8) 0)))) 4) (if True (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 10) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 9) 0))))) (value Random (range (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 11) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 12) 0))))))})) 128000)) 0) (remove (last From)) (set Value at:(last From) (- (value Piece at:(last From)) (/ (* (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (and (is In (last From) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (is In (last To) (sites Occupied by:All component:"Shooter"))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 6) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 10) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 8) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 3) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 5) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))))) (* {(if (is In (last To) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 1) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Tank" "Speeder" "Shooter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 2) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Launcher" "Antiair" "Artillery"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 3) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 4) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Submarine" "Cruiser" "Battleship"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 5) 0)))) 4))))) (if (and (= 8 (state at:(last From))) (!= (mover) (who at:(last From)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 6) 0)))) 5) (if (> (who at:(last From)) 0) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 8) 0)))) 4) (if True (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 10) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 9) 0))))) (value Random (range (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 11) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 12) 0))))))})) 128000)))) (set Value at:(last From) (value Piece at:(last From))))))))) (move Select (from (from) if:(and (> (state at:(from)) 0) (< (value Piece at:(from)) (mapEntry "MaxHealth" (what at:(from)))))) (to (sites Around (from) Orthogonal if:(is In (to) (sites Occupied by:Mover container:"Board" components:{"Town" "Dock" "Base" "Factory" "Airport"})))) (then (and {(set Value at:(last From) (min (mapEntry "MaxHealth" (what at:(last From))) (- (+ (value Piece at:(last From)) (value Piece at:(last To))) 1))) (set Value at:(last To) (max (- (value Piece at:(last To)) (- (mapEntry "MaxHealth" (what at:(last From))) (value Piece at:(last From)))) 1)) (set State at:(last From) 0)}))) (move Select (from (from) if:(> (state at:(from)) 0)) (to (sites Around (from) Orthogonal if:(and (= (what at:(from)) (what at:(to))) (< (value Piece at:(to)) (mapEntry "MaxHealth" (what at:(to))))))) (then (and {(if (<= (+ (value Piece at:(last To)) (value Piece at:(last From))) (mapEntry "MaxHealth" (what at:(last From)))) (and (set Value at:(last To) (min (mapEntry "MaxHealth" (what at:(last From))) (+ (value Piece at:(last From)) (value Piece at:(last To))))) (remove (last From))) (and (set Value at:(last To) (min (mapEntry "MaxHealth" (what at:(last From))) (- (+ (value Piece at:(last From)) (value Piece at:(last To))) 1))) (set Value at:(last From) (max (- (value Piece at:(last To)) (- (mapEntry "MaxHealth" (what at:(last From))) (value Piece at:(last From)))) 1)))) (set State at:(last From) 0) (set State at:(last To) 0)})))})) (piece "Shooter" Each (or {(or (move (from (from) if:(> (state at:(from)) 1)) (to (sites Distance (step Orthogonal (to if:(is In (to) (difference (union (sites Empty) (sites Occupied by:Friend container:"Board")) (union (union (sites "Mountain") (sites "DeepWater")) (union (sites "Forest") (sites "ShallowWater"))))))) from:(from) (range 1 (- (state at:(from)) 1))) if:(is Empty (to)) (apply (set State at:(from) 1)))) (move (from (from) if:(> (state at:(from)) 1)) (to (sites Distance (step Orthogonal (to if:(is In (to) (intersection (sites Empty) (union (sites "Forest") (sites "ShallowWater")))))) from:(from) (range 1 (- 2 1))) if:(is Empty (to)) (apply (set State at:(from) 1))))) (move Select (from (from) if:(> (state at:(from)) 0)) (to (sites Distance Orthogonal from:(from) (range 1 1)) if:(and {(if (is In (from) (sites Occupied by:Mover container:"Board" components:{"Bomber" "Battleship" "Artillery" "Launcher"})) (is In (to) (union (sites Occupied by:Enemy container:"Board" components:{"Soldier" "Motorbike" "Tank" "Speeder" "Shooter" "Launcher" "Antiair" "Battleship" "Artillery" "Base" "Town" "Factory" "Dock" "Airport" "Cruiser" "Submarine"}) (sites Occupied by:Neutral container:"Board"))) (is In (to) (union (sites Occupied by:Enemy container:"Board") (sites Occupied by:Neutral container:"Board")))) (if (is In (from) (sites Occupied by:Mover container:"Board" components:{"Antiair" "Fighter"})) (is In (to) (sites Occupied by:Enemy container:"Board" components:{"Fighter" "Helicopter" "Bomber"})) (is In (to) (union (sites Occupied by:Enemy container:"Board") (sites Occupied by:Neutral container:"Board")))) (if (is In (from) (sites Occupied by:Mover container:"Board" components:{"Submarine"})) (is In (to) (sites Occupied by:Enemy container:"Board" components:{"Submarine" "Battleship" "Cruiser"})) (is In (to) (union (sites Occupied by:Enemy container:"Board") (sites Occupied by:Neutral container:"Board"))))})) (then (do (and (set Value at:(last To) (max 0 (- (value Piece at:(last To)) (/ (* (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (max (/ (* (* (value Piece at:(last From)) 4) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (if (and (is In (last To) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (is In (last From) (sites Occupied by:All component:"Shooter"))) (if (is In (last To) (sites "Forest")) (max (/ (* (* (value Piece at:(last From)) 6) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (if (is In (last To) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last From)) 10) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (max (/ (* (* (value Piece at:(last From)) 8) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1))) (if (is In (last To) (sites "Forest")) (max (/ (* (* (value Piece at:(last From)) 3) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (if (is In (last To) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last From)) 5) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (max (/ (* (* (value Piece at:(last From)) 4) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1))))) (* {(if (is In (last From) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 1) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 1) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 1) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 1) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Tank" "Speeder" "Shooter"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 2) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 2) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 2) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 2) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Launcher" "Antiair" "Artillery"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 3) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 3) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 3) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 3) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 4) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 4) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 4) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 4) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Submarine" "Cruiser" "Battleship"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 5) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 5) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 5) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 5) 0)))) 4))))) (if (and (= 8 (state at:(last To))) (!= (mover) (who at:(last To)))) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 6) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 6) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 6) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 6) 0)))) 5) (if (> (who at:(last To)) 0) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 8) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 8) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 8) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 8) 0)))) 4) (if False (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 10) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 10) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 10) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 10) 0)))) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 9) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 9) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 9) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 9) 0))))) (value Random (range (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 11) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 11) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 11) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 11) 0)))) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 12) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 12) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 12) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 12) 0))))))})) 128000)))) (set State at:(last From) 0)) next:(if (and (= 8 (state at:(last To))) (!= (mover) (who at:(last To)))) (if (= (value Piece at:(last To)) 0) (and {(take Control of:All by:Mover at:(last To)) (set Value at:(last To) 50)}) (set Value at:(last To) (value Piece at:(last To)))) (if (= (value Piece at:(last To)) 0) (remove (last To)) (if (and {(= 0 (count Sites in:(intersection (sites {(last To) (last From)}) (sites Occupied by:All components:{"Launcher" "Artillery" "Battleship" "Antiair"})))) (if (is In (last To) (sites Occupied by:Enemy components:{"Bomber" "Battleship" "Artillery" "Launcher"})) (is In (last From) (union (sites Occupied by:Mover components:{"Soldier" "Motorbike" "Tank" "Speeder" "Shooter" "Launcher" "Antiair" "Battleship" "Artillery" "Base" "Town" "Factory" "Dock" "Airport" "Cruiser" "Submarine"}) (sites Occupied by:Neutral container:"Board"))) (is In (last From) (union (sites Occupied by:Mover) (sites Occupied by:Neutral container:"Board")))) (if (is In (last To) (sites Occupied by:Enemy components:{"Antiair" "Fighter"})) (is In (last From) (sites Occupied by:Mover components:{"Fighter" "Helicopter" "Bomber"})) (is In (last From) (union (sites Occupied by:Mover) (sites Occupied by:Neutral container:"Board")))) (if (is In (last To) (sites Occupied by:Enemy components:{"Submarine"})) (is In (last From) (sites Occupied by:Mover components:{"Submarine" "Battleship" "Cruiser"})) (is In (last From) (union (sites Occupied by:Mover) (sites Occupied by:Neutral container:"Board"))))}) (if (<= (- (value Piece at:(last From)) (/ (* (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (and (is In (last From) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (is In (last To) (sites Occupied by:All component:"Shooter"))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 6) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 10) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 8) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 3) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 5) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))))) (* {(if (is In (last To) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 1) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Tank" "Speeder" "Shooter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 2) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Launcher" "Antiair" "Artillery"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 3) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 4) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Submarine" "Cruiser" "Battleship"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 5) 0)))) 4))))) (if (and (= 8 (state at:(last From))) (!= (mover) (who at:(last From)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 6) 0)))) 5) (if (> (who at:(last From)) 0) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 8) 0)))) 4) (if True (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 10) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 9) 0))))) (value Random (range (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 11) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 12) 0))))))})) 128000)) 0) (remove (last From)) (set Value at:(last From) (- (value Piece at:(last From)) (/ (* (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (and (is In (last From) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (is In (last To) (sites Occupied by:All component:"Shooter"))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 6) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 10) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 8) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 3) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 5) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))))) (* {(if (is In (last To) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 1) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Tank" "Speeder" "Shooter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 2) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Launcher" "Antiair" "Artillery"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 3) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 4) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Submarine" "Cruiser" "Battleship"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 5) 0)))) 4))))) (if (and (= 8 (state at:(last From))) (!= (mover) (who at:(last From)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 6) 0)))) 5) (if (> (who at:(last From)) 0) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 8) 0)))) 4) (if True (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 10) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 9) 0))))) (value Random (range (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 11) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 12) 0))))))})) 128000)))) (set Value at:(last From) (value Piece at:(last From))))))))) (move Select (from (from) if:(and (> (state at:(from)) 0) (< (value Piece at:(from)) (mapEntry "MaxHealth" (what at:(from)))))) (to (sites Around (from) Orthogonal if:(is In (to) (sites Occupied by:Mover container:"Board" components:{"Town" "Dock" "Base" "Factory" "Airport"})))) (then (and {(set Value at:(last From) (min (mapEntry "MaxHealth" (what at:(last From))) (- (+ (value Piece at:(last From)) (value Piece at:(last To))) 1))) (set Value at:(last To) (max (- (value Piece at:(last To)) (- (mapEntry "MaxHealth" (what at:(last From))) (value Piece at:(last From)))) 1)) (set State at:(last From) 0)}))) (move Select (from (from) if:(> (state at:(from)) 0)) (to (sites Around (from) Orthogonal if:(and (= (what at:(from)) (what at:(to))) (< (value Piece at:(to)) (mapEntry "MaxHealth" (what at:(to))))))) (then (and {(if (<= (+ (value Piece at:(last To)) (value Piece at:(last From))) (mapEntry "MaxHealth" (what at:(last From)))) (and (set Value at:(last To) (min (mapEntry "MaxHealth" (what at:(last From))) (+ (value Piece at:(last From)) (value Piece at:(last To))))) (remove (last From))) (and (set Value at:(last To) (min (mapEntry "MaxHealth" (what at:(last From))) (- (+ (value Piece at:(last From)) (value Piece at:(last To))) 1))) (set Value at:(last From) (max (- (value Piece at:(last To)) (- (mapEntry "MaxHealth" (what at:(last From))) (value Piece at:(last From)))) 1)))) (set State at:(last From) 0) (set State at:(last To) 0)})))})) (piece "Tank" Each (or {(or (move (from (from) if:(> (state at:(from)) 1)) (to (sites Distance (step Orthogonal (to if:(is In (to) (difference (union (sites Empty) (sites Occupied by:Friend container:"Board")) (union (union (sites "Mountain") (sites "DeepWater")) (union (sites "Forest") (sites "ShallowWater"))))))) from:(from) (range 1 (- (state at:(from)) 1))) if:(is Empty (to)) (apply (set State at:(from) 1)))) (move (from (from) if:(> (state at:(from)) 1)) (to (sites Distance (step Orthogonal (to if:(is In (to) (intersection (sites Empty) (union (sites "Forest") (sites "ShallowWater")))))) from:(from) (range 1 (- 2 1))) if:(is Empty (to)) (apply (set State at:(from) 1))))) (move Select (from (from) if:(> (state at:(from)) 0)) (to (sites Distance Orthogonal from:(from) (range 1 1)) if:(and {(if (is In (from) (sites Occupied by:Mover container:"Board" components:{"Bomber" "Battleship" "Artillery" "Launcher"})) (is In (to) (union (sites Occupied by:Enemy container:"Board" components:{"Soldier" "Motorbike" "Tank" "Speeder" "Shooter" "Launcher" "Antiair" "Battleship" "Artillery" "Base" "Town" "Factory" "Dock" "Airport" "Cruiser" "Submarine"}) (sites Occupied by:Neutral container:"Board"))) (is In (to) (union (sites Occupied by:Enemy container:"Board") (sites Occupied by:Neutral container:"Board")))) (if (is In (from) (sites Occupied by:Mover container:"Board" components:{"Antiair" "Fighter"})) (is In (to) (sites Occupied by:Enemy container:"Board" components:{"Fighter" "Helicopter" "Bomber"})) (is In (to) (union (sites Occupied by:Enemy container:"Board") (sites Occupied by:Neutral container:"Board")))) (if (is In (from) (sites Occupied by:Mover container:"Board" components:{"Submarine"})) (is In (to) (sites Occupied by:Enemy container:"Board" components:{"Submarine" "Battleship" "Cruiser"})) (is In (to) (union (sites Occupied by:Enemy container:"Board") (sites Occupied by:Neutral container:"Board"))))})) (then (do (and (set Value at:(last To) (max 0 (- (value Piece at:(last To)) (/ (* (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (max (/ (* (* (value Piece at:(last From)) 4) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (if (and (is In (last To) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (is In (last From) (sites Occupied by:All component:"Shooter"))) (if (is In (last To) (sites "Forest")) (max (/ (* (* (value Piece at:(last From)) 6) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (if (is In (last To) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last From)) 10) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (max (/ (* (* (value Piece at:(last From)) 8) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1))) (if (is In (last To) (sites "Forest")) (max (/ (* (* (value Piece at:(last From)) 3) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (if (is In (last To) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last From)) 5) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (max (/ (* (* (value Piece at:(last From)) 4) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1))))) (* {(if (is In (last From) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 1) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 1) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 1) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 1) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Tank" "Speeder" "Shooter"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 2) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 2) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 2) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 2) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Launcher" "Antiair" "Artillery"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 3) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 3) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 3) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 3) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 4) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 4) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 4) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 4) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Submarine" "Cruiser" "Battleship"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 5) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 5) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 5) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 5) 0)))) 4))))) (if (and (= 8 (state at:(last To))) (!= (mover) (who at:(last To)))) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 6) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 6) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 6) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 6) 0)))) 5) (if (> (who at:(last To)) 0) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 8) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 8) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 8) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 8) 0)))) 4) (if False (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 10) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 10) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 10) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 10) 0)))) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 9) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 9) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 9) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 9) 0))))) (value Random (range (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 11) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 11) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 11) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 11) 0)))) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 12) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 12) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 12) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 12) 0))))))})) 128000)))) (set State at:(last From) 0)) next:(if (and (= 8 (state at:(last To))) (!= (mover) (who at:(last To)))) (if (= (value Piece at:(last To)) 0) (and {(take Control of:All by:Mover at:(last To)) (set Value at:(last To) 50)}) (set Value at:(last To) (value Piece at:(last To)))) (if (= (value Piece at:(last To)) 0) (remove (last To)) (if (and {(= 0 (count Sites in:(intersection (sites {(last To) (last From)}) (sites Occupied by:All components:{"Launcher" "Artillery" "Battleship" "Antiair"})))) (if (is In (last To) (sites Occupied by:Enemy components:{"Bomber" "Battleship" "Artillery" "Launcher"})) (is In (last From) (union (sites Occupied by:Mover components:{"Soldier" "Motorbike" "Tank" "Speeder" "Shooter" "Launcher" "Antiair" "Battleship" "Artillery" "Base" "Town" "Factory" "Dock" "Airport" "Cruiser" "Submarine"}) (sites Occupied by:Neutral container:"Board"))) (is In (last From) (union (sites Occupied by:Mover) (sites Occupied by:Neutral container:"Board")))) (if (is In (last To) (sites Occupied by:Enemy components:{"Antiair" "Fighter"})) (is In (last From) (sites Occupied by:Mover components:{"Fighter" "Helicopter" "Bomber"})) (is In (last From) (union (sites Occupied by:Mover) (sites Occupied by:Neutral container:"Board")))) (if (is In (last To) (sites Occupied by:Enemy components:{"Submarine"})) (is In (last From) (sites Occupied by:Mover components:{"Submarine" "Battleship" "Cruiser"})) (is In (last From) (union (sites Occupied by:Mover) (sites Occupied by:Neutral container:"Board"))))}) (if (<= (- (value Piece at:(last From)) (/ (* (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (and (is In (last From) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (is In (last To) (sites Occupied by:All component:"Shooter"))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 6) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 10) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 8) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 3) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 5) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))))) (* {(if (is In (last To) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 1) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Tank" "Speeder" "Shooter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 2) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Launcher" "Antiair" "Artillery"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 3) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 4) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Submarine" "Cruiser" "Battleship"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 5) 0)))) 4))))) (if (and (= 8 (state at:(last From))) (!= (mover) (who at:(last From)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 6) 0)))) 5) (if (> (who at:(last From)) 0) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 8) 0)))) 4) (if True (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 10) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 9) 0))))) (value Random (range (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 11) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 12) 0))))))})) 128000)) 0) (remove (last From)) (set Value at:(last From) (- (value Piece at:(last From)) (/ (* (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (and (is In (last From) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (is In (last To) (sites Occupied by:All component:"Shooter"))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 6) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 10) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 8) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 3) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 5) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))))) (* {(if (is In (last To) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 1) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Tank" "Speeder" "Shooter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 2) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Launcher" "Antiair" "Artillery"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 3) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 4) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Submarine" "Cruiser" "Battleship"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 5) 0)))) 4))))) (if (and (= 8 (state at:(last From))) (!= (mover) (who at:(last From)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 6) 0)))) 5) (if (> (who at:(last From)) 0) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 8) 0)))) 4) (if True (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 10) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 9) 0))))) (value Random (range (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 11) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 12) 0))))))})) 128000)))) (set Value at:(last From) (value Piece at:(last From))))))))) (move Select (from (from) if:(and (> (state at:(from)) 0) (< (value Piece at:(from)) (mapEntry "MaxHealth" (what at:(from)))))) (to (sites Around (from) Orthogonal if:(is In (to) (sites Occupied by:Mover container:"Board" components:{"Town" "Dock" "Base" "Factory" "Airport"})))) (then (and {(set Value at:(last From) (min (mapEntry "MaxHealth" (what at:(last From))) (- (+ (value Piece at:(last From)) (value Piece at:(last To))) 1))) (set Value at:(last To) (max (- (value Piece at:(last To)) (- (mapEntry "MaxHealth" (what at:(last From))) (value Piece at:(last From)))) 1)) (set State at:(last From) 0)}))) (move Select (from (from) if:(> (state at:(from)) 0)) (to (sites Around (from) Orthogonal if:(and (= (what at:(from)) (what at:(to))) (< (value Piece at:(to)) (mapEntry "MaxHealth" (what at:(to))))))) (then (and {(if (<= (+ (value Piece at:(last To)) (value Piece at:(last From))) (mapEntry "MaxHealth" (what at:(last From)))) (and (set Value at:(last To) (min (mapEntry "MaxHealth" (what at:(last From))) (+ (value Piece at:(last From)) (value Piece at:(last To))))) (remove (last From))) (and (set Value at:(last To) (min (mapEntry "MaxHealth" (what at:(last From))) (- (+ (value Piece at:(last From)) (value Piece at:(last To))) 1))) (set Value at:(last From) (max (- (value Piece at:(last To)) (- (mapEntry "MaxHealth" (what at:(last From))) (value Piece at:(last From)))) 1)))) (set State at:(last From) 0) (set State at:(last To) 0)})))})) (piece "Antiair" Each (or {(or (move (from (from) if:(> (state at:(from)) 1)) (to (sites Distance (step Orthogonal (to if:(is In (to) (difference (union (sites Empty) (sites Occupied by:Friend container:"Board")) (union (union (sites "Mountain") (sites "DeepWater")) (union (sites "Forest") (sites "ShallowWater"))))))) from:(from) (range 1 (- (state at:(from)) 1))) if:(is Empty (to)) (apply (set State at:(from) 1)))) (move (from (from) if:(> (state at:(from)) 1)) (to (sites Distance (step Orthogonal (to if:(is In (to) (intersection (sites Empty) (union (sites "Forest") (sites "ShallowWater")))))) from:(from) (range 1 (- 2 1))) if:(is Empty (to)) (apply (set State at:(from) 1))))) (move Select (from (from) if:(> (state at:(from)) 0)) (to (sites Distance Orthogonal from:(from) (range 1 2)) if:(and {(if (is In (from) (sites Occupied by:Mover container:"Board" components:{"Bomber" "Battleship" "Artillery" "Launcher"})) (is In (to) (union (sites Occupied by:Enemy container:"Board" components:{"Soldier" "Motorbike" "Tank" "Speeder" "Shooter" "Launcher" "Antiair" "Battleship" "Artillery" "Base" "Town" "Factory" "Dock" "Airport" "Cruiser" "Submarine"}) (sites Occupied by:Neutral container:"Board"))) (is In (to) (union (sites Occupied by:Enemy container:"Board") (sites Occupied by:Neutral container:"Board")))) (if (is In (from) (sites Occupied by:Mover container:"Board" components:{"Antiair" "Fighter"})) (is In (to) (sites Occupied by:Enemy container:"Board" components:{"Fighter" "Helicopter" "Bomber"})) (is In (to) (union (sites Occupied by:Enemy container:"Board") (sites Occupied by:Neutral container:"Board")))) (if (is In (from) (sites Occupied by:Mover container:"Board" components:{"Submarine"})) (is In (to) (sites Occupied by:Enemy container:"Board" components:{"Submarine" "Battleship" "Cruiser"})) (is In (to) (union (sites Occupied by:Enemy container:"Board") (sites Occupied by:Neutral container:"Board"))))})) (then (do (and (set Value at:(last To) (max 0 (- (value Piece at:(last To)) (/ (* (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (max (/ (* (* (value Piece at:(last From)) 4) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (if (and (is In (last To) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (is In (last From) (sites Occupied by:All component:"Shooter"))) (if (is In (last To) (sites "Forest")) (max (/ (* (* (value Piece at:(last From)) 6) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (if (is In (last To) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last From)) 10) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (max (/ (* (* (value Piece at:(last From)) 8) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1))) (if (is In (last To) (sites "Forest")) (max (/ (* (* (value Piece at:(last From)) 3) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (if (is In (last To) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last From)) 5) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (max (/ (* (* (value Piece at:(last From)) 4) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1))))) (* {(if (is In (last From) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 1) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 1) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 1) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 1) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Tank" "Speeder" "Shooter"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 2) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 2) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 2) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 2) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Launcher" "Antiair" "Artillery"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 3) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 3) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 3) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 3) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 4) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 4) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 4) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 4) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Submarine" "Cruiser" "Battleship"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 5) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 5) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 5) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 5) 0)))) 4))))) (if (and (= 8 (state at:(last To))) (!= (mover) (who at:(last To)))) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 6) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 6) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 6) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 6) 0)))) 5) (if (> (who at:(last To)) 0) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 8) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 8) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 8) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 8) 0)))) 4) (if False (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 10) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 10) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 10) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 10) 0)))) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 9) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 9) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 9) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 9) 0))))) (value Random (range (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 11) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 11) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 11) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 11) 0)))) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 12) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 12) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 12) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 12) 0))))))})) 128000)))) (set State at:(last From) 0)) next:(if (and (= 8 (state at:(last To))) (!= (mover) (who at:(last To)))) (if (= (value Piece at:(last To)) 0) (and {(take Control of:All by:Mover at:(last To)) (set Value at:(last To) 50)}) (set Value at:(last To) (value Piece at:(last To)))) (if (= (value Piece at:(last To)) 0) (remove (last To)) (if (and {(= 0 (count Sites in:(intersection (sites {(last To) (last From)}) (sites Occupied by:All components:{"Launcher" "Artillery" "Battleship" "Antiair"})))) (if (is In (last To) (sites Occupied by:Enemy components:{"Bomber" "Battleship" "Artillery" "Launcher"})) (is In (last From) (union (sites Occupied by:Mover components:{"Soldier" "Motorbike" "Tank" "Speeder" "Shooter" "Launcher" "Antiair" "Battleship" "Artillery" "Base" "Town" "Factory" "Dock" "Airport" "Cruiser" "Submarine"}) (sites Occupied by:Neutral container:"Board"))) (is In (last From) (union (sites Occupied by:Mover) (sites Occupied by:Neutral container:"Board")))) (if (is In (last To) (sites Occupied by:Enemy components:{"Antiair" "Fighter"})) (is In (last From) (sites Occupied by:Mover components:{"Fighter" "Helicopter" "Bomber"})) (is In (last From) (union (sites Occupied by:Mover) (sites Occupied by:Neutral container:"Board")))) (if (is In (last To) (sites Occupied by:Enemy components:{"Submarine"})) (is In (last From) (sites Occupied by:Mover components:{"Submarine" "Battleship" "Cruiser"})) (is In (last From) (union (sites Occupied by:Mover) (sites Occupied by:Neutral container:"Board"))))}) (if (<= (- (value Piece at:(last From)) (/ (* (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (and (is In (last From) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (is In (last To) (sites Occupied by:All component:"Shooter"))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 6) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 10) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 8) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 3) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 5) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))))) (* {(if (is In (last To) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 1) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Tank" "Speeder" "Shooter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 2) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Launcher" "Antiair" "Artillery"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 3) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 4) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Submarine" "Cruiser" "Battleship"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 5) 0)))) 4))))) (if (and (= 8 (state at:(last From))) (!= (mover) (who at:(last From)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 6) 0)))) 5) (if (> (who at:(last From)) 0) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 8) 0)))) 4) (if True (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 10) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 9) 0))))) (value Random (range (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 11) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 12) 0))))))})) 128000)) 0) (remove (last From)) (set Value at:(last From) (- (value Piece at:(last From)) (/ (* (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (and (is In (last From) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (is In (last To) (sites Occupied by:All component:"Shooter"))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 6) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 10) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 8) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 3) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 5) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))))) (* {(if (is In (last To) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 1) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Tank" "Speeder" "Shooter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 2) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Launcher" "Antiair" "Artillery"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 3) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 4) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Submarine" "Cruiser" "Battleship"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 5) 0)))) 4))))) (if (and (= 8 (state at:(last From))) (!= (mover) (who at:(last From)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 6) 0)))) 5) (if (> (who at:(last From)) 0) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 8) 0)))) 4) (if True (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 10) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 9) 0))))) (value Random (range (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 11) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 12) 0))))))})) 128000)))) (set Value at:(last From) (value Piece at:(last From))))))))) (move Select (from (from) if:(and (> (state at:(from)) 0) (< (value Piece at:(from)) (mapEntry "MaxHealth" (what at:(from)))))) (to (sites Around (from) Orthogonal if:(is In (to) (sites Occupied by:Mover container:"Board" components:{"Town" "Dock" "Base" "Factory" "Airport"})))) (then (and {(set Value at:(last From) (min (mapEntry "MaxHealth" (what at:(last From))) (- (+ (value Piece at:(last From)) (value Piece at:(last To))) 1))) (set Value at:(last To) (max (- (value Piece at:(last To)) (- (mapEntry "MaxHealth" (what at:(last From))) (value Piece at:(last From)))) 1)) (set State at:(last From) 0)}))) (move Select (from (from) if:(> (state at:(from)) 0)) (to (sites Around (from) Orthogonal if:(and (= (what at:(from)) (what at:(to))) (< (value Piece at:(to)) (mapEntry "MaxHealth" (what at:(to))))))) (then (and {(if (<= (+ (value Piece at:(last To)) (value Piece at:(last From))) (mapEntry "MaxHealth" (what at:(last From)))) (and (set Value at:(last To) (min (mapEntry "MaxHealth" (what at:(last From))) (+ (value Piece at:(last From)) (value Piece at:(last To))))) (remove (last From))) (and (set Value at:(last To) (min (mapEntry "MaxHealth" (what at:(last From))) (- (+ (value Piece at:(last From)) (value Piece at:(last To))) 1))) (set Value at:(last From) (max (- (value Piece at:(last To)) (- (mapEntry "MaxHealth" (what at:(last From))) (value Piece at:(last From)))) 1)))) (set State at:(last From) 0) (set State at:(last To) 0)})))})) (piece "Launcher" Each (or {(or (move (from (from) if:(> (state at:(from)) 1)) (to (sites Distance (step Orthogonal (to if:(is In (to) (difference (union (sites Empty) (sites Occupied by:Friend container:"Board")) (union (union (sites "Mountain") (sites "DeepWater")) (union (sites "Forest") (sites "ShallowWater"))))))) from:(from) (range 1 (- (state at:(from)) 1))) if:(is Empty (to)) (apply (set State at:(from) 1)))) (move (from (from) if:(> (state at:(from)) 1)) (to (sites Distance (step Orthogonal (to if:(is In (to) (intersection (sites Empty) (union (sites "Forest") (sites "ShallowWater")))))) from:(from) (range 1 (- 2 1))) if:(is Empty (to)) (apply (set State at:(from) 1))))) (move Select (from (from) if:(> (state at:(from)) 0)) (to (sites Distance Orthogonal from:(from) (range 2 3)) if:(and {(if (is In (from) (sites Occupied by:Mover container:"Board" components:{"Bomber" "Battleship" "Artillery" "Launcher"})) (is In (to) (union (sites Occupied by:Enemy container:"Board" components:{"Soldier" "Motorbike" "Tank" "Speeder" "Shooter" "Launcher" "Antiair" "Battleship" "Artillery" "Base" "Town" "Factory" "Dock" "Airport" "Cruiser" "Submarine"}) (sites Occupied by:Neutral container:"Board"))) (is In (to) (union (sites Occupied by:Enemy container:"Board") (sites Occupied by:Neutral container:"Board")))) (if (is In (from) (sites Occupied by:Mover container:"Board" components:{"Antiair" "Fighter"})) (is In (to) (sites Occupied by:Enemy container:"Board" components:{"Fighter" "Helicopter" "Bomber"})) (is In (to) (union (sites Occupied by:Enemy container:"Board") (sites Occupied by:Neutral container:"Board")))) (if (is In (from) (sites Occupied by:Mover container:"Board" components:{"Submarine"})) (is In (to) (sites Occupied by:Enemy container:"Board" components:{"Submarine" "Battleship" "Cruiser"})) (is In (to) (union (sites Occupied by:Enemy container:"Board") (sites Occupied by:Neutral container:"Board"))))})) (then (do (and (set Value at:(last To) (max 0 (- (value Piece at:(last To)) (/ (* (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (max (/ (* (* (value Piece at:(last From)) 4) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (if (and (is In (last To) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (is In (last From) (sites Occupied by:All component:"Shooter"))) (if (is In (last To) (sites "Forest")) (max (/ (* (* (value Piece at:(last From)) 6) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (if (is In (last To) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last From)) 10) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (max (/ (* (* (value Piece at:(last From)) 8) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1))) (if (is In (last To) (sites "Forest")) (max (/ (* (* (value Piece at:(last From)) 3) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (if (is In (last To) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last From)) 5) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (max (/ (* (* (value Piece at:(last From)) 4) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1))))) (* {(if (is In (last From) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 1) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 1) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 1) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 1) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Tank" "Speeder" "Shooter"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 2) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 2) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 2) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 2) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Launcher" "Antiair" "Artillery"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 3) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 3) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 3) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 3) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 4) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 4) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 4) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 4) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Submarine" "Cruiser" "Battleship"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 5) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 5) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 5) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 5) 0)))) 4))))) (if (and (= 8 (state at:(last To))) (!= (mover) (who at:(last To)))) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 6) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 6) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 6) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 6) 0)))) 5) (if (> (who at:(last To)) 0) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 8) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 8) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 8) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 8) 0)))) 4) (if False (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 10) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 10) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 10) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 10) 0)))) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 9) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 9) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 9) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 9) 0))))) (value Random (range (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 11) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 11) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 11) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 11) 0)))) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 12) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 12) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 12) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 12) 0))))))})) 128000)))) (set State at:(last From) 0)) next:(if (and (= 8 (state at:(last To))) (!= (mover) (who at:(last To)))) (if (= (value Piece at:(last To)) 0) (and {(take Control of:All by:Mover at:(last To)) (set Value at:(last To) 50)}) (set Value at:(last To) (value Piece at:(last To)))) (if (= (value Piece at:(last To)) 0) (remove (last To)) (if (and {(= 0 (count Sites in:(intersection (sites {(last To) (last From)}) (sites Occupied by:All components:{"Launcher" "Artillery" "Battleship" "Antiair"})))) (if (is In (last To) (sites Occupied by:Enemy components:{"Bomber" "Battleship" "Artillery" "Launcher"})) (is In (last From) (union (sites Occupied by:Mover components:{"Soldier" "Motorbike" "Tank" "Speeder" "Shooter" "Launcher" "Antiair" "Battleship" "Artillery" "Base" "Town" "Factory" "Dock" "Airport" "Cruiser" "Submarine"}) (sites Occupied by:Neutral container:"Board"))) (is In (last From) (union (sites Occupied by:Mover) (sites Occupied by:Neutral container:"Board")))) (if (is In (last To) (sites Occupied by:Enemy components:{"Antiair" "Fighter"})) (is In (last From) (sites Occupied by:Mover components:{"Fighter" "Helicopter" "Bomber"})) (is In (last From) (union (sites Occupied by:Mover) (sites Occupied by:Neutral container:"Board")))) (if (is In (last To) (sites Occupied by:Enemy components:{"Submarine"})) (is In (last From) (sites Occupied by:Mover components:{"Submarine" "Battleship" "Cruiser"})) (is In (last From) (union (sites Occupied by:Mover) (sites Occupied by:Neutral container:"Board"))))}) (if (<= (- (value Piece at:(last From)) (/ (* (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (and (is In (last From) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (is In (last To) (sites Occupied by:All component:"Shooter"))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 6) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 10) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 8) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 3) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 5) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))))) (* {(if (is In (last To) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 1) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Tank" "Speeder" "Shooter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 2) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Launcher" "Antiair" "Artillery"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 3) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 4) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Submarine" "Cruiser" "Battleship"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 5) 0)))) 4))))) (if (and (= 8 (state at:(last From))) (!= (mover) (who at:(last From)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 6) 0)))) 5) (if (> (who at:(last From)) 0) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 8) 0)))) 4) (if True (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 10) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 9) 0))))) (value Random (range (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 11) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 12) 0))))))})) 128000)) 0) (remove (last From)) (set Value at:(last From) (- (value Piece at:(last From)) (/ (* (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (and (is In (last From) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (is In (last To) (sites Occupied by:All component:"Shooter"))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 6) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 10) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 8) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 3) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 5) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))))) (* {(if (is In (last To) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 1) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Tank" "Speeder" "Shooter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 2) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Launcher" "Antiair" "Artillery"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 3) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 4) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Submarine" "Cruiser" "Battleship"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 5) 0)))) 4))))) (if (and (= 8 (state at:(last From))) (!= (mover) (who at:(last From)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 6) 0)))) 5) (if (> (who at:(last From)) 0) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 8) 0)))) 4) (if True (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 10) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 9) 0))))) (value Random (range (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 11) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 12) 0))))))})) 128000)))) (set Value at:(last From) (value Piece at:(last From))))))))) (move Select (from (from) if:(and (> (state at:(from)) 0) (< (value Piece at:(from)) (mapEntry "MaxHealth" (what at:(from)))))) (to (sites Around (from) Orthogonal if:(is In (to) (sites Occupied by:Mover container:"Board" components:{"Town" "Dock" "Base" "Factory" "Airport"})))) (then (and {(set Value at:(last From) (min (mapEntry "MaxHealth" (what at:(last From))) (- (+ (value Piece at:(last From)) (value Piece at:(last To))) 1))) (set Value at:(last To) (max (- (value Piece at:(last To)) (- (mapEntry "MaxHealth" (what at:(last From))) (value Piece at:(last From)))) 1)) (set State at:(last From) 0)}))) (move Select (from (from) if:(> (state at:(from)) 0)) (to (sites Around (from) Orthogonal if:(and (= (what at:(from)) (what at:(to))) (< (value Piece at:(to)) (mapEntry "MaxHealth" (what at:(to))))))) (then (and {(if (<= (+ (value Piece at:(last To)) (value Piece at:(last From))) (mapEntry "MaxHealth" (what at:(last From)))) (and (set Value at:(last To) (min (mapEntry "MaxHealth" (what at:(last From))) (+ (value Piece at:(last From)) (value Piece at:(last To))))) (remove (last From))) (and (set Value at:(last To) (min (mapEntry "MaxHealth" (what at:(last From))) (- (+ (value Piece at:(last From)) (value Piece at:(last To))) 1))) (set Value at:(last From) (max (- (value Piece at:(last To)) (- (mapEntry "MaxHealth" (what at:(last From))) (value Piece at:(last From)))) 1)))) (set State at:(last From) 0) (set State at:(last To) 0)})))})) (piece "Artillery" Each (or {(or (move (from (from) if:(> (state at:(from)) 1)) (to (sites Distance (step Orthogonal (to if:(is In (to) (difference (union (sites Empty) (sites Occupied by:Friend container:"Board")) (union (union (sites "Mountain") (sites "DeepWater")) (union (sites "Forest") (sites "ShallowWater"))))))) from:(from) (range 1 (- (state at:(from)) 1))) if:(is Empty (to)) (apply (set State at:(from) 0)))) (move (from (from) if:(> (state at:(from)) 1)) (to (sites Distance (step Orthogonal (to if:(is In (to) (intersection (sites Empty) (union (sites "Forest") (sites "ShallowWater")))))) from:(from) (range 1 (- 2 1))) if:(is Empty (to)) (apply (set State at:(from) 0))))) (move Select (from (from) if:(> (state at:(from)) 0)) (to (sites Distance Orthogonal from:(from) (range 3 5)) if:(and {(if (is In (from) (sites Occupied by:Mover container:"Board" components:{"Bomber" "Battleship" "Artillery" "Launcher"})) (is In (to) (union (sites Occupied by:Enemy container:"Board" components:{"Soldier" "Motorbike" "Tank" "Speeder" "Shooter" "Launcher" "Antiair" "Battleship" "Artillery" "Base" "Town" "Factory" "Dock" "Airport" "Cruiser" "Submarine"}) (sites Occupied by:Neutral container:"Board"))) (is In (to) (union (sites Occupied by:Enemy container:"Board") (sites Occupied by:Neutral container:"Board")))) (if (is In (from) (sites Occupied by:Mover container:"Board" components:{"Antiair" "Fighter"})) (is In (to) (sites Occupied by:Enemy container:"Board" components:{"Fighter" "Helicopter" "Bomber"})) (is In (to) (union (sites Occupied by:Enemy container:"Board") (sites Occupied by:Neutral container:"Board")))) (if (is In (from) (sites Occupied by:Mover container:"Board" components:{"Submarine"})) (is In (to) (sites Occupied by:Enemy container:"Board" components:{"Submarine" "Battleship" "Cruiser"})) (is In (to) (union (sites Occupied by:Enemy container:"Board") (sites Occupied by:Neutral container:"Board"))))})) (then (do (and (set Value at:(last To) (max 0 (- (value Piece at:(last To)) (/ (* (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (max (/ (* (* (value Piece at:(last From)) 4) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (if (and (is In (last To) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (is In (last From) (sites Occupied by:All component:"Shooter"))) (if (is In (last To) (sites "Forest")) (max (/ (* (* (value Piece at:(last From)) 6) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (if (is In (last To) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last From)) 10) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (max (/ (* (* (value Piece at:(last From)) 8) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1))) (if (is In (last To) (sites "Forest")) (max (/ (* (* (value Piece at:(last From)) 3) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (if (is In (last To) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last From)) 5) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (max (/ (* (* (value Piece at:(last From)) 4) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1))))) (* {(if (is In (last From) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 1) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 1) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 1) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 1) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Tank" "Speeder" "Shooter"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 2) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 2) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 2) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 2) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Launcher" "Antiair" "Artillery"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 3) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 3) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 3) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 3) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 4) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 4) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 4) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 4) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Submarine" "Cruiser" "Battleship"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 5) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 5) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 5) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 5) 0)))) 4))))) (if (and (= 8 (state at:(last To))) (!= (mover) (who at:(last To)))) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 6) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 6) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 6) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 6) 0)))) 5) (if (> (who at:(last To)) 0) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 8) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 8) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 8) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 8) 0)))) 4) (if False (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 10) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 10) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 10) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 10) 0)))) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 9) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 9) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 9) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 9) 0))))) (value Random (range (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 11) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 11) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 11) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 11) 0)))) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 12) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 12) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 12) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 12) 0))))))})) 128000)))) (set State at:(last From) 0)) next:(if (and (= 8 (state at:(last To))) (!= (mover) (who at:(last To)))) (if (= (value Piece at:(last To)) 0) (and {(take Control of:All by:Mover at:(last To)) (set Value at:(last To) 50)}) (set Value at:(last To) (value Piece at:(last To)))) (if (= (value Piece at:(last To)) 0) (remove (last To)) (if (and {(= 0 (count Sites in:(intersection (sites {(last To) (last From)}) (sites Occupied by:All components:{"Launcher" "Artillery" "Battleship" "Antiair"})))) (if (is In (last To) (sites Occupied by:Enemy components:{"Bomber" "Battleship" "Artillery" "Launcher"})) (is In (last From) (union (sites Occupied by:Mover components:{"Soldier" "Motorbike" "Tank" "Speeder" "Shooter" "Launcher" "Antiair" "Battleship" "Artillery" "Base" "Town" "Factory" "Dock" "Airport" "Cruiser" "Submarine"}) (sites Occupied by:Neutral container:"Board"))) (is In (last From) (union (sites Occupied by:Mover) (sites Occupied by:Neutral container:"Board")))) (if (is In (last To) (sites Occupied by:Enemy components:{"Antiair" "Fighter"})) (is In (last From) (sites Occupied by:Mover components:{"Fighter" "Helicopter" "Bomber"})) (is In (last From) (union (sites Occupied by:Mover) (sites Occupied by:Neutral container:"Board")))) (if (is In (last To) (sites Occupied by:Enemy components:{"Submarine"})) (is In (last From) (sites Occupied by:Mover components:{"Submarine" "Battleship" "Cruiser"})) (is In (last From) (union (sites Occupied by:Mover) (sites Occupied by:Neutral container:"Board"))))}) (if (<= (- (value Piece at:(last From)) (/ (* (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (and (is In (last From) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (is In (last To) (sites Occupied by:All component:"Shooter"))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 6) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 10) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 8) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 3) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 5) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))))) (* {(if (is In (last To) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 1) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Tank" "Speeder" "Shooter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 2) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Launcher" "Antiair" "Artillery"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 3) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 4) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Submarine" "Cruiser" "Battleship"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 5) 0)))) 4))))) (if (and (= 8 (state at:(last From))) (!= (mover) (who at:(last From)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 6) 0)))) 5) (if (> (who at:(last From)) 0) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 8) 0)))) 4) (if True (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 10) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 9) 0))))) (value Random (range (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 11) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 12) 0))))))})) 128000)) 0) (remove (last From)) (set Value at:(last From) (- (value Piece at:(last From)) (/ (* (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (and (is In (last From) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (is In (last To) (sites Occupied by:All component:"Shooter"))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 6) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 10) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 8) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 3) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 5) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))))) (* {(if (is In (last To) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 1) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Tank" "Speeder" "Shooter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 2) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Launcher" "Antiair" "Artillery"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 3) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 4) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Submarine" "Cruiser" "Battleship"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 5) 0)))) 4))))) (if (and (= 8 (state at:(last From))) (!= (mover) (who at:(last From)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 6) 0)))) 5) (if (> (who at:(last From)) 0) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 8) 0)))) 4) (if True (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 10) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 9) 0))))) (value Random (range (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 11) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 12) 0))))))})) 128000)))) (set Value at:(last From) (value Piece at:(last From))))))))) (move Select (from (from) if:(and (> (state at:(from)) 0) (< (value Piece at:(from)) (mapEntry "MaxHealth" (what at:(from)))))) (to (sites Around (from) Orthogonal if:(is In (to) (sites Occupied by:Mover container:"Board" components:{"Town" "Dock" "Base" "Factory" "Airport"})))) (then (and {(set Value at:(last From) (min (mapEntry "MaxHealth" (what at:(last From))) (- (+ (value Piece at:(last From)) (value Piece at:(last To))) 1))) (set Value at:(last To) (max (- (value Piece at:(last To)) (- (mapEntry "MaxHealth" (what at:(last From))) (value Piece at:(last From)))) 1)) (set State at:(last From) 0)}))) (move Select (from (from) if:(> (state at:(from)) 0)) (to (sites Around (from) Orthogonal if:(and (= (what at:(from)) (what at:(to))) (< (value Piece at:(to)) (mapEntry "MaxHealth" (what at:(to))))))) (then (and {(if (<= (+ (value Piece at:(last To)) (value Piece at:(last From))) (mapEntry "MaxHealth" (what at:(last From)))) (and (set Value at:(last To) (min (mapEntry "MaxHealth" (what at:(last From))) (+ (value Piece at:(last From)) (value Piece at:(last To))))) (remove (last From))) (and (set Value at:(last To) (min (mapEntry "MaxHealth" (what at:(last From))) (- (+ (value Piece at:(last From)) (value Piece at:(last To))) 1))) (set Value at:(last From) (max (- (value Piece at:(last To)) (- (mapEntry "MaxHealth" (what at:(last From))) (value Piece at:(last From)))) 1)))) (set State at:(last From) 0) (set State at:(last To) 0)})))})) (piece "Helicopter" Each (or {(move (from (from) if:(> (state at:(from)) 1)) (to (sites Distance (step Orthogonal (to if:(is In (to) (union (sites Empty) (sites Occupied by:Friend container:"Board"))))) from:(from) (range 1 (- (state at:(from)) 1))) if:(is Empty (to)) (apply (set State at:(from) 1)))) (move Select (from (from) if:(> (state at:(from)) 0)) (to (sites Distance Orthogonal from:(from) (range 1 1)) if:(and {(if (is In (from) (sites Occupied by:Mover container:"Board" components:{"Bomber" "Battleship" "Artillery" "Launcher"})) (is In (to) (union (sites Occupied by:Enemy container:"Board" components:{"Soldier" "Motorbike" "Tank" "Speeder" "Shooter" "Launcher" "Antiair" "Battleship" "Artillery" "Base" "Town" "Factory" "Dock" "Airport" "Cruiser" "Submarine"}) (sites Occupied by:Neutral container:"Board"))) (is In (to) (union (sites Occupied by:Enemy container:"Board") (sites Occupied by:Neutral container:"Board")))) (if (is In (from) (sites Occupied by:Mover container:"Board" components:{"Antiair" "Fighter"})) (is In (to) (sites Occupied by:Enemy container:"Board" components:{"Fighter" "Helicopter" "Bomber"})) (is In (to) (union (sites Occupied by:Enemy container:"Board") (sites Occupied by:Neutral container:"Board")))) (if (is In (from) (sites Occupied by:Mover container:"Board" components:{"Submarine"})) (is In (to) (sites Occupied by:Enemy container:"Board" components:{"Submarine" "Battleship" "Cruiser"})) (is In (to) (union (sites Occupied by:Enemy container:"Board") (sites Occupied by:Neutral container:"Board"))))})) (then (do (and (set Value at:(last To) (max 0 (- (value Piece at:(last To)) (/ (* (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (max (/ (* (* (value Piece at:(last From)) 4) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (if (and (is In (last To) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (is In (last From) (sites Occupied by:All component:"Shooter"))) (if (is In (last To) (sites "Forest")) (max (/ (* (* (value Piece at:(last From)) 6) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (if (is In (last To) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last From)) 10) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (max (/ (* (* (value Piece at:(last From)) 8) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1))) (if (is In (last To) (sites "Forest")) (max (/ (* (* (value Piece at:(last From)) 3) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (if (is In (last To) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last From)) 5) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (max (/ (* (* (value Piece at:(last From)) 4) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1))))) (* {(if (is In (last From) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 1) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 1) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 1) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 1) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Tank" "Speeder" "Shooter"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 2) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 2) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 2) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 2) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Launcher" "Antiair" "Artillery"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 3) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 3) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 3) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 3) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 4) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 4) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 4) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 4) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Submarine" "Cruiser" "Battleship"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 5) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 5) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 5) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 5) 0)))) 4))))) (if (and (= 8 (state at:(last To))) (!= (mover) (who at:(last To)))) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 6) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 6) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 6) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 6) 0)))) 5) (if (> (who at:(last To)) 0) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 8) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 8) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 8) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 8) 0)))) 4) (if False (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 10) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 10) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 10) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 10) 0)))) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 9) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 9) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 9) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 9) 0))))) (value Random (range (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 11) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 11) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 11) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 11) 0)))) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 12) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 12) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 12) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 12) 0))))))})) 128000)))) (set State at:(last From) 0)) next:(if (and (= 8 (state at:(last To))) (!= (mover) (who at:(last To)))) (if (= (value Piece at:(last To)) 0) (and {(take Control of:All by:Mover at:(last To)) (set Value at:(last To) 50)}) (set Value at:(last To) (value Piece at:(last To)))) (if (= (value Piece at:(last To)) 0) (remove (last To)) (if (and {(= 0 (count Sites in:(intersection (sites {(last To) (last From)}) (sites Occupied by:All components:{"Launcher" "Artillery" "Battleship" "Antiair"})))) (if (is In (last To) (sites Occupied by:Enemy components:{"Bomber" "Battleship" "Artillery" "Launcher"})) (is In (last From) (union (sites Occupied by:Mover components:{"Soldier" "Motorbike" "Tank" "Speeder" "Shooter" "Launcher" "Antiair" "Battleship" "Artillery" "Base" "Town" "Factory" "Dock" "Airport" "Cruiser" "Submarine"}) (sites Occupied by:Neutral container:"Board"))) (is In (last From) (union (sites Occupied by:Mover) (sites Occupied by:Neutral container:"Board")))) (if (is In (last To) (sites Occupied by:Enemy components:{"Antiair" "Fighter"})) (is In (last From) (sites Occupied by:Mover components:{"Fighter" "Helicopter" "Bomber"})) (is In (last From) (union (sites Occupied by:Mover) (sites Occupied by:Neutral container:"Board")))) (if (is In (last To) (sites Occupied by:Enemy components:{"Submarine"})) (is In (last From) (sites Occupied by:Mover components:{"Submarine" "Battleship" "Cruiser"})) (is In (last From) (union (sites Occupied by:Mover) (sites Occupied by:Neutral container:"Board"))))}) (if (<= (- (value Piece at:(last From)) (/ (* (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (and (is In (last From) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (is In (last To) (sites Occupied by:All component:"Shooter"))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 6) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 10) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 8) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 3) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 5) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))))) (* {(if (is In (last To) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 1) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Tank" "Speeder" "Shooter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 2) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Launcher" "Antiair" "Artillery"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 3) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 4) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Submarine" "Cruiser" "Battleship"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 5) 0)))) 4))))) (if (and (= 8 (state at:(last From))) (!= (mover) (who at:(last From)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 6) 0)))) 5) (if (> (who at:(last From)) 0) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 8) 0)))) 4) (if True (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 10) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 9) 0))))) (value Random (range (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 11) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 12) 0))))))})) 128000)) 0) (remove (last From)) (set Value at:(last From) (- (value Piece at:(last From)) (/ (* (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (and (is In (last From) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (is In (last To) (sites Occupied by:All component:"Shooter"))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 6) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 10) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 8) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 3) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 5) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))))) (* {(if (is In (last To) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 1) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Tank" "Speeder" "Shooter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 2) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Launcher" "Antiair" "Artillery"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 3) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 4) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Submarine" "Cruiser" "Battleship"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 5) 0)))) 4))))) (if (and (= 8 (state at:(last From))) (!= (mover) (who at:(last From)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 6) 0)))) 5) (if (> (who at:(last From)) 0) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 8) 0)))) 4) (if True (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 10) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 9) 0))))) (value Random (range (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 11) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 12) 0))))))})) 128000)))) (set Value at:(last From) (value Piece at:(last From))))))))) (move Select (from (from) if:(and (> (state at:(from)) 0) (< (value Piece at:(from)) (mapEntry "MaxHealth" (what at:(from)))))) (to (sites Around (from) Orthogonal if:(is In (to) (sites Occupied by:Mover container:"Board" components:{"Town" "Dock" "Base" "Factory" "Airport"})))) (then (and {(set Value at:(last From) (min (mapEntry "MaxHealth" (what at:(last From))) (- (+ (value Piece at:(last From)) (value Piece at:(last To))) 1))) (set Value at:(last To) (max (- (value Piece at:(last To)) (- (mapEntry "MaxHealth" (what at:(last From))) (value Piece at:(last From)))) 1)) (set State at:(last From) 0)}))) (move Select (from (from) if:(> (state at:(from)) 0)) (to (sites Around (from) Orthogonal if:(and (= (what at:(from)) (what at:(to))) (< (value Piece at:(to)) (mapEntry "MaxHealth" (what at:(to))))))) (then (and {(if (<= (+ (value Piece at:(last To)) (value Piece at:(last From))) (mapEntry "MaxHealth" (what at:(last From)))) (and (set Value at:(last To) (min (mapEntry "MaxHealth" (what at:(last From))) (+ (value Piece at:(last From)) (value Piece at:(last To))))) (remove (last From))) (and (set Value at:(last To) (min (mapEntry "MaxHealth" (what at:(last From))) (- (+ (value Piece at:(last From)) (value Piece at:(last To))) 1))) (set Value at:(last From) (max (- (value Piece at:(last To)) (- (mapEntry "MaxHealth" (what at:(last From))) (value Piece at:(last From)))) 1)))) (set State at:(last From) 0) (set State at:(last To) 0)})))})) (piece "Fighter" Each (or {(move (from (from) if:(> (state at:(from)) 1)) (to (sites Distance (step Orthogonal (to if:(is In (to) (union (sites Empty) (sites Occupied by:Friend container:"Board"))))) from:(from) (range 1 (- (state at:(from)) 1))) if:(is Empty (to)) (apply (set State at:(from) 1)))) (move Select (from (from) if:(> (state at:(from)) 0)) (to (sites Distance Orthogonal from:(from) (range 1 1)) if:(and {(if (is In (from) (sites Occupied by:Mover container:"Board" components:{"Bomber" "Battleship" "Artillery" "Launcher"})) (is In (to) (union (sites Occupied by:Enemy container:"Board" components:{"Soldier" "Motorbike" "Tank" "Speeder" "Shooter" "Launcher" "Antiair" "Battleship" "Artillery" "Base" "Town" "Factory" "Dock" "Airport" "Cruiser" "Submarine"}) (sites Occupied by:Neutral container:"Board"))) (is In (to) (union (sites Occupied by:Enemy container:"Board") (sites Occupied by:Neutral container:"Board")))) (if (is In (from) (sites Occupied by:Mover container:"Board" components:{"Antiair" "Fighter"})) (is In (to) (sites Occupied by:Enemy container:"Board" components:{"Fighter" "Helicopter" "Bomber"})) (is In (to) (union (sites Occupied by:Enemy container:"Board") (sites Occupied by:Neutral container:"Board")))) (if (is In (from) (sites Occupied by:Mover container:"Board" components:{"Submarine"})) (is In (to) (sites Occupied by:Enemy container:"Board" components:{"Submarine" "Battleship" "Cruiser"})) (is In (to) (union (sites Occupied by:Enemy container:"Board") (sites Occupied by:Neutral container:"Board"))))})) (then (do (and (set Value at:(last To) (max 0 (- (value Piece at:(last To)) (/ (* (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (max (/ (* (* (value Piece at:(last From)) 4) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (if (and (is In (last To) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (is In (last From) (sites Occupied by:All component:"Shooter"))) (if (is In (last To) (sites "Forest")) (max (/ (* (* (value Piece at:(last From)) 6) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (if (is In (last To) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last From)) 10) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (max (/ (* (* (value Piece at:(last From)) 8) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1))) (if (is In (last To) (sites "Forest")) (max (/ (* (* (value Piece at:(last From)) 3) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (if (is In (last To) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last From)) 5) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (max (/ (* (* (value Piece at:(last From)) 4) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1))))) (* {(if (is In (last From) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 1) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 1) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 1) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 1) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Tank" "Speeder" "Shooter"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 2) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 2) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 2) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 2) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Launcher" "Antiair" "Artillery"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 3) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 3) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 3) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 3) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 4) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 4) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 4) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 4) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Submarine" "Cruiser" "Battleship"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 5) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 5) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 5) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 5) 0)))) 4))))) (if (and (= 8 (state at:(last To))) (!= (mover) (who at:(last To)))) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 6) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 6) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 6) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 6) 0)))) 5) (if (> (who at:(last To)) 0) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 8) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 8) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 8) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 8) 0)))) 4) (if False (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 10) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 10) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 10) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 10) 0)))) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 9) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 9) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 9) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 9) 0))))) (value Random (range (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 11) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 11) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 11) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 11) 0)))) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 12) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 12) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 12) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 12) 0))))))})) 128000)))) (set State at:(last From) 0)) next:(if (and (= 8 (state at:(last To))) (!= (mover) (who at:(last To)))) (if (= (value Piece at:(last To)) 0) (and {(take Control of:All by:Mover at:(last To)) (set Value at:(last To) 50)}) (set Value at:(last To) (value Piece at:(last To)))) (if (= (value Piece at:(last To)) 0) (remove (last To)) (if (and {(= 0 (count Sites in:(intersection (sites {(last To) (last From)}) (sites Occupied by:All components:{"Launcher" "Artillery" "Battleship" "Antiair"})))) (if (is In (last To) (sites Occupied by:Enemy components:{"Bomber" "Battleship" "Artillery" "Launcher"})) (is In (last From) (union (sites Occupied by:Mover components:{"Soldier" "Motorbike" "Tank" "Speeder" "Shooter" "Launcher" "Antiair" "Battleship" "Artillery" "Base" "Town" "Factory" "Dock" "Airport" "Cruiser" "Submarine"}) (sites Occupied by:Neutral container:"Board"))) (is In (last From) (union (sites Occupied by:Mover) (sites Occupied by:Neutral container:"Board")))) (if (is In (last To) (sites Occupied by:Enemy components:{"Antiair" "Fighter"})) (is In (last From) (sites Occupied by:Mover components:{"Fighter" "Helicopter" "Bomber"})) (is In (last From) (union (sites Occupied by:Mover) (sites Occupied by:Neutral container:"Board")))) (if (is In (last To) (sites Occupied by:Enemy components:{"Submarine"})) (is In (last From) (sites Occupied by:Mover components:{"Submarine" "Battleship" "Cruiser"})) (is In (last From) (union (sites Occupied by:Mover) (sites Occupied by:Neutral container:"Board"))))}) (if (<= (- (value Piece at:(last From)) (/ (* (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (and (is In (last From) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (is In (last To) (sites Occupied by:All component:"Shooter"))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 6) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 10) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 8) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 3) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 5) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))))) (* {(if (is In (last To) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 1) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Tank" "Speeder" "Shooter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 2) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Launcher" "Antiair" "Artillery"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 3) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 4) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Submarine" "Cruiser" "Battleship"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 5) 0)))) 4))))) (if (and (= 8 (state at:(last From))) (!= (mover) (who at:(last From)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 6) 0)))) 5) (if (> (who at:(last From)) 0) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 8) 0)))) 4) (if True (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 10) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 9) 0))))) (value Random (range (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 11) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 12) 0))))))})) 128000)) 0) (remove (last From)) (set Value at:(last From) (- (value Piece at:(last From)) (/ (* (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (and (is In (last From) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (is In (last To) (sites Occupied by:All component:"Shooter"))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 6) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 10) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 8) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 3) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 5) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))))) (* {(if (is In (last To) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 1) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Tank" "Speeder" "Shooter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 2) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Launcher" "Antiair" "Artillery"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 3) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 4) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Submarine" "Cruiser" "Battleship"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 5) 0)))) 4))))) (if (and (= 8 (state at:(last From))) (!= (mover) (who at:(last From)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 6) 0)))) 5) (if (> (who at:(last From)) 0) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 8) 0)))) 4) (if True (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 10) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 9) 0))))) (value Random (range (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 11) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 12) 0))))))})) 128000)))) (set Value at:(last From) (value Piece at:(last From))))))))) (move Select (from (from) if:(and (> (state at:(from)) 0) (< (value Piece at:(from)) (mapEntry "MaxHealth" (what at:(from)))))) (to (sites Around (from) Orthogonal if:(is In (to) (sites Occupied by:Mover container:"Board" components:{"Town" "Dock" "Base" "Factory" "Airport"})))) (then (and {(set Value at:(last From) (min (mapEntry "MaxHealth" (what at:(last From))) (- (+ (value Piece at:(last From)) (value Piece at:(last To))) 1))) (set Value at:(last To) (max (- (value Piece at:(last To)) (- (mapEntry "MaxHealth" (what at:(last From))) (value Piece at:(last From)))) 1)) (set State at:(last From) 0)}))) (move Select (from (from) if:(> (state at:(from)) 0)) (to (sites Around (from) Orthogonal if:(and (= (what at:(from)) (what at:(to))) (< (value Piece at:(to)) (mapEntry "MaxHealth" (what at:(to))))))) (then (and {(if (<= (+ (value Piece at:(last To)) (value Piece at:(last From))) (mapEntry "MaxHealth" (what at:(last From)))) (and (set Value at:(last To) (min (mapEntry "MaxHealth" (what at:(last From))) (+ (value Piece at:(last From)) (value Piece at:(last To))))) (remove (last From))) (and (set Value at:(last To) (min (mapEntry "MaxHealth" (what at:(last From))) (- (+ (value Piece at:(last From)) (value Piece at:(last To))) 1))) (set Value at:(last From) (max (- (value Piece at:(last To)) (- (mapEntry "MaxHealth" (what at:(last From))) (value Piece at:(last From)))) 1)))) (set State at:(last From) 0) (set State at:(last To) 0)})))})) (piece "Bomber" Each (or {(move (from (from) if:(> (state at:(from)) 1)) (to (sites Distance (step Orthogonal (to if:(is In (to) (union (sites Empty) (sites Occupied by:Friend container:"Board"))))) from:(from) (range 1 (- (state at:(from)) 1))) if:(is Empty (to)) (apply (set State at:(from) 1)))) (move Select (from (from) if:(> (state at:(from)) 0)) (to (sites Distance Orthogonal from:(from) (range 1 1)) if:(and {(if (is In (from) (sites Occupied by:Mover container:"Board" components:{"Bomber" "Battleship" "Artillery" "Launcher"})) (is In (to) (union (sites Occupied by:Enemy container:"Board" components:{"Soldier" "Motorbike" "Tank" "Speeder" "Shooter" "Launcher" "Antiair" "Battleship" "Artillery" "Base" "Town" "Factory" "Dock" "Airport" "Cruiser" "Submarine"}) (sites Occupied by:Neutral container:"Board"))) (is In (to) (union (sites Occupied by:Enemy container:"Board") (sites Occupied by:Neutral container:"Board")))) (if (is In (from) (sites Occupied by:Mover container:"Board" components:{"Antiair" "Fighter"})) (is In (to) (sites Occupied by:Enemy container:"Board" components:{"Fighter" "Helicopter" "Bomber"})) (is In (to) (union (sites Occupied by:Enemy container:"Board") (sites Occupied by:Neutral container:"Board")))) (if (is In (from) (sites Occupied by:Mover container:"Board" components:{"Submarine"})) (is In (to) (sites Occupied by:Enemy container:"Board" components:{"Submarine" "Battleship" "Cruiser"})) (is In (to) (union (sites Occupied by:Enemy container:"Board") (sites Occupied by:Neutral container:"Board"))))})) (then (do (and (set Value at:(last To) (max 0 (- (value Piece at:(last To)) (/ (* (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (max (/ (* (* (value Piece at:(last From)) 4) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (if (and (is In (last To) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (is In (last From) (sites Occupied by:All component:"Shooter"))) (if (is In (last To) (sites "Forest")) (max (/ (* (* (value Piece at:(last From)) 6) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (if (is In (last To) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last From)) 10) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (max (/ (* (* (value Piece at:(last From)) 8) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1))) (if (is In (last To) (sites "Forest")) (max (/ (* (* (value Piece at:(last From)) 3) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (if (is In (last To) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last From)) 5) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (max (/ (* (* (value Piece at:(last From)) 4) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1))))) (* {(if (is In (last From) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 1) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 1) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 1) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 1) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Tank" "Speeder" "Shooter"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 2) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 2) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 2) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 2) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Launcher" "Antiair" "Artillery"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 3) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 3) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 3) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 3) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 4) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 4) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 4) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 4) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Submarine" "Cruiser" "Battleship"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 5) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 5) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 5) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 5) 0)))) 4))))) (if (and (= 8 (state at:(last To))) (!= (mover) (who at:(last To)))) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 6) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 6) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 6) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 6) 0)))) 5) (if (> (who at:(last To)) 0) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 8) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 8) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 8) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 8) 0)))) 4) (if False (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 10) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 10) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 10) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 10) 0)))) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 9) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 9) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 9) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 9) 0))))) (value Random (range (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 11) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 11) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 11) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 11) 0)))) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 12) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 12) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 12) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 12) 0))))))})) 128000)))) (set State at:(last From) 0)) next:(if (and (= 8 (state at:(last To))) (!= (mover) (who at:(last To)))) (if (= (value Piece at:(last To)) 0) (and {(take Control of:All by:Mover at:(last To)) (set Value at:(last To) 50)}) (set Value at:(last To) (value Piece at:(last To)))) (if (= (value Piece at:(last To)) 0) (remove (last To)) (if (and {(= 0 (count Sites in:(intersection (sites {(last To) (last From)}) (sites Occupied by:All components:{"Launcher" "Artillery" "Battleship" "Antiair"})))) (if (is In (last To) (sites Occupied by:Enemy components:{"Bomber" "Battleship" "Artillery" "Launcher"})) (is In (last From) (union (sites Occupied by:Mover components:{"Soldier" "Motorbike" "Tank" "Speeder" "Shooter" "Launcher" "Antiair" "Battleship" "Artillery" "Base" "Town" "Factory" "Dock" "Airport" "Cruiser" "Submarine"}) (sites Occupied by:Neutral container:"Board"))) (is In (last From) (union (sites Occupied by:Mover) (sites Occupied by:Neutral container:"Board")))) (if (is In (last To) (sites Occupied by:Enemy components:{"Antiair" "Fighter"})) (is In (last From) (sites Occupied by:Mover components:{"Fighter" "Helicopter" "Bomber"})) (is In (last From) (union (sites Occupied by:Mover) (sites Occupied by:Neutral container:"Board")))) (if (is In (last To) (sites Occupied by:Enemy components:{"Submarine"})) (is In (last From) (sites Occupied by:Mover components:{"Submarine" "Battleship" "Cruiser"})) (is In (last From) (union (sites Occupied by:Mover) (sites Occupied by:Neutral container:"Board"))))}) (if (<= (- (value Piece at:(last From)) (/ (* (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (and (is In (last From) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (is In (last To) (sites Occupied by:All component:"Shooter"))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 6) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 10) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 8) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 3) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 5) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))))) (* {(if (is In (last To) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 1) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Tank" "Speeder" "Shooter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 2) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Launcher" "Antiair" "Artillery"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 3) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 4) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Submarine" "Cruiser" "Battleship"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 5) 0)))) 4))))) (if (and (= 8 (state at:(last From))) (!= (mover) (who at:(last From)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 6) 0)))) 5) (if (> (who at:(last From)) 0) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 8) 0)))) 4) (if True (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 10) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 9) 0))))) (value Random (range (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 11) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 12) 0))))))})) 128000)) 0) (remove (last From)) (set Value at:(last From) (- (value Piece at:(last From)) (/ (* (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (and (is In (last From) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (is In (last To) (sites Occupied by:All component:"Shooter"))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 6) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 10) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 8) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 3) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 5) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))))) (* {(if (is In (last To) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 1) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Tank" "Speeder" "Shooter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 2) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Launcher" "Antiair" "Artillery"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 3) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 4) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Submarine" "Cruiser" "Battleship"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 5) 0)))) 4))))) (if (and (= 8 (state at:(last From))) (!= (mover) (who at:(last From)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 6) 0)))) 5) (if (> (who at:(last From)) 0) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 8) 0)))) 4) (if True (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 10) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 9) 0))))) (value Random (range (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 11) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 12) 0))))))})) 128000)))) (set Value at:(last From) (value Piece at:(last From))))))))) (move Select (from (from) if:(and (> (state at:(from)) 0) (< (value Piece at:(from)) (mapEntry "MaxHealth" (what at:(from)))))) (to (sites Around (from) Orthogonal if:(is In (to) (sites Occupied by:Mover container:"Board" components:{"Town" "Dock" "Base" "Factory" "Airport"})))) (then (and {(set Value at:(last From) (min (mapEntry "MaxHealth" (what at:(last From))) (- (+ (value Piece at:(last From)) (value Piece at:(last To))) 1))) (set Value at:(last To) (max (- (value Piece at:(last To)) (- (mapEntry "MaxHealth" (what at:(last From))) (value Piece at:(last From)))) 1)) (set State at:(last From) 0)}))) (move Select (from (from) if:(> (state at:(from)) 0)) (to (sites Around (from) Orthogonal if:(and (= (what at:(from)) (what at:(to))) (< (value Piece at:(to)) (mapEntry "MaxHealth" (what at:(to))))))) (then (and {(if (<= (+ (value Piece at:(last To)) (value Piece at:(last From))) (mapEntry "MaxHealth" (what at:(last From)))) (and (set Value at:(last To) (min (mapEntry "MaxHealth" (what at:(last From))) (+ (value Piece at:(last From)) (value Piece at:(last To))))) (remove (last From))) (and (set Value at:(last To) (min (mapEntry "MaxHealth" (what at:(last From))) (- (+ (value Piece at:(last From)) (value Piece at:(last To))) 1))) (set Value at:(last From) (max (- (value Piece at:(last To)) (- (mapEntry "MaxHealth" (what at:(last From))) (value Piece at:(last From)))) 1)))) (set State at:(last From) 0) (set State at:(last To) 0)})))})) (piece "Cruiser" Each (or {(move (from (from) if:(> (state at:(from)) 1)) (to (sites Distance (step Orthogonal (to if:(is In (to) (difference (union (sites Empty) (sites Occupied by:Friend container:"Board")) (union (sites "Mountain") (difference (sites Board) (union (sites "ShallowWater") (sites "DeepWater")))))))) from:(from) (range 1 (- (state at:(from)) 1))) if:(is Empty (to)) (apply (set State at:(from) 1)))) (move Select (from (from) if:(> (state at:(from)) 0)) (to (sites Distance Orthogonal from:(from) (range 1 1)) if:(and {(if (is In (from) (sites Occupied by:Mover container:"Board" components:{"Bomber" "Battleship" "Artillery" "Launcher"})) (is In (to) (union (sites Occupied by:Enemy container:"Board" components:{"Soldier" "Motorbike" "Tank" "Speeder" "Shooter" "Launcher" "Antiair" "Battleship" "Artillery" "Base" "Town" "Factory" "Dock" "Airport" "Cruiser" "Submarine"}) (sites Occupied by:Neutral container:"Board"))) (is In (to) (union (sites Occupied by:Enemy container:"Board") (sites Occupied by:Neutral container:"Board")))) (if (is In (from) (sites Occupied by:Mover container:"Board" components:{"Antiair" "Fighter"})) (is In (to) (sites Occupied by:Enemy container:"Board" components:{"Fighter" "Helicopter" "Bomber"})) (is In (to) (union (sites Occupied by:Enemy container:"Board") (sites Occupied by:Neutral container:"Board")))) (if (is In (from) (sites Occupied by:Mover container:"Board" components:{"Submarine"})) (is In (to) (sites Occupied by:Enemy container:"Board" components:{"Submarine" "Battleship" "Cruiser"})) (is In (to) (union (sites Occupied by:Enemy container:"Board") (sites Occupied by:Neutral container:"Board"))))})) (then (do (and (set Value at:(last To) (max 0 (- (value Piece at:(last To)) (/ (* (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (max (/ (* (* (value Piece at:(last From)) 4) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (if (and (is In (last To) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (is In (last From) (sites Occupied by:All component:"Shooter"))) (if (is In (last To) (sites "Forest")) (max (/ (* (* (value Piece at:(last From)) 6) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (if (is In (last To) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last From)) 10) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (max (/ (* (* (value Piece at:(last From)) 8) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1))) (if (is In (last To) (sites "Forest")) (max (/ (* (* (value Piece at:(last From)) 3) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (if (is In (last To) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last From)) 5) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (max (/ (* (* (value Piece at:(last From)) 4) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1))))) (* {(if (is In (last From) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 1) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 1) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 1) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 1) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Tank" "Speeder" "Shooter"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 2) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 2) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 2) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 2) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Launcher" "Antiair" "Artillery"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 3) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 3) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 3) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 3) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 4) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 4) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 4) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 4) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Submarine" "Cruiser" "Battleship"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 5) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 5) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 5) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 5) 0)))) 4))))) (if (and (= 8 (state at:(last To))) (!= (mover) (who at:(last To)))) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 6) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 6) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 6) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 6) 0)))) 5) (if (> (who at:(last To)) 0) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 8) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 8) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 8) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 8) 0)))) 4) (if False (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 10) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 10) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 10) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 10) 0)))) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 9) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 9) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 9) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 9) 0))))) (value Random (range (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 11) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 11) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 11) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 11) 0)))) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 12) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 12) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 12) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 12) 0))))))})) 128000)))) (set State at:(last From) 0)) next:(if (and (= 8 (state at:(last To))) (!= (mover) (who at:(last To)))) (if (= (value Piece at:(last To)) 0) (and {(take Control of:All by:Mover at:(last To)) (set Value at:(last To) 50)}) (set Value at:(last To) (value Piece at:(last To)))) (if (= (value Piece at:(last To)) 0) (remove (last To)) (if (and {(= 0 (count Sites in:(intersection (sites {(last To) (last From)}) (sites Occupied by:All components:{"Launcher" "Artillery" "Battleship" "Antiair"})))) (if (is In (last To) (sites Occupied by:Enemy components:{"Bomber" "Battleship" "Artillery" "Launcher"})) (is In (last From) (union (sites Occupied by:Mover components:{"Soldier" "Motorbike" "Tank" "Speeder" "Shooter" "Launcher" "Antiair" "Battleship" "Artillery" "Base" "Town" "Factory" "Dock" "Airport" "Cruiser" "Submarine"}) (sites Occupied by:Neutral container:"Board"))) (is In (last From) (union (sites Occupied by:Mover) (sites Occupied by:Neutral container:"Board")))) (if (is In (last To) (sites Occupied by:Enemy components:{"Antiair" "Fighter"})) (is In (last From) (sites Occupied by:Mover components:{"Fighter" "Helicopter" "Bomber"})) (is In (last From) (union (sites Occupied by:Mover) (sites Occupied by:Neutral container:"Board")))) (if (is In (last To) (sites Occupied by:Enemy components:{"Submarine"})) (is In (last From) (sites Occupied by:Mover components:{"Submarine" "Battleship" "Cruiser"})) (is In (last From) (union (sites Occupied by:Mover) (sites Occupied by:Neutral container:"Board"))))}) (if (<= (- (value Piece at:(last From)) (/ (* (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (and (is In (last From) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (is In (last To) (sites Occupied by:All component:"Shooter"))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 6) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 10) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 8) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 3) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 5) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))))) (* {(if (is In (last To) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 1) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Tank" "Speeder" "Shooter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 2) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Launcher" "Antiair" "Artillery"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 3) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 4) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Submarine" "Cruiser" "Battleship"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 5) 0)))) 4))))) (if (and (= 8 (state at:(last From))) (!= (mover) (who at:(last From)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 6) 0)))) 5) (if (> (who at:(last From)) 0) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 8) 0)))) 4) (if True (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 10) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 9) 0))))) (value Random (range (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 11) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 12) 0))))))})) 128000)) 0) (remove (last From)) (set Value at:(last From) (- (value Piece at:(last From)) (/ (* (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (and (is In (last From) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (is In (last To) (sites Occupied by:All component:"Shooter"))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 6) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 10) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 8) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 3) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 5) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))))) (* {(if (is In (last To) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 1) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Tank" "Speeder" "Shooter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 2) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Launcher" "Antiair" "Artillery"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 3) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 4) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Submarine" "Cruiser" "Battleship"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 5) 0)))) 4))))) (if (and (= 8 (state at:(last From))) (!= (mover) (who at:(last From)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 6) 0)))) 5) (if (> (who at:(last From)) 0) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 8) 0)))) 4) (if True (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 10) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 9) 0))))) (value Random (range (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 11) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 12) 0))))))})) 128000)))) (set Value at:(last From) (value Piece at:(last From))))))))) (move Select (from (from) if:(and (> (state at:(from)) 0) (< (value Piece at:(from)) (mapEntry "MaxHealth" (what at:(from)))))) (to (sites Around (from) Orthogonal if:(is In (to) (sites Occupied by:Mover container:"Board" components:{"Town" "Dock" "Base" "Factory" "Airport"})))) (then (and {(set Value at:(last From) (min (mapEntry "MaxHealth" (what at:(last From))) (- (+ (value Piece at:(last From)) (value Piece at:(last To))) 1))) (set Value at:(last To) (max (- (value Piece at:(last To)) (- (mapEntry "MaxHealth" (what at:(last From))) (value Piece at:(last From)))) 1)) (set State at:(last From) 0)}))) (move Select (from (from) if:(> (state at:(from)) 0)) (to (sites Around (from) Orthogonal if:(and (= (what at:(from)) (what at:(to))) (< (value Piece at:(to)) (mapEntry "MaxHealth" (what at:(to))))))) (then (and {(if (<= (+ (value Piece at:(last To)) (value Piece at:(last From))) (mapEntry "MaxHealth" (what at:(last From)))) (and (set Value at:(last To) (min (mapEntry "MaxHealth" (what at:(last From))) (+ (value Piece at:(last From)) (value Piece at:(last To))))) (remove (last From))) (and (set Value at:(last To) (min (mapEntry "MaxHealth" (what at:(last From))) (- (+ (value Piece at:(last From)) (value Piece at:(last To))) 1))) (set Value at:(last From) (max (- (value Piece at:(last To)) (- (mapEntry "MaxHealth" (what at:(last From))) (value Piece at:(last From)))) 1)))) (set State at:(last From) 0) (set State at:(last To) 0)})))})) (piece "Submarine" Each (or {(move (from (from) if:(> (state at:(from)) 1)) (to (sites Distance (step Orthogonal (to if:(is In (to) (difference (union (sites Empty) (sites Occupied by:Friend container:"Board")) (union (sites "Mountain") (difference (sites Board) (union (sites "ShallowWater") (sites "DeepWater")))))))) from:(from) (range 1 (- (state at:(from)) 1))) if:(is Empty (to)) (apply (set State at:(from) 1)))) (move Select (from (from) if:(> (state at:(from)) 0)) (to (sites Distance Orthogonal from:(from) (range 1 1)) if:(and {(if (is In (from) (sites Occupied by:Mover container:"Board" components:{"Bomber" "Battleship" "Artillery" "Launcher"})) (is In (to) (union (sites Occupied by:Enemy container:"Board" components:{"Soldier" "Motorbike" "Tank" "Speeder" "Shooter" "Launcher" "Antiair" "Battleship" "Artillery" "Base" "Town" "Factory" "Dock" "Airport" "Cruiser" "Submarine"}) (sites Occupied by:Neutral container:"Board"))) (is In (to) (union (sites Occupied by:Enemy container:"Board") (sites Occupied by:Neutral container:"Board")))) (if (is In (from) (sites Occupied by:Mover container:"Board" components:{"Antiair" "Fighter"})) (is In (to) (sites Occupied by:Enemy container:"Board" components:{"Fighter" "Helicopter" "Bomber"})) (is In (to) (union (sites Occupied by:Enemy container:"Board") (sites Occupied by:Neutral container:"Board")))) (if (is In (from) (sites Occupied by:Mover container:"Board" components:{"Submarine"})) (is In (to) (sites Occupied by:Enemy container:"Board" components:{"Submarine" "Battleship" "Cruiser"})) (is In (to) (union (sites Occupied by:Enemy container:"Board") (sites Occupied by:Neutral container:"Board"))))})) (then (do (and (set Value at:(last To) (max 0 (- (value Piece at:(last To)) (/ (* (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (max (/ (* (* (value Piece at:(last From)) 4) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (if (and (is In (last To) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (is In (last From) (sites Occupied by:All component:"Shooter"))) (if (is In (last To) (sites "Forest")) (max (/ (* (* (value Piece at:(last From)) 6) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (if (is In (last To) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last From)) 10) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (max (/ (* (* (value Piece at:(last From)) 8) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1))) (if (is In (last To) (sites "Forest")) (max (/ (* (* (value Piece at:(last From)) 3) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (if (is In (last To) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last From)) 5) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (max (/ (* (* (value Piece at:(last From)) 4) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1))))) (* {(if (is In (last From) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 1) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 1) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 1) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 1) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Tank" "Speeder" "Shooter"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 2) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 2) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 2) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 2) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Launcher" "Antiair" "Artillery"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 3) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 3) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 3) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 3) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 4) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 4) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 4) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 4) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Submarine" "Cruiser" "Battleship"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 5) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 5) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 5) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 5) 0)))) 4))))) (if (and (= 8 (state at:(last To))) (!= (mover) (who at:(last To)))) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 6) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 6) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 6) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 6) 0)))) 5) (if (> (who at:(last To)) 0) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 8) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 8) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 8) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 8) 0)))) 4) (if False (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 10) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 10) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 10) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 10) 0)))) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 9) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 9) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 9) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 9) 0))))) (value Random (range (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 11) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 11) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 11) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 11) 0)))) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 12) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 12) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 12) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 12) 0))))))})) 128000)))) (set State at:(last From) 0)) next:(if (and (= 8 (state at:(last To))) (!= (mover) (who at:(last To)))) (if (= (value Piece at:(last To)) 0) (and {(take Control of:All by:Mover at:(last To)) (set Value at:(last To) 50)}) (set Value at:(last To) (value Piece at:(last To)))) (if (= (value Piece at:(last To)) 0) (remove (last To)) (if (and {(= 0 (count Sites in:(intersection (sites {(last To) (last From)}) (sites Occupied by:All components:{"Launcher" "Artillery" "Battleship" "Antiair"})))) (if (is In (last To) (sites Occupied by:Enemy components:{"Bomber" "Battleship" "Artillery" "Launcher"})) (is In (last From) (union (sites Occupied by:Mover components:{"Soldier" "Motorbike" "Tank" "Speeder" "Shooter" "Launcher" "Antiair" "Battleship" "Artillery" "Base" "Town" "Factory" "Dock" "Airport" "Cruiser" "Submarine"}) (sites Occupied by:Neutral container:"Board"))) (is In (last From) (union (sites Occupied by:Mover) (sites Occupied by:Neutral container:"Board")))) (if (is In (last To) (sites Occupied by:Enemy components:{"Antiair" "Fighter"})) (is In (last From) (sites Occupied by:Mover components:{"Fighter" "Helicopter" "Bomber"})) (is In (last From) (union (sites Occupied by:Mover) (sites Occupied by:Neutral container:"Board")))) (if (is In (last To) (sites Occupied by:Enemy components:{"Submarine"})) (is In (last From) (sites Occupied by:Mover components:{"Submarine" "Battleship" "Cruiser"})) (is In (last From) (union (sites Occupied by:Mover) (sites Occupied by:Neutral container:"Board"))))}) (if (<= (- (value Piece at:(last From)) (/ (* (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (and (is In (last From) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (is In (last To) (sites Occupied by:All component:"Shooter"))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 6) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 10) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 8) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 3) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 5) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))))) (* {(if (is In (last To) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 1) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Tank" "Speeder" "Shooter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 2) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Launcher" "Antiair" "Artillery"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 3) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 4) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Submarine" "Cruiser" "Battleship"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 5) 0)))) 4))))) (if (and (= 8 (state at:(last From))) (!= (mover) (who at:(last From)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 6) 0)))) 5) (if (> (who at:(last From)) 0) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 8) 0)))) 4) (if True (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 10) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 9) 0))))) (value Random (range (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 11) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 12) 0))))))})) 128000)) 0) (remove (last From)) (set Value at:(last From) (- (value Piece at:(last From)) (/ (* (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (and (is In (last From) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (is In (last To) (sites Occupied by:All component:"Shooter"))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 6) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 10) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 8) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 3) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 5) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))))) (* {(if (is In (last To) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 1) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Tank" "Speeder" "Shooter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 2) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Launcher" "Antiair" "Artillery"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 3) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 4) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Submarine" "Cruiser" "Battleship"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 5) 0)))) 4))))) (if (and (= 8 (state at:(last From))) (!= (mover) (who at:(last From)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 6) 0)))) 5) (if (> (who at:(last From)) 0) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 8) 0)))) 4) (if True (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 10) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 9) 0))))) (value Random (range (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 11) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 12) 0))))))})) 128000)))) (set Value at:(last From) (value Piece at:(last From))))))))) (move Select (from (from) if:(and (> (state at:(from)) 0) (< (value Piece at:(from)) (mapEntry "MaxHealth" (what at:(from)))))) (to (sites Around (from) Orthogonal if:(is In (to) (sites Occupied by:Mover container:"Board" components:{"Town" "Dock" "Base" "Factory" "Airport"})))) (then (and {(set Value at:(last From) (min (mapEntry "MaxHealth" (what at:(last From))) (- (+ (value Piece at:(last From)) (value Piece at:(last To))) 1))) (set Value at:(last To) (max (- (value Piece at:(last To)) (- (mapEntry "MaxHealth" (what at:(last From))) (value Piece at:(last From)))) 1)) (set State at:(last From) 0)}))) (move Select (from (from) if:(> (state at:(from)) 0)) (to (sites Around (from) Orthogonal if:(and (= (what at:(from)) (what at:(to))) (< (value Piece at:(to)) (mapEntry "MaxHealth" (what at:(to))))))) (then (and {(if (<= (+ (value Piece at:(last To)) (value Piece at:(last From))) (mapEntry "MaxHealth" (what at:(last From)))) (and (set Value at:(last To) (min (mapEntry "MaxHealth" (what at:(last From))) (+ (value Piece at:(last From)) (value Piece at:(last To))))) (remove (last From))) (and (set Value at:(last To) (min (mapEntry "MaxHealth" (what at:(last From))) (- (+ (value Piece at:(last From)) (value Piece at:(last To))) 1))) (set Value at:(last From) (max (- (value Piece at:(last To)) (- (mapEntry "MaxHealth" (what at:(last From))) (value Piece at:(last From)))) 1)))) (set State at:(last From) 0) (set State at:(last To) 0)})))})) (piece "Battleship" Each (or {(move (from (from) if:(> (state at:(from)) 1)) (to (sites Distance (step Orthogonal (to if:(is In (to) (difference (union (sites Empty) (sites Occupied by:Friend container:"Board")) (union (sites "Mountain") (difference (sites Board) (union (sites "ShallowWater") (sites "DeepWater")))))))) from:(from) (range 1 (- (state at:(from)) 1))) if:(is Empty (to)) (apply (set State at:(from) 1)))) (move Select (from (from) if:(> (state at:(from)) 0)) (to (sites Distance Orthogonal from:(from) (range 2 4)) if:(and {(if (is In (from) (sites Occupied by:Mover container:"Board" components:{"Bomber" "Battleship" "Artillery" "Launcher"})) (is In (to) (union (sites Occupied by:Enemy container:"Board" components:{"Soldier" "Motorbike" "Tank" "Speeder" "Shooter" "Launcher" "Antiair" "Battleship" "Artillery" "Base" "Town" "Factory" "Dock" "Airport" "Cruiser" "Submarine"}) (sites Occupied by:Neutral container:"Board"))) (is In (to) (union (sites Occupied by:Enemy container:"Board") (sites Occupied by:Neutral container:"Board")))) (if (is In (from) (sites Occupied by:Mover container:"Board" components:{"Antiair" "Fighter"})) (is In (to) (sites Occupied by:Enemy container:"Board" components:{"Fighter" "Helicopter" "Bomber"})) (is In (to) (union (sites Occupied by:Enemy container:"Board") (sites Occupied by:Neutral container:"Board")))) (if (is In (from) (sites Occupied by:Mover container:"Board" components:{"Submarine"})) (is In (to) (sites Occupied by:Enemy container:"Board" components:{"Submarine" "Battleship" "Cruiser"})) (is In (to) (union (sites Occupied by:Enemy container:"Board") (sites Occupied by:Neutral container:"Board"))))})) (then (do (and (set Value at:(last To) (max 0 (- (value Piece at:(last To)) (/ (* (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (max (/ (* (* (value Piece at:(last From)) 4) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (if (and (is In (last To) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (is In (last From) (sites Occupied by:All component:"Shooter"))) (if (is In (last To) (sites "Forest")) (max (/ (* (* (value Piece at:(last From)) 6) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (if (is In (last To) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last From)) 10) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (max (/ (* (* (value Piece at:(last From)) 8) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1))) (if (is In (last To) (sites "Forest")) (max (/ (* (* (value Piece at:(last From)) 3) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (if (is In (last To) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last From)) 5) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1) (max (/ (* (* (value Piece at:(last From)) 4) (mapEntry "DamageMultiplier" (what at:(last From)))) 100) 1))))) (* {(if (is In (last From) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 1) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 1) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 1) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 1) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Tank" "Speeder" "Shooter"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 2) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 2) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 2) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 2) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Launcher" "Antiair" "Artillery"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 3) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 3) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 3) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 3) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 4) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 4) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 4) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 4) 0)))) (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Submarine" "Cruiser" "Battleship"})) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 5) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 5) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 5) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 5) 0)))) 4))))) (if (and (= 8 (state at:(last To))) (!= (mover) (who at:(last To)))) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 6) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 6) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 6) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 6) 0)))) 5) (if (> (who at:(last To)) 0) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 8) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 8) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 8) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 8) 0)))) 4) (if False (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 10) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 10) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 10) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 10) 0)))) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 9) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 9) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 9) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 9) 0))))) (value Random (range (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 11) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 11) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 11) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 11) 0)))) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 12) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 12) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 12) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 12) 0))))))})) 128000)))) (set State at:(last From) 0)) next:(if (and (= 8 (state at:(last To))) (!= (mover) (who at:(last To)))) (if (= (value Piece at:(last To)) 0) (and {(take Control of:All by:Mover at:(last To)) (set Value at:(last To) 50)}) (set Value at:(last To) (value Piece at:(last To)))) (if (= (value Piece at:(last To)) 0) (remove (last To)) (if (and {(= 0 (count Sites in:(intersection (sites {(last To) (last From)}) (sites Occupied by:All components:{"Launcher" "Artillery" "Battleship" "Antiair"})))) (if (is In (last To) (sites Occupied by:Enemy components:{"Bomber" "Battleship" "Artillery" "Launcher"})) (is In (last From) (union (sites Occupied by:Mover components:{"Soldier" "Motorbike" "Tank" "Speeder" "Shooter" "Launcher" "Antiair" "Battleship" "Artillery" "Base" "Town" "Factory" "Dock" "Airport" "Cruiser" "Submarine"}) (sites Occupied by:Neutral container:"Board"))) (is In (last From) (union (sites Occupied by:Mover) (sites Occupied by:Neutral container:"Board")))) (if (is In (last To) (sites Occupied by:Enemy components:{"Antiair" "Fighter"})) (is In (last From) (sites Occupied by:Mover components:{"Fighter" "Helicopter" "Bomber"})) (is In (last From) (union (sites Occupied by:Mover) (sites Occupied by:Neutral container:"Board")))) (if (is In (last To) (sites Occupied by:Enemy components:{"Submarine"})) (is In (last From) (sites Occupied by:Mover components:{"Submarine" "Battleship" "Cruiser"})) (is In (last From) (union (sites Occupied by:Mover) (sites Occupied by:Neutral container:"Board"))))}) (if (<= (- (value Piece at:(last From)) (/ (* (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (and (is In (last From) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (is In (last To) (sites Occupied by:All component:"Shooter"))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 6) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 10) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 8) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 3) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 5) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))))) (* {(if (is In (last To) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 1) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Tank" "Speeder" "Shooter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 2) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Launcher" "Antiair" "Artillery"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 3) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 4) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Submarine" "Cruiser" "Battleship"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 5) 0)))) 4))))) (if (and (= 8 (state at:(last From))) (!= (mover) (who at:(last From)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 6) 0)))) 5) (if (> (who at:(last From)) 0) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 8) 0)))) 4) (if True (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 10) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 9) 0))))) (value Random (range (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 11) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 12) 0))))))})) 128000)) 0) (remove (last From)) (set Value at:(last From) (- (value Piece at:(last From)) (/ (* (if (is In (last From) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (and (is In (last From) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (is In (last To) (sites Occupied by:All component:"Shooter"))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 6) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 10) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 8) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))) (if (is In (last From) (sites "Forest")) (max (/ (* (* (value Piece at:(last To)) 3) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (if (is In (last From) (union (sites "ShallowWater") (sites "DeepWater"))) (max (/ (* (* (value Piece at:(last To)) 5) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1) (max (/ (* (* (value Piece at:(last To)) 4) (mapEntry "DamageMultiplier" (what at:(last To)))) 100) 1))))) (* {(if (is In (last To) (sites Occupied by:All container:"Board" components:{"Soldier" "Motorbike"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 1) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 1) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Tank" "Speeder" "Shooter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 2) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 2) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Launcher" "Antiair" "Artillery"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 3) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 3) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Fighter" "Bomber" "Helicopter"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 4) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 4) 0)))) (if (is In (last To) (sites Occupied by:All container:"Board" components:{"Submarine" "Cruiser" "Battleship"})) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 5) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 5) 0)))) 4))))) (if (and (= 8 (state at:(last From))) (!= (mover) (who at:(last From)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 6) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 6) 0)))) 5) (if (> (who at:(last From)) 0) (if (= (who at:(last From)) 1) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 2) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 3) (mapEntry "NoDoctrine" 8) (if (= (who at:(last From)) 4) (mapEntry "NoDoctrine" 8) 0)))) 4) (if True (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 10) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 10) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 9) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 9) 0))))) (value Random (range (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 11) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 11) 0)))) (if (= (who at:(last To)) 1) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 2) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 3) (mapEntry "NoDoctrine" 12) (if (= (who at:(last To)) 4) (mapEntry "NoDoctrine" 12) 0))))))})) 128000)))) (set Value at:(last From) (value Piece at:(last From))))))))) (move Select (from (from) if:(and (> (state at:(from)) 0) (< (value Piece at:(from)) (mapEntry "MaxHealth" (what at:(from)))))) (to (sites Around (from) Orthogonal if:(is In (to) (sites Occupied by:Mover container:"Board" components:{"Town" "Dock" "Base" "Factory" "Airport"})))) (then (and {(set Value at:(last From) (min (mapEntry "MaxHealth" (what at:(last From))) (- (+ (value Piece at:(last From)) (value Piece at:(last To))) 1))) (set Value at:(last To) (max (- (value Piece at:(last To)) (- (mapEntry "MaxHealth" (what at:(last From))) (value Piece at:(last From)))) 1)) (set State at:(last From) 0)}))) (move Select (from (from) if:(> (state at:(from)) 0)) (to (sites Around (from) Orthogonal if:(and (= (what at:(from)) (what at:(to))) (< (value Piece at:(to)) (mapEntry "MaxHealth" (what at:(to))))))) (then (and {(if (<= (+ (value Piece at:(last To)) (value Piece at:(last From))) (mapEntry "MaxHealth" (what at:(last From)))) (and (set Value at:(last To) (min (mapEntry "MaxHealth" (what at:(last From))) (+ (value Piece at:(last From)) (value Piece at:(last To))))) (remove (last From))) (and (set Value at:(last To) (min (mapEntry "MaxHealth" (what at:(last From))) (- (+ (value Piece at:(last From)) (value Piece at:(last To))) 1))) (set Value at:(last From) (max (- (value Piece at:(last To)) (- (mapEntry "MaxHealth" (what at:(last From))) (value Piece at:(last From)))) 1)))) (set State at:(last From) 0) (set State at:(last To) 0)})))})) (piece "Base" Neutral) (piece "Factory" Neutral) (piece "Town" Neutral) (piece "Airport" Neutral) (piece "Dock" Neutral) (piece "Soldier" Neutral) (piece "Motorbike" Neutral) (piece "Speeder" Neutral) (piece "Shooter" Neutral) (piece "Tank" Neutral) (piece "Antiair" Neutral) (piece "Launcher" Neutral) (piece "Artillery" Neutral) (piece "Helicopter" Neutral) (piece "Fighter" Neutral) (piece "Bomber" Neutral) (piece "Cruiser" Neutral) (piece "Submarine" Neutral) (piece "Battleship" Neutral) (map "Movement" {(pair 1 8) (pair 2 8) (pair 3 8) (pair 4 8) (pair 5 8) (pair 6 8) (pair 7 8) (pair 8 8) (pair 9 8) (pair 10 8) (pair 11 4) (pair 12 4) (pair 13 6) (pair 14 6) (pair 15 7) (pair 16 7) (pair 17 5) (pair 18 5) (pair 19 5) (pair 20 5) (pair 21 5) (pair 22 5) (pair 23 4) (pair 24 4) (pair 25 4) (pair 26 4) (pair 27 5) (pair 28 5) (pair 29 7) (pair 30 7) (pair 31 6) (pair 32 6) (pair 33 6) (pair 34 6) (pair 35 6) (pair 36 6) (pair 37 5) (pair 38 5) (pair 39 8) (pair 40 8) (pair 41 8) (pair 42 8) (pair 43 8)}) (map "MaxHealth" {(pair 1 100) (pair 2 100) (pair 3 100) (pair 4 100) (pair 5 100) (pair 6 100) (pair 7 100) (pair 8 100) (pair 9 100) (pair 10 100) (pair 11 30) (pair 12 30) (pair 13 40) (pair 14 40) (pair 15 60) (pair 16 60) (pair 17 60) (pair 18 60) (pair 19 80) (pair 20 80) (pair 21 50) (pair 22 50) (pair 23 50) (pair 24 50) (pair 25 40) (pair 26 40) (pair 27 40) (pair 28 40) (pair 29 100) (pair 30 100) (pair 31 100) (pair 32 100) (pair 33 70) (pair 34 70) (pair 35 100) (pair 36 100) (pair 37 120) (pair 38 120) (pair 39 100) (pair 40 100) (pair 41 100) (pair 42 100) (pair 43 100)}) (map "DamageMultiplier" {(pair 1 0) (pair 2 0) (pair 3 0) (pair 4 0) (pair 5 0) (pair 6 0) (pair 7 0) (pair 8 0) (pair 9 0) (pair 10 0) (pair 11 50) (pair 12 50) (pair 13 50) (pair 14 50) (pair 15 40) (pair 16 40) (pair 17 40) (pair 18 40) (pair 19 50) (pair 20 50) (pair 21 100) (pair 22 100) (pair 23 50) (pair 24 50) (pair 25 100) (pair 26 100) (pair 27 70) (pair 28 70) (pair 29 100) (pair 30 100) (pair 31 80) (pair 32 80) (pair 33 50) (pair 34 50) (pair 35 80) (pair 36 80) (pair 37 50) (pair 38 50) (pair 39 0) (pair 40 0) (pair 41 0) (pair 42 0) (pair 43 0)}) (map "NoDoctrine" {(pair 1 4) (pair 2 4) (pair 3 4) (pair 4 4) (pair 5 4) (pair 6 5) (pair 7 4) (pair 8 4) (pair 9 4) (pair 10 4) (pair 11 100) (pair 12 100)}) (map "SpecialForces" {(pair 1 6) (pair 2 3) (pair 3 3) (pair 4 3) (pair 5 3) (pair 6 5) (pair 7 4) (pair 8 4) (pair 9 4) (pair 10 4) (pair 11 100) (pair 12 100)}) (map "BruteStrength" {(pair 1 3) (pair 2 6) (pair 3 3) (pair 4 3) (pair 5 3) (pair 6 5) (pair 7 4) (pair 8 4) (pair 9 4) (pair 10 4) (pair 11 100) (pair 12 100)}) (map "Sharpshooter" {(pair 1 3) (pair 2 3) (pair 3 6) (pair 4 3) (pair 5 3) (pair 6 5) (pair 7 4) (pair 8 4) (pair 9 4) (pair 10 4) (pair 11 100) (pair 12 100)}) (map "AcePilot" {(pair 1 3) (pair 2 3) (pair 3 3) (pair 4 6) (pair 5 3) (pair 6 5) (pair 7 4) (pair 8 4) (pair 9 4) (pair 10 4) (pair 11 100) (pair 12 100)}) (map "SeaDog" {(pair 1 3) (pair 2 3) (pair 3 3) (pair 4 3) (pair 5 6) (pair 6 5) (pair 7 4) (pair 8 4) (pair 9 4) (pair 10 4) (pair 11 100) (pair 12 100)}) (map "GuerrillaWarfare" {(pair 1 3) (pair 2 3) (pair 3 3) (pair 4 3) (pair 5 3) (pair 6 10) (pair 7 4) (pair 8 4) (pair 9 4) (pair 10 4) (pair 11 100) (pair 12 100)}) (map "ForeignInvader" {(pair 1 5) (pair 2 5) (pair 3 5) (pair 4 5) (pair 5 5) (pair 6 2) (pair 7 4) (pair 8 4) (pair 9 4) (pair 10 4) (pair 11 100) (pair 12 100)}) (map "Conscription" {(pair 1 2) (pair 2 2) (pair 3 2) (pair 4 2) (pair 5 2) (pair 6 5) (pair 7 2) (pair 8 4) (pair 9 4) (pair 10 4) (pair 11 100) (pair 12 100)}) (map "EliteTraining" {(pair 1 6) (pair 2 6) (pair 3 6) (pair 4 6) (pair 5 6) (pair 6 5) (pair 7 6) (pair 8 4) (pair 9 4) (pair 10 4) (pair 11 100) (pair 12 100)}) (map "GlassCannon" {(pair 1 6) (pair 2 6) (pair 3 6) (pair 4 6) (pair 5 6) (pair 6 5) (pair 7 4) (pair 8 6) (pair 9 4) (pair 10 4) (pair 11 100) (pair 12 100)}) (map "HardenedResolve" {(pair 1 2) (pair 2 2) (pair 3 2) (pair 4 2) (pair 5 2) (pair 6 5) (pair 7 4) (pair 8 2) (pair 9 4) (pair 10 4) (pair 11 100) (pair 12 100)}) (map "PreemptiveStrike" {(pair 1 4) (pair 2 4) (pair 3 4) (pair 4 4) (pair 5 4) (pair 6 5) (pair 7 4) (pair 8 4) (pair 9 6) (pair 10 0) (pair 11 100) (pair 12 100)}) (map "Retaliation" {(pair 1 4) (pair 2 4) (pair 3 4) (pair 4 4) (pair 5 4) (pair 6 5) (pair 7 4) (pair 8 4) (pair 9 2) (pair 10 8) (pair 11 100) (pair 12 100)}) (map "LadyLuck" {(pair 1 4) (pair 2 4) (pair 3 4) (pair 4 4) (pair 5 4) (pair 6 5) (pair 7 4) (pair 8 4) (pair 9 4) (pair 10 4) (pair 11 50) (pair 12 150)})}) (rules (meta (passEnd NoEnd)) (start {(place "Base1" (sites {"C7"}) state:8 value:100) (place "Base2" (sites {"G3"}) state:8 value:100) (place "Airport0" (sites {"H8"}) state:8 value:100) (place "Dock0" (sites {"C2"}) state:8 value:100) (place "Town2" (sites {"I5" "I6"}) state:8 value:100) (place "Town1" (sites {"E9" "F9"}) state:8 value:100) (place "Factory0" (sites {"C5" "F4"}) state:8 value:100) (set Team 1 {P1}) (set Team 2 {P2}) (set Score Each 100) (place "Soldier0" (handSite Shared 0) count:30 state:1 value:30) (place "Motorbike0" (handSite Shared 1) count:50 state:1 value:40) (place "Speeder0" (handSite Shared 2) count:60 state:1 value:60) (place "Shooter0" (handSite Shared 3) count:80 state:1 value:60) (place "Tank0" (handSite Shared 4) count:100 state:1 value:80) (place "Antiair0" (handSite Shared 5) count:80 state:1 value:50) (place "Launcher0" (handSite Shared 6) count:80 state:1 value:50) (place "Artillery0" (handSite Shared 7) count:100 state:1 value:40) (place "Helicopter0" (handSite Shared 8) count:60 state:1 value:40) (place "Fighter0" (handSite Shared 9) count:100 state:1 value:100) (place "Bomber0" (handSite Shared 10) count:120 state:1 value:100) (place "Cruiser0" (handSite Shared 11) count:60 state:1 value:70) (place "Submarine0" (handSite Shared 12) count:100 state:1 value:100) (place "Battleship0" (handSite Shared 13) count:120 state:1 value:120)}) (play (or (or {(forEach Piece) (forEach Site (sites Occupied by:Neutral container:1 components:{"Soldier" "Motorbike"}) (move (from (site)) (to (difference (sites Around (sites Occupied by:Mover component:"Town") Orthogonal) (sites "DeepWater")) if:(and (is Empty (to)) (<= (/ (* (count at:(site)) (if (= (mover) 1) (mapEntry "NoDoctrine" 7) (if (= (mover) 2) (mapEntry "NoDoctrine" 7) (if (= (mover) 3) (mapEntry "NoDoctrine" 7) (if (= (mover) 4) (mapEntry "NoDoctrine" 7) 0))))) 4) (score Mover)))) copy:True (then (and {(addScore Mover (- (/ (* (count at:(last From)) (if (= (mover) 1) (mapEntry "NoDoctrine" 7) (if (= (mover) 2) (mapEntry "NoDoctrine" 7) (if (= (mover) 3) (mapEntry "NoDoctrine" 7) (if (= (mover) 4) (mapEntry "NoDoctrine" 7) 0))))) 4))) (take Control of:All by:Mover at:(last To)) (set State at:(last To) 0)})))) (forEach Site (sites Occupied by:Neutral container:1 components:{"Cruiser" "Submarine" "Battleship"}) (move (from (site)) (to (difference (sites Around (sites Occupied by:Mover component:"Dock") Orthogonal) (union (sites "Mountain") (difference (sites Board) (union (sites "ShallowWater") (sites "DeepWater"))))) if:(and (is Empty (to)) (<= (/ (* (count at:(site)) (if (= (mover) 1) (mapEntry "NoDoctrine" 7) (if (= (mover) 2) (mapEntry "NoDoctrine" 7) (if (= (mover) 3) (mapEntry "NoDoctrine" 7) (if (= (mover) 4) (mapEntry "NoDoctrine" 7) 0))))) 4) (score Mover)))) copy:True (then (and {(addScore Mover (- (/ (* (count at:(last From)) (if (= (mover) 1) (mapEntry "NoDoctrine" 7) (if (= (mover) 2) (mapEntry "NoDoctrine" 7) (if (= (mover) 3) (mapEntry "NoDoctrine" 7) (if (= (mover) 4) (mapEntry "NoDoctrine" 7) 0))))) 4))) (take Control of:All by:Mover at:(last To)) (set State at:(last To) 0)})))) (forEach Site (sites Occupied by:Neutral container:1 components:{"Helicopter" "Fighter" "Bomber"}) (move (from (site)) (to (sites Around (sites Occupied by:Mover component:"Airport") Orthogonal) if:(and (is Empty (to)) (<= (/ (* (count at:(site)) (if (= (mover) 1) (mapEntry "NoDoctrine" 7) (if (= (mover) 2) (mapEntry "NoDoctrine" 7) (if (= (mover) 3) (mapEntry "NoDoctrine" 7) (if (= (mover) 4) (mapEntry "NoDoctrine" 7) 0))))) 4) (score Mover)))) copy:True (then (and {(addScore Mover (- (/ (* (count at:(last From)) (if (= (mover) 1) (mapEntry "NoDoctrine" 7) (if (= (mover) 2) (mapEntry "NoDoctrine" 7) (if (= (mover) 3) (mapEntry "NoDoctrine" 7) (if (= (mover) 4) (mapEntry "NoDoctrine" 7) 0))))) 4))) (take Control of:All by:Mover at:(last To)) (set State at:(last To) 0)})))) (forEach Site (sites Occupied by:Neutral container:1 components:{"Speeder" "Shooter" "Tank" "Antiair" "Launcher" "Artillery"}) (move (from (site)) (to (difference (sites Around (sites Occupied by:Mover component:"Factory") Orthogonal) (union (sites "Mountain") (sites "DeepWater"))) if:(and (is Empty (to)) (<= (/ (* (count at:(site)) (if (= (mover) 1) (mapEntry "NoDoctrine" 7) (if (= (mover) 2) (mapEntry "NoDoctrine" 7) (if (= (mover) 3) (mapEntry "NoDoctrine" 7) (if (= (mover) 4) (mapEntry "NoDoctrine" 7) 0))))) 4) (score Mover)))) copy:True (then (and {(addScore Mover (- (/ (* (count at:(last From)) (if (= (mover) 1) (mapEntry "NoDoctrine" 7) (if (= (mover) 2) (mapEntry "NoDoctrine" 7) (if (= (mover) 3) (mapEntry "NoDoctrine" 7) (if (= (mover) 4) (mapEntry "NoDoctrine" 7) 0))))) 4))) (take Control of:All by:Mover at:(last To)) (set State at:(last To) 0)}))))} (then (and {(forEach Player (if (and {(is Active Player) (> (count Active) 2) (= (where "Base" Player) -1)}) (forEach Site (sites Occupied by:Player) (if (is In (site) (sites Occupied by:Player components:{"Town" "Base" "Factory" "Dock" "Airport"})) (take Control of:All by:Neutral at:(site)) (remove (site)))))) (moveAgain) (and {})}))) (move Pass (then (and {(forEach Site (sites Occupied by:Mover container:"Board") (set State at:(site) (mapEntry "Movement" (what at:(site))))) (set Score Mover (+ {(* (count Sites in:(sites Occupied by:Mover component:"Base")) 20) (* (count Sites in:(sites Occupied by:Mover component:"Town")) 10) (score Mover)})) (forEach Site (sites Occupied by:Mover components:{"Town" "Base" "Factory" "Dock" "Airport"}) (set Value at:(site) (min (mapEntry "MaxHealth" (what at:(site))) (+ (value Piece at:(site)) 10)))) (and {})}))))) (end (forEach NonMover if:(= (where "Base" Player) -1) (result Player Loss))))) 
The two players take turns moving stacks of their own color (including singletons - stacks of height one), one stack per turn. Players will always have a move available and must make one. OBJECT OF THE GAME: Kill the enemy queen, or deprive your opponent of moves. The pie rule is used in Monkey Queen. Each player will always have exactly one queen monkey on the board which is a stack of two or more checkers all of the player's own color. Additionally, each player may have one or more baby monkeys on the board which are singletons of his own color. CAPTURING QUEEN MOVES - A monkey queen captures exactly like a Chess queen. Slide the entire stack in any direction (horizontally, vertically or diagonally) along a straight sequence of unoccupied squares terminated by an enemy occupied square, and capture the enemy queen or baby by replacement. NOTE: A queen may not give birth to its own baby and kill an enemy baby in the same move. NOTE: A queen of height two may not make a non-capturing move. NON-CAPTURING QUEEN MOVES - When not capturing, a queen moves any distance in any one direction, exactly like a Chess queen, except it leaves its bottom checker behind on the originating square, reducing the stack height by one. The queen monkey has thus given birth to a baby monkey. CAPTURING BABY MOVES - A monkey baby, like a monkey queen, captures exactly like a Chess queen. Slide the baby (singleton) in any direction along a straight sequence of unoccupied squares terminated by an enemy occupied square, and capture the enemy queen or baby by replacement. NON-CAPTURING BABY MOVES - When not capturing, a baby must move toward the enemy queen in the following sense: The straight line distance between your baby and the enemy queen must be shortened by your move. NOTE: There's no requirement to make a kill in Monkey Queen. 
(game "Monkey Queen" (players 2) (equipment {(board (square 12)) (piece "Marker" (or {(move Slide (to if:(is Enemy (who at:(to))) (apply if:(is Enemy (who at:(to))) (remove (to) count:(size Stack at:(to))))) stack:True (then (if (< 1 (size Stack at:(last To))) (set Value Mover (last To))))) (if (< 2 (size Stack at:(from))) (move Slide stack:True (then (and (fromTo (from (last To) level:0) (to (last From))) (set Value Mover (last To)))))) (if (= 1 (size Stack at:(from))) (move Slide (between if:(and (< (count Steps (to) (value Player Next)) (count Steps (from) (value Player Next))) (is Empty (between))))))}))}) (rules (meta (swap)) (start {(place Stack "Marker1" 6 count:20) (place Stack "Marker2" 137 count:20)}) (play (forEach Piece top:True)) (end (if (or (all Sites (sites Occupied by:Next) if:(= 1 (size Stack at:(site)))) (no Moves Next)) (result Mover Win))))) 
The goal is to capture the enemy Commander, or reduce the opponent army to a single Commander. Each piece has an indicator which determines at which directions the piece can move. This can be altered by rotating the piece 45 degrees= to the left or right. Rotating the piece costs a move. Each player has 3 Shields, 5 Probes, 6 Lances, and one Commander. The Shield moves one step and has only one movement freedom at any time. The Probe slides two steps and has two freedoms. The Lance slides three steps and has three freedoms. The Commander has four, but can only move one step. A player must either make a direction move or a motion move. The three Shields are the only pieces that can perform a direction move immediately after a motion move. Capture occurs by displacement. The two players version of Ploy.
(game "Ploy" (players 2) (equipment {(board (square 9) use:Vertex) (piece "Commander" Each (or (move Step (directions {FR FL BL BR} of:All) (to if:(not (is Friend (who at:(to)))) (apply (remove (to))))) (move Set Rotation))) (piece "Shield" Each (or (move Step (directions Forward of:All) (to if:(not (is Friend (who at:(to)))) (apply (remove (to)))) (then (moveAgain))) (move Set Rotation))) (piece "LanceW" Each (or (move Slide (directions Forwards of:All) (between (max 3)) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Set Rotation))) (piece "LanceY" Each (or (move Slide (directions {FR FL Backward} of:All) (between (max 3)) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Set Rotation))) (piece "LanceT" Each (or (move Slide (directions {Forward Rightward Leftward} of:All) (between (max 3)) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Set Rotation))) (piece "ProbeI" Each (or (move Slide (directions {Forward Backward} of:All) (between (max 2)) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Set Rotation))) (piece "ProbeMinV" Each (or (move Slide (directions {Forward FR} of:All) (between (max 2)) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Set Rotation))) (piece "ProbeBigV" Each (or (move Slide (directions {FR FL} of:All) (between (max 2)) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (move Set Rotation)))}) (rules (start {(place "Commander1" coord:"E1" rotation:0) (place "Shield1" {"D3" "E3" "F3"} rotation:0) (place "ProbeI1" coord:"E2" rotation:0) (place "ProbeBigV1" {"D2" "F2"} rotation:0) (place "ProbeMinV1" coord:"C2" rotation:0) (place "ProbeMinV1" coord:"G2" rotation:7) (place "LanceW1" {"D1" "F1"} rotation:0) (place "LanceY1" {"C1" "G1"} rotation:0) (place "LanceT1" {"B1" "H1"} rotation:0) (place "Commander2" coord:"E9" rotation:4) (place "Shield2" {"D7" "E7" "F7"} rotation:4) (place "ProbeI2" coord:"E8" rotation:4) (place "ProbeBigV2" {"D8" "F8"} rotation:4) (place "ProbeMinV2" coord:"C8" rotation:3) (place "ProbeMinV2" coord:"G8" rotation:4) (place "LanceW2" {"D9" "F9"} rotation:4) (place "LanceY2" {"C9" "G9"} rotation:4) (place "LanceT2" {"B9" "H9"} rotation:4)}) (play (if (is Prev Mover) (or (move Set Rotation (to (last To))) (move Pass)) (forEach Piece))) (end (if (or (= (where "Commander" Next) -1) (= (count Pieces Next) 1)) (result Mover Win))))) 
8x16 board. Two players, one black, one white. Each player has three types of pieces: Circles, triangle, squares, and one pyramid made up of multiple pieces stacked. Circles move one space orthogonally. Triangles move two spaces diagonally. Squares move three spaces orthogonally. Pyramids may move in any of the directions allowed by one of its constituent pieces. Each piece has a number. For white—circles: 2, 4, 6, 8, 4, 16, 36, 64; triangles: 6, 20 , 42, 72, 9, 25, 49, 81; squares: 15, 45, 153, 25, 81, 169, 289; pyramid (91) from the base: square 36, square 25, triangle 16, triangle 9, circle 4, circle 1. For black—circles: 3, 5, 7, 9, 9, 25, 49, 81; triangles: 12, 30, 56, 90, 16, 36, 64, 100; squares: 28, 66, 120, 49, 121, 225, 361; pyramid (190): from the base: square 64, square 49, triangle 36, triangle 25, circle 16. Pieces capture other pieces by mathematical allowances based on the numbers on the pieces. There are nine scenarios in which pieces can be taken when a piece moves to a space occupied by an opponent's piece. Multiplication with distance: If the value of the piece to be taken equals the value of the piece making the capture multiplied by the distance between the two pieces; Division by distance: If the value of the piece to be taken equals the value of the piece making the capture divided by the distance between the pieces. Addition: When two pieces can both move to the space of an opponent's piece, if the sum of the two pieces equals the value of the opponent's piece, it is captured and the player chooses which piece to move to that space. Subtraction: When two pieces can both move to the space of an opponent's piece, if the difference between the value of these pieces equals the value of the opponent's piece, it is taken, and the player chooses which piece to move to the space. Multiplication: When two pieces can both move to the space of an opponent's piece, if the product of the values of the two pieces equals the value of the opponent's piece, it is taken and the player chooses which piece to move to the space. Division: When two pieces can both move to the space of an opponent's piece, if the quotient of the values of the two pieces equals the value of the opponent's piece, it is taken and the player chooses which piece to move to the space. Encirclement: If pieces are positioned such that there is no possible move or capture for the opponent's piece, the opponent's piece is taken. Pyramid capture: A pyramid can be captured by capturing its constituent pieces one-by-one according to the above methods; by encircling it so it cannot move, or by obtaining the sum of the constituent pieces or of its base pieces according to the above rules; A pyramid captures as a single one of its component pieces according to the above rules (the direction of the move is independent of the value chosen), or by using the sum of its pieces according to the above rules. The goal of the game is to capture the opponent's pyramid and to create an alignment on the opponent's half of the board forming a mathematical progression. The progression may be arithmetic (a sequence where the difference between the values is constant), geometric (where each value after the first is determined by multiplying the previous value by a fixed number), or harmonic (1/a, 1/a+d, 1/a+2d, 1/a+3d). The pieces in the progression must be in a straight orthogonal or diagonal line or in a chevron shape, and must be equally spaced.
(game "Rithmomachia" (players 2) (equipment {(board (rectangle 16 8)) (piece "Square" Each (move Slide Orthogonal (between (exact 3) if:(is Empty (between))) (to if:(and (is Enemy (who at:(to))) (or {(= (value Piece at:(to) level:0) (* (value Piece at:(from) level:(level)) (count Steps (from) (to)))) (= (value Piece at:(to) level:0) (/ (value Piece at:(from) level:(level)) (count Steps (from) (to)))) (!= 0 (count Sites in:(forEach (sites Occupied by:Mover) if:(and {(!= (from) (site)) (is In (to) (sites To (forEach Level (site) FromBottom (if (= (what at:(site) level:(level)) (id "Disc" Mover)) (step (from (site) level:(level)) Orthogonal (to if:(not (is Friend (who at:(to)))))) (if (= (what at:(site) level:(level)) (id "Triangle" Mover)) (slide (from (site) level:(level)) Diagonal (between (exact 2) if:(is Empty (between))) (to if:(is Enemy (who at:(to))))) (if (= (what at:(site) level:(level)) (id "Square" Mover)) (slide (from (site) level:(level)) Orthogonal (between (exact 3) if:(is Empty (between))) (to if:(is Enemy (who at:(to))))))))))) (= (value Piece at:(to) level:0) (+ (value Piece at:(from) level:(level)) (value Piece at:(site))))})))) (!= 0 (count Sites in:(forEach (sites Occupied by:Mover) if:(and {(!= (from) (site)) (is In (to) (sites To (forEach Level (site) FromBottom (if (= (what at:(site) level:(level)) (id "Disc" Mover)) (step (from (site) level:(level)) Orthogonal (to if:(not (is Friend (who at:(to)))))) (if (= (what at:(site) level:(level)) (id "Triangle" Mover)) (slide (from (site) level:(level)) Diagonal (between (exact 2) if:(is Empty (between))) (to if:(is Enemy (who at:(to))))) (if (= (what at:(site) level:(level)) (id "Square" Mover)) (slide (from (site) level:(level)) Orthogonal (between (exact 3) if:(is Empty (between))) (to if:(is Enemy (who at:(to))))))))))) (= (value Piece at:(to) level:0) (abs (- (value Piece at:(from) level:(level)) (value Piece at:(site)))))})))) (!= 0 (count Sites in:(forEach (sites Occupied by:Mover) if:(and {(!= (from) (site)) (is In (to) (sites To (forEach Level (site) FromBottom (if (= (what at:(site) level:(level)) (id "Disc" Mover)) (step (from (site) level:(level)) Orthogonal (to if:(not (is Friend (who at:(to)))))) (if (= (what at:(site) level:(level)) (id "Triangle" Mover)) (slide (from (site) level:(level)) Diagonal (between (exact 2) if:(is Empty (between))) (to if:(is Enemy (who at:(to))))) (if (= (what at:(site) level:(level)) (id "Square" Mover)) (slide (from (site) level:(level)) Orthogonal (between (exact 3) if:(is Empty (between))) (to if:(is Enemy (who at:(to))))))))))) (= (value Piece at:(to) level:0) (* (value Piece at:(from) level:(level)) (value Piece at:(site))))})))) (!= 0 (count Sites in:(forEach (sites Occupied by:Mover) if:(and {(!= (from) (site)) (is In (to) (sites To (forEach Level (site) FromBottom (if (= (what at:(site) level:(level)) (id "Disc" Mover)) (step (from (site) level:(level)) Orthogonal (to if:(not (is Friend (who at:(to)))))) (if (= (what at:(site) level:(level)) (id "Triangle" Mover)) (slide (from (site) level:(level)) Diagonal (between (exact 2) if:(is Empty (between))) (to if:(is Enemy (who at:(to))))) (if (= (what at:(site) level:(level)) (id "Square" Mover)) (slide (from (site) level:(level)) Orthogonal (between (exact 3) if:(is Empty (between))) (to if:(is Enemy (who at:(to))))))))))) (or (and (!= 0 (value Piece at:(site))) (= (value Piece at:(to)) (/ (value Piece at:(from) level:(level)) (value Piece at:(site))))) (and (!= 0 (value Piece at:(from))) (= (value Piece at:(to)) (/ (value Piece at:(site) level:(level)) (value Piece at:(from))))))}))))})) (apply (if (is Enemy (who at:(to))) (forEach Level (to) FromTop (remove (to) level:(level)))))) stack:True)) (piece "Triangle" Each (move Slide Diagonal (between (exact 2) if:(is Empty (between))) (to if:(and (is Enemy (who at:(to))) (or {(= (value Piece at:(to) level:0) (* (value Piece at:(from) level:(level)) (count Steps (from) (to)))) (= (value Piece at:(to) level:0) (/ (value Piece at:(from) level:(level)) (count Steps (from) (to)))) (!= 0 (count Sites in:(forEach (sites Occupied by:Mover) if:(and {(!= (from) (site)) (is In (to) (sites To (forEach Level (site) FromBottom (if (= (what at:(site) level:(level)) (id "Disc" Mover)) (step (from (site) level:(level)) Orthogonal (to if:(not (is Friend (who at:(to)))))) (if (= (what at:(site) level:(level)) (id "Triangle" Mover)) (slide (from (site) level:(level)) Diagonal (between (exact 2) if:(is Empty (between))) (to if:(is Enemy (who at:(to))))) (if (= (what at:(site) level:(level)) (id "Square" Mover)) (slide (from (site) level:(level)) Orthogonal (between (exact 3) if:(is Empty (between))) (to if:(is Enemy (who at:(to))))))))))) (= (value Piece at:(to) level:0) (+ (value Piece at:(from) level:(level)) (value Piece at:(site))))})))) (!= 0 (count Sites in:(forEach (sites Occupied by:Mover) if:(and {(!= (from) (site)) (is In (to) (sites To (forEach Level (site) FromBottom (if (= (what at:(site) level:(level)) (id "Disc" Mover)) (step (from (site) level:(level)) Orthogonal (to if:(not (is Friend (who at:(to)))))) (if (= (what at:(site) level:(level)) (id "Triangle" Mover)) (slide (from (site) level:(level)) Diagonal (between (exact 2) if:(is Empty (between))) (to if:(is Enemy (who at:(to))))) (if (= (what at:(site) level:(level)) (id "Square" Mover)) (slide (from (site) level:(level)) Orthogonal (between (exact 3) if:(is Empty (between))) (to if:(is Enemy (who at:(to))))))))))) (= (value Piece at:(to) level:0) (abs (- (value Piece at:(from) level:(level)) (value Piece at:(site)))))})))) (!= 0 (count Sites in:(forEach (sites Occupied by:Mover) if:(and {(!= (from) (site)) (is In (to) (sites To (forEach Level (site) FromBottom (if (= (what at:(site) level:(level)) (id "Disc" Mover)) (step (from (site) level:(level)) Orthogonal (to if:(not (is Friend (who at:(to)))))) (if (= (what at:(site) level:(level)) (id "Triangle" Mover)) (slide (from (site) level:(level)) Diagonal (between (exact 2) if:(is Empty (between))) (to if:(is Enemy (who at:(to))))) (if (= (what at:(site) level:(level)) (id "Square" Mover)) (slide (from (site) level:(level)) Orthogonal (between (exact 3) if:(is Empty (between))) (to if:(is Enemy (who at:(to))))))))))) (= (value Piece at:(to) level:0) (* (value Piece at:(from) level:(level)) (value Piece at:(site))))})))) (!= 0 (count Sites in:(forEach (sites Occupied by:Mover) if:(and {(!= (from) (site)) (is In (to) (sites To (forEach Level (site) FromBottom (if (= (what at:(site) level:(level)) (id "Disc" Mover)) (step (from (site) level:(level)) Orthogonal (to if:(not (is Friend (who at:(to)))))) (if (= (what at:(site) level:(level)) (id "Triangle" Mover)) (slide (from (site) level:(level)) Diagonal (between (exact 2) if:(is Empty (between))) (to if:(is Enemy (who at:(to))))) (if (= (what at:(site) level:(level)) (id "Square" Mover)) (slide (from (site) level:(level)) Orthogonal (between (exact 3) if:(is Empty (between))) (to if:(is Enemy (who at:(to))))))))))) (or (and (!= 0 (value Piece at:(site))) (= (value Piece at:(to)) (/ (value Piece at:(from) level:(level)) (value Piece at:(site))))) (and (!= 0 (value Piece at:(from))) (= (value Piece at:(to)) (/ (value Piece at:(site) level:(level)) (value Piece at:(from))))))}))))})) (apply (if (is Enemy (who at:(to))) (forEach Level (to) FromTop (remove (to) level:(level)))))) stack:True)) (piece "Disc" Each (move Step Orthogonal (to if:(if (is Enemy (who at:(to))) (or {(= (value Piece at:(to) level:0) (* (value Piece at:(from) level:(level)) (count Steps (from) (to)))) (= (value Piece at:(to) level:0) (/ (value Piece at:(from) level:(level)) (count Steps (from) (to)))) (!= 0 (count Sites in:(forEach (sites Occupied by:Mover) if:(and {(!= (from) (site)) (is In (to) (sites To (forEach Level (site) FromBottom (if (= (what at:(site) level:(level)) (id "Disc" Mover)) (step (from (site) level:(level)) Orthogonal (to if:(not (is Friend (who at:(to)))))) (if (= (what at:(site) level:(level)) (id "Triangle" Mover)) (slide (from (site) level:(level)) Diagonal (between (exact 2) if:(is Empty (between))) (to if:(is Enemy (who at:(to))))) (if (= (what at:(site) level:(level)) (id "Square" Mover)) (slide (from (site) level:(level)) Orthogonal (between (exact 3) if:(is Empty (between))) (to if:(is Enemy (who at:(to))))))))))) (= (value Piece at:(to) level:0) (+ (value Piece at:(from) level:(level)) (value Piece at:(site))))})))) (!= 0 (count Sites in:(forEach (sites Occupied by:Mover) if:(and {(!= (from) (site)) (is In (to) (sites To (forEach Level (site) FromBottom (if (= (what at:(site) level:(level)) (id "Disc" Mover)) (step (from (site) level:(level)) Orthogonal (to if:(not (is Friend (who at:(to)))))) (if (= (what at:(site) level:(level)) (id "Triangle" Mover)) (slide (from (site) level:(level)) Diagonal (between (exact 2) if:(is Empty (between))) (to if:(is Enemy (who at:(to))))) (if (= (what at:(site) level:(level)) (id "Square" Mover)) (slide (from (site) level:(level)) Orthogonal (between (exact 3) if:(is Empty (between))) (to if:(is Enemy (who at:(to))))))))))) (= (value Piece at:(to) level:0) (abs (- (value Piece at:(from) level:(level)) (value Piece at:(site)))))})))) (!= 0 (count Sites in:(forEach (sites Occupied by:Mover) if:(and {(!= (from) (site)) (is In (to) (sites To (forEach Level (site) FromBottom (if (= (what at:(site) level:(level)) (id "Disc" Mover)) (step (from (site) level:(level)) Orthogonal (to if:(not (is Friend (who at:(to)))))) (if (= (what at:(site) level:(level)) (id "Triangle" Mover)) (slide (from (site) level:(level)) Diagonal (between (exact 2) if:(is Empty (between))) (to if:(is Enemy (who at:(to))))) (if (= (what at:(site) level:(level)) (id "Square" Mover)) (slide (from (site) level:(level)) Orthogonal (between (exact 3) if:(is Empty (between))) (to if:(is Enemy (who at:(to))))))))))) (= (value Piece at:(to) level:0) (* (value Piece at:(from) level:(level)) (value Piece at:(site))))})))) (!= 0 (count Sites in:(forEach (sites Occupied by:Mover) if:(and {(!= (from) (site)) (is In (to) (sites To (forEach Level (site) FromBottom (if (= (what at:(site) level:(level)) (id "Disc" Mover)) (step (from (site) level:(level)) Orthogonal (to if:(not (is Friend (who at:(to)))))) (if (= (what at:(site) level:(level)) (id "Triangle" Mover)) (slide (from (site) level:(level)) Diagonal (between (exact 2) if:(is Empty (between))) (to if:(is Enemy (who at:(to))))) (if (= (what at:(site) level:(level)) (id "Square" Mover)) (slide (from (site) level:(level)) Orthogonal (between (exact 3) if:(is Empty (between))) (to if:(is Enemy (who at:(to))))))))))) (or (and (!= 0 (value Piece at:(site))) (= (value Piece at:(to)) (/ (value Piece at:(from) level:(level)) (value Piece at:(site))))) (and (!= 0 (value Piece at:(from))) (= (value Piece at:(to)) (/ (value Piece at:(site) level:(level)) (value Piece at:(from))))))}))))}) (is Empty (to))) (apply (if (is Enemy (who at:(to))) (forEach Level (to) FromTop (remove (to) level:(level)))))) stack:True)) (regions P1 (expand (sites Bottom) steps:7)) (regions P2 (expand (sites Top) steps:7))}) (rules (start {(place "Square1" coord:"A1" value:289) (place "Square1" coord:"B1" value:169) (place "Square1" coord:"G1" value:81) (place "Square1" coord:"H1" value:25) (place "Square1" coord:"A2" value:153) (place "Square1" coord:"G2" value:45) (place "Square1" coord:"H2" value:15) (place "Triangle1" coord:"G3" value:6) (place "Triangle1" coord:"E2" value:20) (place "Triangle1" coord:"D2" value:42) (place "Triangle1" coord:"B3" value:72) (place "Triangle1" coord:"H3" value:9) (place "Triangle1" coord:"F2" value:25) (place "Triangle1" coord:"C2" value:49) (place "Triangle1" coord:"A3" value:81) (place "Disc1" coord:"F4" value:2) (place "Disc1" coord:"E4" value:4) (place "Disc1" coord:"F3" value:4) (place "Disc1" coord:"D4" value:6) (place "Disc1" coord:"C4" value:8) (place "Disc1" coord:"E3" value:16) (place "Disc1" coord:"D3" value:36) (place "Disc1" coord:"C3" value:64) (place "Square2" coord:"H16" value:361) (place "Square2" coord:"G16" value:225) (place "Square2" coord:"B16" value:121) (place "Square2" coord:"A16" value:49) (place "Square2" coord:"G15" value:120) (place "Square2" coord:"B15" value:66) (place "Square2" coord:"A15" value:28) (place "Triangle2" coord:"B14" value:12) (place "Triangle2" coord:"D15" value:30) (place "Triangle2" coord:"E15" value:56) (place "Triangle2" coord:"G14" value:90) (place "Triangle2" coord:"A14" value:16) (place "Triangle2" coord:"C15" value:36) (place "Triangle2" coord:"F15" value:64) (place "Triangle2" coord:"H14" value:100) (place "Disc2" coord:"C13" value:3) (place "Disc2" coord:"D13" value:5) (place "Disc2" coord:"E13" value:7) (place "Disc2" coord:"F13" value:9) (place "Disc2" coord:"C14" value:9) (place "Disc2" coord:"D14" value:25) (place "Disc2" coord:"E14" value:49) (place "Disc2" coord:"F14" value:81) (place Stack "Square1" 9 value:36) (place Stack "Square1" 9 value:25) (place Stack "Triangle1" 9 value:16) (place Stack "Triangle1" 9 value:9) (place Stack "Disc1" 9 value:4) (place Stack "Disc1" 9 value:1) (place Stack "Square2" 119 value:64) (place Stack "Square2" 119 value:49) (place Stack "Triangle2" 119 value:36) (place Stack "Triangle2" 119 value:25) (place Stack "Disc2" 119 value:16)}) (play (or (forEach Piece) (forEach Site (sites Occupied by:Next) (forEach Level (site) FromBottom (if (and (!= (count Sites in:(sites To (if (= (what at:(site) level:(level)) (id "Disc" Next)) (step (from (site) level:(level)) Orthogonal (to if:(is Friend (who at:(to))))) (if (= (what at:(site) level:(level)) (id "Triangle" Next)) (slide (from (site) level:(level)) Diagonal (between (exact 2) if:(is Empty (between))) (to if:(is Friend (who at:(to))) (apply if:(is Friend (who at:(to)))))) (if (= (what at:(site) level:(level)) (id "Square" Next)) (slide (from (site) level:(level)) Orthogonal (between (exact 3) if:(is Empty (between))) (to if:(is Friend (who at:(to))) (apply if:(is Friend (who at:(to))))))))))) 0) (= (count Sites in:(sites To (if (= (what at:(site) level:(level)) (id "Disc" Next)) (step (from (site) level:(level)) Orthogonal (to if:(or (is Empty (to)) (is Enemy (who at:(to)))))) (if (= (what at:(site) level:(level)) (id "Triangle" Next)) (slide (from (site) level:(level)) Diagonal (between (exact 2) if:(is Empty (between))) (to if:(is Enemy (who at:(to))))) (if (= (what at:(site) level:(level)) (id "Square" Next)) (slide (from (site) level:(level)) Orthogonal (between (exact 3) if:(is Empty (between))) (to if:(is Enemy (who at:(to)))))))))) 0)) (move Remove (site) level:(level))))))) (end (if (and (or {(if (is In (last To) (sites Next)) (or {(if (and (!= (ahead (last To) N) (last To)) (!= (ahead (last To) S) (last To))) (and {(is Mover (who at:(ahead (last To) N))) (is Mover (who at:(ahead (last To) S))) (is In (ahead (last To) N) (sites Next)) (is In (ahead (last To) S) (sites Next)) (= (abs (- (value Piece at:(ahead (last To) N)) (value Piece at:(last To)))) (abs (- (value Piece at:(ahead (last To) S)) (value Piece at:(last To)))))})) (if (and (!= (ahead (last To) N) (last To)) (!= (ahead (last To) steps:2 N) (last To))) (and {(is Mover (who at:(ahead (last To) N))) (is Mover (who at:(ahead (last To) steps:2 N))) (is In (ahead (last To) N) (sites Next)) (is In (ahead (last To) steps:2 N) (sites Next)) (= (abs (- (value Piece at:(ahead (last To) N)) (value Piece at:(last To)))) (abs (- (value Piece at:(ahead (last To) steps:2 N)) (value Piece at:(ahead (last To) N)))))})) (if (and (!= (ahead (last To) S) (last To)) (!= (ahead (last To) steps:2 S) (last To))) (and {(is Mover (who at:(ahead (last To) S))) (is Mover (who at:(ahead (last To) steps:2 S))) (is In (ahead (last To) S) (sites Next)) (is In (ahead (last To) steps:2 S) (sites Next)) (= (abs (- (value Piece at:(ahead (last To) S)) (value Piece at:(last To)))) (abs (- (value Piece at:(ahead (last To) steps:2 S)) (value Piece at:(ahead (last To) S)))))})) (if (and (!= (ahead (last To) E) (last To)) (!= (ahead (last To) W) (last To))) (and {(is Mover (who at:(ahead (last To) E))) (is Mover (who at:(ahead (last To) W))) (is In (ahead (last To) E) (sites Next)) (is In (ahead (last To) W) (sites Next)) (= (abs (- (value Piece at:(ahead (last To) E)) (value Piece at:(last To)))) (abs (- (value Piece at:(ahead (last To) W)) (value Piece at:(last To)))))})) (if (and (!= (ahead (last To) E) (last To)) (!= (ahead (last To) steps:2 E) (last To))) (and {(is Mover (who at:(ahead (last To) E))) (is Mover (who at:(ahead (last To) steps:2 E))) (is In (ahead (last To) E) (sites Next)) (is In (ahead (last To) steps:2 E) (sites Next)) (= (abs (- (value Piece at:(ahead (last To) E)) (value Piece at:(last To)))) (abs (- (value Piece at:(ahead (last To) steps:2 E)) (value Piece at:(ahead (last To) E)))))})) (if (and (!= (ahead (last To) W) (last To)) (!= (ahead (last To) steps:2 W) (last To))) (and {(is Mover (who at:(ahead (last To) W))) (is Mover (who at:(ahead (last To) steps:2 W))) (is In (ahead (last To) W) (sites Next)) (is In (ahead (last To) steps:2 W) (sites Next)) (= (abs (- (value Piece at:(ahead (last To) W)) (value Piece at:(last To)))) (abs (- (value Piece at:(ahead (last To) steps:2 W)) (value Piece at:(ahead (last To) W)))))})) (if (and (!= (ahead (last To) NE) (last To)) (!= (ahead (last To) SW) (last To))) (and {(is Mover (who at:(ahead (last To) NE))) (is Mover (who at:(ahead (last To) SW))) (is In (ahead (last To) NE) (sites Next)) (is In (ahead (last To) SW) (sites Next)) (= (abs (- (value Piece at:(ahead (last To) NE)) (value Piece at:(last To)))) (abs (- (value Piece at:(ahead (last To) SW)) (value Piece at:(last To)))))})) (if (and (!= (ahead (last To) NE) (last To)) (!= (ahead (last To) steps:2 NE) (last To))) (and {(is Mover (who at:(ahead (last To) NE))) (is Mover (who at:(ahead (last To) steps:2 NE))) (is In (ahead (last To) NE) (sites Next)) (is In (ahead (last To) steps:2 NE) (sites Next)) (= (abs (- (value Piece at:(ahead (last To) NE)) (value Piece at:(last To)))) (abs (- (value Piece at:(ahead (last To) steps:2 NE)) (value Piece at:(ahead (last To) NE)))))})) (if (and (!= (ahead (last To) SW) (last To)) (!= (ahead (last To) steps:2 SW) (last To))) (and {(is Mover (who at:(ahead (last To) SW))) (is Mover (who at:(ahead (last To) steps:2 SW))) (is In (ahead (last To) SW) (sites Next)) (is In (ahead (last To) steps:2 SW) (sites Next)) (= (abs (- (value Piece at:(ahead (last To) SW)) (value Piece at:(last To)))) (abs (- (value Piece at:(ahead (last To) steps:2 SW)) (value Piece at:(ahead (last To) SW)))))})) (if (and (!= (ahead (last To) SE) (last To)) (!= (ahead (last To) NW) (last To))) (and {(is Mover (who at:(ahead (last To) SE))) (is Mover (who at:(ahead (last To) NW))) (is In (ahead (last To) SE) (sites Next)) (is In (ahead (last To) NW) (sites Next)) (= (abs (- (value Piece at:(ahead (last To) SE)) (value Piece at:(last To)))) (abs (- (value Piece at:(ahead (last To) NW)) (value Piece at:(last To)))))})) (if (and (!= (ahead (last To) SE) (last To)) (!= (ahead (last To) steps:2 SE) (last To))) (and {(is Mover (who at:(ahead (last To) SE))) (is Mover (who at:(ahead (last To) steps:2 SE))) (is In (ahead (last To) SE) (sites Next)) (is In (ahead (last To) steps:2 SE) (sites Next)) (= (abs (- (value Piece at:(ahead (last To) SE)) (value Piece at:(last To)))) (abs (- (value Piece at:(ahead (last To) steps:2 SE)) (value Piece at:(ahead (last To) SE)))))})) (if (and (!= (ahead (last To) NW) (last To)) (!= (ahead (last To) steps:2 NW) (last To))) (and {(is Mover (who at:(ahead (last To) NW))) (is Mover (who at:(ahead (last To) steps:2 NW))) (is In (ahead (last To) NW) (sites Next)) (is In (ahead (last To) steps:2 NW) (sites Next)) (= (abs (- (value Piece at:(ahead (last To) NW)) (value Piece at:(last To)))) (abs (- (value Piece at:(ahead (last To) steps:2 NW)) (value Piece at:(ahead (last To) NW)))))}))})) (if (is In (last To) (sites Next)) (or {(if (and (!= (ahead (last To) N) (last To)) (!= (ahead (last To) S) (last To))) (and {(is Mover (who at:(ahead (last To) N))) (is Mover (who at:(ahead (last To) S))) (is In (ahead (last To) N) (sites Next)) (is In (ahead (last To) S) (sites Next)) (!= 0 (value Piece at:(last To))) (!= 0 (value Piece at:(ahead (last To) S))) (= (/ (value Piece at:(ahead (last To) N)) (value Piece at:(last To))) (/ (value Piece at:(last To)) (value Piece at:(ahead (last To) S))))})) (if (and (!= (ahead (last To) N) (last To)) (!= (ahead (last To) steps:2 N) (last To))) (and {(is Mover (who at:(ahead (last To) N))) (is Mover (who at:(ahead (last To) steps:2 N))) (is In (ahead (last To) N) (sites Next)) (is In (ahead (last To) steps:2 N) (sites Next)) (!= 0 (value Piece at:(last To))) (!= 0 (value Piece at:(ahead (last To) N))) (= (/ (value Piece at:(ahead (last To) N)) (value Piece at:(last To))) (/ (value Piece at:(ahead (last To) steps:2 N)) (value Piece at:(ahead (last To) N))))})) (if (and (!= (ahead (last To) S) (last To)) (!= (ahead (last To) steps:2 S) (last To))) (and {(is Mover (who at:(ahead (last To) S))) (is Mover (who at:(ahead (last To) steps:2 S))) (is In (ahead (last To) S) (sites Next)) (is In (ahead (last To) steps:2 S) (sites Next)) (!= 0 (value Piece at:(last To))) (!= 0 (value Piece at:(ahead (last To) S))) (= (/ (value Piece at:(ahead (last To) S)) (value Piece at:(last To))) (/ (value Piece at:(ahead (last To) steps:2 S)) (value Piece at:(ahead (last To) S))))})) (if (and (!= (ahead (last To) E) (last To)) (!= (ahead (last To) W) (last To))) (and {(is Mover (who at:(ahead (last To) E))) (is Mover (who at:(ahead (last To) W))) (is In (ahead (last To) E) (sites Next)) (is In (ahead (last To) W) (sites Next)) (!= 0 (value Piece at:(last To))) (!= 0 (value Piece at:(ahead (last To) W))) (= (/ (value Piece at:(ahead (last To) E)) (value Piece at:(last To))) (/ (value Piece at:(last To)) (value Piece at:(ahead (last To) W))))})) (if (and (!= (ahead (last To) E) (last To)) (!= (ahead (last To) steps:2 E) (last To))) (and {(is Mover (who at:(ahead (last To) E))) (is Mover (who at:(ahead (last To) steps:2 E))) (is In (ahead (last To) E) (sites Next)) (is In (ahead (last To) steps:2 E) (sites Next)) (!= 0 (value Piece at:(last To))) (!= 0 (value Piece at:(ahead (last To) E))) (= (/ (value Piece at:(ahead (last To) E)) (value Piece at:(last To))) (/ (value Piece at:(ahead (last To) steps:2 E)) (value Piece at:(ahead (last To) E))))})) (if (and (!= (ahead (last To) W) (last To)) (!= (ahead (last To) steps:2 W) (last To))) (and {(is Mover (who at:(ahead (last To) W))) (is Mover (who at:(ahead (last To) steps:2 W))) (is In (ahead (last To) W) (sites Next)) (is In (ahead (last To) steps:2 W) (sites Next)) (!= 0 (value Piece at:(last To))) (!= 0 (value Piece at:(ahead (last To) W))) (= (/ (value Piece at:(ahead (last To) W)) (value Piece at:(last To))) (/ (value Piece at:(ahead (last To) steps:2 W)) (value Piece at:(ahead (last To) W))))})) (if (and (!= (ahead (last To) NE) (last To)) (!= (ahead (last To) SW) (last To))) (and {(is Mover (who at:(ahead (last To) NE))) (is Mover (who at:(ahead (last To) SW))) (is In (ahead (last To) NE) (sites Next)) (is In (ahead (last To) SW) (sites Next)) (!= 0 (value Piece at:(last To))) (!= 0 (value Piece at:(ahead (last To) SW))) (= (/ (value Piece at:(ahead (last To) NE)) (value Piece at:(last To))) (/ (value Piece at:(last To)) (value Piece at:(ahead (last To) SW))))})) (if (and (!= (ahead (last To) NE) (last To)) (!= (ahead (last To) steps:2 NE) (last To))) (and {(is Mover (who at:(ahead (last To) NE))) (is Mover (who at:(ahead (last To) steps:2 NE))) (is In (ahead (last To) NE) (sites Next)) (is In (ahead (last To) steps:2 NE) (sites Next)) (!= 0 (value Piece at:(last To))) (!= 0 (value Piece at:(ahead (last To) NE))) (= (/ (value Piece at:(ahead (last To) NE)) (value Piece at:(last To))) (/ (value Piece at:(ahead (last To) steps:2 NE)) (value Piece at:(ahead (last To) NE))))})) (if (and (!= (ahead (last To) SW) (last To)) (!= (ahead (last To) steps:2 SW) (last To))) (and {(is Mover (who at:(ahead (last To) SW))) (is Mover (who at:(ahead (last To) steps:2 SW))) (is In (ahead (last To) SW) (sites Next)) (is In (ahead (last To) steps:2 SW) (sites Next)) (!= 0 (value Piece at:(last To))) (!= 0 (value Piece at:(ahead (last To) SW))) (= (/ (value Piece at:(ahead (last To) SW)) (value Piece at:(last To))) (/ (value Piece at:(ahead (last To) steps:2 SW)) (value Piece at:(ahead (last To) SW))))})) (if (and (!= (ahead (last To) SE) (last To)) (!= (ahead (last To) NW) (last To))) (and {(is Mover (who at:(ahead (last To) SE))) (is Mover (who at:(ahead (last To) NW))) (is In (ahead (last To) SE) (sites Next)) (is In (ahead (last To) NW) (sites Next)) (!= 0 (value Piece at:(last To))) (!= 0 (value Piece at:(ahead (last To) NW))) (= (/ (value Piece at:(ahead (last To) SE)) (value Piece at:(last To))) (/ (value Piece at:(last To)) (value Piece at:(ahead (last To) NW))))})) (if (and (!= (ahead (last To) SE) (last To)) (!= (ahead (last To) steps:2 SE) (last To))) (and {(is Mover (who at:(ahead (last To) SE))) (is Mover (who at:(ahead (last To) steps:2 SE))) (is In (ahead (last To) SE) (sites Next)) (is In (ahead (last To) steps:2 SE) (sites Next)) (!= 0 (value Piece at:(last To))) (!= 0 (value Piece at:(ahead (last To) SE))) (= (/ (value Piece at:(ahead (last To) SE)) (value Piece at:(last To))) (/ (value Piece at:(ahead (last To) steps:2 SE)) (value Piece at:(ahead (last To) SE))))})) (if (and (!= (ahead (last To) NW) (last To)) (!= (ahead (last To) steps:2 NW) (last To))) (and {(is Mover (who at:(ahead (last To) NW))) (is Mover (who at:(ahead (last To) steps:2 NW))) (is In (ahead (last To) NW) (sites Next)) (is In (ahead (last To) steps:2 NW) (sites Next)) (!= 0 (value Piece at:(last To))) (!= 0 (value Piece at:(ahead (last To) NW))) (= (/ (value Piece at:(ahead (last To) NW)) (value Piece at:(last To))) (/ (value Piece at:(ahead (last To) steps:2 NW)) (value Piece at:(ahead (last To) NW))))}))})) (if (is In (last To) (sites Next)) (or {(if (and (!= (ahead (last To) N) (last To)) (!= (ahead (last To) S) (last To))) (and {(is Mover (who at:(ahead (last To) N))) (is Mover (who at:(ahead (last To) S))) (is In (ahead (last To) N) (sites Next)) (is In (ahead (last To) S) (sites Next)) (!= 0 (value Piece at:(last To))) (!= 0 (value Piece at:(ahead (last To) S))) (= (/ (value Piece at:(ahead (last To) N)) (value Piece at:(last To))) (/ (value Piece at:(last To)) (value Piece at:(ahead (last To) S))))})) (if (and (!= (ahead (last To) N) (last To)) (!= (ahead (last To) steps:2 N) (last To))) (and {(is Mover (who at:(ahead (last To) N))) (is Mover (who at:(ahead (last To) steps:2 N))) (is In (ahead (last To) N) (sites Next)) (is In (ahead (last To) steps:2 N) (sites Next)) (!= 0 (value Piece at:(last To))) (!= 0 (value Piece at:(ahead (last To) N))) (= (/ (value Piece at:(ahead (last To) N)) (value Piece at:(last To))) (/ (value Piece at:(ahead (last To) steps:2 N)) (value Piece at:(ahead (last To) N))))})) (if (and (!= (ahead (last To) S) (last To)) (!= (ahead (last To) steps:2 S) (last To))) (and {(is Mover (who at:(ahead (last To) S))) (is Mover (who at:(ahead (last To) steps:2 S))) (is In (ahead (last To) S) (sites Next)) (is In (ahead (last To) steps:2 S) (sites Next)) (!= 0 (value Piece at:(last To))) (!= 0 (value Piece at:(ahead (last To) S))) (= (/ (value Piece at:(ahead (last To) S)) (value Piece at:(last To))) (/ (value Piece at:(ahead (last To) steps:2 S)) (value Piece at:(ahead (last To) S))))})) (if (and (!= (ahead (last To) E) (last To)) (!= (ahead (last To) W) (last To))) (and {(is Mover (who at:(ahead (last To) E))) (is Mover (who at:(ahead (last To) W))) (is In (ahead (last To) E) (sites Next)) (is In (ahead (last To) W) (sites Next)) (!= 0 (value Piece at:(last To))) (!= 0 (value Piece at:(ahead (last To) W))) (= (/ (value Piece at:(ahead (last To) E)) (value Piece at:(last To))) (/ (value Piece at:(last To)) (value Piece at:(ahead (last To) W))))})) (if (and (!= (ahead (last To) E) (last To)) (!= (ahead (last To) steps:2 E) (last To))) (and {(is Mover (who at:(ahead (last To) E))) (is Mover (who at:(ahead (last To) steps:2 E))) (is In (ahead (last To) E) (sites Next)) (is In (ahead (last To) steps:2 E) (sites Next)) (!= 0 (value Piece at:(last To))) (!= 0 (value Piece at:(ahead (last To) E))) (= (/ (value Piece at:(ahead (last To) E)) (value Piece at:(last To))) (/ (value Piece at:(ahead (last To) steps:2 E)) (value Piece at:(ahead (last To) E))))})) (if (and (!= (ahead (last To) W) (last To)) (!= (ahead (last To) steps:2 W) (last To))) (and {(is Mover (who at:(ahead (last To) W))) (is Mover (who at:(ahead (last To) steps:2 W))) (is In (ahead (last To) W) (sites Next)) (is In (ahead (last To) steps:2 W) (sites Next)) (!= 0 (value Piece at:(last To))) (!= 0 (value Piece at:(ahead (last To) W))) (= (/ (value Piece at:(ahead (last To) W)) (value Piece at:(last To))) (/ (value Piece at:(ahead (last To) steps:2 W)) (value Piece at:(ahead (last To) W))))})) (if (and (!= (ahead (last To) NE) (last To)) (!= (ahead (last To) SW) (last To))) (and {(is Mover (who at:(ahead (last To) NE))) (is Mover (who at:(ahead (last To) SW))) (is In (ahead (last To) NE) (sites Next)) (is In (ahead (last To) SW) (sites Next)) (!= 0 (value Piece at:(last To))) (!= 0 (value Piece at:(ahead (last To) SW))) (= (/ (value Piece at:(ahead (last To) NE)) (value Piece at:(last To))) (/ (value Piece at:(last To)) (value Piece at:(ahead (last To) SW))))})) (if (and (!= (ahead (last To) NE) (last To)) (!= (ahead (last To) steps:2 NE) (last To))) (and {(is Mover (who at:(ahead (last To) NE))) (is Mover (who at:(ahead (last To) steps:2 NE))) (is In (ahead (last To) NE) (sites Next)) (is In (ahead (last To) steps:2 NE) (sites Next)) (!= 0 (value Piece at:(last To))) (!= 0 (value Piece at:(ahead (last To) NE))) (= (/ (value Piece at:(ahead (last To) NE)) (value Piece at:(last To))) (/ (value Piece at:(ahead (last To) steps:2 NE)) (value Piece at:(ahead (last To) NE))))})) (if (and (!= (ahead (last To) SW) (last To)) (!= (ahead (last To) steps:2 SW) (last To))) (and {(is Mover (who at:(ahead (last To) SW))) (is Mover (who at:(ahead (last To) steps:2 SW))) (is In (ahead (last To) SW) (sites Next)) (is In (ahead (last To) steps:2 SW) (sites Next)) (!= 0 (value Piece at:(last To))) (!= 0 (value Piece at:(ahead (last To) SW))) (= (/ (value Piece at:(ahead (last To) SW)) (value Piece at:(last To))) (/ (value Piece at:(ahead (last To) steps:2 SW)) (value Piece at:(ahead (last To) SW))))})) (if (and (!= (ahead (last To) SE) (last To)) (!= (ahead (last To) NW) (last To))) (and {(is Mover (who at:(ahead (last To) SE))) (is Mover (who at:(ahead (last To) NW))) (is In (ahead (last To) SE) (sites Next)) (is In (ahead (last To) NW) (sites Next)) (!= 0 (value Piece at:(last To))) (!= 0 (value Piece at:(ahead (last To) NW))) (= (/ (value Piece at:(ahead (last To) SE)) (value Piece at:(last To))) (/ (value Piece at:(last To)) (value Piece at:(ahead (last To) NW))))})) (if (and (!= (ahead (last To) SE) (last To)) (!= (ahead (last To) steps:2 SE) (last To))) (and {(is Mover (who at:(ahead (last To) SE))) (is Mover (who at:(ahead (last To) steps:2 SE))) (is In (ahead (last To) SE) (sites Next)) (is In (ahead (last To) steps:2 SE) (sites Next)) (!= 0 (value Piece at:(last To))) (!= 0 (value Piece at:(ahead (last To) SE))) (= (/ (value Piece at:(ahead (last To) SE)) (value Piece at:(last To))) (/ (value Piece at:(ahead (last To) steps:2 SE)) (value Piece at:(ahead (last To) SE))))})) (if (and (!= (ahead (last To) NW) (last To)) (!= (ahead (last To) steps:2 NW) (last To))) (and {(is Mover (who at:(ahead (last To) NW))) (is Mover (who at:(ahead (last To) steps:2 NW))) (is In (ahead (last To) NW) (sites Next)) (is In (ahead (last To) steps:2 NW) (sites Next)) (!= 0 (value Piece at:(last To))) (!= 0 (value Piece at:(ahead (last To) NW))) (= (/ (value Piece at:(ahead (last To) NW)) (value Piece at:(last To))) (/ (value Piece at:(ahead (last To) steps:2 NW)) (value Piece at:(ahead (last To) NW))))}))}))}) (all Sites (sites Occupied by:Next) if:(= 1 (size Stack at:(site))))) (result Mover Win))))) 
<a href="https://boardgamegeek.com/image/1488366/shogun" target="_blank" class="style1" style="color: #0000EE" />BGG rules</a> 1976 version
(game "Shogun" (players {(player N) (player S)}) (equipment {(board (square 8)) (piece "Pawn" Each (move (from (from)) (to (intersection (sites To (if (= 1 (value Piece at:(from))) (step Orthogonal (to if:(not (is Friend (who at:(to)))))) (forEach Site (sites To (slide (from) Orthogonal (between (range 1 3) if:(is Empty (between))) (to if:(is Enemy (who at:(to))) (apply if:(is Empty (to)))))) (slide (from (site)) Orthogonal (between (range 1 3) if:(is Empty (between))) (to if:(is Enemy (who at:(to)))))))) (sites Distance Orthogonal from:(from) (exact (value Piece at:(from))))) if:(not (is Friend (who at:(to)))) (apply (set Value at:(from) (value Random (range 1 4))))))) (piece "King" Each (move (from (from)) (to (intersection (sites To (if (= 1 (value Piece at:(from))) (step Orthogonal (to if:(not (is Friend (who at:(to)))))) (forEach Site (sites To (slide (from) Orthogonal (between (range 1 3) if:(is Empty (between))) (to if:(is Enemy (who at:(to))) (apply if:(is Empty (to)))))) (slide (from (site)) Orthogonal (between (range 1 3) if:(is Empty (between))) (to if:(is Enemy (who at:(to)))))))) (sites Distance Orthogonal from:(from) (exact (value Piece at:(from))))) if:(not (is Friend (who at:(to)))) (apply (set Value at:(from) (value Random (range 1 2)))))))}) (rules (start {(place "Pawn1" coord:"A1" value:(value Random (range 1 4))) (place "Pawn1" coord:"B1" value:(value Random (range 1 4))) (place "Pawn1" coord:"C1" value:(value Random (range 1 4))) (place "Pawn1" coord:"D1" value:(value Random (range 1 4))) (place "Pawn1" coord:"F1" value:(value Random (range 1 4))) (place "Pawn1" coord:"G1" value:(value Random (range 1 4))) (place "Pawn1" coord:"H1" value:(value Random (range 1 4))) (place "King1" coord:"E1" value:(value Random (range 1 2))) (place "Pawn2" coord:"A8" value:(value Random (range 1 4))) (place "Pawn2" coord:"B8" value:(value Random (range 1 4))) (place "Pawn2" coord:"C8" value:(value Random (range 1 4))) (place "Pawn2" coord:"E8" value:(value Random (range 1 4))) (place "Pawn2" coord:"F8" value:(value Random (range 1 4))) (place "Pawn2" coord:"G8" value:(value Random (range 1 4))) (place "Pawn2" coord:"H8" value:(value Random (range 1 4))) (place "King2" coord:"D8" value:(value Random (range 1 2)))}) (play (forEach Piece)) (end (if (or (no Pieces Next "King") (<= (count Pieces Next) 2)) (result Mover Win))))) 
To start the game, each of the squares on the checkerboard is occupied by a stone. White stones are placed on the white squares and black stones on the black squares. To move, the player must pick up one of his or her own stones and 'clobber' an opponent's stone on an adjacent square, either horizontally or vertically. Once the opponent's stone is clobbered, it must then be removed from the board and replaced by the stone that was moved. The player who, on their turn, is unable to move, loses the game. The board has 10 rows. The board has 10 columns. Pieces must step onto an enemy piece.
(game "Clobber" (players 2) (equipment {(board (rectangle 10 10)) (piece "Marker" Each (move Step Orthogonal (to if:(is Enemy (who at:(to))) (apply (remove (to))))))}) (rules (start {(place "Marker1" (sites Phase 1)) (place "Marker2" (sites Phase 0))}) (play (forEach Piece)) (end (if (no Moves Next) (result Next Loss))))) 
One player has red pegs, the other player blue pegs. The player who can get all his color pegs pressed down first wins the game. Each player can press his opponent's color pegs. At any time during the game, if it becomes impossible to press a peg next to the last one pressed the game finishes. The player with the most of his own color pegs pressed down is the winner.
(game "Press Ups" (players 2) (equipment {(board (square 7)) (piece "Disc" Each) (piece "Disc" Neutral) (regions P1 (difference (union (sites Bottom) (sites Top)) (union (sites Right) (sites Left)))) (regions P2 (difference (union (sites Right) (sites Left)) (union (sites Bottom) (sites Top))))}) (rules (start {(place "Disc1" (sites P1)) (place "Disc2" (sites P2)) (place "Disc0" (difference (sites Board) (union (sites P1) (sites P2))))}) phases:{(phase "Init" (play (move Select (from (difference (sites Board) (union (sites P1) (sites P2)))) (then (remove (last To))))) (nextPhase "Remove")) (phase "Remove" (play (move Select (from (sites Around (last To)) if:(is Occupied (from))) (then (remove (last To))))))} (end {(if (no Pieces P1) (result P1 Loss)) (if (no Pieces P2) (result P2 Loss)) (if (no Moves Next) (byScore {(score P1 (count Pieces P1)) (score P2 (count Pieces P2))}))}))) 
