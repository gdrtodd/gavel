Twenty small circles arranged in a large circle, with a cross of nine more circles in the center of the large circle. The central circle and the circles where the crosses meet the larger circle are larger than the others. Two players play with either one or four pieces each. Four stick dice with a white and a black side, with the following values for the throws: four white sides up = 4; four black sides up = 5; three white sides up = 3, two white sides up = 2, one white side up = 1. Throws of 4 and 5 allow the player another throw, pieces being moved after all of the player's throws. Pieces enter the board on the spot to the left of the topmost position of the circle, and proceed around the circle in an anti-clockwise direction. If a piece lands on one of the spaces where the central cross meets the circle, the piece may proceed along the cross to the opposite side on the next turn. A piece may not turn and move along a cross if it does not land on the end of the cross at the end of a throw. Pieces proceed to the topmost space, and move off the board by throwing one or more than required to land on this space. When a player lands on the same spot as one of their own pieces, these may be moved together as one piece. When a player lands on an opponent's piece, the opponent's piece is sent back to the start. The first player to remove all of their pieces from the board wins. 2 players involved with four pieces per player.
(game "Nyout" (players 2) (equipment {(board (concentric {1 -4 -4 20}) {(track "Track1" {29 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28} P1 directed:True) (track "Track2" {30 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28} P2 directed:True) (track "HorizontalTrack" {13 5 1 0 3 7 23 24 25 26 27 28} directed:True) (track "VerticalTrack" {18 6 2 0 4 8 28} directed:True)} use:Vertex) (piece "Counter" Each (or {(if (is In (from) (sites Track Mover "Track")) (forEach Value (values Remembered "Throws") (or (if (equals (trackSite Move from:(from) "Track" steps:(value)) -1) (do (forget Value "Throws" (value)) next:(move Remove (from) level:(level)))) (move (from (from) level:(level)) (to (trackSite Move from:(from) "Track" steps:(value)) if:(or (not (is Enemy (who at:(to)))) (equals 1 (size Stack at:(to)))) (apply (and (if (is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite (who at:(to)))))) (forget Value "Throws" (value))))) (then (if (and (notEqual (last From) (handSite Mover)) (is Occupied (last From))) (forEach Level (last From) FromTop (fromTo (from (last From) level:(level)) (to (last To))))))) (then (if (notEqual 0 (size Array (values Remembered "Throws"))) (moveAgain)))))) (if (is In (from) (sites Track "HorizontalTrack")) (forEach Value (values Remembered "Throws") (or (if (equals (trackSite Move from:(from) "HorizontalTrack" steps:(value)) -1) (do (forget Value "Throws" (value)) next:(move Remove (from) level:(level)))) (move (from (from) level:(level)) (to (trackSite Move from:(from) "HorizontalTrack" steps:(value)) if:(or (not (is Enemy (who at:(to)))) (equals 1 (size Stack at:(to)))) (apply (and (if (is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite (who at:(to)))))) (forget Value "Throws" (value))))) (then (if (and (notEqual (last From) (handSite Mover)) (is Occupied (last From))) (forEach Level (last From) FromTop (fromTo (from (last From) level:(level)) (to (last To))))))) (then (if (notEqual 0 (size Array (values Remembered "Throws"))) (moveAgain)))))) (if (is In (from) (sites Track "VerticalTrack")) (forEach Value (values Remembered "Throws") (or (if (equals (trackSite Move from:(from) "VerticalTrack" steps:(value)) -1) (do (forget Value "Throws" (value)) next:(move Remove (from) level:(level)))) (move (from (from) level:(level)) (to (trackSite Move from:(from) "VerticalTrack" steps:(value)) if:(or (not (is Enemy (who at:(to)))) (equals 1 (size Stack at:(to)))) (apply (and (if (is Enemy (who at:(to))) (fromTo (from (to)) (to (handSite (who at:(to)))))) (forget Value "Throws" (value))))) (then (if (and (notEqual (last From) (handSite Mover)) (is Occupied (last From))) (forEach Level (last From) FromTop (fromTo (from (last From) level:(level)) (to (last To))))))) (then (if (notEqual 0 (size Array (values Remembered "Throws"))) (moveAgain))))))})) (dice d:2 from:0 num:4) (hand Each) (map "Throw" {(pair 0 4) (pair 1 3) (pair 2 2) (pair 3 1) (pair 4 5)})}) (rules (start {(set Team 1 {P1}) (set Team 2 {P2}) (place Stack "Counter1" (handSite P1) count:4) (place Stack "Counter2" (handSite P2) count:4)}) phases:{(phase "Throwing" (play (do (roll) next:(move Pass (then (remember Value "Throws" (mapEntry "Throw" (count Pips))))) (then (moveAgain)))) (nextPhase Mover (not (is In (mapEntry "Throw" (count Pips)) (sites {4 5}))) "Moving")) (phase "Moving" (play (if (can Move (or (forEach Piece top:True) (forEach Piece container:(mover) top:True))) (or (forEach Piece top:True) (forEach Piece container:(mover) top:True)) (move Pass (then (forget Value "Throws" All))))) (nextPhase Mover (equals 0 (size Array (values Remembered "Throws"))) "Throwing"))} (end (if (no Pieces TeamMover) (result TeamMover Win))))) 
