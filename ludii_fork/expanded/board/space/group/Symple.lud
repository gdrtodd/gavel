Players alternate making a move. White plays with the white stones and makes the first move, Black plays with the black stones. On his turn, a player may choose either a) to place a stone on the board without contact to other stones of his color in order to start a new group, or b) to grow all possible groups by one stone. When you grow your groups in this implementation, you place grey stones adjacent to your groups until each of your groups is adjacent to exactly one grey stone. At no point may a group of yours be adjacent to more than one grey stone. When your turn ends, all grey stones are replaced with stones of your color. For balancing, there is an extra rule: Black is allowed to grow all his groups and place a single stone as long as neither player has not yet grown any groups. The game ends when the board is filled in. The score is the number of stones each player has on the board minus 'P' times the number of groups he has, where 'P' is en even number of 4 or higher (the Ludii implementation also allows 0 and 2 as values of 'P'). With an even penalty and an odd boardsize, draws are not possible. A size 19 board is currently selected A group penalty of 10 points is currently selected
(game "Symple" (players 2) (equipment {(board (square 19) use:Vertex) (piece "Marker" Each) (piece "Marker" Neutral)}) (rules (play (if (equals (count Moves) (var "MoveThatMustBePlant")) (move Add (to (sites Empty) if:(equals 0 (count Sites in:(sites Around (to) Own Orthogonal)))) (then (set Score Mover (sub (count Sites in:(sites Occupied by:Mover)) (mul 10 (count Groups Orthogonal if:(is Mover (who at:(to))))))))) (if (equals 0 (count MovesThisTurn)) (or (move Add (to (sites Empty) if:(equals 0 (count Sites in:(sites Around (to) Own Orthogonal)))) (then (set Score Mover (sub (count Sites in:(sites Occupied by:Mover)) (mul 10 (count Groups Orthogonal if:(is Mover (who at:(to))))))))) (do (move Add (piece "Marker0") (to (sites Empty) if:(lt 0 (count Sites in:(sites Around (to) Own Orthogonal))))) ifAfterwards:(all Groups Orthogonal of:(is Mover (who at:(to))) if:(gt 2 (count Sites in:(intersection (sites Around (sites) NotEmpty Orthogonal) (sites Occupied by:Neutral))))) (then (if (can Move (do (move Add (piece "Marker0") (to (sites Empty) if:(lt 0 (count Sites in:(sites Around (to) Own Orthogonal))))) ifAfterwards:(all Groups Orthogonal of:(is Mover (who at:(to))) if:(gt 2 (count Sites in:(intersection (sites Around (sites) NotEmpty Orthogonal) (sites Occupied by:Neutral))))))) (moveAgain) (do (add (to (sites Occupied by:Neutral) (apply (remove (to)))) (then (if (notEqual 1 (var "HasGrown")) (and (set Var "HasGrown" 1) (if (equals (id P2) (mover)) (and (set Var "MoveThatMustBePlant" (count Moves)) (moveAgain))))))) next:(set Score Mover (sub (count Sites in:(sites Occupied by:Mover)) (mul 10 (count Groups Orthogonal if:(is Mover (who at:(to)))))))))))) (do (move Add (piece "Marker0") (to (sites Empty) if:(lt 0 (count Sites in:(sites Around (to) Own Orthogonal))))) ifAfterwards:(all Groups Orthogonal of:(is Mover (who at:(to))) if:(gt 2 (count Sites in:(intersection (sites Around (sites) NotEmpty Orthogonal) (sites Occupied by:Neutral))))) (then (if (can Move (do (move Add (piece "Marker0") (to (sites Empty) if:(lt 0 (count Sites in:(sites Around (to) Own Orthogonal))))) ifAfterwards:(all Groups Orthogonal of:(is Mover (who at:(to))) if:(gt 2 (count Sites in:(intersection (sites Around (sites) NotEmpty Orthogonal) (sites Occupied by:Neutral))))))) (moveAgain) (do (add (to (sites Occupied by:Neutral) (apply (remove (to)))) (then (if (notEqual 1 (var "HasGrown")) (and (set Var "HasGrown" 1) (if (equals (id P2) (mover)) (and (set Var "MoveThatMustBePlant" (count Moves)) (moveAgain))))))) next:(set Score Mover (sub (count Sites in:(sites Occupied by:Mover)) (mul 10 (count Groups Orthogonal if:(is Mover (who at:(to)))))))))))))) (end (if (is Full) (byScore))))) 
