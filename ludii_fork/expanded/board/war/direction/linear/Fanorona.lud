Fanorona-Tsivy is played on a board of 9x5 intersecting lines with diagonals. Each player has 22 pieces, starting on the intersections of the lines except in the centre position, placed on opposite rows of the board, but alternating in the central row.. Pieces move to an adjacent intersection along the lines. Players must capture pieces when possible. Capturing is accomplished by moving to an adjacent intersection to an opposing piece in the continuing direction of the capturing stones movement, or by moving away from an adjacent opposing pieces in such a direction. When an opponent's piece is captured, all other of the opponent's pieces in that line are also captured. Multiple captures can be made, but cannot be done by moving twice in the same direction. Multiple captures are optional. A player wins by capturing all of the other player's pieces. The game is played on a 5x9 board
(game "Fanorona" (players 2) (equipment {(board (rectangle 5 9 diagonals:Alternating) use:Vertex) (piece "Marker" Each)}) (rules (start {(place "Marker1" (union {(union (expand (sites Bottom)) (sites {"B3" "D3" "G3" "I3"}))})) (place "Marker2" (union {(union (sites {"A3" "C3" "F3" "H3"}) (expand (sites Top)))}))}) (play (if (is Prev Mover) (or (if (is Occupied (last To)) (or (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (to) SameDirection)))})) (then (and {(fromTo (from (last From)) (to (last To))) (directional (from (last To)) (directions Vertex from:(last From) to:(last To)) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (if (can Move (or (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (to) SameDirection)))}))) (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (from) OppositeDirection)))}))))) (moveAgain))}))) (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (from) OppositeDirection)))})) (then (and {(fromTo (from (last From)) (to (last To))) (directional (from (last From)) (directions Vertex from:(last To) to:(last From)) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (if (can Move (or (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (to) SameDirection)))}))) (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (from) OppositeDirection)))}))))) (moveAgain))})))) (or (move Select (from (last From)) (to (sites Around (last From)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (to) SameDirection)))})) (then (and {(fromTo (from (last From)) (to (last To))) (directional (from (last To)) (directions Vertex from:(last From) to:(last To)) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (if (can Move (or (move Select (from (last From)) (to (sites Around (last From)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (to) SameDirection)))}))) (move Select (from (last From)) (to (sites Around (last From)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (from) OppositeDirection)))}))))) (moveAgain))}))) (move Select (from (last From)) (to (sites Around (last From)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (from) OppositeDirection)))})) (then (and {(fromTo (from (last From)) (to (last To))) (directional (from (last From)) (directions Vertex from:(last To) to:(last From)) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (if (can Move (or (move Select (from (last From)) (to (sites Around (last From)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (to) SameDirection)))}))) (move Select (from (last From)) (to (sites Around (last From)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (from) OppositeDirection)))}))))) (moveAgain))}))))) (move Pass)) (priority {(or (forEach Piece (move Select (from) (to (sites Around (from)) if:(and (is Empty (to)) (is Enemy (who at:(ahead (to) SameDirection))))) (then (and (fromTo (from (last From)) (to (last To))) (directional (from (last To)) (directions Vertex from:(last From) to:(last To)) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))))) (then (if (can Move (or (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (to) SameDirection)))})) (then (and {(fromTo (from (last From)) (to (last To))) (directional (from (last To)) (directions Vertex from:(last From) to:(last To)) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (if (can Move (or (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (to) SameDirection)))}))) (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (from) OppositeDirection)))}))))) (moveAgain))}))) (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (from) OppositeDirection)))})) (then (and {(fromTo (from (last From)) (to (last To))) (directional (from (last From)) (directions Vertex from:(last To) to:(last From)) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (if (can Move (or (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (to) SameDirection)))}))) (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (from) OppositeDirection)))}))))) (moveAgain))}))))) (moveAgain)))) (forEach Piece (move Select (from) (to (sites Around (from)) if:(and (is Empty (to)) (is Enemy (who at:(ahead (from) OppositeDirection))))) (then (and (fromTo (from (last From)) (to (last To))) (directional (from (last From)) (directions Vertex from:(last To) to:(last From)) (to if:(is Enemy (who at:(to))) (apply (remove (to)))))))) (then (if (can Move (or (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (to) SameDirection)))})) (then (and {(fromTo (from (last From)) (to (last To))) (directional (from (last To)) (directions Vertex from:(last From) to:(last To)) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (if (can Move (or (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (to) SameDirection)))}))) (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (from) OppositeDirection)))}))))) (moveAgain))}))) (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (from) OppositeDirection)))})) (then (and {(fromTo (from (last From)) (to (last To))) (directional (from (last From)) (directions Vertex from:(last To) to:(last From)) (to if:(is Enemy (who at:(to))) (apply (remove (to))))) (if (can Move (or (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (to) SameDirection)))}))) (move Select (from (last To)) (to (sites Around (last To)) if:(and {(not (is Visited (to))) (is Empty (to)) (is Enemy (who at:(ahead (from) OppositeDirection)))}))))) (moveAgain))}))))) (moveAgain))))) (forEach Piece (move Step (to if:(is Empty (to)))))}))) (end (if (no Pieces Mover) (result Next Win))))) 
