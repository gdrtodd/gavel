In Seesaw Draughts, when a man reaches the rank farthest away in its stepping direction, its capture range is increased and it changes the direction it steps in. It can thereby promote again if it reaches the opposite rank. The mechanism is implemented like this: All men are stacks. Single pieces are stacks of size 1. Every time a man promotes a piece is added to it, so it's stack size increases by 1. The following two-fold meaning of stack size is the key idea: 1) Odd stacks step forwards and even stacks step backwards. 2) A stack of size n can capture a piece up to n steps away in a straight line provided that there are no pieces between the capturing piece and its target, and that the square immediately behind the target in the capture direction is empty. The capturing piece must land there. Thus, the men gradually acquire the capturing power of a king in Thai Checkers as they seesaw up and down the board. There is no obligation to choose the capture sequence that maximizes the number of pieces captured. We deem this calculation a bit too demanding when a stack's range is a function of its size. Other than this, the rules are as in Brazillian Draughts/Checkers, which is like International Draughts, but on 8x8.
(game "Seesaw Draughts" (players 2) (equipment {(board (square 8)) (piece "Disc" P1 N) (piece "Disc" P2 S) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Disc1" (difference (expand (sites Bottom) steps:2) (sites Phase 1))) (place "Disc2" (difference (expand (sites Top) steps:2) (sites Phase 1)))}) (play (priority (forEach Piece "Disc" (move (from if:(equals (mul (from) (if (lt 0 (count MovesThisTurn)) 1 0)) (mul (last To) (if (lt 0 (count MovesThisTurn)) 1 0)))) (to (sites Direction from:(from) Diagonal distance:(add 1 (size Stack at:(from)))) if:(and {(is Empty (to)) (equals 1 (count Sites in:(intersection (sites Occupied by:Enemy) (sites Between from:(from) to:(to))))) (equals 0 (count Sites in:(intersection (sites Occupied by:Mover) (sites Between from:(from) to:(to))))) (equals 1 (count Steps (to) (add (array (intersection (sites Occupied by:Enemy) (sites Between from:(from) to:(to))))))) (not (is In (add (array (intersection (sites Occupied by:Enemy) (sites Between from:(from) to:(to))))) (values Remembered)))}) (apply (remember Value (add (array (intersection (sites Occupied by:Enemy) (sites Between from:(from) to:(to)))))))) count:(size Stack at:(from)) stack:True (then (if (can Move (move (from (last To)) (to (sites Direction from:(from) (difference Diagonal (directions Cell from:(last To) to:(last From))) distance:(add 1 (size Stack at:(from)))) if:(and {(is Empty (to)) (equals 1 (count Sites in:(intersection (sites Occupied by:Enemy) (sites Between from:(from) to:(to))))) (equals 0 (count Sites in:(intersection (sites Occupied by:Mover) (sites Between from:(from) to:(to))))) (equals 1 (count Steps (to) (add (array (intersection (sites Occupied by:Enemy) (sites Between from:(from) to:(to))))))) (not (is In (add (array (intersection (sites Occupied by:Enemy) (sites Between from:(from) to:(to))))) (values Remembered)))})))) (moveAgain) (do (forEach Site (sites (values Remembered)) (remove (site) count:(size Stack at:(site)))) next:(and (if (or (and (is Odd (size Stack at:(last To))) (is In (last To) (sites (player (add 1 (mod (mover) 2)))))) (and (is Even (size Stack at:(last To))) (is In (last To) (sites (player (mover)))))) (add (to (last To)) stack:True)) (forget Value All)))))) top:True) (forEach Piece "Disc" (move Step (from) (if (is Odd (size Stack at:(from))) (directions {FL FR}) (directions {BL BR})) (to if:(is Empty (to))) stack:True (then (if (or (and (is Odd (size Stack at:(last To))) (is In (last To) (sites (player (add 1 (mod (mover) 2)))))) (and (is Even (size Stack at:(last To))) (is In (last To) (sites (player (mover)))))) (add (to (last To)) stack:True)))) top:True))) (end (if (no Moves Next) (result Next Loss))))) 
