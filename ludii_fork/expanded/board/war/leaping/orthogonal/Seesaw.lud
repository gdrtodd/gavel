Overview: In Seesaw the players (North and South) command opposing armies with soldiers that can promote. Your army starts out as a single soldier and your promotion area evolves as you deploy more soldiers. Every time a soldier promotes it grows - first into a 2-stack, then a 3-stack, and so on. The central idea of Seesaw is the 2-fold significance of stack-size: (i) Odd-sized stacks move forwards and even-sized stacks move backwards, and (ii) on any given turn, a stack can take as many steps as it likes from 1 up to its size. This results in soldiers seesawing up and down the board as their strength increases to the point where the game is forced to conclude in one side completely eliminating the other. How to play: On your turn, you must either make a stack-move, or place a new stack. 1. Placing a new stack: A newly placed stack will always be of size 1. You may only place a stack on an empty cell next to a cell of your color. These cells are promotion cells, and each cell you place a new stack on automatically turns into a promotion cell of your color. 2. Stackmoves: You only ever move one stack per turn, but that stack may be able to move several steps or capture several enemiy stacks, depending on its size. The number of steps a stack may take is the number of pieces in it, i.e. its size. 2.1 Noncapturing moves: On turns where you do not have to capture an enemy (see below) all the steps a stack takes is either constrained to the 3 upward directions or to the 3 downward directions, depending on the size and the owner of the stack. South's forward directions are the 3 upward directions, and North's forward directions are the 3 downward directions. 2.2 Capturing moves: If one or more of your stacks can reach an enemy by lifting the restraint on direction, you must capture such a reachable enemy by replacement. If that stack did not spend all its steps reaching the captured enemy, you can, before you end your turn, spend the left-over steps by making a noncapturing move. However, if yet an enemy is in range immediately after you have captured (counting only the steps left over), you must capture again. 3. Promoting: Your odd-sized stacks promote when they end up on a promotion cell belonging to your opponent at the end of your turn. Your even-sized stacks promote when they end up on a promotion cell belonging to you at the end of your turn. The object of Seesaw is to capture all your opponent's soldiers. More precisely: If, at the end of your turn, your opponent has no stacks on the board, you have won the game. A base 4 board is currently selected
(game "Seesaw" (players {(player N) (player S)}) (equipment {(board (rotate 30 (hex 4))) (piece "Disc" Each) (tile "Hex" Each)}) (rules (start {(place Stack "Hex1" 0) (place Stack "Disc1" 0) (place Stack "Hex2" (mul 4 (mul 3 (sub 4 1)))) (place Stack "Disc2" (mul 4 (mul 3 (sub 4 1))))}) (play (if (can Move (forEach Piece "Disc" (do (if (equals 0 (count MovesThisTurn)) (set Var (count Stack at:(from) if:(or (equals (what at:(to) level:(level)) (id "Disc" Next)) (equals (what at:(to) level:(level)) (id "Disc" Mover)))))) next:(move (from if:(equals (mul (from) (if (lt 0 (count MovesThisTurn)) 1 0)) (mul (last To) (if (lt 0 (count MovesThisTurn)) 1 0)))) (to (if (gt (var) 1) (intersection (sites Around (intersection (sites Distance (step (to if:(equals 0 (count Stack at:(to) if:(or (equals (what at:(to) level:(level)) (id "Disc" Next)) (equals (what at:(to) level:(level)) (id "Disc" Mover))))))) from:(from) (range 1 (sub (var) 1))) (sites Around (sites Occupied by:Enemy component:"Disc")))) (sites Occupied by:Enemy component:"Disc")) (intersection (sites Around (from)) (sites Occupied by:Enemy component:"Disc"))) (apply (remove (to) count:(count Stack at:(to) if:(or (equals (what at:(to) level:(level)) (id "Disc" Next)) (equals (what at:(to) level:(level)) (id "Disc" Mover))))))) count:(count Stack at:(from) if:(or (equals (what at:(to) level:(level)) (id "Disc" Next)) (equals (what at:(to) level:(level)) (id "Disc" Mover)))) stack:True)) top:True)) (forEach Piece "Disc" (do (if (equals 0 (count MovesThisTurn)) (set Var (count Stack at:(from) if:(or (equals (what at:(to) level:(level)) (id "Disc" Next)) (equals (what at:(to) level:(level)) (id "Disc" Mover)))))) next:(move (from if:(equals (mul (from) (if (lt 0 (count MovesThisTurn)) 1 0)) (mul (last To) (if (lt 0 (count MovesThisTurn)) 1 0)))) (to (if (gt (var) 1) (intersection (sites Around (intersection (sites Distance (step (to if:(equals 0 (count Stack at:(to) if:(or (equals (what at:(to) level:(level)) (id "Disc" Next)) (equals (what at:(to) level:(level)) (id "Disc" Mover))))))) from:(from) (range 1 (sub (var) 1))) (sites Around (sites Occupied by:Enemy component:"Disc")))) (sites Occupied by:Enemy component:"Disc")) (intersection (sites Around (from)) (sites Occupied by:Enemy component:"Disc"))) (apply (remove (to) count:(count Stack at:(to) if:(or (equals (what at:(to) level:(level)) (id "Disc" Next)) (equals (what at:(to) level:(level)) (id "Disc" Mover))))))) count:(count Stack at:(from) if:(or (equals (what at:(to) level:(level)) (id "Disc" Next)) (equals (what at:(to) level:(level)) (id "Disc" Mover)))) stack:True)) top:True (then (set Var (sub (var) (count Steps (step (to if:(or (equals (last To) (to)) (equals 0 (count Stack at:(to) if:(or (equals (what at:(to) level:(level)) (id "Disc" Next)) (equals (what at:(to) level:(level)) (id "Disc" Mover)))))))) (last From) (last To))) (then (if (lt 0 (var)) (moveAgain) (if (equals (add (mul 1 (mod (count Stack at:(last To) if:(or (equals (what at:(to) level:(level)) (id "Disc" Next)) (equals (what at:(to) level:(level)) (id "Disc" Mover)))) 2)) (mod (mover) (sub 3 (mod (count Stack at:(last To) if:(or (equals (what at:(to) level:(level)) (id "Disc" Next)) (equals (what at:(to) level:(level)) (id "Disc" Mover)))) 2)))) (mul (who at:(last To) level:0) (count Stack at:(last To) if:(or (equals (id "Hex" Next) (what at:(to) level:(level))) (equals (id "Hex" Mover) (what at:(to) level:(level))))))) (add (piece (id "Disc" Mover)) (to (last To)) stack:True))))))) (if (lt 0 (count MovesThisTurn)) (or (forEach Piece "Disc" (do (if (equals 0 (count MovesThisTurn)) (set Var (count Stack at:(from) if:(or (equals (what at:(to) level:(level)) (id "Disc" Next)) (equals (what at:(to) level:(level)) (id "Disc" Mover)))))) next:(move (from if:(equals (mul (from) (if (lt 0 (count MovesThisTurn)) 1 0)) (mul (last To) (if (lt 0 (count MovesThisTurn)) 1 0)))) (to (if (is Odd (count Stack at:(from) if:(or (equals (what at:(to) level:(level)) (id "Disc" Next)) (equals (what at:(to) level:(level)) (id "Disc" Mover))))) (sites Distance (step Forwards (to if:(equals 0 (count Stack at:(to) if:(or (equals (what at:(to) level:(level)) (id "Disc" Next)) (equals (what at:(to) level:(level)) (id "Disc" Mover))))))) from:(from) (range 1 (var))) (sites Distance (step Backwards (to if:(equals 0 (count Stack at:(to) if:(or (equals (what at:(to) level:(level)) (id "Disc" Next)) (equals (what at:(to) level:(level)) (id "Disc" Mover))))))) from:(from) (range 1 (var))))) count:(count Stack at:(from) if:(or (equals (what at:(to) level:(level)) (id "Disc" Next)) (equals (what at:(to) level:(level)) (id "Disc" Mover)))) stack:True)) top:True) (move Pass) (then (if (equals (add (mul 1 (mod (count Stack at:(last To) if:(or (equals (what at:(to) level:(level)) (id "Disc" Next)) (equals (what at:(to) level:(level)) (id "Disc" Mover)))) 2)) (mod (mover) (sub 3 (mod (count Stack at:(last To) if:(or (equals (what at:(to) level:(level)) (id "Disc" Next)) (equals (what at:(to) level:(level)) (id "Disc" Mover)))) 2)))) (mul (who at:(last To) level:0) (count Stack at:(last To) if:(or (equals (id "Hex" Next) (what at:(to) level:(level))) (equals (id "Hex" Mover) (what at:(to) level:(level))))))) (add (piece (id "Disc" Mover)) (to (last To)) stack:True)))) (or (forEach Piece "Disc" (do (if (equals 0 (count MovesThisTurn)) (set Var (count Stack at:(from) if:(or (equals (what at:(to) level:(level)) (id "Disc" Next)) (equals (what at:(to) level:(level)) (id "Disc" Mover)))))) next:(move (from if:(equals (mul (from) (if (lt 0 (count MovesThisTurn)) 1 0)) (mul (last To) (if (lt 0 (count MovesThisTurn)) 1 0)))) (to (if (is Odd (count Stack at:(from) if:(or (equals (what at:(to) level:(level)) (id "Disc" Next)) (equals (what at:(to) level:(level)) (id "Disc" Mover))))) (sites Distance (step Forwards (to if:(equals 0 (count Stack at:(to) if:(or (equals (what at:(to) level:(level)) (id "Disc" Next)) (equals (what at:(to) level:(level)) (id "Disc" Mover))))))) from:(from) (range 1 (var))) (sites Distance (step Backwards (to if:(equals 0 (count Stack at:(to) if:(or (equals (what at:(to) level:(level)) (id "Disc" Next)) (equals (what at:(to) level:(level)) (id "Disc" Mover))))))) from:(from) (range 1 (var))))) count:(count Stack at:(from) if:(or (equals (what at:(to) level:(level)) (id "Disc" Next)) (equals (what at:(to) level:(level)) (id "Disc" Mover)))) stack:True)) top:True (then (if (equals (add (mul 1 (mod (count Stack at:(last To) if:(or (equals (what at:(to) level:(level)) (id "Disc" Next)) (equals (what at:(to) level:(level)) (id "Disc" Mover)))) 2)) (mod (mover) (sub 3 (mod (count Stack at:(last To) if:(or (equals (what at:(to) level:(level)) (id "Disc" Next)) (equals (what at:(to) level:(level)) (id "Disc" Mover)))) 2)))) (mul (who at:(last To) level:0) (count Stack at:(last To) if:(or (equals (id "Hex" Next) (what at:(to) level:(level))) (equals (id "Hex" Mover) (what at:(to) level:(level))))))) (add (piece (id "Disc" Mover)) (to (last To)) stack:True)))) (move Add (piece (id "Hex" Mover)) (to (sites Around (sites Occupied by:Mover component:"Hex" top:False)) if:(is Empty (to))) (then (add (piece (id "Disc" Mover)) (to (last To)) stack:True))))))) (end (if (equals 0 (count Sites in:(sites Occupied by:Next component:"Disc"))) (result Next Loss))))) 
