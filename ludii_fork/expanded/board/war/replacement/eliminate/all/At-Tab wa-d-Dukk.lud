4x13, 19, 21, or 29 board. The number of pieces per player equals the number of spaces in a row, which begin the game arrayed in the outer rows of the board. Four sticks, each with a white side and a yellow side. Throws equal the number of white sides which fall up; when only yellow sides are up the throw equals 6. A throw of 1, 4, or 6 grants another throw to the player. Players perform all of their throws first, and then move pieces according to the values of the throws without subdividing the value of a single throw. Players cannot move their pieces until the throw a 1. Pieces cannot move past one another in the home row. Each piece in the home row must individually be unlocked with a throw of 1 before it can move. In the central rows, when two of a player's pieces land on the same spot, they become a king and can be moved as one piece. There is no limit to the number of pieces in the king. They may be uncoupled with a throw of 1, or another throw which removes that number of pieces from the king. When a player's piece lands in a space occupied by an opponent's piece, the opponent's piece is removed from the board. Play progresses from left to right in the player's home row, and then from right to left in the second row, left to right in the third row, and then right to left in the opponent's row. When a piece enters the opponent's row, it cannot move if there are other pieces which can be moved. The player to capture the most of the opponent's pieces wins. The board has 13 columns.
(game "At-Tab wa-d-Dukk" (players 2) (equipment {(board (rectangle 4 13) {(track "Track1" "0,E,N1,W,N1,E,N1,W" P1 directed:True) (track "Track2" "51,W,S1,E,S1,W,S1,E" P2 directed:True)}) (dice d:2 from:0 num:4) (map {(pair 0 6) (pair 1 1) (pair 2 2) (pair 3 3) (pair 4 4)}) (piece "Marker" Each (if (or (equals (state at:(from)) 0) (and (equals 1 (mapEntry (count Pips))) (equals (state at:(from)) 1))) (if (notEqual (trackSite Move steps:(mapEntry (count Pips))) -1) (if (or (not (is In (from) (sites Next))) (and (is In (from) (sites Next)) (equals (count Sites in:(intersection (sites Occupied by:Next) (sites Next))) 0))) (if (or (is In (trackSite Move steps:(mapEntry (count Pips))) (sites Empty)) (is Enemy (who at:(trackSite Move steps:(mapEntry (count Pips)))))) (or (if (equals (add (mapEntry (count Pips)) 1) (count at:(from))) (move (from) (to (trackSite Move steps:(mapEntry (count Pips))) (apply if:(is Enemy (who at:(to))) (remove (to) (then (addScore Mover 1))))) count:(mapEntry (count Pips)))) (move (from) (to (trackSite Move steps:(mapEntry (count Pips))) (apply if:(is Enemy (who at:(to))) (remove (to) (then (addScore Mover 1))))) count:(count at:(from)))) (if (and (is In (trackSite Move steps:(mapEntry (count Pips))) (sites "CentralRows")) (is Friend (who at:(trackSite Move steps:(mapEntry (count Pips)))))) (move (from) (to (trackSite Move steps:(mapEntry (count Pips)))))))) (then (set State at:(last To) 0))))) (regions "AnotherThrow" (sites {1 4 6})) (regions "CentralRows" (union (sites Row 1) (sites Row 2))) (regions P1 (sites Bottom)) (regions P2 (sites Top))}) (rules (start {(place "Marker1" (sites Bottom) state:1) (place "Marker2" (sites Top) state:1)}) (play (do (roll) next:(if (can Move (forEach Piece)) (forEach Piece (then (if (is In (mapEntry (count Pips)) (sites "AnotherThrow")) (moveAgain)))) (move Pass (then (if (is In (mapEntry (count Pips)) (sites "AnotherThrow")) (moveAgain))))))) (end (if (or (and (equals (count Sites in:(difference (sites Occupied by:P1) (sites P2))) 0) (equals (count Sites in:(difference (sites Occupied by:P2) (sites P1))) 0)) (no Pieces Mover)) (byScore))))) 
