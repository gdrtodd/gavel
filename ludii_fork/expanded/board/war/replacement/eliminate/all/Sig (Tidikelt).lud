Three rows of holes, arranged vertically, the outer two have twelve holes and the central one has thirteen. Twelve pieces per player, which begin in the outer rows. Four sticks, black on one side and white on the other, the number of white faces up is the value of the throw; all black faces up = 6. A player must throw a 1 (sig) to unlock a piece, which moves from the top hole in the player's row to the top hole of the central row. When a piece reaches the thirteenth space in the central row, they must throw a sig to enter the opponent's home row, at the bottom hole in that row, and proceed up that row to the top and then back into the central row. When entering the opponent's row, the opponent's piece in their bottom hole is sent to the next available hole in their row. In the central row, when a piece lands on a hole with an opponent's piece, the opponent's piece is sent back to start in their home row. A player landing on a hole occupied by an opponent in the home row captures the opponent's piece. The player who captures all of the opponent's pieces wins. The game is played with 4 dice.
(game "Sig (Tidikelt)" (players 2) (equipment {(board (merge {(rectangle 12 3) (shift 1 -1 (rectangle 13 1))}) {(track "HomeTrack1" "0,N,E1,S" P1 directed:True) (track "HomeTrack2" "2,N,W1,S" P2 directed:True) (track "EnemyTrack1" "2,N,W1,S" P1 directed:True) (track "EnemyTrack2" "0,N,E1,S" P2 directed:True)} use:Vertex) (piece "Stick" Each) (regions "AllSites" (sites Board)) (dice d:2 from:0 num:4) (map "Throw" {(pair 0 6) (pair 1 1) (pair 2 2) (pair 3 3) (pair 4 4)}) (map "FirstEnemySite" {(pair P1 2) (pair P2 0)}) (regions "Home" P1 (sites Left)) (regions "Home" P2 (sites Right))}) (rules (start {(place "Stick1" (sites Left)) (place "Stick2" (sites Right))}) (play (do (roll) next:(or (if (and (equals 1 (mapEntry "Throw" (count Pips))) (equals (mover) (who at:36))) (move (from 36) (to (mapEntry "FirstEnemySite" (mover)) if:(not (is Friend (mapEntry "FirstEnemySite" (mover)))) (apply if:(is Enemy (who at:(to))) (if (equals (min (array (intersection (sites Empty) (sites Next "Home")))) -1) (remove (to)) (fromTo (from (to)) (to (min (array (intersection (sites Empty) (sites Next "Home"))))))))))) (forEach Piece (or (if (is In (from) (sites Track Mover "HomeTrack")) (if (if (notEqual 0 (state at:(from))) True (equals 1 (mapEntry "Throw" (count Pips)))) (if (not (is Friend (who at:(trackSite Move "HomeTrack" steps:(mapEntry "Throw" (count Pips)))))) (move (from) (to (trackSite Move "HomeTrack" steps:(mapEntry "Throw" (count Pips))) (apply if:(is Enemy (who at:(to))) (if (is In (to) (sites Next "Home")) (remove (to)) (if (equals (min (array (intersection (sites Empty) (sites Next "Home")))) -1) (remove (to)) (fromTo (from (to)) (to (min (array (intersection (sites Empty) (sites Next "Home")))))))))) (then (if (and (not (notEqual 0 (state at:(last To)))) (equals 1 (mapEntry "Throw" (count Pips)))) (set State at:(last To) 1))))))) (if (is In (from) (sites Track Mover "EnemyTrack")) (if (not (is Friend (who at:(trackSite Move "EnemyTrack" steps:(mapEntry "Throw" (count Pips)))))) (move (from) (to (trackSite Move "EnemyTrack" steps:(mapEntry "Throw" (count Pips))) (apply if:(is Enemy (who at:(to))) (if (is In (to) (sites Next "Home")) (remove (to)) (if (equals (min (array (intersection (sites Empty) (sites Next "Home")))) -1) (remove (to)) (fromTo (from (to)) (to (min (array (intersection (sites Empty) (sites Next "Home")))))))))))))))))) (end (if (no Pieces Next) (result Next Loss))))) 
