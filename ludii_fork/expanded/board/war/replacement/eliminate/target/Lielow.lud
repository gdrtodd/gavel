Each turn you must move one of your stacks, in a straight line orthogonally or diagonally, a distance exactly equal to the size of that stack. If it lands on an empty space, the stack grows by 1. If it lands on an enemy, the enemy is removed and your stack shrinks down to size 1. It is not legal to land on a friendly stack. Jumping over stacks is allowed. Stacks may also jump off the board, removing themselves from the game. Passing is not allowed. Definitions for crown and king: In this implementation, the king-stack will have a red stroke color. This red ring is the crown. Which stack has the crown is determined like this: After your move, if there is, among your stacks, a unique stack of the biggest size, the crown will be on that stack. There is no other way the crown can change heads. The piece with a crown on it is the king. Goal: If the enemy king is removed from the game, you win. Note: In this implementation, jumping off the board is only possible if the stack can reach exactly 1 row or column beyond the perimeter. But it seems to always be the case that it is possible to jump off the board when a stack is big enough. Please let Michael know if you encounter a scenario where a piece is stuck. This should not be allowed according to the rules of the game.
(game "Lielow" (players 2) (equipment {(board (square 10)) (piece "Disc" Each)}) (rules (start {(place "Disc1" (difference (difference (expand (sites Bottom) steps:2) (expand (sites Bottom) steps:1)) (sites Outer))) (place "Disc2" (difference (difference (expand (sites Top) steps:2) (expand (sites Top) steps:1)) (sites Outer)))}) (play (forEach Piece (or (move (from) (to (sites Around (from) Empty distance:(size Stack at:(from))) (apply (if (and {(equals 1 (state at:(from))) (is In (to) (sites Outer))}) (set Var "MoverHasLost" 1)))) count:(size Stack at:(from)) stack:True (then (add (to (last To) level:0) stack:True))) (move (from) (to (sites Around (from) Enemy distance:(size Stack at:(from))) (apply (and {(if (equals 1 (state at:(to))) (set Var "MoverHasWon" 1)) (set Var (state at:(from))) (remove (to) count:(size Stack at:(to)))}))) count:(size Stack at:(from)) stack:True (then (if (lt 1 (size Stack at:(last To))) (and (remove (last To) count:(sub (size Stack at:(last To)) 1)) (set State at:(last To) (var))))))) Mover top:True (then (do (remove (sites Outer) count:(size Stack at:(last To))) next:(if (equals 1 (count Sites in:(forEach (sites Occupied by:Mover) if:(equals (size Stack at:(site)) (max (results from:(sites Occupied by:Mover) to:0 (size Stack at:(from)))))))) (forEach Piece (if (equals (size Stack at:(from)) (max (results from:(sites Occupied by:Mover) to:0 (size Stack at:(from))))) (set State at:(from) 1) (set State at:(from) 0)) Mover top:True)))))) (end {(if (equals 1 (var "MoverHasLost")) (result Mover Loss)) (if (equals 1 (var "MoverHasWon")) (result Mover Win))}))) 
