Goal: End with the largest chain of stones, the goal cascades to the next largest in the case of ties. A 'chain' is any set of player's stones that comprised of a starting stone and every stone which can be reached from it by a series steps between adjacent stones. Starting with an empty board, players alternate taking turns. A turn consists of either placing or moving a stone followed by removing opposing stones, if applicable. Placing: A friendly stone may be placed either: - 1) where there are no adjacent stones of either player, or - 2) where the number of stones in adjacent chains that belong to the opponent equal those that belong to the player including the stone to be placed. For example: A stone may be placed next to an opponent's 1-chain (isolated stone). Moving: B) A friendly stone may be moved one step to an empty site, but only if the number of chains on the board is reduced by merger and the merged chain becomes at least as large as every opponent's chain that it is adjacent to. Special movement restrictions: Pieces may not step to merge with a chain that is the larger than any other chain on the board. This restriction does not affect the placement rule. It also does not apply if more than one group is tied for largest. Removing stones: After placement or movement, the player removes every opponent's stone that is directly adjacent to a larger friendly chain than its own. When the turn is completed, only chains of equal size remain in contact. Ending the game: There is no passing. The game ends when either player is unable to move. Please also try the optional board grids. Choose smaller boards for a good AI experience and tactical game. Choose larger boards for a strategy game experience with other players. The other rule variants are only for experimentation. Order 4, Hex Grid Cascading scoring of largest chain. Placement: If placed adjacent to a chain, the sum of the stones in the adjacent chains for each player must be equal when the placed piece is included in the sums. Movement: Move a piece to reduce the number of chains by merger, except with the largest group Remove any opponent's stone that is directly adjacent to a larger friendly chain.
(game "Chains of Thought" (players 2) (equipment {(board (tri Hexagon 4) use:Vertex) (piece "Disc" Each)}) (rules (play (or (move Add (to (sites Empty) if:(or (no Pieces in:(sites Around (to) Orthogonal)) (equals (add 1 (count Pieces in:(sites Group from:(sites Around (to) Orthogonal) Orthogonal if:(is Mover (who at:(to)))))) (count Pieces in:(sites Group from:(sites Around (to) Orthogonal) Orthogonal if:(is Next (who at:(to)))))))) (then (remove (forEach (sites Around (sites Group at:(last To) Orthogonal if:(is In (to) (sites Occupied by:Mover))) Orthogonal if:(is Next (who at:(to)))) if:(gt (size Group at:(last To) Orthogonal if:(is Mover (who at:(to)))) (size Group at:(site) Orthogonal if:(is Next (who at:(to)))))) (then (forEach Value (array (sites Around (sites Occupied by:Mover) Orthogonal if:(is Next (who at:(to))))) (if (gt (count Pieces in:(sites Group from:(sites Around (value) Orthogonal) Orthogonal if:(is Mover (who at:(to))))) (size Group at:(value) Orthogonal if:(is Next (who at:(to))))) (remove (value)))))))) (do (and {(set Var "GroupCount" (count Groups Orthogonal if:(is Mover (who at:(to))))) (set Var "LargestMover" (max (sizes Group Orthogonal Mover)) (then (set Var "LargestNext" (max (sizes Group Orthogonal Next)) (then (set Var "SecondLargestMover" (max (difference (sizes Group Orthogonal Mover) (var "LargestMover"))) (then (set Var "LargestUnique" (if (and (gt (var "LargestMover") (var "LargestNext")) (gt (var "LargestMover") (var "SecondLargestMover"))) (var "LargestMover") 0))))))))}) next:(forEach Piece (move Step Orthogonal (to if:(is In (to) (difference (intersection (sites Empty) (sites Around (difference (sites Occupied by:Mover) (from)) Orthogonal)) (sites Around (forEach (sites Occupied by:Mover) if:(equals (size Group at:(site) Orthogonal) (var "LargestUnique"))) Orthogonal)))))) ifAfterwards:(and {(lt (count Groups Orthogonal if:(is Mover (who at:(to)))) (var "GroupCount")) (ge (size Group at:(last To) Orthogonal if:(is Mover (who at:(to)))) (max (results from:(sites Around (last To) Orthogonal if:(is Next (who at:(to)))) to:(from) (size Group at:(to) Orthogonal if:(is Next (who at:(to)))))))}) (then (remove (forEach (sites Around (sites Group at:(last To) Orthogonal if:(is In (to) (sites Occupied by:Mover))) Orthogonal if:(is Next (who at:(to)))) if:(gt (size Group at:(last To) Orthogonal if:(is Mover (who at:(to)))) (size Group at:(site) Orthogonal if:(is Next (who at:(to)))))) (then (forEach Value (array (sites Around (sites Occupied by:Mover) Orthogonal if:(is Next (who at:(to))))) (if (gt (count Pieces in:(sites Group from:(sites Around (value) Orthogonal) Orthogonal if:(is Mover (who at:(to))))) (size Group at:(value) Orthogonal if:(is Next (who at:(to))))) (remove (value)))))))) (then (and (set Score P1 (max (difference (sizes Group Orthogonal P1) (sizes Group Orthogonal P2)))) (set Score P2 (max (difference (sizes Group Orthogonal P2) (sizes Group Orthogonal P1)))))))) (end (if (no Moves Next) (byScore))))) 
