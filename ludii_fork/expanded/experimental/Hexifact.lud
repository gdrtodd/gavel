Goal:Score the product of the sizes of your two largest groups. Highest score wins. In case of a tie, the last to play wins. Groups are based on the orthogonal connections between adjacent pieces. Play: Boards starts empty. The darker color starts by placing anywhere. Thereafter, a turn is either a placement or a jump (but not both) according to the following rules. There are no captures. Passing is allowed. Placement: Pieces must be placed on an empty site that is BOTH: - next to an opponent's stone(s) and - away from one's own stones. Jumping: Jumping is only allowed when a placement was made on the mover's last turn (but see Options) A stone jumps in a straight line over any number of opponent's stones. Jump Restrictions: 1) The piece must land at an empty site that is directly after the last opponent's piece in the jump. 2) The stone may not pass over empty sites nor over sites occupied by friendly stones. 3) The stone may not connect more than 3 of a player's stones, nor cause another stone to be connected to more than 3. The game ends when both players pass. Available Options - Jumps: No individual piece may jump more than once before the mover takes a placement turn. Order 3-4, Hex Grid Jumping is only allowed if a player made a placement on the last turn
(game "Hexifact" (players 2) (equipment {(board (tri Limping 3) use:Vertex) (piece "Disc" Each)}) (rules (play (or {(move Add (piece (id "Disc" Mover)) (to (sites Empty) if:(or (and (no Pieces Mover in:(sites Around (to) Orthogonal)) (not (no Pieces Next in:(sites Around (to) Orthogonal)))) (equals -1 (counter)))) (then (forEach Site (sites Occupied by:Mover) (set State at:(site) 0)))) (if (no Pieces Mover in:(sites State 1)) (do (forEach Piece (move Hop (from if:(equals 0 (state at:(from)))) Orthogonal (between (range 1 1000000000) if:(is In (between) (sites Occupied by:Next))) (to if:(is In (to) (sites Empty))) (then (set State at:(last To) 1))) Mover) ifAfterwards:(all Sites (sites Occupied by:Mover) if:(gt 4 (count Pieces Mover in:(sites Around (site) Orthogonal)))))) (move Pass)} (then (do (and {(remember Value 0) (remember Value 0) (forEach Group Orthogonal (remember Value (count Sites in:(sites))))}) next:(set Var "TopValue" (max (values Remembered)) (then (forget Value (max (values Remembered)) (then (set Score Mover (mul (var "TopValue") (max (values Remembered))) (then (forget Value All))))))))))) (end (if (all Passed) {(if (ge (score Mover) (score Next)) (result Mover Win))} (result Next Win))))) 
