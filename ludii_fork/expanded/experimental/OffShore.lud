Definitions: -- Each of a player's stones belongs to exactly one group. -- The group it belongs to contains all the stones that connect to it by virtue of being next to one another (across an edge). -- A player's territory is the union of all the cells that are within the convex grid-oriented hulls of the player's groups. In simpler language: Imagine a line of cells that goes through just one stone of a group and leaves the rest of that group to one side. Surround the group with six of these lines and they will exactly contain all the territory of the stones of that group. A player's territory is then the combined territory of every group, counting cells only once where any of the group territories overlap. -- A player's score is the number of empty cells in their territory. Play: The mover places a stone onto an empty site, with the following two limitations: 1) No placing in the opponent's territory. 2) No placing next to a friendly group that has more stones than there are friendly groups. (Note that the resulting size of a group is irrelevant.) After the placement, every opponent's group that lies completely within the mover's territory is removed. Passing is voluntary. When both players pass consecutively, the higher score wins. In case of a tie, the last to play wins. Various boards are optional. Weak Territory, allowing placement next to a friendly group in enemy territory is optional. 4 Hexagon No placement within Enemy territory.
(game "OffShore" (players 2) (equipment {(board (hex Hexagon 4) use:Cell) (hand Each size:1) (piece "Disc" Each)}) (rules (start {(place "Disc1" (handSite P1 0) value:0) (place "Disc2" (handSite P2 0) value:0)}) (play (or (move Pass) (move Add (to (difference (union {(if (equals 1 (mover)) (difference (sites Empty) (sites (values Remembered "P2"))) (difference (sites Empty) (sites (values Remembered "P1")))) (sites {})}) (forEach of:(intersection (sites Board) (sites Occupied by:Mover)) (if (gt (value Piece at:(site)) (value Piece at:(handSite Mover 0))) (sites Around (site) Orthogonal))))) (then (do (forEach Site (sites Group at:(last To) Orthogonal) (set Value at:(site) (count Sites in:(sites Group at:(last To) Orthogonal)))) next:(set Value at:(handSite Mover 0) (size Array (sizes Group Orthogonal Mover))) (then (if (lt 0 (count Pieces Mover in:(sites Around (last To) Orthogonal))) (forEach Site (union {(intersection (sites Direction from:(sites Group at:(last To) Orthogonal) NNW) (sites Direction from:(sites Group at:(last To) Orthogonal) E)) (intersection (sites Direction from:(sites Group at:(last To) Orthogonal) NNE) (sites Direction from:(sites Group at:(last To) Orthogonal) SSE)) (intersection (sites Direction from:(sites Group at:(last To) Orthogonal) E) (sites Direction from:(sites Group at:(last To) Orthogonal) SSW)) (intersection (sites Direction from:(sites Group at:(last To) Orthogonal) SSE) (sites Direction from:(sites Group at:(last To) Orthogonal) W)) (intersection (sites Direction from:(sites Group at:(last To) Orthogonal) SSW) (sites Direction from:(sites Group at:(last To) Orthogonal) NNW)) (intersection (sites Direction from:(sites Group at:(last To) Orthogonal) W) (sites Direction from:(sites Group at:(last To) Orthogonal) NNE))}) (if (equals (mover) 1) (remember Value "P1" (site) unique:True) (remember Value "P2" (site) unique:True))) (then (priority (if (equals (mover) 1) (forEach Group Orthogonal if:(is In (to) (intersection (sites Board) (sites Occupied by:Next))) (if (no Pieces Next in:(difference (sites) (sites (values Remembered "P1")))) (and (forEach Site (union {(intersection (sites Direction from:(sites) NNW) (sites Direction from:(sites) E)) (intersection (sites Direction from:(sites) NNE) (sites Direction from:(sites) SSE)) (intersection (sites Direction from:(sites) E) (sites Direction from:(sites) SSW)) (intersection (sites Direction from:(sites) SSE) (sites Direction from:(sites) W)) (intersection (sites Direction from:(sites) SSW) (sites Direction from:(sites) NNW)) (intersection (sites Direction from:(sites) W) (sites Direction from:(sites) NNE))}) (forget Value "P2" (site))) (remove (sites))))) (forEach Group Orthogonal if:(is In (to) (intersection (sites Board) (sites Occupied by:Next))) (if (no Pieces Next in:(difference (sites) (sites (values Remembered "P2")))) (and (forEach Site (union {(intersection (sites Direction from:(sites) NNW) (sites Direction from:(sites) E)) (intersection (sites Direction from:(sites) NNE) (sites Direction from:(sites) SSE)) (intersection (sites Direction from:(sites) E) (sites Direction from:(sites) SSW)) (intersection (sites Direction from:(sites) SSE) (sites Direction from:(sites) W)) (intersection (sites Direction from:(sites) SSW) (sites Direction from:(sites) NNW)) (intersection (sites Direction from:(sites) W) (sites Direction from:(sites) NNE))}) (forget Value "P1" (site))) (remove (sites))))) (then (and {(set Score P1 (count Sites in:(intersection (sites Empty) (sites (values Remembered "P1"))))) (set Score P2 (count Sites in:(intersection (sites Empty) (sites (values Remembered "P2"))))) (set Value at:(handSite P1 0) (size Array (sizes Group Orthogonal P1))) (set Value at:(handSite P2 0) (size Array (sizes Group Orthogonal P2)))}))) (and {(set Score P1 (count Sites in:(intersection (sites Empty) (sites (values Remembered "P1"))))) (set Score P2 (count Sites in:(intersection (sites Empty) (sites (values Remembered "P2"))))) (set Value at:(handSite P1 0) (size Array (sizes Group Orthogonal P1))) (set Value at:(handSite P2 0) (size Array (sizes Group Orthogonal P2)))})))))))))) (end (if (all Passed) {(if (gt (score Mover) (score Next)) (result Mover Win)) (if (lt (score Mover) (score Next)) (result Mover Loss))} (result Mover Win))))) 
