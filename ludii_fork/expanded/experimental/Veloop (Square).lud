Goal: Form an orthogonally connected path of friendly stones that surrounds at least one non-friendly stone. Set-up: Two stones, one of each colour, are placed next to each other adjacent to the center of the board. Then Black starts by taking one turn. After that players take DOUBLE turns in alternation. Play: Each turn has two parts that both must be completed: A PLACEMENT and a SWAP. -- The PLACEMENT is made a knight's leap away from a selected stone of the same color. -- The SWAP is done by exchanging the contents of the 2 squares that lie between the selected stone and the placed stone. For a SWAP to be valid, the contents of these squares must be different, i.e.: two stones of different color, or an empty space and a stone. If a turn cannot be completed with a placement to an empty position, the placement must be made by placing on top of an opponent's stone. The placement and swap rules apply to the visible stones and must still be followed. Voluntary passing is not allowed. When neither player can move, the game ends in a draw. To help visualise the moves, the 'Show Last Move' option shows an arrow from the placement site to the supporting friendly piece and the swap pieces are to either side of this arrow. Optional Variants: -- Larger Board to reduce the strategic effect of the edge squares. / Smaller board to focus on stacked play as a significant part of the game. -- Normal single turn alternation for a more fine-grained experience, but with a first player advantage. 8x8 Square First player takes one turn, then players alternate taking 2 turns each
(game "Veloop (Square)" (players 2) (equipment {(board (renumber (rotate 90 (square Square 8))) use:Cell) (piece "Disc" Each)}) (rules (start {(place "Disc1" {28}) (place "Disc2" {36})}) (play (priority (move Select (from (sites Empty) if:(gt 2 (count Stack at:(from)))) (to (sites (from) {{F R F L F} {F L F R F}}) if:(and {(is In (to) (sites Occupied by:Mover top:True)) (equals 2 (count Sites in:(intersection (sites Around (to) Adjacent) (sites Around (from) Adjacent)))) (or (equals 1 (count Sites in:(intersection (intersection (sites Around (to) Adjacent) (sites Around (from) Adjacent)) (sites Occupied by:Mover top:True)))) (equals 1 (count Sites in:(intersection (intersection (sites Around (to) Adjacent) (sites Around (from) Adjacent)) (sites Occupied by:Next top:True)))))})) (then (and {(add (piece (id "Disc" Mover)) (to (last From)) stack:True) (forEach Site (intersection (sites Around (last To) Adjacent) (sites Around (last From) Adjacent)) (remember Value (site)))}))) (move Select (from (sites Occupied by:Next) if:(gt 2 (count Stack at:(from)))) (to (sites (from) {{F R F L F} {F L F R F}}) if:(and {(is In (to) (sites Occupied by:Mover top:True)) (equals 2 (count Sites in:(intersection (sites Around (to) Adjacent) (sites Around (from) Adjacent)))) (or (equals 1 (count Sites in:(intersection (intersection (sites Around (to) Adjacent) (sites Around (from) Adjacent)) (sites Occupied by:Mover top:True)))) (equals 1 (count Sites in:(intersection (intersection (sites Around (to) Adjacent) (sites Around (from) Adjacent)) (sites Occupied by:Next top:True)))))})) (then (and {(add (piece (id "Disc" Mover)) (to (last From)) stack:True) (forEach Site (intersection (sites Around (last To) Adjacent) (sites Around (last From) Adjacent)) (remember Value (site)))}))) (then (if (is Empty (arrayValue (values Remembered) index:1)) (fromTo (from (arrayValue (values Remembered) index:0)) (to (arrayValue (values Remembered) index:1))) (if (is Empty (arrayValue (values Remembered) index:0)) (fromTo (from (arrayValue (values Remembered) index:1)) (to (arrayValue (values Remembered) index:0))) (set Var "Piece1" (what at:(arrayValue (values Remembered) index:1) level:(topLevel at:(arrayValue (values Remembered) index:1))) (then (add (piece (what at:(arrayValue (values Remembered) index:0) level:(topLevel at:(arrayValue (values Remembered) index:0)))) (to (arrayValue (values Remembered) index:1) (apply (remove (to)))) (then (add (piece (var "Piece1")) (to (arrayValue (values Remembered) index:0) (apply (remove (to)))))))))) (then (and {(set Score Mover (sub 0 (count Sites in:(difference (sites Occupied by:Mover) (forEach (sites Board) if:(notEqual 1000000000 (count Steps Adjacent (step Adjacent (to if:(or (is Empty (to)) (is Mover (who at:(to)))))) (site) (sites Outer)))))))) (set Score Next (sub 0 (count Sites in:(difference (sites Occupied by:Next) (forEach (sites Board) if:(notEqual 1000000000 (count Steps Adjacent (step Adjacent (to if:(or (is Empty (to)) (is Next (who at:(to)))))) (site) (sites Outer)))))))) (forget Value All) (if (and (not (is Prev Mover)) (lt -1 (counter))) (moveAgain))})))))) (end (if (notEqual 0 (add (score P1) (score P2))) (byScore))))) 
